---
title: C# Attributes
description: Learn how to use attributes in C# to add metadata to your code and enhance functionality through reflection

---

# C# Attributes

## Introduction

Attributes in C# provide a powerful way to add metadata (additional information) to your code elements like classes, methods, properties, and more. They are declarative tags that can be queried at runtime through reflection, allowing for dynamic behavior and code analysis.

Attributes are a key feature that enables many framework capabilities in the .NET ecosystem, from serialization to dependency injection to unit testing. Understanding attributes will help you not only use existing framework features more effectively but also build your own extensible applications.

## What Are Attributes?

Attributes in C# are special declarative tags that you place in square brackets (`[]`) above the code elements they describe. They provide additional information about the elements in your code. The compiler stores this information as metadata in the assembly, which can later be retrieved through reflection.

Here's a simple example:

```csharp
[Obsolete("This method is obsolete. Use NewMethod() instead.")]
public void OldMethod()
{
    // Method implementation
}
```

In this example, the `Obsolete` attribute tells the compiler that `OldMethod()` is outdated, and developers should use a different method instead. The compiler will generate a warning when someone tries to use this method.

## Built-in Attributes in C#

C# comes with several built-in attributes that serve various purposes:

### 1. `Obsolete`

The `Obsolete` attribute marks code elements as deprecated:

```csharp
[Obsolete]
public void SimpleObsoleteMethod()
{
    // This will generate a compiler warning
}

[Obsolete("Use NewMethod() instead.", true)]
public void StrictObsoleteMethod()
{
    // This will generate a compiler error
}
```

When you compile code that uses `SimpleObsoleteMethod`, you'll get a warning. For `StrictObsoleteMethod`, you'll get a compilation error because the second parameter `true` makes it a hard error rather than a warning.

### 2. `Conditional`

The `Conditional` attribute makes method execution conditional based on preprocessor directives:

```csharp
using System.Diagnostics;

class DebugExample
{
    [Conditional("DEBUG")]
    public static void ShowDebugInfo(string info)
    {
        Console.WriteLine($"Debug Info: {info}");
    }

    public static void Main()
    {
        ShowDebugInfo("Testing conditional methods");
        // This call will be removed entirely when not compiled in DEBUG mode
    }
}
```

When you compile your application without defining the `DEBUG` symbol, any calls to `ShowDebugInfo` will be removed by the compiler, resulting in zero performance impact in your release build.

### 3. `Serializable`

The `Serializable` attribute marks a class or struct as serializable:

```csharp
[Serializable]
public class User
{
    public string Username { get; set; }
    public int Age { get; set; }
    
    [NonSerialized] // This field won't be serialized
    private string temporaryData;
}
```

This allows instances of the `User` class to be converted to a byte stream for storage or transmission, and later reconstructed.

## Creating Custom Attributes

You can create your own attributes by inheriting from the `System.Attribute` class:

```csharp
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, 
                AllowMultiple = false, Inherited = true)]
public class AuthorAttribute : Attribute
{
    public string Name { get; }
    public string Email { get; }
    public int Version { get; set; } // Optional property

    public AuthorAttribute(string name, string email)
    {
        Name = name;
        Email = email;
        Version = 1; // Default value
    }
}
```

Now you can use this attribute in your code:

```csharp
[Author("John Doe", "john@example.com", Version = 2)]
public class SampleCode
{
    [Author("Jane Smith", "jane@example.com")]
    public void SampleMethod()
    {
        // Method implementation
    }
}
```

Let's break down the custom attribute declaration:

1. `AttributeUsage`: This attribute specifies where and how your attribute can be used.
   - `AttributeTargets`: Specifies which code elements can have this attribute (classes and methods in this case).
   - `AllowMultiple`: Determines if the attribute can be applied multiple times to the same element.
   - `Inherited`: Determines if the attribute is inherited by derived classes.

2. Class name: By convention, attribute class names end with "Attribute" but when using them, the "Attribute" suffix is optional.

3. Constructor and properties: Attributes can have constructors for required parameters and properties for optional ones.

## Reading Attributes with Reflection

After defining and applying attributes, you'll need reflection to read them at runtime:

```csharp
using System;
using System.Reflection;

class Program
{
    static void Main()
    {
        Type type = typeof(SampleCode);
        
        // Check if the class has the Author attribute
        if (Attribute.IsDefined(type, typeof(AuthorAttribute)))
        {
            // Get the Author attribute from the class
            AuthorAttribute author = (AuthorAttribute)Attribute.GetCustomAttribute(
                type, typeof(AuthorAttribute));
                
            Console.WriteLine($"Class Author: {author.Name} ({author.Email})");
            Console.WriteLine($"Version: {author.Version}");
        }
        
        // Get all methods of the class
        MethodInfo[] methods = type.GetMethods();
        
        foreach (MethodInfo method in methods)
        {
            // Check if the method has the Author attribute
            if (Attribute.IsDefined(method, typeof(AuthorAttribute)))
            {
                // Get the Author attribute from the method
                AuthorAttribute author = (AuthorAttribute)Attribute.GetCustomAttribute(
                    method, typeof(AuthorAttribute));
                    
                Console.WriteLine($"Method {method.Name} Author: {author.Name} ({author.Email})");
            }
        }
    }
}
```

When executed, this code will output:

```
Class Author: John Doe (john@example.com)
Version: 2
Method SampleMethod Author: Jane Smith (jane@example.com)
```

## Practical Examples of Attributes

### Example 1: Validation Attributes

Custom attributes can be used to validate object properties:

```csharp
// Define validation attributes
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class RequiredAttribute : Attribute { }

[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class MaxLengthAttribute : Attribute
{
    public int Length { get; }
    
    public MaxLengthAttribute(int length)
    {
        Length = length;
    }
}

// Class with properties to validate
public class RegisterModel
{
    [Required]
    public string Username { get; set; }
    
    [Required]
    [MaxLength(50)]
    public string Email { get; set; }
    
    [Required]
    [MaxLength(20)]
    public string Password { get; set; }
}

// Validator class that uses reflection to check attributes
public class ModelValidator
{
    public List<string> Validate(object model)
    {
        List<string> validationErrors = new List<string>();
        Type type = model.GetType();
        
        foreach (PropertyInfo property in type.GetProperties())
        {
            object value = property.GetValue(model);
            
            // Check Required attribute
            if (Attribute.IsDefined(property, typeof(RequiredAttribute)))
            {
                if (value == null || (value is string && string.IsNullOrWhiteSpace((string)value)))
                {
                    validationErrors.Add($"{property.Name} is required.");
                }
            }
            
            // Check MaxLength attribute
            if (Attribute.IsDefined(property, typeof(MaxLengthAttribute)) && value is string)
            {
                MaxLengthAttribute maxLength = (MaxLengthAttribute)Attribute.GetCustomAttribute(
                    property, typeof(MaxLengthAttribute));
                    
                if (((string)value).Length > maxLength.Length)
                {
                    validationErrors.Add($"{property.Name} cannot exceed {maxLength.Length} characters.");
                }
            }
        }
        
        return validationErrors;
    }
}
```

You can use this validation system like this:

```csharp
RegisterModel model = new RegisterModel
{
    Username = "",  // Empty, will trigger Required validation
    Email = "very.long.email.address.that.exceeds.fifty.characters@example.com", // Too long
    Password = "password123"
};

ModelValidator validator = new ModelValidator();
List<string> errors = validator.Validate(model);

foreach (string error in errors)
{
    Console.WriteLine(error);
}
```

Output:
```
Username is required.
Email cannot exceed 50 characters.
```

### Example 2: API Routing with Attributes

Many web frameworks use attributes for routing. Here's a simplified example:

```csharp
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class RouteAttribute : Attribute
{
    public string Path { get; }
    
    public RouteAttribute(string path)
    {
        Path = path;
    }
}

[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
public class HttpMethodAttribute : Attribute
{
    public string Method { get; }
    
    public HttpMethodAttribute(string method)
    {
        Method = method;
    }
}

// Sample controller class
public class UserController
{
    [Route("/users")]
    [HttpMethod("GET")]
    public void GetUsers()
    {
        Console.WriteLine("Retrieving all users");
    }
    
    [Route("/users/{id}")]
    [HttpMethod("GET")]
    public void GetUserById(int id)
    {
        Console.WriteLine($"Retrieving user with ID: {id}");
    }
    
    [Route("/users")]
    [HttpMethod("POST")]
    public void CreateUser()
    {
        Console.WriteLine("Creating a new user");
    }
}
```

A routing system could use reflection to map HTTP requests to these methods:

```csharp
public class Router
{
    public void RouteRequest(string path, string method)
    {
        Type controllerType = typeof(UserController);
        UserController controller = new UserController();
        
        foreach (MethodInfo methodInfo in controllerType.GetMethods())
        {
            // Skip methods that are not from our controller
            if (methodInfo.DeclaringType != controllerType)
                continue;
            
            // Check if the method has Route attribute
            if (Attribute.IsDefined(methodInfo, typeof(RouteAttribute)))
            {
                RouteAttribute route = (RouteAttribute)Attribute.GetCustomAttribute(
                    methodInfo, typeof(RouteAttribute));
                    
                // Simple path matching (in real routing systems, this would be more sophisticated)
                if (MatchesPath(route.Path, path))
                {
                    // Check if the HTTP method matches
                    HttpMethodAttribute httpMethod = (HttpMethodAttribute)Attribute.GetCustomAttribute(
                        methodInfo, typeof(HttpMethodAttribute));
                        
                    if (httpMethod != null && httpMethod.Method == method)
                    {
                        // Invoke the method (in a real system, we'd also handle parameters)
                        methodInfo.Invoke(controller, null);
                        return;
                    }
                }
            }
        }
        
        Console.WriteLine("No route found");
    }
    
    private bool MatchesPath(string routePath, string requestPath)
    {
        // This is a simplified version of path matching
        // Real implementations would handle path parameters, etc.
        return routePath == requestPath;
    }
}
```

Using this router:

```csharp
Router router = new Router();
router.RouteRequest("/users", "GET"); // Will call GetUsers()
router.RouteRequest("/users", "POST"); // Will call CreateUser()
```

Output:
```
Retrieving all users
Creating a new user
```

## Best Practices for Using Attributes

1. **Be specific with AttributeUsage**: Always specify exactly which code elements can use your attribute to avoid misuse.

2. **Document your attributes**: Clearly document the purpose and usage of your attributes, especially if they're part of a public API.

3. **Avoid performance-critical code**: Attribute lookup through reflection can be slow. Cache results if you need to access attributes frequently.

4. **Keep attributes simple**: Attributes should primarily hold data, not implement complex logic.

5. **Use standard naming convention**: By convention, attribute class names end with "Attribute" (like `ObsoleteAttribute`), but when applying them, you can omit the suffix (like `[Obsolete]`).

## Summary

Attributes in C# provide a powerful mechanism for adding declarative metadata to your code. They enable many advanced scenarios:

- Marking code elements with additional information
- Building declarative programming interfaces
- Implementing cross-cutting concerns like validation
- Enabling framework features like serialization and dependency injection

Combined with reflection, attributes allow for dynamic, metadata-driven programming that can dramatically reduce boilerplate code and increase flexibility.

## Additional Resources

- [Official Microsoft Documentation on Attributes](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/attributes/)
- [Custom Attributes in C#](https://docs.microsoft.com/en-us/dotnet/standard/attributes/writing-custom-attributes)
- [System.ComponentModel.DataAnnotations Namespace](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations) - A built-in validation framework using attributes

## Exercises

1. Create a custom `LoggingAttribute` that can be applied to methods. When applied, it should log the method's name, parameters, and return value when the method is called.

2. Implement a simple dependency injection container that uses a custom `InjectAttribute` to automatically inject dependencies into class properties.

3. Create a serialization system that uses custom attributes to control which properties are serialized and how they're named in the output.

4. Extend the validation system from the example to include more validation types like `EmailAttribute`, `RangeAttribute`, etc.