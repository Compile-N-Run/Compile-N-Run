---
title: "C# Member Information"
description: "Learn how to use C# Reflection to access and manipulate member information such as properties, methods, fields, and events in classes and objects."

---

# C# Member Information

## Introduction

In C# programming, **reflection** gives us the power to examine and interact with the structure of types at runtime. One of the most common uses of reflection is to access **member information** - the properties, methods, fields, and events that make up a class or object.

Understanding how to access and use member information through reflection opens up powerful possibilities for dynamic programming, creating generic utilities, and working with components whose types aren't known at compile time.

In this tutorial, you'll learn:
- How to retrieve information about different member types
- How to get and set property values
- How to invoke methods dynamically
- Practical scenarios where member reflection is valuable

## The Basics of Member Information

In .NET, all members of a class (properties, methods, fields, events) are represented by specific classes in the `System.Reflection` namespace:

- `PropertyInfo`: Represents a property of a class
- `MethodInfo`: Represents a method of a class
- `FieldInfo`: Represents a field of a class
- `EventInfo`: Represents an event of a class

Let's start by examining how to access each of these member types.

## Getting Property Information

Properties are some of the most commonly accessed members through reflection. Here's how to get information about properties:

```csharp
using System;
using System.Reflection;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    private string Address { get; set; }
}

class Program
{
    static void Main()
    {
        // Get the type of Person
        Type personType = typeof(Person);
        
        // Get all public properties
        PropertyInfo[] properties = personType.GetProperties();
        
        Console.WriteLine("Public Properties of Person class:");
        foreach (PropertyInfo property in properties)
        {
            Console.WriteLine($"Name: {property.Name}, Type: {property.PropertyType}, Can Read: {property.CanRead}, Can Write: {property.CanWrite}");
        }
        
        // Get all properties, including non-public ones
        PropertyInfo[] allProperties = personType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        
        Console.WriteLine("\nAll Properties of Person class (including private):");
        foreach (PropertyInfo property in allProperties)
        {
            Console.WriteLine($"Name: {property.Name}, Type: {property.PropertyType}, Is Public: {property.GetMethod?.IsPublic}");
        }
    }
}
```

**Output:**
```
Public Properties of Person class:
Name: Name, Type: System.String, Can Read: True, Can Write: True
Name: Age, Type: System.Int32, Can Read: True, Can Write: True

All Properties of Person class (including private):
Name: Name, Type: System.String, Is Public: True
Name: Age, Type: System.Int32, Is Public: True
Name: Address, Type: System.String, Is Public: False
```

### Getting and Setting Property Values

Once you have a `PropertyInfo` object, you can get or set its value for a specific instance:

```csharp
Person person = new Person();
person.Name = "John";
person.Age = 30;

PropertyInfo nameProperty = typeof(Person).GetProperty("Name");

// Get the value
string name = (string)nameProperty.GetValue(person);
Console.WriteLine($"Name: {name}");  // Output: Name: John

// Set the value
nameProperty.SetValue(person, "Jane");
Console.WriteLine($"New name: {person.Name}");  // Output: New name: Jane
```

## Accessing Method Information

Methods can also be examined and even invoked through reflection:

```csharp
using System;
using System.Reflection;

public class Calculator
{
    public int Add(int a, int b) => a + b;
    
    private double Multiply(double a, double b) => a * b;
    
    public static void PrintMessage(string message) => Console.WriteLine(message);
}

class Program
{
    static void Main()
    {
        Type calculatorType = typeof(Calculator);
        
        // Get public methods
        MethodInfo[] methods = calculatorType.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
        
        Console.WriteLine("Public instance methods of Calculator:");
        foreach (MethodInfo method in methods)
        {
            Console.WriteLine($"Method: {method.Name}, Return Type: {method.ReturnType}");
            
            // List parameters
            ParameterInfo[] parameters = method.GetParameters();
            Console.Write("Parameters: ");
            if (parameters.Length == 0)
                Console.WriteLine("None");
            else
            {
                foreach (ParameterInfo param in parameters)
                {
                    Console.Write($"{param.ParameterType} {param.Name}, ");
                }
                Console.WriteLine();
            }
        }
    }
}
```

**Output:**
```
Public instance methods of Calculator:
Method: Add, Return Type: System.Int32
Parameters: System.Int32 a, System.Int32 b, 
```

### Invoking Methods Dynamically

You can invoke methods on an object using reflection:

```csharp
Calculator calculator = new Calculator();
MethodInfo addMethod = typeof(Calculator).GetMethod("Add");

// Invoke the Add method with parameters 5 and 3
object result = addMethod.Invoke(calculator, new object[] { 5, 3 });
Console.WriteLine($"5 + 3 = {result}");  // Output: 5 + 3 = 8

// Invoke a static method
MethodInfo printMethod = typeof(Calculator).GetMethod("PrintMessage");
printMethod.Invoke(null, new object[] { "Hello from reflection!" });  // Output: Hello from reflection!
```

## Working with Fields

Fields represent variables declared within a class scope:

```csharp
using System;
using System.Reflection;

public class Product
{
    public string Name;
    private decimal _price;
    public static int Count = 0;
    
    public Product(string name, decimal price)
    {
        Name = name;
        _price = price;
        Count++;
    }
}

class Program
{
    static void Main()
    {
        Type productType = typeof(Product);
        
        // Get all fields (public and private)
        FieldInfo[] fields = productType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | 
                                                  BindingFlags.Static | BindingFlags.Instance);
        
        Console.WriteLine("All fields of Product class:");
        foreach (FieldInfo field in fields)
        {
            string scope = field.IsPublic ? "public" : "private";
            string kind = field.IsStatic ? "static" : "instance";
            Console.WriteLine($"Name: {field.Name}, Type: {field.FieldType}, {scope} {kind}");
        }
        
        // Create a Product instance
        Product laptop = new Product("Laptop", 999.99m);
        
        // Get and set field values
        FieldInfo nameField = productType.GetField("Name");
        Console.WriteLine($"Name field value: {nameField.GetValue(laptop)}");  // Output: Name field value: Laptop
        
        nameField.SetValue(laptop, "Gaming Laptop");
        Console.WriteLine($"New name: {laptop.Name}");  // Output: New name: Gaming Laptop
        
        // Access private field
        FieldInfo priceField = productType.GetField("_price", BindingFlags.NonPublic | BindingFlags.Instance);
        Console.WriteLine($"Private price field value: {priceField.GetValue(laptop)}");  // Output: Private price field value: 999.99
        
        // Access static field
        FieldInfo countField = productType.GetField("Count");
        Console.WriteLine($"Static Count field value: {countField.GetValue(null)}");  // Output: Static Count field value: 1
    }
}
```

**Output:**
```
All fields of Product class:
Name: Name, Type: System.String, public instance
Name: _price, Type: System.Decimal, private instance
Name: Count, Type: System.Int32, public static
Name field value: Laptop
New name: Gaming Laptop
Private price field value: 999.99
Static Count field value: 1
```

## Exploring Events

Events are a bit trickier to work with through reflection, but you can still examine them:

```csharp
using System;
using System.Reflection;

public class Publisher
{
    public event EventHandler DataChanged;
    
    public void RaiseEvent()
    {
        DataChanged?.Invoke(this, EventArgs.Empty);
    }
}

class Program
{
    static void Main()
    {
        Type publisherType = typeof(Publisher);
        
        // Get event information
        EventInfo[] events = publisherType.GetEvents();
        
        Console.WriteLine("Events in the Publisher class:");
        foreach (EventInfo eventInfo in events)
        {
            Console.WriteLine($"Name: {eventInfo.Name}, EventHandlerType: {eventInfo.EventHandlerType.FullName}");
        }
    }
}
```

**Output:**
```
Events in the Publisher class:
Name: DataChanged, EventHandlerType: System.EventHandler
```

## Practical Example: Building a Dynamic Property Inspector

Let's create a utility that can display all property values of any object - useful for debugging or data inspection:

```csharp
using System;
using System.Reflection;

public static class ObjectInspector
{
    public static void InspectObject(object obj)
    {
        if (obj == null)
        {
            Console.WriteLine("Object is null");
            return;
        }
        
        Type type = obj.GetType();
        Console.WriteLine($"Object of type: {type.Name}");
        Console.WriteLine("Properties:");
        
        PropertyInfo[] properties = type.GetProperties();
        
        foreach (PropertyInfo property in properties)
        {
            try
            {
                object value = property.GetValue(obj);
                string valueStr = value?.ToString() ?? "null";
                Console.WriteLine($"  {property.Name}: {valueStr}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  {property.Name}: [Error accessing property: {ex.Message}]");
            }
        }
    }
}

// Example usage
class Program
{
    static void Main()
    {
        var person = new Person { Name = "Alice", Age = 25 };
        ObjectInspector.InspectObject(person);
        
        Console.WriteLine();
        
        var dateTime = DateTime.Now;
        ObjectInspector.InspectObject(dateTime);
    }
}
```

**Output:**
```
Object of type: Person
Properties:
  Name: Alice
  Age: 25

Object of type: DateTime
Properties:
  Date: 10/12/2023 12:00:00 AM
  Day: 12
  DayOfWeek: Thursday
  DayOfYear: 285
  Hour: 14
  Kind: Local
  Millisecond: 345
  Minute: 25
  Month: 10
  Second: 30
  Ticks: 638326539303456789
  TimeOfDay: 14:25:30.3456789
  Year: 2023
```

## Real-World Applications

Member reflection is extremely useful in many scenarios:

1. **ORM (Object-Relational Mapping)** libraries like Entity Framework use reflection to map between database columns and object properties.

2. **Serialization/Deserialization**: Libraries like JSON.NET use reflection to convert between objects and JSON.

3. **Unit Testing Frameworks**: Test frameworks often use reflection to find test methods and access private members for testing.

4. **Dependency Injection Containers**: These use reflection to create and wire up instances at runtime.

5. **Plugin Systems**: When loading plugins dynamically, reflection helps discover their functionality.

Here's a simple example of how you might implement a basic JSON serializer using reflection:

```csharp
using System;
using System.Reflection;
using System.Text;

public static class SimpleJsonSerializer
{
    public static string Serialize(object obj)
    {
        if (obj == null) return "null";
        
        Type type = obj.GetType();
        
        // Handle primitive types and strings
        if (type.IsPrimitive)
            return obj.ToString().ToLowerInvariant();
        if (type == typeof(string))
            return $"\"{obj}\"";
        
        // Handle objects by serializing their properties
        var sb = new StringBuilder();
        sb.Append("{");
        
        PropertyInfo[] properties = type.GetProperties();
        bool first = true;
        
        foreach (PropertyInfo property in properties)
        {
            // Skip non-readable properties
            if (!property.CanRead) continue;
            
            // Add comma if not the first property
            if (!first) sb.Append(",");
            first = false;
            
            // Add property name
            sb.Append($"\"{property.Name}\":");
            
            // Add property value
            object value = property.GetValue(obj);
            sb.Append(Serialize(value));
        }
        
        sb.Append("}");
        return sb.ToString();
    }
}

// Usage example
class Program
{
    static void Main()
    {
        var person = new Person { Name = "Bob", Age = 42 };
        string json = SimpleJsonSerializer.Serialize(person);
        Console.WriteLine(json);  // Output: {"Name":"Bob","Age":42}
    }
}
```

## Performance Considerations

While reflection is powerful, it's important to understand its performance implications:

1. **Slower Execution**: Reflection operations are significantly slower than direct method calls or property access.

2. **Caching**: If you need to repeatedly access the same members, cache the `PropertyInfo`, `MethodInfo`, etc. objects rather than retrieving them each time.

3. **Use Selectively**: Only use reflection when necessary. For performance-critical code, consider alternatives like code generation or expression trees.

## Summary

In this tutorial, you've learned how to:

- Access property, method, field, and event information through reflection
- Get and set property and field values dynamically
- Invoke methods at runtime
- Apply reflection in practical scenarios like object inspection and serialization

Reflection's ability to access member information gives C# developers powerful tools for creating flexible, dynamic code. While it should be used judiciously due to performance considerations, understanding member reflection opens up possibilities for creating generic frameworks and tools that can work with arbitrary types.

## Additional Resources

- [Official Microsoft Docs on Reflection](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection)
- [Performance Tips for Reflection in .NET](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection-performance)

## Exercises

1. Create a method that takes an object and a string property name, and returns the property's value.

2. Write a utility that compares two objects of the same type and lists any properties that have different values.

3. Implement a simple "object copier" that creates a new instance of a class and copies all property values from one object to another using reflection.

4. Create a utility that can automatically generate an "Equals" method implementation for any class by comparing all properties.

5. Extend the SimpleJsonSerializer to handle collections like `List<T>` and arrays.