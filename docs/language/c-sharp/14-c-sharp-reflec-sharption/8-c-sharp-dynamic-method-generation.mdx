---
title: C# Dynamic Method Generation
description: Learn how to dynamically create and execute methods at runtime using C# reflection capabilities

---

# C# Dynamic Method Generation

## Introduction

Dynamic Method Generation is an advanced feature of C# that allows you to create and execute methods at runtime rather than compile time. It falls under the broader umbrella of reflection but focuses specifically on generating executable code dynamically. This powerful capability enables scenarios where you need to:

- Create high-performance data access code
- Build expression evaluators
- Implement just-in-time compilation techniques
- Generate proxy classes for interoperability

While this might sound intimidating for beginners, understanding the basics of dynamic method generation can open up new possibilities in your C# programming journey.

## Understanding the Basics

### What is Dynamic Method Generation?

Dynamic method generation involves creating methods programmatically during runtime that can be executed just like regular methods. This is different from typical C# development where methods are defined at compile time.

In C#, the primary tool for dynamic method generation is the `DynamicMethod` class from the `System.Reflection.Emit` namespace. This class allows you to:

1. Define a method signature (return type, parameters)
2. Generate the method body using IL (Intermediate Language) instructions
3. Create a delegate to the method for easy invocation

### Prerequisites

Before diving into dynamic method generation, you should be familiar with:

- Basic C# syntax and concepts
- Understanding of what delegates are
- Basic knowledge of reflection
- (Optional but helpful) Understanding of how .NET compiles and executes code

## Creating a Simple Dynamic Method

Let's start by creating a very simple dynamic method that adds two integers:

```csharp
using System;
using System.Reflection;
using System.Reflection.Emit;

class Program
{
    static void Main()
    {
        // 1. Define the dynamic method with its signature
        DynamicMethod addMethod = new DynamicMethod(
            "Add",                                   // Method name
            typeof(int),                             // Return type
            new Type[] { typeof(int), typeof(int) }, // Parameter types
            typeof(Program).Module);                 // Module where the method will be available
            
        // 2. Get an IL generator for the method
        ILGenerator il = addMethod.GetILGenerator();
        
        // 3. Generate the method body using IL instructions
        il.Emit(OpCodes.Ldarg_0);      // Load the first argument onto the stack
        il.Emit(OpCodes.Ldarg_1);      // Load the second argument onto the stack
        il.Emit(OpCodes.Add);          // Add the two values on the stack
        il.Emit(OpCodes.Ret);          // Return the result
        
        // 4. Create a delegate to the method (to make it callable)
        var add = (Func<int, int, int>)addMethod.CreateDelegate(typeof(Func<int, int, int>));
        
        // 5. Call the dynamically generated method
        int result = add(5, 7);
        Console.WriteLine($"5 + 7 = {result}");  // Output: 5 + 7 = 12
    }
}
```

### Step-by-Step Explanation

1. **Define the Method Signature**: We create a `DynamicMethod` specifying its name, return type, parameter types, and the module where it will be available.

2. **Get an IL Generator**: The `ILGenerator` allows us to emit IL instructions that make up the method body.

3. **Emit IL Instructions**: We create the method body using IL opcodes:
   - `Ldarg_0` and `Ldarg_1` load the first and second arguments onto the evaluation stack.
   - `Add` pops those two values, adds them, and pushes the result back onto the stack.
   - `Ret` returns from the method with the value on top of the stack.

4. **Create a Delegate**: We create a strongly-typed delegate to our dynamic method to make it easily callable.

5. **Invoke the Method**: We call our dynamic method using the delegate and get the result.

## Understanding IL Instructions

IL (Intermediate Language) instructions are the low-level commands that the .NET runtime executes. Writing IL directly requires understanding how the evaluation stack works:

- Values are pushed onto the stack
- Operations pop values from the stack, process them, and push results back
- Local variables can store values from the stack

Here's a quick reference of common IL instructions:

| Instruction | Description |
|-------------|-------------|
| `Ldarg_n` | Load argument number n onto the stack |
| `Ldloc_n` | Load local variable number n onto the stack |
| `Stloc_n` | Store value from stack into local variable n |
| `Ldc_I4_n` | Load integer constant n onto the stack |
| `Add`, `Sub`, `Mul`, `Div` | Arithmetic operations |
| `Ret` | Return from method |

## Practical Example: Dynamic Property Accessor

A common real-world application of dynamic method generation is creating fast property accessors. Let's create a dynamic method that gets a property value from an object:

```csharp
using System;
using System.Reflection;
using System.Reflection.Emit;

public class Person
{
    public string Name { get; set; }
}

public static class FastPropertyAccessor
{
    public static Func<object, object> CreateGetter(PropertyInfo property)
    {
        // Define a dynamic method that takes an object and returns an object
        DynamicMethod getter = new DynamicMethod(
            "Get_" + property.Name,
            typeof(object),
            new Type[] { typeof(object) },
            property.DeclaringType.Module);
            
        ILGenerator il = getter.GetILGenerator();
        
        // Cast the input object to the correct type
        il.Emit(OpCodes.Ldarg_0);
        il.Emit(OpCodes.Castclass, property.DeclaringType);
        
        // Call the property's get method
        il.EmitCall(OpCodes.Callvirt, property.GetMethod, null);
        
        // Box value types to object
        if (property.PropertyType.IsValueType)
        {
            il.Emit(OpCodes.Box, property.PropertyType);
        }
        
        il.Emit(OpCodes.Ret);
        
        // Create and return the delegate
        return (Func<object, object>)getter.CreateDelegate(typeof(Func<object, object>));
    }
}

class Program
{
    static void Main()
    {
        // Get the property info
        PropertyInfo nameProperty = typeof(Person).GetProperty("Name");
        
        // Create a fast getter for the Name property
        var nameGetter = FastPropertyAccessor.CreateGetter(nameProperty);
        
        // Use the getter
        Person person = new Person { Name = "John Doe" };
        string name = (string)nameGetter(person);
        
        Console.WriteLine($"Person's name: {name}");  // Output: Person's name: John Doe
        
        // Compare to normal reflection for educational purposes
        string nameViaReflection = (string)nameProperty.GetValue(person);
        Console.WriteLine($"Name via standard reflection: {nameViaReflection}");
    }
}
```

### Performance Advantage

Dynamic method generation can provide significant performance improvements over regular reflection. While regular reflection involves runtime lookup and invocation overhead for each call, a dynamically generated method only incurs this cost once during creation.

## Advanced Example: Expression Evaluator

Let's create a simple expression evaluator that takes a mathematical expression as a string and compiles it into a dynamically generated method:

```csharp
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

public class SimpleExpressionEvaluator
{
    public static Func<int, int> CompileExpression(string expression)
    {
        // This is a very simplified parser for expressions like "x + 5", "x * 3", etc.
        string[] parts = expression.Split(' ');
        if (parts.Length != 3 || parts[0] != "x")
            throw new ArgumentException("Only expressions in the form 'x op number' are supported");
        
        string op = parts[1];
        int constant = int.Parse(parts[2]);
        
        // Create a dynamic method that takes an int and returns an int
        DynamicMethod evalMethod = new DynamicMethod(
            "Eval_" + Guid.NewGuid().ToString("N"),
            typeof(int),
            new Type[] { typeof(int) },
            typeof(SimpleExpressionEvaluator).Module);
            
        ILGenerator il = evalMethod.GetILGenerator();
        
        // Load the input parameter (x)
        il.Emit(OpCodes.Ldarg_0);
        
        // Load the constant
        il.Emit(OpCodes.Ldc_I4, constant);
        
        // Perform the operation
        switch (op)
        {
            case "+":
                il.Emit(OpCodes.Add);
                break;
            case "-":
                il.Emit(OpCodes.Sub);
                break;
            case "*":
                il.Emit(OpCodes.Mul);
                break;
            case "/":
                il.Emit(OpCodes.Div);
                break;
            default:
                throw new ArgumentException($"Unsupported operation: {op}");
        }
        
        il.Emit(OpCodes.Ret);
        
        // Create and return the delegate
        return (Func<int, int>)evalMethod.CreateDelegate(typeof(Func<int, int>));
    }
}

class Program
{
    static void Main()
    {
        // Compile expressions into functions
        var addFive = SimpleExpressionEvaluator.CompileExpression("x + 5");
        var multiplyByThree = SimpleExpressionEvaluator.CompileExpression("x * 3");
        
        // Use the compiled functions
        Console.WriteLine($"10 + 5 = {addFive(10)}");           // Output: 10 + 5 = 15
        Console.WriteLine($"7 * 3 = {multiplyByThree(7)}");     // Output: 7 * 3 = 21
        
        // We can reuse the compiled functions many times with different inputs
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine($"{i} + 5 = {addFive(i)}");
        }
    }
}
```

This example demonstrates a practical use case where dynamic method generation can be used to compile expressions into efficient, executable code.

## Best Practices and Considerations

When working with dynamic method generation:

1. **Cache Generated Methods**: Creating dynamic methods has overhead, so cache and reuse them when possible.

2. **Error Handling**: IL generation errors won't be caught at compile time, so implement proper error handling and validation.

3. **Security Considerations**: Dynamic code generation can introduce security risks if not handled carefully, especially when the input comes from user input.

4. **Performance Testing**: Always benchmark your dynamic methods against alternatives to ensure they provide the expected performance benefits.

5. **Debugging Challenges**: Dynamically generated methods can be harder to debug than regular code.

## Summary

Dynamic method generation in C# is a powerful technique that allows you to:

- Create methods at runtime
- Generate high-performance alternatives to reflection
- Build flexible and extensible systems

While it has a steeper learning curve due to the need to understand IL instructions, it provides a level of flexibility and performance optimization that can't be achieved with standard C# code alone.

As you continue to work with C# and explore more advanced scenarios, dynamic method generation can be a valuable tool in your programming toolkit, especially when dealing with performance-critical applications or creating frameworks that need to adapt to different data models at runtime.

## Additional Resources and Exercises

### Resources
- [Microsoft Documentation on DynamicMethod](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.dynamicmethod)
- [IL Opcode Reference](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes)
- [Understanding MSIL (Microsoft Intermediate Language)](https://docs.microsoft.com/en-us/dotnet/standard/managed-execution-process)

### Exercises

1. **Simple Calculator**: Extend the expression evaluator to handle more complex expressions like "x + y * 2".

2. **Property Setter**: Implement a dynamic property setter to complement the getter example.

3. **Method Invoker**: Create a dynamic method that can invoke any method on a given object with better performance than regular reflection.

4. **Conditional Logic**: Build a dynamic method that includes conditional branching using `OpCodes.Brfalse` or `OpCodes.Brtrue`.

5. **Benchmark**: Compare the performance of standard reflection, compiled expression trees, and dynamic method generation for property access.

By practicing these exercises, you'll gain a deeper understanding of dynamic method generation and its practical applications in C#.