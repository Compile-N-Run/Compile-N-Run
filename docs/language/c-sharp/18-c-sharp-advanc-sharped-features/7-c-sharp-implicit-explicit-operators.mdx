---
title: "C# Implicit Explicit Operators"
description: "Learn how to create custom type conversion operators in C# using implicit and explicit operators, with practical examples and best practices."

---

# C# Implicit and Explicit Operators

## Introduction

In C#, type conversion is a common operation that allows you to convert a value from one type to another. While C# provides built-in conversions for primitive types, sometimes you need to define custom conversions between your own types or between your types and existing ones.

This is where **implicit** and **explicit** operators come into play. These operators allow you to define how instances of your classes or structs can be converted to or from other types, making your code more intuitive and reducing the need for helper methods.

## Understanding Type Conversion

Before diving into custom operators, let's review the built-in type conversions in C#:

1. **Implicit conversion**: Happens automatically when there's no risk of data loss
   ```csharp
   int number = 100;
   long bigNumber = number; // Implicit conversion from int to long
   ```

2. **Explicit conversion** (casting): Requires an explicit cast operation and acknowledges potential data loss
   ```csharp
   double pi = 3.14159;
   int approximatePi = (int)pi; // Explicit conversion, data loss occurs (result: 3)
   ```

## Custom Conversion Operators

C# allows you to define your own conversion operators for your custom types using the `implicit` and `explicit` keywords.

### Implicit Operators

An implicit operator defines a conversion that can be performed automatically by the compiler. Use implicit operators when:

- The conversion is always safe
- No data or precision will be lost
- The conversion is a logical extension of the source type

#### Syntax:

```csharp
public static implicit operator TargetType(SourceType source)
{
    // Conversion logic here
    return new TargetType(...);
}
```

### Explicit Operators

An explicit operator defines a conversion that requires an explicit cast. Use explicit operators when:

- The conversion might cause data loss
- The conversion isn't always valid
- The developer should be aware of the potential issues

#### Syntax:

```csharp
public static explicit operator TargetType(SourceType source)
{
    // Conversion logic here
    return new TargetType(...);
}
```

## Practical Examples

### Example 1: Temperature Conversion

Let's create a `Temperature` class that can be implicitly and explicitly converted between Celsius and Fahrenheit:

```csharp
public class Celsius
{
    public double Degrees { get; }

    public Celsius(double degrees)
    {
        Degrees = degrees;
    }

    // Implicit conversion from Celsius to Fahrenheit
    public static implicit operator Fahrenheit(Celsius celsius)
    {
        return new Fahrenheit(celsius.Degrees * 9 / 5 + 32);
    }

    public override string ToString() => $"{Degrees}°C";
}

public class Fahrenheit
{
    public double Degrees { get; }

    public Fahrenheit(double degrees)
    {
        Degrees = degrees;
    }

    // Explicit conversion from Fahrenheit to Celsius
    public static explicit operator Celsius(Fahrenheit fahrenheit)
    {
        return new Celsius((fahrenheit.Degrees - 32) * 5 / 9);
    }

    public override string ToString() => $"{Degrees}°F";
}
```

Now let's see how we can use these conversions:

```csharp
// Usage example
Celsius freezing = new Celsius(0);
Fahrenheit fahrenheit = freezing;  // Implicit conversion
Console.WriteLine($"Water freezes at {freezing} or {fahrenheit}");

Fahrenheit boiling = new Fahrenheit(212);
Celsius celsius = (Celsius)boiling;  // Explicit conversion required
Console.WriteLine($"Water boils at {celsius} or {boiling}");
```

**Output:**
```
Water freezes at 0°C or 32°F
Water boils at 100°C or 212°F
```

Notice how we didn't need to call any conversion methods. The implicit operator allowed direct assignment from `Celsius` to `Fahrenheit`, while the explicit operator required the casting syntax `(Celsius)`.

### Example 2: Money and Decimal Conversion

Let's create a `Money` class that represents a monetary amount and implement conversion operators:

```csharp
public class Money
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency = "USD")
    {
        Amount = amount;
        Currency = currency;
    }

    // Implicit conversion from decimal to Money
    public static implicit operator Money(decimal amount)
    {
        return new Money(amount);
    }

    // Explicit conversion from Money to decimal
    // Explicit because we're losing the currency information
    public static explicit operator decimal(Money money)
    {
        return money.Amount;
    }

    public override string ToString() => $"{Amount} {Currency}";
}
```

Using the `Money` class:

```csharp
// Implicit conversion from decimal to Money
Money salary = 5000.50m;  // No explicit cast needed
Console.WriteLine($"Monthly salary: {salary}");

// Explicit conversion from Money to decimal
Money price = new Money(29.99m, "USD");
decimal rawPrice = (decimal)price;  // Explicit cast required
Console.WriteLine($"Raw price value: {rawPrice}");
```

**Output:**
```
Monthly salary: 5000.50 USD
Raw price value: 29.99
```

## Real-World Applications

### Complex Number Conversion

Complex numbers are frequently used in engineering, physics, and computer graphics. Let's implement a `Complex` struct with conversion operators:

```csharp
public struct Complex
{
    public double Real { get; }
    public double Imaginary { get; }

    public Complex(double real, double imaginary)
    {
        Real = real;
        Imaginary = imaginary;
    }

    // Implicit conversion from double to Complex (real part only)
    public static implicit operator Complex(double real)
    {
        return new Complex(real, 0);
    }

    // Explicit conversion from Complex to double (loses imaginary part)
    public static explicit operator double(Complex complex)
    {
        // We're losing the imaginary part, so this should be explicit
        return complex.Real;
    }

    // Magnitude of the complex number
    public double Magnitude => Math.Sqrt(Real * Real + Imaginary * Imaginary);

    public override string ToString()
    {
        if (Imaginary == 0) return Real.ToString();
        if (Real == 0) return $"{Imaginary}i";
        string sign = Imaginary > 0 ? "+" : "";
        return $"{Real}{sign}{Imaginary}i";
    }
}
```

Usage:

```csharp
// Implicit conversion from double to Complex
Complex c1 = 5.0;
Console.WriteLine($"c1: {c1}");

// Creating a complex number normally
Complex c2 = new Complex(3, 4);
Console.WriteLine($"c2: {c2}");
Console.WriteLine($"Magnitude of c2: {c2.Magnitude}");

// Explicit conversion from Complex to double
double realPart = (double)c2;  // Explicit cast, loses imaginary part
Console.WriteLine($"Real part of c2: {realPart}");
```

**Output:**
```
c1: 5
c2: 3+4i
Magnitude of c2: 5
Real part of c2: 3
```

### Database ID Conversion

In applications with database interaction, it's common to wrap primitive ID types in strongly-typed wrapper classes:

```csharp
public readonly struct UserId
{
    public int Value { get; }

    public UserId(int value)
    {
        if (value <= 0)
            throw new ArgumentOutOfRangeException(nameof(value), "User ID must be positive");
        Value = value;
    }

    // Implicit conversion from UserId to int
    public static implicit operator int(UserId userId) => userId.Value;

    // Explicit conversion from int to UserId
    // Explicit because not all integers are valid UserIds
    public static explicit operator UserId(int value) => new UserId(value);

    public override string ToString() => Value.ToString();
}
```

Usage:

```csharp
// Create a UserId
UserId userId = new UserId(42);

// Implicit conversion to int
int rawId = userId;
Console.WriteLine($"Raw ID: {rawId}");

// Explicit conversion from int
UserId fromInt = (UserId)123;
Console.WriteLine($"User ID from int: {fromInt}");

// This would throw an exception due to the validation
try
{
    UserId invalid = (UserId)(-5);
}
catch (Exception ex)
{
    Console.WriteLine($"Error: {ex.Message}");
}

// Using in a database context (simulated)
void FindUserInDatabase(int id)
{
    Console.WriteLine($"Finding user with ID: {id} in database...");
}

// We can pass UserId directly to methods expecting int
FindUserInDatabase(userId);
```

**Output:**
```
Raw ID: 42
User ID from int: 123
Error: User ID must be positive (Parameter 'value')
Finding user with ID: 42 in database...
```

## Best Practices

1. **Use implicit operators only when the conversion is lossless and always safe**
   - Conversion from a specialized type to a more general type
   - Conversions that preserve all information

2. **Use explicit operators when:**
   - There's potential data loss
   - The conversion isn't always valid
   - Runtime checks are needed

3. **Maintain symmetry where possible:**
   - If you define a conversion from A to B, consider defining the reverse conversion
   - Be consistent with implicit/explicit choices

4. **Don't overuse:**
   - Conversion operators can make code less readable if overused
   - Use them primarily for intuitive conversions that reduce verbosity

5. **Consider null handling:**
   - Define behavior for null values in reference types
   - Document the behavior clearly

## When to Use Conversion Operators vs. Methods

**Use operators when:**
- The conversion is natural and intuitive
- You want to enable direct assignment or casting syntax
- The conversion is a core capability of the type

**Use methods when:**
- The conversion is complex or conditional
- You want to provide multiple overloaded versions with different parameters
- The operation isn't really a conversion (e.g., it's a formatting or transformation)

## Summary

Implicit and explicit operators in C# are powerful tools for defining custom type conversions. They allow you to create more intuitive APIs by enabling direct assignment or casting syntax between your types.

- **Implicit operators** (`public static implicit operator TargetType(SourceType source)`) enable automatic conversions when there's no risk of data loss
- **Explicit operators** (`public static explicit operator TargetType(SourceType source)`) require an explicit cast, acknowledging potential data loss

By implementing these operators appropriately, you can make your code more readable and reduce the need for explicit conversion helper methods.

## Additional Resources

- [C# Documentation on User-defined Conversion Operators](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators)
- [C# Programming Guide: Casting and Type Conversions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions)

## Exercises

1. Create a `Percentage` struct that can be implicitly converted to and from decimal values (0-100)
2. Implement a `FileSize` class with conversions between bytes, kilobytes, and megabytes
3. Design a `Fraction` struct with implicit/explicit conversions to and from double/decimal
4. Create a strongly-typed `EmailAddress` class with appropriate conversion operators
5. Implement a `Duration` class that can represent time spans and convert between various units (seconds, minutes, hours)