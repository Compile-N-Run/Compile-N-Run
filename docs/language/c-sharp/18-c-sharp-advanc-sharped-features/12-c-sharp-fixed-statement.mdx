---
title: C# Fixed Statement
description: Learn how to use the fixed statement in C# to prevent the garbage collector from relocating variables, especially when working with unmanaged resources and unsafe code.

---

# C# Fixed Statement

## Introduction

The `fixed` statement in C# is a specialized feature that belongs to the realm of unsafe code. It's designed to temporarily "pin" a managed object in memory, preventing the garbage collector from relocating it during the execution of a block of code. This is particularly important when working with unmanaged code or when passing managed memory to external methods that might hold references to that memory across operations.

Understanding the `fixed` statement requires some knowledge of how C#'s garbage collection works. In normal C# code, the garbage collector can move objects around in memory to optimize memory usage. However, when working with unmanaged code or when direct memory manipulation is needed, we need to ensure objects stay at fixed memory locationsâ€”and that's precisely what the `fixed` statement helps us achieve.

## The Basics of the Fixed Statement

### Syntax

The basic syntax for the `fixed` statement is:

```csharp
unsafe
{
    fixed (type* pointer = &variable | array | string)
    {
        // Code that uses the pointer
    }
}
```

Key points to note:
1. The `fixed` statement must be inside an `unsafe` context
2. It pins a variable, array, or string to a specific memory location
3. It creates a pointer to this memory location
4. The pinned object remains fixed only within the scope of the `fixed` block

### When to Use the Fixed Statement

You should consider using the `fixed` statement when:
- Working with unmanaged code that interacts with managed data
- Passing data to native APIs
- Performing direct memory manipulation for performance-critical operations
- Working with hardware interactions where memory addresses need to be stable

## Using Fixed with Different Types

### Fixed with Arrays

One common use of the `fixed` statement is to pin arrays in memory when you need to pass them to unmanaged code:

```csharp
unsafe
{
    int[] numbers = { 1, 2, 3, 4, 5 };
    
    // Pin the array and get a pointer to its first element
    fixed (int* ptr = numbers)
    {
        // Now we can work with the array via pointer arithmetic
        for (int i = 0; i < numbers.Length; i++)
        {
            Console.WriteLine($"Element at position {i}: {*(ptr + i)}");
        }
    }
    // Outside the fixed block, the array can be moved by the GC again
}
```

Output:
```
Element at position 0: 1
Element at position 1: 2
Element at position 2: 3
Element at position 3: 4
Element at position 4: 5
```

### Fixed with Strings

Strings in C# are immutable but can still be pinned for interop scenarios:

```csharp
unsafe
{
    string message = "Hello, World!";
    
    fixed (char* ptr = message)
    {
        // Now we can access characters directly
        for (int i = 0; i < message.Length; i++)
        {
            Console.WriteLine($"Character at position {i}: {*(ptr + i)}");
        }
    }
}
```

Output (first few lines):
```
Character at position 0: H
Character at position 1: e
Character at position 2: l
Character at position 3: l
Character at position 4: o
```

### Fixed with Structs Containing Reference Types

If you have a struct that contains reference types (like arrays), you can pin those fields:

```csharp
unsafe
{
    struct DataPacket
    {
        public int Id;
        public byte[] Data;
    }

    DataPacket packet = new DataPacket
    {
        Id = 42,
        Data = new byte[] { 10, 20, 30, 40, 50 }
    };

    fixed (byte* dataPtr = packet.Data)
    {
        // The Data array is now pinned in memory
        for (int i = 0; i < packet.Data.Length; i++)
        {
            Console.WriteLine($"Byte at index {i}: {*(dataPtr + i)}");
        }
    }
}
```

Output:
```
Byte at index 0: 10
Byte at index 1: 20
Byte at index 2: 30
Byte at index 3: 40
Byte at index 4: 50
```

## Using Multiple Fixed Pointers

You can pin multiple objects in a single `fixed` statement:

```csharp
unsafe
{
    int[] ages = { 25, 30, 35 };
    int[] scores = { 90, 85, 95 };
    
    fixed (int* agesPtr = ages, scoresPtr = scores)
    {
        for (int i = 0; i < ages.Length; i++)
        {
            Console.WriteLine($"Person {i}: Age = {*(agesPtr + i)}, Score = {*(scoresPtr + i)}");
        }
    }
}
```

Output:
```
Person 0: Age = 25, Score = 90
Person 1: Age = 30, Score = 85
Person 2: Age = 35, Score = 95
```

## Real-World Applications

### Image Processing

A common practical use of the `fixed` statement is in image processing, where direct pixel manipulation can significantly improve performance:

```csharp
unsafe
{
    // Simplified example: Modifying image data
    byte[] imageData = GetImageData(); // Assume this method returns image bytes
    
    fixed (byte* ptr = imageData)
    {
        // Apply a brightness adjustment
        for (int i = 0; i < imageData.Length; i++)
        {
            // Increase brightness by 10, but don't exceed 255
            byte newValue = (byte)Math.Min(255, *(ptr + i) + 10);
            *(ptr + i) = newValue;
        }
    }
    
    // Now imageData contains the modified image
    SaveImageData(imageData);
}

// These methods would be implemented elsewhere
static byte[] GetImageData() => new byte[] { 100, 150, 200, 125, 175 }; // Simplified
static void SaveImageData(byte[] data) 
{
    Console.WriteLine("Modified image data:");
    foreach (var b in data)
        Console.Write($"{b} ");
}
```

Output:
```
Modified image data:
110 160 210 135 185
```

### Interoperability with Native Code

Another common scenario is interfacing with native libraries:

```csharp
using System;
using System.Runtime.InteropServices;

class NativeInterop
{
    // Import a native function from a DLL
    [DllImport("NativeDLL.dll")]
    private static extern void ProcessBuffer(IntPtr buffer, int length);
    
    public static void ProcessManagedArray(int[] data)
    {
        unsafe
        {
            fixed (int* ptr = data)
            {
                // Convert the pointer to IntPtr for P/Invoke
                IntPtr bufferPtr = (IntPtr)ptr;
                
                // Call the native function
                ProcessBuffer(bufferPtr, data.Length);
                
                // The native function may have modified the data
                // When we exit the fixed block, the array is no longer pinned
            }
        }
        
        // data array now potentially contains results from the native code
    }
}
```

## Fixed Buffer Size in Structs

C# also allows the creation of fixed-size buffers within structs using the `fixed` keyword, which is slightly different from the `fixed` statement:

```csharp
unsafe
{
    // Define a struct with fixed-size buffers
    public struct Packet
    {
        public fixed byte Header[16];
        public fixed char Message[128];
        public int CheckSum;
    }
    
    // Using the struct
    Packet packet = new Packet();
    
    // Accessing the fixed buffers
    packet.CheckSum = 42;
    
    fixed (byte* headerPtr = packet.Header)
    {
        // Initialize header
        for (int i = 0; i < 16; i++)
        {
            headerPtr[i] = (byte)(i + 1);
        }
    }
    
    fixed (char* messagePtr = packet.Message)
    {
        // Copy a string into the message buffer
        string text = "Hello from fixed buffer!";
        for (int i = 0; i < text.Length && i < 128; i++)
        {
            messagePtr[i] = text[i];
        }
    }
    
    // Display the packet contents
    Console.WriteLine($"Packet CheckSum: {packet.CheckSum}");
    fixed (byte* headerPtr = packet.Header)
    {
        Console.Write("Header bytes: ");
        for (int i = 0; i < 5; i++) // Just showing first 5 bytes
        {
            Console.Write($"{headerPtr[i]} ");
        }
        Console.WriteLine();
    }
}
```

Output:
```
Packet CheckSum: 42
Header bytes: 1 2 3 4 5
```

## Potential Pitfalls and Considerations

When using the `fixed` statement, be aware of these important considerations:

1. **Limited Scope**: The pointer created with `fixed` is only valid within the scope of the `fixed` block. Using it outside this scope can lead to undefined behavior.

2. **Memory Management**: While objects are pinned, the garbage collector's efficiency might be reduced, as it cannot move these objects to optimize memory.

3. **Safety**: Unsafe code bypasses C#'s type safety and should be used judiciously.

4. **Performance**: While direct memory manipulation can improve performance, incorrectly using pointers can lead to difficult-to-find bugs.

5. **Platform-Specific**: Pointer operations may behave differently across different architectures and platforms.

## Summary

The `fixed` statement in C# is a powerful tool that allows you to pin objects in memory when working with unsafe code. It's particularly useful for interop scenarios with native code, direct memory manipulation, and performance-critical operations.

Key takeaways:
- The `fixed` statement prevents the garbage collector from moving objects in memory
- It must be used within an `unsafe` context
- It creates pointers to the pinned memory
- It works with arrays, strings, and structs containing reference types
- It's commonly used for image processing and interop with native code
- Fixed-size buffers can be declared within structs using the `fixed` keyword

While powerful, the `fixed` statement should be used carefully and only when necessary, as it involves unsafe code that bypasses C#'s type safety mechanisms.

## Additional Resources

- [Official Microsoft Documentation on the fixed Statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/fixed-statement)
- [C# Unsafe Code Tutorial](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code)
- [Interoperability in .NET](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/)

## Exercises

1. Create a program that uses the `fixed` statement to find the sum of all elements in an integer array using pointer arithmetic.

2. Write a function that performs a case-insensitive string comparison using the `fixed` statement and pointers.

3. Implement a simple image processing function that inverts the colors of an image by directly manipulating pixel data using the `fixed` statement.

4. Create a struct with fixed-size buffers and implement methods to serialize and deserialize data to and from these buffers.

5. Write a program that uses the `fixed` statement to efficiently swap elements in a large array without creating temporary copies.