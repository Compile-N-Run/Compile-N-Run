---
title: "C# File-scoped Namespaces"
description: "Learn about file-scoped namespaces in C#, a modern syntax introduced in C# 10 that simplifies namespace declarations and makes code more concise."

---

# C# File-scoped Namespaces

## Introduction

Namespaces in C# have always been an essential organizational tool, helping developers structure their code and avoid naming conflicts. Traditionally, namespaces required curly braces `{}` and indentation, which added visual noise to the code. With C# 10, Microsoft introduced **file-scoped namespaces**, a more concise syntax that can make your code cleaner and easier to read.

In this lesson, we'll explore what file-scoped namespaces are, how they differ from traditional namespaces, and when you should use them in your C# projects.

## Understanding Traditional Namespaces

Before diving into file-scoped namespaces, let's refresh our understanding of traditional namespace declarations in C#:

```csharp
using System;

namespace MyApplication.Services
{
    public class UserService
    {
        public void RegisterUser()
        {
            Console.WriteLine("Registering user...");
        }
    }
    
    public class EmailService
    {
        public void SendWelcomeEmail()
        {
            Console.WriteLine("Sending welcome email...");
        }
    }
    
    // More classes, interfaces, etc.
}
```

In this traditional approach, the entire file content must be indented within the namespace's curly braces. While this works perfectly fine, it creates an extra level of indentation that doesn't provide much value in most cases.

## Introducing File-Scoped Namespaces

File-scoped namespaces, introduced in C# 10, allow you to declare a namespace for an entire file without using curly braces. The syntax is simpler and requires just a semicolon at the end of the namespace declaration:

```csharp
using System;

namespace MyApplication.Services;  // Notice the semicolon instead of opening brace

public class UserService
{
    public void RegisterUser()
    {
        Console.WriteLine("Registering user...");
    }
}

public class EmailService
{
    public void SendWelcomeEmail()
    {
        Console.WriteLine("Sending welcome email...");
    }
}

// More classes, interfaces, etc.
```

As you can see, this eliminates one level of indentation, making the code cleaner and easier to read.

## Key Rules and Considerations

When using file-scoped namespaces, there are some important rules to keep in mind:

1. **Only one namespace per file**: With file-scoped namespaces, you can only have one namespace declaration per file. This enforces a clean organization approach.

2. **Top-level position**: The file-scoped namespace declaration must appear before any type declarations in the file (but after using directives).

3. **No nested namespaces**: You cannot nest traditional namespaces inside a file-scoped namespace.

4. **No non-namespace members**: All code in the file becomes part of the declared namespace.

Let's see what happens if we try to use multiple namespaces in a file:

```csharp
using System;

namespace MyApplication.Services;  // First file-scoped namespace

public class UserService
{
    // Class implementation
}

namespace MyApplication.Models;  // Error: Cannot declare another namespace in this file
                                // because it already has a file-scoped namespace declaration

public class User
{
    // Class implementation
}
```

This code will not compile. If you need multiple namespaces in a single file, you must use the traditional syntax with curly braces.

## Practical Example: Building a Simple Library

Let's create a small library that demonstrates the use of file-scoped namespaces in a real-world scenario. We'll create a simple data access and service layer for a book management system.

### File: BookRepository.cs

```csharp
using System;
using System.Collections.Generic;

namespace BookLibrary.DataAccess;

public class BookRepository
{
    private readonly List<Book> _books = new();
    
    public void AddBook(Book book)
    {
        book.Id = Guid.NewGuid();
        _books.Add(book);
        Console.WriteLine($"Added book: {book.Title} with ID: {book.Id}");
    }
    
    public Book GetBookById(Guid id)
    {
        return _books.Find(b => b.Id == id);
    }
    
    public List<Book> GetAllBooks()
    {
        return new List<Book>(_books);
    }
}

public class Book
{
    public Guid Id { get; set; }
    public string Title { get; set; }
    public string Author { get; set; }
    public int Year { get; set; }
    
    public override string ToString()
    {
        return $"{Title} by {Author} ({Year})";
    }
}
```

### File: BookService.cs

```csharp
using BookLibrary.DataAccess;
using System;

namespace BookLibrary.Services;

public class BookService
{
    private readonly BookRepository _repository;
    
    public BookService()
    {
        _repository = new BookRepository();
    }
    
    public void AddNewBook(string title, string author, int year)
    {
        var book = new Book
        {
            Title = title,
            Author = author,
            Year = year
        };
        
        _repository.AddBook(book);
    }
    
    public void ListAllBooks()
    {
        var books = _repository.GetAllBooks();
        
        Console.WriteLine("\nLibrary Catalog:");
        Console.WriteLine("----------------");
        
        foreach (var book in books)
        {
            Console.WriteLine(book);
        }
        
        Console.WriteLine("----------------");
    }
}
```

### File: Program.cs

```csharp
using BookLibrary.Services;

namespace BookLibrary.App;

class Program
{
    static void Main(string[] args)
    {
        var bookService = new BookService();
        
        // Add some books
        bookService.AddNewBook("The Lord of the Rings", "J.R.R. Tolkien", 1954);
        bookService.AddNewBook("Dune", "Frank Herbert", 1965);
        bookService.AddNewBook("Neuromancer", "William Gibson", 1984);
        
        // Display all books
        bookService.ListAllBooks();
    }
}
```

### Output:

```
Added book: The Lord of the Rings with ID: 3f8b6e21-4c9f-4a3b-8f12-dc496e234121
Added book: Dune with ID: 7a1c3b5d-2e8f-4a6b-9c0d-1e2f3a4b5c6d
Added book: Neuromancer with ID: 9d8c7b6a-5f4e-3d2c-1b0a-9e8d7c6b5a4f

Library Catalog:
----------------
The Lord of the Rings by J.R.R. Tolkien (1954)
Dune by Frank Herbert (1965)
Neuromancer by William Gibson (1984)
----------------
```

In this example, we've organized our code using file-scoped namespaces across multiple files. Each file contains exactly one namespace, making the code cleaner and easier to read.

## When to Use File-Scoped Namespaces

File-scoped namespaces are best used when:

1. You follow the "one type per file" or "one logical unit per file" pattern
2. You want to reduce indentation levels in your code
3. You're working in a C# 10 or later environment
4. You want to enforce a cleaner organization where each file belongs to exactly one namespace

They're particularly beneficial in larger projects where reducing visual noise can significantly improve code readability.

## When to Stick with Traditional Namespaces

There are still scenarios where traditional namespaces make more sense:

1. When you need multiple namespaces in a single file
2. When you need nested namespaces
3. When maintaining compatibility with older C# versions
4. When working with team members who prefer the traditional syntax

## Summary

File-scoped namespaces in C# 10 provide a cleaner, more concise syntax for namespace declarations by eliminating unnecessary curly braces and indentation. This feature is particularly useful when you follow the common practice of having one type or logical unit per file.

The key features of file-scoped namespaces are:

- They use a semicolon instead of curly braces
- They apply to the entire file
- Only one namespace per file is allowed
- They reduce code indentation and improve readability

By using file-scoped namespaces appropriately, you can make your C# code more readable and maintainable, especially in larger projects where every reduction in visual complexity matters.

## Additional Resources and Exercises

### Resources:
- [Microsoft Documentation on File-scoped Namespaces](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-10.0/file-scoped-namespaces)
- [C# 10 New Features Overview](https://devblogs.microsoft.com/dotnet/welcome-to-csharp-10/)

### Exercises:

1. **Namespace Conversion**: Take an existing C# file that uses traditional namespaces and convert it to use file-scoped namespaces. Note any issues you encounter during the conversion.

2. **Library Organization**: Create a small class library with at least 5 files organized into a logical namespace hierarchy using file-scoped namespaces.

3. **Mixed Approach**: Create a solution where some files use traditional namespaces and others use file-scoped namespaces. Document the reasons for your choices in each case.

4. **Refactoring Challenge**: Take a file with multiple nested namespaces and refactor it into separate files with file-scoped namespaces. How does this change the organization of your code?