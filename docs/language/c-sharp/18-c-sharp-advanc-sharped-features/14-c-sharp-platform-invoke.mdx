---
title: "C# Platform Invoke"
description: "Learn how to use Platform Invoke (P/Invoke) in C# to call functions in unmanaged DLLs and leverage native Windows APIs and other external libraries"

---

# C# Platform Invoke (P/Invoke)

## Introduction

Platform Invoke, commonly known as P/Invoke, is a powerful feature in C# that enables you to call functions in unmanaged libraries (DLLs) from your managed C# code. This capability is crucial when you need to access operating system functionality, hardware devices, or third-party native libraries that don't have .NET equivalents.

In this tutorial, we'll explore how to use P/Invoke to bridge the gap between managed C# code and unmanaged native code, opening up a world of possibilities for your applications.

## What is Platform Invoke?

Platform Invoke is a service that allows managed code to call unmanaged functions implemented in DLLs, such as those in the Windows API. It handles the marshaling of data between the managed and unmanaged environments, ensuring that data is correctly transformed as it crosses the boundary.

Key components of P/Invoke include:

- **DllImport Attribute**: Marks a method as implemented in an unmanaged DLL
- **Marshaling**: The process of converting data between managed and unmanaged code formats
- **Structure Layout**: Specifying how managed structures map to unmanaged structures
- **Function Callbacks**: Passing managed delegates to unmanaged code

## Basic P/Invoke Example

Let's start with a simple example: displaying a message box using the Windows API:

```csharp
using System;
using System.Runtime.InteropServices;

class Program
{
    // Importing the MessageBox function from user32.dll
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int MessageBox(IntPtr hWnd, string text, string caption, uint type);
    
    static void Main()
    {
        // Calling the unmanaged function
        MessageBox(IntPtr.Zero, "Hello from P/Invoke!", "P/Invoke Example", 0);
    }
}
```

When you run this code, a standard Windows message box will appear with the specified text and caption.

### Understanding the Code

- `[DllImport("user32.dll", CharSet = CharSet.Unicode)]`: This attribute specifies that the MessageBox function is found in the user32.dll library and that strings should be marshaled as Unicode.
  
- `public static extern int MessageBox(...)`: The `extern` keyword indicates that the method is implemented externally, and the function signature matches the one in the Windows API.
  
- `IntPtr.Zero`: Represents a null window handle (no parent window).

## Marshaling Data Types

When calling unmanaged functions, you need to ensure data types are properly marshaled between managed and unmanaged code. Here's a guide to common mappings:

| C# Type | Native Type | Notes |
|---------|-------------|-------|
| `byte` | `BYTE`, `unsigned char` | 8-bit unsigned |
| `sbyte` | `char` | 8-bit signed |
| `short` | `SHORT`, `short` | 16-bit signed |
| `ushort` | `WORD`, `unsigned short` | 16-bit unsigned |
| `int` | `INT`, `int`, `BOOL` | 32-bit signed |
| `uint` | `UINT`, `unsigned int` | 32-bit unsigned |
| `long` | `LONG64`, `__int64` | 64-bit signed |
| `ulong` | `ULONG64`, `unsigned __int64` | 64-bit unsigned |
| `float` | `float` | 32-bit floating point |
| `double` | `double` | 64-bit floating point |
| `char` | `WCHAR` | 16-bit Unicode character |
| `string` | `LPWSTR`, `LPCWSTR` | Unicode string |
| `IntPtr` | `HANDLE`, `HWND`, `LPVOID`, etc. | Platform-specific handle or pointer |
| `bool` | `BOOL` | Boolean value |

## Working with Structures

Often, you'll need to pass structures to or receive structures from unmanaged code:

```csharp
using System;
using System.Runtime.InteropServices;

class Program
{
    // Define a structure that matches the SYSTEMTIME structure in Windows API
    [StructLayout(LayoutKind.Sequential)]
    public struct SYSTEMTIME
    {
        public ushort wYear;
        public ushort wMonth;
        public ushort wDayOfWeek;
        public ushort wDay;
        public ushort wHour;
        public ushort wMinute;
        public ushort wSecond;
        public ushort wMilliseconds;
    }

    // Import GetLocalTime function
    [DllImport("kernel32.dll")]
    public static extern void GetLocalTime(out SYSTEMTIME lpSystemTime);

    static void Main()
    {
        SYSTEMTIME systemTime;
        GetLocalTime(out systemTime);
        
        Console.WriteLine($"Current date/time: {systemTime.wMonth}/{systemTime.wDay}/{systemTime.wYear} " +
                         $"{systemTime.wHour}:{systemTime.wMinute}:{systemTime.wSecond}");
    }
}
```

Output:
```
Current date/time: 3/15/2023 14:32:45
```

### Understanding Structure Marshaling

- `[StructLayout(LayoutKind.Sequential)]`: This attribute ensures that the fields in the structure are laid out sequentially in memory, matching the C/C++ structure layout.
  
- The field types in the C# structure should match the corresponding field types in the unmanaged structure.

## String Marshaling

Strings require special attention because .NET strings are different from C-style strings:

```csharp
using System;
using System.Runtime.InteropServices;

class Program
{
    // Import GetWindowsDirectory function with ANSI string
    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
    public static extern uint GetWindowsDirectoryA(
        [Out] StringBuilder lpBuffer,
        uint uSize
    );
    
    // Import GetWindowsDirectory function with Unicode string
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern uint GetWindowsDirectoryW(
        [Out] StringBuilder lpBuffer,
        uint uSize
    );

    static void Main()
    {
        StringBuilder buffer = new StringBuilder(256);
        
        // Call the Unicode version
        uint size = GetWindowsDirectoryW(buffer, (uint)buffer.Capacity);
        Console.WriteLine($"Windows Directory (Unicode): {buffer}");
        
        // Reset buffer and call the ANSI version
        buffer.Clear();
        size = GetWindowsDirectoryA(buffer, (uint)buffer.Capacity);
        Console.WriteLine($"Windows Directory (ANSI): {buffer}");
    }
}
```

Output:
```
Windows Directory (Unicode): C:\Windows
Windows Directory (ANSI): C:\Windows
```

### String Marshaling Options

- `CharSet.Ansi`: Marshals strings as ANSI (single-byte characters)
- `CharSet.Unicode`: Marshals strings as Unicode (UTF-16)
- `CharSet.Auto`: Uses ANSI on Windows 9x and Unicode on Windows NT/2000/XP and later

## Error Handling in P/Invoke

When calling native Windows API functions, you often need to check for errors:

```csharp
using System;
using System.ComponentModel;
using System.Runtime.InteropServices;

class Program
{
    // Import CreateFile function
    [DllImport("kernel32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    public static extern IntPtr CreateFile(
        string lpFileName,
        uint dwDesiredAccess,
        uint dwShareMode,
        IntPtr lpSecurityAttributes,
        uint dwCreationDisposition,
        uint dwFlagsAndAttributes,
        IntPtr hTemplateFile);

    // Import CloseHandle function
    [DllImport("kernel32.dll", SetLastError = true)]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool CloseHandle(IntPtr hObject);

    // Constants for CreateFile
    const uint GENERIC_READ = 0x80000000;
    const uint OPEN_EXISTING = 3;
    const uint FILE_ATTRIBUTE_NORMAL = 0x80;
    static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);

    static void Main()
    {
        // Try to open a file that doesn't exist
        IntPtr fileHandle = CreateFile(
            "NonExistentFile.txt", 
            GENERIC_READ, 
            0, 
            IntPtr.Zero, 
            OPEN_EXISTING, 
            FILE_ATTRIBUTE_NORMAL, 
            IntPtr.Zero);
            
        if (fileHandle == INVALID_HANDLE_VALUE)
        {
            // Get the error code
            int errorCode = Marshal.GetLastWin32Error();
            Console.WriteLine($"Failed to open file. Error code: {errorCode}");
            Console.WriteLine($"Error message: {new Win32Exception(errorCode).Message}");
        }
        else
        {
            Console.WriteLine("File opened successfully.");
            // Always close handles when done
            CloseHandle(fileHandle);
        }
    }
}
```

Output:
```
Failed to open file. Error code: 2
Error message: The system cannot find the file specified.
```

### Error Handling Key Points

1. Include `SetLastError = true` in your DllImport attribute
2. Call `Marshal.GetLastWin32Error()` immediately after the P/Invoke call to retrieve the error code
3. Use `Win32Exception` to get a friendly error message from the error code

## Callback Functions

You can also pass managed delegates as callback functions to unmanaged code:

```csharp
using System;
using System.Runtime.InteropServices;

class Program
{
    // Define the signature for the callback function
    public delegate bool EnumWindowsProc(IntPtr hWnd, IntPtr lParam);

    // Import EnumWindows function
    [DllImport("user32.dll")]
    public static extern bool EnumWindows(EnumWindowsProc enumProc, IntPtr lParam);

    // Import GetWindowText function
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);

    // Import IsWindowVisible function
    [DllImport("user32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool IsWindowVisible(IntPtr hWnd);

    static void Main()
    {
        Console.WriteLine("Visible windows:");
        EnumWindows(EnumWindowsCallback, IntPtr.Zero);
    }

    // This method will be called for each top-level window
    private static bool EnumWindowsCallback(IntPtr hWnd, IntPtr lParam)
    {
        // Check if the window is visible
        if (IsWindowVisible(hWnd))
        {
            StringBuilder windowTitle = new StringBuilder(100);
            GetWindowText(hWnd, windowTitle, windowTitle.Capacity);
            
            if (windowTitle.Length > 0)
            {
                Console.WriteLine($"Window handle: {hWnd}, Title: {windowTitle}");
            }
        }
        
        // Return true to continue enumeration
        return true;
    }
}
```

Output:
```
Visible windows:
Window handle: 65772, Title: Program Manager
Window handle: 197618, Title: Windows PowerShell
Window handle: 328482, Title: Visual Studio Code
Window handle: 132396, Title: C# Platform Invoke - Microsoft Edge
```

### Callback Key Points

1. Define a delegate that matches the signature expected by the unmanaged function
2. Implement a method that matches this delegate signature
3. Pass an instance of the delegate to the unmanaged function
4. Keep a reference to the delegate while the callback might be called (to prevent garbage collection)

## Real-World Example: Screenshot Utility

Let's create a practical example that uses P/Invoke to take a screenshot:

```csharp
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;

class ScreenshotUtility
{
    // Import required functions from user32.dll and gdi32.dll
    [DllImport("user32.dll")]
    private static extern IntPtr GetDesktopWindow();

    [DllImport("user32.dll")]
    private static extern IntPtr GetWindowDC(IntPtr hWnd);

    [DllImport("user32.dll")]
    private static extern IntPtr ReleaseDC(IntPtr hWnd, IntPtr hDC);

    [DllImport("user32.dll")]
    private static extern bool GetWindowRect(IntPtr hWnd, ref RECT rect);

    [DllImport("gdi32.dll")]
    private static extern bool BitBlt(
        IntPtr hdc, int nXDest, int nYDest, int nWidth, int nHeight,
        IntPtr hdcSrc, int nXSrc, int nYSrc, uint dwRop);

    [DllImport("gdi32.dll")]
    private static extern IntPtr CreateCompatibleDC(IntPtr hdc);

    [DllImport("gdi32.dll")]
    private static extern IntPtr CreateCompatibleBitmap(IntPtr hdc, int nWidth, int nHeight);

    [DllImport("gdi32.dll")]
    private static extern IntPtr SelectObject(IntPtr hdc, IntPtr hObject);

    [DllImport("gdi32.dll")]
    private static extern bool DeleteObject(IntPtr hObject);

    [DllImport("gdi32.dll")]
    private static extern bool DeleteDC(IntPtr hdc);

    // Structure for window rectangle
    [StructLayout(LayoutKind.Sequential)]
    private struct RECT
    {
        public int Left;
        public int Top;
        public int Right;
        public int Bottom;
    }

    // Constants
    private const uint SRCCOPY = 0x00CC0020;

    public static void CaptureScreenToFile(string fileName)
    {
        // Get desktop window handle
        IntPtr desktopWindow = GetDesktopWindow();
        
        // Get window rectangle
        RECT windowRect = new RECT();
        GetWindowRect(desktopWindow, ref windowRect);
        
        // Calculate dimensions
        int width = windowRect.Right - windowRect.Left;
        int height = windowRect.Bottom - windowRect.Top;
        
        // Get device context for the desktop
        IntPtr desktopDC = GetWindowDC(desktopWindow);
        
        // Create compatible DC and bitmap
        IntPtr memoryDC = CreateCompatibleDC(desktopDC);
        IntPtr bitmap = CreateCompatibleBitmap(desktopDC, width, height);
        IntPtr oldBitmap = SelectObject(memoryDC, bitmap);
        
        // Copy screen to bitmap
        BitBlt(memoryDC, 0, 0, width, height, desktopDC, 0, 0, SRCCOPY);
        
        // Convert to Bitmap object
        Bitmap screenshot = Image.FromHbitmap(bitmap);
        
        // Save to file
        screenshot.Save(fileName, ImageFormat.Png);
        
        // Cleanup
        SelectObject(memoryDC, oldBitmap);
        DeleteObject(bitmap);
        DeleteDC(memoryDC);
        ReleaseDC(desktopWindow, desktopDC);
        
        Console.WriteLine($"Screenshot saved to {fileName}");
    }

    static void Main()
    {
        // Take a screenshot and save it
        CaptureScreenToFile("screenshot.png");
    }
}
```

This example demonstrates several P/Invoke concepts:
1. Importing multiple functions from different DLLs (user32.dll and gdi32.dll)
2. Using structures to communicate with unmanaged code (RECT)
3. Proper resource management (releasing handles and objects)
4. Combining multiple API calls to create a useful function

## Best Practices for P/Invoke

1. **Dispose of Unmanaged Resources**: Always release handles, memory, and other resources that you obtain from unmanaged code.

2. **Use SafeHandle**: For better resource management, use SafeHandle or derived classes rather than raw IntPtr.

3. **Optimize Marshaling**: Be mindful of performance implications, especially when passing large structures or arrays.

4. **Error Handling**: Always check return values and use SetLastError=true with Marshal.GetLastWin32Error() for Windows API functions.

5. **Use Existing Wrappers**: Before writing P/Invoke declarations, check if .NET already provides managed wrappers for the functionality you need.

6. **Document API Signatures**: Always include comments about the original unmanaged signature or link to documentation.

7. **Check Platform Compatibility**: Remember that native DLLs may not be available on all platforms.

## Common Pitfalls

1. **String Marshaling**: Be careful with string marshaling, especially when dealing with ANSI vs Unicode functions.

2. **Structure Layout**: Ensure your structure layouts match exactly what the unmanaged code expects.

3. **Memory Leaks**: Native resources aren't automatically managed by the garbage collector.

4. **Thread Safety**: Unmanaged code may have different threading assumptions than your managed code.

5. **Callback Lifetime**: Keep references to delegates that you pass to unmanaged code until they're no longer needed.

## Summary

Platform Invoke (P/Invoke) is a powerful feature that allows C# developers to leverage existing native libraries and access operating system functionality not directly available in .NET. By understanding how to properly declare external functions, marshal data between managed and unmanaged environments, and handle resources, you can significantly extend your applications' capabilities.

While P/Invoke adds complexity and potential pitfalls, it's an essential tool for advanced .NET development, particularly when working with hardware, operating system features, or third-party native libraries.

## Additional Resources

1. **Microsoft Documentation**: [P/Invoke on docs.microsoft.com](https://docs.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke)

2. **P/Invoke.net**: A community-driven wiki with thousands of P/Invoke signatures: [pinvoke.net](http://pinvoke.net/)

3. **ClrInterop**: Microsoft's tool for automatically generating P/Invoke signatures: [GitHub repository](https://github.com/microsoft/clrmd/tree/master/src/Microsoft.Diagnostics.Runtime.Utilities/Interop)

## Exercises

1. Create a simple application that uses P/Invoke to access the system beep function (`Beep` in kernel32.dll).

2. Modify the screenshot example to capture only the active window instead of the entire screen.

3. Write a program that retrieves and displays system information using the Windows API (like available memory, CPU information).

4. Create a simple file watcher using P/Invoke to monitor changes to a specific file.

5. Implement a custom message box that uses P/Invoke to create a non-standard window with custom buttons.