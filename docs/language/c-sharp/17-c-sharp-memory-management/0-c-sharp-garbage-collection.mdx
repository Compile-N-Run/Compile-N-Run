---
title: C# Garbage Collection
description: Learn how C# manages memory automatically through garbage collection, how it works behind the scenes, and best practices for efficient memory usage.

---

# C# Garbage Collection

## Introduction

Memory management is a critical aspect of any programming language. In C#, memory management is handled automatically through a process called **Garbage Collection (GC)**. Unlike languages such as C and C++ where developers need to explicitly allocate and free memory, C# abstracts this complexity away, making development easier and reducing common memory-related bugs like memory leaks and dangling pointers.

In this article, we'll explore how C#'s garbage collection works, its benefits, potential issues, and best practices to make the most of this important feature.

## What is Garbage Collection?

Garbage Collection is an automatic memory management system that:

1. Allocates memory for objects when they are created
2. Tracks references to those objects during program execution
3. Identifies objects that are no longer reachable
4. Reclaims the memory used by those unreachable objects

The .NET runtime's garbage collector runs on its own schedule, typically when memory pressure increases or when explicitly triggered in code (though the latter is rarely needed).

## How Memory Works in C#

Before diving into garbage collection details, let's understand how memory is organized in C#:

### The Stack and the Heap

C# utilizes two main regions of memory:

1. **Stack**: Stores value types (like `int`, `double`, `struct`) and reference variables (not the actual objects)
2. **Heap**: Stores reference type objects (like instances of classes, arrays, delegates)

Here's a simple example showing this distinction:

```csharp
// This value is stored on the stack
int age = 30;  

// The reference (address) is stored on the stack
// The actual Person object data is stored on the heap
Person person = new Person("John", 30);  
```

## How C# Garbage Collection Works

### The Garbage Collection Process

The garbage collection process in C# involves several phases:

1. **Marking Phase**: The garbage collector identifies which objects in memory are still being used (reachable).
2. **Compacting Phase**: After removing unreachable objects, the GC compacts the memory by moving objects to fill the gaps.
3. **Promotion**: Objects that survive multiple collection cycles get promoted to older generations.

### Generations in Garbage Collection

The .NET garbage collector uses a generational approach, which divides the heap into three generations:

- **Generation 0** (Gen 0): Contains newly created objects
- **Generation 1** (Gen 1): Contains objects that survived a Gen 0 collection
- **Generation 2** (Gen 2): Contains long-lived objects that survived Gen 1 collections

This approach is based on two important observations about most applications:
- Most objects have short lifetimes and can be collected quickly
- Older objects tend to have longer lifetimes

Let's see how to inspect the generation of an object:

```csharp
using System;

class Program
{
    static void Main()
    {
        // Create a new object (in Gen 0)
        object myObject = new object();
        
        Console.WriteLine($"Generation: {GC.GetGeneration(myObject)}");
        
        // Force a garbage collection of Gen 0
        GC.Collect(0);
        
        // If myObject survived, it's now in Gen 1
        Console.WriteLine($"Generation after collection: {GC.GetGeneration(myObject)}");
        
        // Force a garbage collection of Gen 1
        GC.Collect(1);
        
        // If myObject survived, it's now in Gen 2
        Console.WriteLine($"Generation after another collection: {GC.GetGeneration(myObject)}");
    }
}

// Output:
// Generation: 0
// Generation after collection: 1
// Generation after another collection: 2
```

## Deterministic vs Non-Deterministic Cleanup

Garbage collection is non-deterministic, meaning you don't know exactly when an object will be cleaned up. This can be problematic for resources that need to be released immediately (like files, database connections, etc.).

C# provides mechanisms to address this:

### The IDisposable Pattern

The `IDisposable` interface allows for deterministic cleanup of resources:

```csharp
using System;
using System.IO;

class Program
{
    static void Main()
    {
        // Approach 1: Using try-finally
        FileStream file1 = null;
        try
        {
            file1 = new FileStream("data.txt", FileMode.Open);
            // Work with the file
        }
        finally
        {
            // This will always run, ensuring the file is closed
            file1?.Dispose();
        }
        
        // Approach 2: Using using statement (preferred)
        using (FileStream file2 = new FileStream("data.txt", FileMode.Open))
        {
            // Work with the file
            // File will be automatically disposed when exiting this block
        }
        
        // Approach 3: Using declaration (C# 8.0 and later)
        using FileStream file3 = new FileStream("data.txt", FileMode.Open);
        // Work with the file
        // File will be disposed at the end of the containing scope
    }
}
```

## Common Memory Issues and How to Avoid Them

### 1. Memory Leaks

Even with garbage collection, memory leaks can still occur in C#:

```csharp
public class EventPublisher
{
    public event EventHandler SomeEvent;
    
    public void RaiseEvent()
    {
        SomeEvent?.Invoke(this, EventArgs.Empty);
    }
}

public class Program
{
    static EventPublisher publisher = new EventPublisher();
    
    static void Main()
    {
        // This creates a potential memory leak
        LeakySubscription();
        
        // Many more operations...
        
        // Even though the LeakySubscription method has finished,
        // the subscriber object can't be garbage collected because
        // it's still referenced by the publisher's event
    }
    
    static void LeakySubscription()
    {
        var subscriber = new Subscriber();
        
        // The publisher now holds a reference to subscriber via the event
        publisher.SomeEvent += subscriber.HandleEvent;
        
        // Problem: We never unsubscribe!
    }
}

public class Subscriber
{
    public void HandleEvent(object sender, EventArgs e)
    {
        Console.WriteLine("Event handled");
    }
}
```

**Solution**: Always unsubscribe from events when they're no longer needed:

```csharp
static void ProperSubscription()
{
    var subscriber = new Subscriber();
    publisher.SomeEvent += subscriber.HandleEvent;
    
    // Do work...
    
    // Properly unsubscribe when done
    publisher.SomeEvent -= subscriber.HandleEvent;
}
```

### 2. Large Object Heap Issues

Objects larger than 85,000 bytes are placed on the Large Object Heap (LOH), which is not compacted by default, leading to potential fragmentation:

```csharp
// This creates a large array that goes on the Large Object Heap
byte[] largeArray = new byte[100000];

// Creating and discarding many large objects can lead to fragmentation
for (int i = 0; i < 1000; i++)
{
    // This creates LOH fragmentation
    byte[] tempLargeArray = new byte[1000000];
    // Process the array...
}
```

**Solution**: Reuse large objects when possible rather than creating and discarding them.

## Best Practices for Efficient Garbage Collection

### 1. Dispose of Unmanaged Resources Properly

```csharp
public class ResourceHandler : IDisposable
{
    private bool disposed = false;
    private IntPtr nativeResource;
    private FileStream managedResource;
    
    public ResourceHandler()
    {
        // Allocate resources
        nativeResource = AllocateNativeResource();
        managedResource = new FileStream("file.txt", FileMode.Open);
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Free managed resources
                managedResource?.Dispose();
            }
            
            // Free unmanaged resources
            if (nativeResource != IntPtr.Zero)
            {
                FreeNativeResource(nativeResource);
                nativeResource = IntPtr.Zero;
            }
            
            disposed = true;
        }
    }
    
    ~ResourceHandler()
    {
        Dispose(false);
    }
    
    // Simulate native resource allocation/deallocation
    private IntPtr AllocateNativeResource() => new IntPtr(1);
    private void FreeNativeResource(IntPtr ptr) { /* Free the resource */ }
}
```

### 2. Avoid Excessive Object Creation

```csharp
// Inefficient - creates many temporary string objects
string result = "";
for (int i = 0; i < 10000; i++)
{
    result += i.ToString() + ", ";
}

// Better - uses StringBuilder to minimize object creation
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++)
{
    sb.Append(i).Append(", ");
}
string result = sb.ToString();
```

### 3. Be Cautious with Static References

Static references can prevent objects from being garbage collected:

```csharp
public class CacheManager
{
    // This static collection will keep references to all objects added to it
    // preventing them from being garbage collected
    private static Dictionary<string, object> cache = new Dictionary<string, object>();
    
    public static void Add(string key, object value)
    {
        cache[key] = value;
    }
    
    // Without a method to remove items, this cache will only grow
}
```

**Solution**: Implement a way to remove objects from static collections when they're no longer needed, or use a weak reference collection.

### 4. Use Memory Profiling Tools

Visual Studio includes memory profiling tools to help identify memory issues. Using them regularly can help catch problems early.

## Real-World Example: Caching with Memory Considerations

Let's implement a simple cache that considers memory management best practices:

```csharp
using System;
using System.Collections.Generic;
using System.Runtime.Caching;

public class SmartCache<TKey, TValue>
{
    // Use MemoryCache which manages memory pressure
    private MemoryCache cache = MemoryCache.Default;
    
    // Add an item with expiration to automatically clean up
    public void Add(TKey key, TValue value, TimeSpan expiration)
    {
        string cacheKey = key.ToString();
        CacheItemPolicy policy = new CacheItemPolicy
        {
            AbsoluteExpiration = DateTimeOffset.Now.Add(expiration)
        };
        
        cache.Add(cacheKey, value, policy);
    }
    
    public bool TryGetValue(TKey key, out TValue value)
    {
        string cacheKey = key.ToString();
        object cachedItem = cache.Get(cacheKey);
        
        if (cachedItem != null)
        {
            value = (TValue)cachedItem;
            return true;
        }
        
        value = default;
        return false;
    }
    
    public void Remove(TKey key)
    {
        string cacheKey = key.ToString();
        cache.Remove(cacheKey);
    }
}

// Usage example
public class Program
{
    static void Main()
    {
        var cache = new SmartCache<string, Customer>();
        
        // Add customer to cache with 10-minute expiration
        cache.Add("customer1", new Customer { Id = 1, Name = "John Doe" }, TimeSpan.FromMinutes(10));
        
        // Retrieve customer
        if (cache.TryGetValue("customer1", out Customer customer))
        {
            Console.WriteLine($"Found customer: {customer.Name}");
        }
    }
}

public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
}
```

## Summary

C#'s Garbage Collection system provides automatic memory management that simplifies development and helps prevent common memory-related bugs. Key points to remember:

- The garbage collector automatically identifies and reclaims memory from objects that are no longer reachable
- Memory is organized into generations (0, 1, and 2) for optimization
- Use the `IDisposable` pattern and the `using` statement for deterministic cleanup of unmanaged resources
- Even with garbage collection, memory leaks can happen - especially with events and static references
- Follow best practices to work efficiently with the garbage collector

By understanding how garbage collection works and following best practices, you can write more efficient and reliable C# applications.

## Additional Resources

1. [Microsoft Docs: Fundamentals of Garbage Collection](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)
2. [Microsoft Learn: Memory management and garbage collection in .NET](https://learn.microsoft.com/en-us/dotnet/standard/garbage-collection/)
3. [Book: "Pro .NET Memory Management" by Konrad Kokosa](https://prodotnetmemory.com/)

## Practice Exercises

1. Create a class that implements `IDisposable` correctly, including a finalizer.
2. Write a program that demonstrates the difference between weak references and strong references.
3. Use profiling tools in Visual Studio to analyze memory usage in a sample application.
4. Implement a custom cache with size limits that automatically removes the least recently used items when the cache becomes too large.