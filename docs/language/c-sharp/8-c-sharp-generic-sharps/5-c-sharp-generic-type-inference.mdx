---
title: C# Generic Type Inference
description: Learn how C# automatically determines type parameters for generic methods, making your code cleaner and more concise.

---

# C# Generic Type Inference

When working with generics in C#, you might have noticed that sometimes you don't need to explicitly specify the type parameters. This convenient feature is called **type inference** - C#'s ability to automatically determine the type parameters based on the method arguments you provide.

## What is Type Inference?

Type inference refers to the compiler's capability to automatically determine the type arguments for generic methods based on:
- The types of the arguments you pass to the method
- The context in which the method is called

This means you can write more concise code without explicitly specifying the types when calling generic methods.

## Basic Example

Let's start with a simple example:

```csharp
// Generic method definition
public static T Max<T>(T a, T b) where T : IComparable<T>
{
    return a.CompareTo(b) > 0 ? a : b;
}

// Without type inference (explicit type specification)
int maxValue1 = Max<int>(5, 10);

// With type inference (compiler determines T is int)
int maxValue2 = Max(5, 10);
```

In the second call, the compiler infers that `T` must be `int` because we're passing two integers. Both calls produce the same result, but the second one is more concise.

## How Type Inference Works

The C# compiler uses the following process for type inference:

1. Examines the arguments passed to the generic method
2. Determines the best matching type for the type parameters
3. Uses those inferred types when compiling the method call

Let's see type inference in action with more examples:

```csharp
public static void Display<T>(T item)
{
    Console.WriteLine($"Item: {item}, Type: {typeof(T).Name}");
}

// The compiler infers these types automatically
Display(42);           // T is inferred as int
Display("Hello");      // T is inferred as string
Display(3.14);         // T is inferred as double
Display(new List<int>()); // T is inferred as List<int>
```

**Output:**
```
Item: 42, Type: Int32
Item: Hello, Type: String
Item: 3.14, Type: Double
Item: System.Collections.Generic.List`1[System.Int32], Type: List`1
```

## Type Inference with Multiple Type Parameters

Type inference works well with methods that have multiple type parameters:

```csharp
public static KeyValuePair<TKey, TValue> CreatePair<TKey, TValue>(TKey key, TValue value)
{
    return new KeyValuePair<TKey, TValue>(key, value);
}

// Type inference in action - TKey is inferred as string, TValue as int
var pair = CreatePair("ID", 42);

Console.WriteLine($"Key: {pair.Key} ({pair.Key.GetType().Name})");
Console.WriteLine($"Value: {pair.Value} ({pair.Value.GetType().Name})");
```

**Output:**
```
Key: ID (String)
Value: 42 (Int32)
```

## Type Inference with Generic Collections

Type inference is particularly useful with generic collections:

```csharp
// Without type inference
List<string> names1 = new List<string>();

// With type inference
var names2 = new List<string>();

// With collection initializers
var fruits = new List<string> { "Apple", "Banana", "Cherry" };
```

## LINQ and Type Inference

LINQ heavily relies on type inference to make code more readable:

```csharp
var numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Without type inference
IEnumerable<int> evenNumbers1 = numbers.Where<int>(n => n % 2 == 0);

// With type inference
var evenNumbers2 = numbers.Where(n => n % 2 == 0);

foreach (var num in evenNumbers2)
{
    Console.Write($"{num} ");
}
```

**Output:**
```
2 4 6 8 10
```

## Limitations of Type Inference

While type inference is powerful, it has some limitations:

1. **Type inference doesn't work with generic class constructors**:
   ```csharp
   // This won't compile - type inference doesn't work for constructors
   var instance = new GenericClass(42);
   
   // You need to specify the type
   var instance = new GenericClass<int>(42);
   ```

2. **Method overloading can be ambiguous**:
   ```csharp
   public static void Process<T>(T value) { /* ... */ }
   public static void Process<T>(List<T> values) { /* ... */ }
   
   // This can lead to ambiguity in some cases
   ```

3. **Return types are not used for inference**:
   ```csharp
   public static T Create<T>() where T : new()
   {
       return new T();
   }
   
   // This won't compile - the compiler can't infer T
   var obj = Create();
   
   // This works - type is explicitly specified
   var obj = Create<Person>();
   ```

## Real-World Application: Generic Repository Pattern

Type inference shines in design patterns like the Generic Repository pattern:

```csharp
public class Repository<T> where T : class
{
    public void Add(T entity) 
    {
        // Code to add entity to database
        Console.WriteLine($"Added {typeof(T).Name} to database");
    }
    
    public T GetById(int id)
    {
        // Code to retrieve entity by id
        Console.WriteLine($"Retrieved {typeof(T).Name} with ID: {id}");
        return null; // In real code, return actual entity
    }
}

// Usage with different entity types
public class Customer { /* ... */ }
public class Product { /* ... */ }

public static void RepositoryDemo()
{
    // Create repositories
    var customerRepo = new Repository<Customer>();
    var productRepo = new Repository<Product>();
    
    // Use the repositories
    customerRepo.Add(new Customer());
    
    // Type inference works for method parameters, even in generic classes
    var product = new Product();
    productRepo.Add(product);
}
```

## Best Practices

1. **Use type inference for shorter, cleaner code** when the types are obvious from context.

2. **Be explicit when clarity is needed** - sometimes specifying types makes code more readable.

3. **Remember that `var` is not the same as dynamic typing** - C# is still statically typed; the compiler just infers the types.

4. **Use type inference with LINQ** to make complex queries more readable.

## Summary

Generic type inference is a powerful feature in C# that allows the compiler to automatically determine the types for generic methods based on the arguments provided. This leads to cleaner, more concise code while still maintaining the benefits of strong typing.

Key points to remember:
- Type inference works for generic methods but not for generic class constructors
- The compiler determines types based on the method arguments
- Type inference makes LINQ queries and collection operations more readable
- Despite type inference, C# remains a statically typed language

## Exercises

1. Create a generic method `Swap<T>` that swaps the values of two variables of the same type. Test it with different types using type inference.

2. Create a generic method `FindMax<T>` that finds the maximum value in an array of comparable objects. Use it with arrays of integers, doubles, and strings using type inference.

3. Implement a simple generic cache that stores items by key, making use of type inference in its methods.

## Additional Resources

- [Microsoft Docs: Type Inference](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/type-inference)
- [C# Language Specification on Type Inference](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/expressions#type-inference)
- [C# in Depth by Jon Skeet](http://csharpindepth.com/) - A great resource for understanding advanced C# features