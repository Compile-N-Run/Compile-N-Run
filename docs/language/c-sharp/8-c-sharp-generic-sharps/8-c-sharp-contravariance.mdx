---
title: C# Contravariance
description: Learn about contravariance in C# generics, how it works, and how to use it in your code with practical examples.

---

# C# Contravariance

## Introduction to Contravariance

Contravariance is an advanced but powerful concept in C# generics that allows for greater flexibility when working with generic interfaces and delegates. While it might sound intimidating at first, understanding contravariance can help you write more flexible and reusable code.

In simple terms, **contravariance** allows you to use a *more general* (less derived) type than originally specified. It's essentially the opposite of covariance, which allows you to use a more specific type.

The key to remember is:
- With contravariance, you can assign a generic interface or delegate with a **less derived** type parameter to a variable with a **more derived** type parameter.

Let's dive into how contravariance works in C# and explore practical examples to solidify your understanding.

## Understanding Contravariance with Interfaces

Contravariance is indicated by the `in` keyword in generic type parameters. This keyword tells the C# compiler that the type parameter will only be used in input positions (as method parameters).

Here's a simple example of a contravariant interface:

```csharp
public interface IComparer<in T>
{
    int Compare(T x, T y);
}
```

Notice the `in` keyword before the type parameter `T`. This indicates that `T` is contravariant.

## How Contravariance Works

To understand contravariance, let's consider a hierarchy of classes:

```csharp
public class Animal { }
public class Mammal : Animal { }
public class Dog : Mammal { }
```

With contravariance, you can use a generic interface or delegate with a base type where a derived type is expected:

```csharp
// This is valid with contravariance
IComparer<Animal> animalComparer = new CustomComparer<Animal>();
IComparer<Mammal> mammalComparer = animalComparer;  // This works with contravariance
```

This might seem counterintuitive at first, but it makes sense when you think about it: if a comparer can compare any `Animal`, it certainly can compare any `Mammal` (which is a more specific type of `Animal`).

## Practical Example: Custom Comparer

Let's implement a custom comparer to demonstrate contravariance:

```csharp
using System;
using System.Collections.Generic;

public class WeightComparer<T> : IComparer<T> where T : Animal
{
    public int Compare(T x, T y)
    {
        return x.Weight.CompareTo(y.Weight);
    }
}

// Adding Weight property to our hierarchy
public class Animal
{
    public int Weight { get; set; }
}

public class Mammal : Animal { }
public class Dog : Mammal { }

// Using contravariance
public static void Main()
{
    IComparer<Animal> animalComparer = new WeightComparer<Animal>();
    IComparer<Mammal> mammalComparer = animalComparer;  // Valid thanks to contravariance
    
    var dog1 = new Dog { Weight = 15 };
    var dog2 = new Dog { Weight = 25 };
    
    int result = mammalComparer.Compare(dog1, dog2);
    Console.WriteLine($"Comparison result: {result}");  // Output: Comparison result: -1
}
```

In this example, we can use an `IComparer<Animal>` where an `IComparer<Mammal>` is expected because the `in` keyword in `IComparer<in T>` makes `T` contravariant.

## Contravariance with Delegates

Contravariance is also applicable to delegates. The `Action<T>` delegate is a good example:

```csharp
// Action<in T> is contravariant in T
Action<Animal> feedAnimal = animal => Console.WriteLine($"Feeding an animal");
Action<Mammal> feedMammal = feedAnimal;  // Valid with contravariance

Mammal mammal = new Mammal();
feedMammal(mammal);  // Output: Feeding an animal
```

This makes sense because if a method can handle any `Animal`, it can certainly handle a `Mammal`. The contravariance allows us to pass a more specific type (Mammal) to a method that expects a more general type (Animal).

## Real-World Applications of Contravariance

### Example 1: Logging System

Consider a logging system where you want to log different types of events:

```csharp
public interface ILogger<in T>
{
    void Log(T item);
}

public class ConsoleLogger<T> : ILogger<T>
{
    public void Log(T item)
    {
        Console.WriteLine($"Logging: {item}");
    }
}

public class Event { }
public class ErrorEvent : Event { }
public class CriticalErrorEvent : ErrorEvent { }

// Using contravariance
public static void Main()
{
    ILogger<Event> generalLogger = new ConsoleLogger<Event>();
    
    // Thanks to contravariance, we can use a logger for all events
    // to log more specific types of events
    ILogger<ErrorEvent> errorLogger = generalLogger;
    ILogger<CriticalErrorEvent> criticalLogger = generalLogger;
    
    criticalLogger.Log(new CriticalErrorEvent());  // Output: Logging: CriticalErrorEvent
}
```

### Example 2: Event Processing System

```csharp
public interface IEventProcessor<in TEvent>
{
    void Process(TEvent eventData);
}

public class DefaultEventProcessor : IEventProcessor<Event>
{
    public void Process(Event eventData)
    {
        Console.WriteLine($"Processing {eventData.GetType().Name}");
    }
}

public static void Main()
{
    IEventProcessor<Event> generalProcessor = new DefaultEventProcessor();
    IEventProcessor<ErrorEvent> errorProcessor = generalProcessor;
    
    errorProcessor.Process(new ErrorEvent());  // Output: Processing ErrorEvent
}
```

## When to Use Contravariance

Contravariance is particularly useful when:

1. You have generic interfaces or delegates that consume types (use them as inputs)
2. You want to allow more flexibility in the type hierarchy
3. You need to reuse implementations that work with base types for derived types

## Common Mistakes and Misconceptions

### Mistake 1: Trying to Use Contravariance with Output Parameters

Contravariance works only with input type parameters. If your interface has methods that return the generic type, contravariance won't work:

```csharp
// This won't work with contravariance
public interface IFactory<in T>
{
    T Create();  // Error! Cannot use T as return type if T is contravariant
}
```

### Mistake 2: Confusing Contravariance with Covariance

Remember:
- Contravariance (`in`): Allows a more general type to be used where a more specific type is expected
- Covariance (`out`): Allows a more specific type to be used where a more general type is expected

## Summary

Contravariance in C# allows for greater flexibility in your code by enabling you to use a more general type where a more specific type is expected, particularly in interfaces and delegates. The key points to remember are:

1. Contravariance is indicated with the `in` keyword
2. It works for input parameters in interfaces and delegates
3. It allows you to pass a reference to a component that works with a base class when a component working with a derived class is expected
4. It's particularly useful for interfaces that consume types rather than produce them

Mastering contravariance will help you write more flexible and reusable code, particularly when designing systems with complex type hierarchies.

## Exercises to Reinforce Learning

1. Create a contravariant interface `IProcessor<in T>` with a method to process items of type T
2. Implement a generic validator that can validate both base and derived classes
3. Design a system with contravariant delegates that can handle different types of notifications
4. Try to convert an example of covariance to contravariance and vice versa

## Additional Resources

- [Microsoft Docs on Covariance and Contravariance](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/covariance-contravariance/)
- [C# in Depth by Jon Skeet](http://csharpindepth.com/) - Contains excellent explanations of variance in C#
- [Contravariant Interfaces in the .NET Framework](https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance)

Remember that variance concepts (both contravariance and covariance) might take time to fully understand. Practice with different examples, and gradually you'll build a solid intuition for when and how to use these powerful features in your C# code.