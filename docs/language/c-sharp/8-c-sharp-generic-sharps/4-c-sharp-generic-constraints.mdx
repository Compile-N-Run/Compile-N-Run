---
title: C# Generic Constraints
description: Learn how to restrict the types that can be used as type arguments in generic classes and methods using C# generic constraints.

---

# C# Generic Constraints

## Introduction

Generic types and methods in C# provide excellent type safety and code reusability. However, sometimes you need to restrict what types can be used as type arguments in your generic classes or methods. This is where **generic constraints** come in.

Generic constraints allow you to specify requirements that types must meet to be used as generic type parameters. They ensure that the code inside your generic class or method can safely perform certain operations on the generic type parameters.

In this tutorial, we'll explore the various generic constraints available in C#, understand their purpose, and see how they can be used to create more robust generic code.

## Why Use Generic Constraints?

Without constraints, generic type parameters can be substituted with any type. But sometimes, your generic code needs to perform specific operations on the generic types, such as:

- Accessing a property or method
- Creating a new instance
- Comparing values
- Converting between types

By applying constraints, you can tell the compiler what operations are allowed on the generic parameters, which helps prevent runtime errors and makes your code more reliable.

## Types of Generic Constraints

C# offers several kinds of constraints that can be combined to precisely specify the requirements for type parameters.

### 1. `where T : class` - Reference Type Constraint

This constraint specifies that the type argument must be a reference type.

```csharp
public class Repository<T> where T : class
{
    public void Add(T item)
    {
        // We can be sure that T is a reference type
        Console.WriteLine($"Adding {item} to repository");
    }
}
```

Example usage:

```csharp
// Valid - string is a reference type
Repository<string> stringRepo = new Repository<string>();
stringRepo.Add("Hello");

// Invalid - int is a value type, this won't compile
// Repository<int> intRepo = new Repository<int>();
```

### 2. `where T : struct` - Value Type Constraint

This constraint specifies that the type argument must be a non-nullable value type.

```csharp
public class Calculator<T> where T : struct
{
    public void PerformOperation(T value1, T value2)
    {
        Console.WriteLine($"Operating on {value1} and {value2}");
    }
}
```

Example usage:

```csharp
// Valid - int is a value type
Calculator<int> intCalc = new Calculator<int>();
intCalc.PerformOperation(10, 20);

// Invalid - string is a reference type, this won't compile
// Calculator<string> stringCalc = new Calculator<string>();
```

### 3. `where T : new()` - Parameterless Constructor Constraint

This constraint specifies that the type argument must have a public parameterless constructor. This allows you to create new instances of the type parameter.

```csharp
public class Factory<T> where T : new()
{
    public T CreateInstance()
    {
        return new T();
    }
}
```

Example usage:

```csharp
// Valid - List<string> has a parameterless constructor
Factory<List<string>> listFactory = new Factory<List<string>>();
List<string> newList = listFactory.CreateInstance();
newList.Add("Item 1");
Console.WriteLine(newList[0]); // Output: Item 1

// Invalid - FileStream requires constructor parameters, this won't compile
// Factory<FileStream> fileStreamFactory = new Factory<FileStream>();
```

### 4. `where T : <base class>` - Base Class Constraint

This constraint specifies that the type argument must be or derive from the specified base class.

```csharp
public class AnimalShelter<T> where T : Animal
{
    private List<T> animals = new List<T>();
    
    public void AddAnimal(T animal)
    {
        animals.Add(animal);
        animal.MakeSound(); // We can call Animal methods because of the constraint
    }
}

public class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("Some generic animal sound");
    }
}

public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
}
```

Example usage:

```csharp
// Valid - Dog derives from Animal
AnimalShelter<Dog> dogShelter = new AnimalShelter<Dog>();
dogShelter.AddAnimal(new Dog()); // Output: Woof!

// Invalid - string doesn't derive from Animal, this won't compile
// AnimalShelter<string> stringShelter = new AnimalShelter<string>();
```

### 5. `where T : <interface>` - Interface Constraint

This constraint specifies that the type argument must implement the specified interface.

```csharp
public interface ILogger
{
    void Log(string message);
}

public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
}

public class LoggingService<T> where T : ILogger
{
    private T logger;
    
    public LoggingService(T logger)
    {
        this.logger = logger;
    }
    
    public void LogMessage(string message)
    {
        logger.Log(message); // We can call ILogger methods because of the constraint
    }
}
```

Example usage:

```csharp
// Valid - ConsoleLogger implements ILogger
LoggingService<ConsoleLogger> loggingService = new LoggingService<ConsoleLogger>(new ConsoleLogger());
loggingService.LogMessage("This is a test message"); // Output: [LOG] This is a test message

// Invalid - string doesn't implement ILogger, this won't compile
// LoggingService<string> badService = new LoggingService<string>();
```

### 6. `where T : U` - Type Parameter Constraint

This constraint specifies that the type argument must be or derive from another type parameter.

```csharp
public class Converter<TSource, TTarget> where TTarget : TSource
{
    public TTarget Convert(TSource source)
    {
        // In a real-world scenario, you might use reflection or other conversion methods
        Console.WriteLine($"Converting {source} from {typeof(TSource)} to {typeof(TTarget)}");
        return (TTarget)(object)source;
    }
}
```

Example usage:

```csharp
// Using type parameter constraints with inheritance
public class Shape { }
public class Circle : Shape { }

// Valid - Circle is derived from Shape
Converter<Shape, Circle> shapeConverter = new Converter<Shape, Circle>();
// (Not a practical example but demonstrates the concept)

// Invalid - Shape is not derived from Circle, this won't compile
// Converter<Circle, Shape> invalidConverter = new Converter<Circle, Shape>();
```

### 7. `where T : unmanaged` - Unmanaged Type Constraint

This constraint, introduced in C# 7.3, specifies that the type argument must be an unmanaged type. Unmanaged types are types that can be stored in unmanaged memory, such as:
- `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal`, `bool`
- Enums
- Pointers
- User-defined structs that contain only unmanaged types and are not constructed with `ref` fields

```csharp
public class UnmanagedWrapper<T> where T : unmanaged
{
    public unsafe void ProcessData(T data)
    {
        // Can safely work with the data in an unsafe context
        fixed (T* ptr = &data)
        {
            Console.WriteLine($"Address of data: {(long)ptr:X}");
            Console.WriteLine($"Value: {data}");
        }
    }
}
```

Example usage:

```csharp
// Valid - int is an unmanaged type
UnmanagedWrapper<int> intWrapper = new UnmanagedWrapper<int>();
intWrapper.ProcessData(42);

// Invalid - string is a managed type, this won't compile
// UnmanagedWrapper<string> stringWrapper = new UnmanagedWrapper<string>();
```

### 8. `where T : notnull` - Non-Nullable Type Constraint (C# 8.0+)

This constraint, introduced in C# 8.0, specifies that the type argument cannot be a nullable type.

```csharp
public class NotNullContainer<T> where T : notnull
{
    private T item;
    
    public NotNullContainer(T item)
    {
        this.item = item ?? throw new ArgumentNullException(nameof(item));
    }
    
    public T GetItem() => item;
}
```

Example usage:

```csharp
// Valid usage
NotNullContainer<string> stringContainer = new NotNullContainer<string>("Hello");
Console.WriteLine(stringContainer.GetItem()); // Output: Hello

// This will compile but throw an exception at runtime if null is passed
NotNullContainer<string> nullContainer = new NotNullContainer<string>(null);

// In a nullable context, the compiler would warn about the null assignment above
```

## Combining Multiple Constraints

You can apply multiple constraints to a single type parameter by chaining them with the `where` keyword.

```csharp
public class MultiConstraintExample<T> where T : class, IComparable, new()
{
    // T must be a reference type, implement IComparable, and have a parameterless constructor
    public T CreateAndCompare(T other)
    {
        T newInstance = new T();
        
        if (newInstance.CompareTo(other) < 0)
        {
            Console.WriteLine("New instance is less than the provided instance");
        }
        else
        {
            Console.WriteLine("New instance is greater than or equal to the provided instance");
        }
        
        return newInstance;
    }
}
```

Example usage:

```csharp
// Valid - string is a reference type, implements IComparable, and has a parameterless constructor
MultiConstraintExample<string> example = new MultiConstraintExample<string>();
string result = example.CreateAndCompare("Hello"); // Output: New instance is less than the provided instance
Console.WriteLine(result); // Output: (empty string)

// Invalid - int is not a reference type, this won't compile
// MultiConstraintExample<int> badExample = new MultiConstraintExample<int>();
```

## Practical Example: Generic Repository Pattern

A common real-world application of generic constraints is in implementing the Repository pattern for data access:

```csharp
// Define an interface for entity types
public interface IEntity
{
    int Id { get; set; }
}

// A simple entity class
public class User : IEntity
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    
    public override string ToString()
    {
        return $"User {Id}: {Username} ({Email})";
    }
}

// Generic repository with constraints
public class Repository<T> where T : class, IEntity, new()
{
    private List<T> _items = new List<T>();
    private int _nextId = 1;
    
    // Create an item
    public T Create()
    {
        T item = new T();
        item.Id = _nextId++;
        _items.Add(item);
        return item;
    }
    
    // Get item by id
    public T GetById(int id)
    {
        return _items.FirstOrDefault(item => item.Id == id);
    }
    
    // Get all items
    public IEnumerable<T> GetAll()
    {
        return _items;
    }
    
    // Update an item
    public bool Update(T item)
    {
        int index = _items.FindIndex(i => i.Id == item.Id);
        if (index >= 0)
        {
            _items[index] = item;
            return true;
        }
        return false;
    }
    
    // Delete an item
    public bool Delete(int id)
    {
        int index = _items.FindIndex(item => item.Id == id);
        if (index >= 0)
        {
            _items.RemoveAt(index);
            return true;
        }
        return false;
    }
}
```

Example usage:

```csharp
// Create repository for User entities
Repository<User> userRepo = new Repository<User>();

// Create some users
User user1 = userRepo.Create();
user1.Username = "john_doe";
user1.Email = "john@example.com";
userRepo.Update(user1);

User user2 = userRepo.Create();
user2.Username = "jane_smith";
user2.Email = "jane@example.com";
userRepo.Update(user2);

// List all users
Console.WriteLine("All users:");
foreach (var user in userRepo.GetAll())
{
    Console.WriteLine(user);
}

// Output:
// All users:
// User 1: john_doe (john@example.com)
// User 2: jane_smith (jane@example.com)

// Get user by id
User retrievedUser = userRepo.GetById(1);
Console.WriteLine($"Retrieved user: {retrievedUser}");
// Output: Retrieved user: User 1: john_doe (john@example.com)

// Delete user
userRepo.Delete(2);
Console.WriteLine("After deletion:");
foreach (var user in userRepo.GetAll())
{
    Console.WriteLine(user);
}
// Output: 
// After deletion:
// User 1: john_doe (john@example.com)
```

## Summary

Generic constraints in C# allow you to restrict the types that can be used with your generic classes and methods. This provides several benefits:

- **Type safety**: Constraints help ensure that your code can work with the types provided.
- **Better IntelliSense**: Visual Studio can provide better code completion when constraints are used.
- **Performance optimizations**: The compiler can generate more efficient code by knowing more about the type.
- **Cleaner code**: You can avoid type-checking and casting within the generic class or method.

The main constraints available in C# are:
- `where T : class` - Reference types
- `where T : struct` - Value types
- `where T : new()` - Types with a parameterless constructor
- `where T : BaseClass` - Types derived from a specific base class
- `where T : IInterface` - Types implementing a specific interface
- `where T : U` - Types that are or derive from another type parameter
- `where T : unmanaged` - Unmanaged types
- `where T : notnull` - Non-nullable types

By mastering generic constraints, you can write more robust, reusable, and type-safe generic code in C#.

## Exercises

1. Create a generic Validator class with a constraint that requires type parameters to implement an IValidatable interface.

2. Implement a generic `Cache<T>` class that stores objects by their ID. Use constraints to ensure that cached objects implement an IIdentifiable interface.

3. Create a generic sorting algorithm that works only with comparable objects.

4. Design a generic EventAggregator class that uses constraints to ensure event handlers are properly typed.

5. Implement a generic binary tree where nodes can only contain value types.

## Additional Resources

- [Microsoft Docs: Constraints on Type Parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)
- [C# 8.0 Feature: notnull constraint](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/nullable-reference-types)
- [C# 7.3 Feature: unmanaged constraint](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-7.3/blittable)
- [Generic Repository Pattern in C#](https://medium.com/@uttam.bhadani/repository-pattern-in-c-featuring-net-core-generics-dependency-injection-unit-testing-3dc8bb23d4df)