---
title: "C# LINQ Joining"
description: "Learn how to use LINQ Join operations in C# to combine data from multiple collections. This guide covers Inner Joins, Group Joins, Left Joins, and Cross Joins with practical examples."

---

# C# LINQ Joining

When working with collections of data in C#, you'll often need to combine or relate data from multiple sources. LINQ provides powerful joining capabilities that allow you to merge data from different collections based on matching keys or other criteria. These operations are similar to SQL joins but operate on in-memory collections.

## Introduction to LINQ Joins

In real-world applications, data is rarely isolated. You'll frequently need to combine information from different sources to produce meaningful results. LINQ join operations allow you to:

- Correlate elements from different collections
- Create new result sets based on relationships between collections
- Filter and transform data from multiple sources in a single operation

In this guide, we'll explore the various types of LINQ joins:

1. Inner Join - combines elements when there's a match in both collections
2. Group Join - groups matched elements from the second collection
3. Left Outer Join - keeps all elements from the first collection, even without matches
4. Cross Join - creates all possible combinations between collections

## Inner Join

An inner join returns elements from both collections that have matching values in the specified key fields. Elements without matches are excluded from the result.

### Basic Syntax

```csharp
var query = from first in firstCollection
            join second in secondCollection
            on first.Key equals second.Key
            select new { first.Property1, second.Property2 };
```

### Method Syntax

```csharp
var query = firstCollection.Join(
    secondCollection,
    first => first.Key,
    second => second.Key,
    (first, second) => new { first.Property1, second.Property2 }
);
```

### Practical Example

Let's imagine we have two collections: `Students` and `Courses`. We want to find out which student is enrolled in which course:

```csharp
// Define our sample data classes
class Student
{
    public int StudentId { get; set; }
    public string Name { get; set; }
}

class Enrollment
{
    public int StudentId { get; set; }
    public int CourseId { get; set; }
}

class Course
{
    public int CourseId { get; set; }
    public string Title { get; set; }
}

// Create sample data
List<Student> students = new List<Student>
{
    new Student { StudentId = 1, Name = "Alice" },
    new Student { StudentId = 2, Name = "Bob" },
    new Student { StudentId = 3, Name = "Charlie" }
};

List<Course> courses = new List<Course>
{
    new Course { CourseId = 101, Title = "C# Fundamentals" },
    new Course { CourseId = 102, Title = "LINQ Mastery" },
    new Course { CourseId = 103, Title = "ASP.NET Core" }
};

List<Enrollment> enrollments = new List<Enrollment>
{
    new Enrollment { StudentId = 1, CourseId = 101 },
    new Enrollment { StudentId = 1, CourseId = 102 },
    new Enrollment { StudentId = 2, CourseId = 101 },
    new Enrollment { StudentId = 3, CourseId = 103 }
};

// Query syntax
var studentCourses = from s in students
                     join e in enrollments on s.StudentId equals e.StudentId
                     join c in courses on e.CourseId equals c.CourseId
                     select new { StudentName = s.Name, CourseTitle = c.Title };

// Method syntax
var studentCoursesMethod = students
    .Join(
        enrollments,
        s => s.StudentId,
        e => e.StudentId,
        (s, e) => new { Student = s, Enrollment = e }
    )
    .Join(
        courses,
        se => se.Enrollment.CourseId,
        c => c.CourseId,
        (se, c) => new { StudentName = se.Student.Name, CourseTitle = c.Title }
    );

// Display results
foreach (var item in studentCourses)
{
    Console.WriteLine($"{item.StudentName} is enrolled in {item.CourseTitle}");
}
```

**Output:**
```
Alice is enrolled in C# Fundamentals
Alice is enrolled in LINQ Mastery
Bob is enrolled in C# Fundamentals
Charlie is enrolled in ASP.NET Core
```

## Group Join

A group join combines elements from two collections but preserves all elements from the first collection and groups matching elements from the second collection.

### Basic Syntax

```csharp
var query = from first in firstCollection
            join second in secondCollection
            on first.Key equals second.Key into groupedSecond
            select new { first.Property, Items = groupedSecond };
```

### Method Syntax

```csharp
var query = firstCollection.GroupJoin(
    secondCollection,
    first => first.Key,
    second => second.Key,
    (first, groupedSecond) => new { first.Property, Items = groupedSecond }
);
```

### Practical Example

Let's use a group join to find all courses each student is enrolled in:

```csharp
// Query syntax
var studentWithCourses = from s in students
                         join e in enrollments on s.StudentId equals e.StudentId into studentEnrollments
                         select new
                         {
                             StudentName = s.Name,
                             Enrollments = from enrollment in studentEnrollments
                                           join course in courses on enrollment.CourseId equals course.CourseId
                                           select course.Title
                         };

// Method syntax
var studentWithCoursesMethod = students.GroupJoin(
    enrollments,
    s => s.StudentId,
    e => e.StudentId,
    (student, studentEnrollments) => new
    {
        StudentName = student.Name,
        Enrollments = studentEnrollments
            .Join(
                courses,
                e => e.CourseId,
                c => c.CourseId,
                (e, c) => c.Title
            )
    }
);

// Display results
foreach (var student in studentWithCourses)
{
    Console.WriteLine($"{student.StudentName} is enrolled in:");
    foreach (var course in student.Enrollments)
    {
        Console.WriteLine($"  - {course}");
    }
    if (!student.Enrollments.Any())
    {
        Console.WriteLine("  - No courses");
    }
    Console.WriteLine();
}
```

**Output:**
```
Alice is enrolled in:
  - C# Fundamentals
  - LINQ Mastery

Bob is enrolled in:
  - C# Fundamentals

Charlie is enrolled in:
  - ASP.NET Core
```

## Left Outer Join

A left outer join keeps all elements from the first collection, regardless of whether there are matches in the second collection. LINQ doesn't have a direct left join operator, but we can simulate one using a combination of `GroupJoin` and `SelectMany`.

### Implementation

```csharp
// Left outer join
var leftJoin = from s in students
               join e in enrollments on s.StudentId equals e.StudentId into studentEnrollments
               from enrollment in studentEnrollments.DefaultIfEmpty()
               select new
               {
                   StudentName = s.Name,
                   CourseId = enrollment?.CourseId,
                   HasEnrollment = enrollment != null
               };

// Method syntax
var leftJoinMethod = students
    .GroupJoin(
        enrollments,
        s => s.StudentId,
        e => e.StudentId,
        (student, enrollments) => new { Student = student, Enrollments = enrollments }
    )
    .SelectMany(
        x => x.Enrollments.DefaultIfEmpty(),
        (x, enrollment) => new
        {
            StudentName = x.Student.Name,
            CourseId = enrollment?.CourseId,
            HasEnrollment = enrollment != null
        }
    );

// Add a student with no enrollments to demonstrate left join
students.Add(new Student { StudentId = 4, Name = "David" });

// Display results
foreach (var item in leftJoin)
{
    if (item.HasEnrollment)
    {
        Console.WriteLine($"{item.StudentName} is enrolled in course {item.CourseId}");
    }
    else
    {
        Console.WriteLine($"{item.StudentName} is not enrolled in any courses");
    }
}
```

**Output:**
```
Alice is enrolled in course 101
Alice is enrolled in course 102
Bob is enrolled in course 101
Charlie is enrolled in course 103
David is not enrolled in any courses
```

## Cross Join

A cross join creates a Cartesian product of the two collections, producing all possible combinations of elements.

### Implementation

```csharp
// Cross join - all possible combinations
var crossJoin = from s in students
                from c in courses
                select new { StudentName = s.Name, CourseTitle = c.Title };

// Method syntax
var crossJoinMethod = students
    .SelectMany(
        s => courses,
        (s, c) => new { StudentName = s.Name, CourseTitle = c.Title }
    );

// Display results (limiting to first 5 for brevity)
foreach (var item in crossJoin.Take(5))
{
    Console.WriteLine($"Possible enrollment: {item.StudentName} in {item.CourseTitle}");
}
```

**Output:**
```
Possible enrollment: Alice in C# Fundamentals
Possible enrollment: Alice in LINQ Mastery
Possible enrollment: Alice in ASP.NET Core
Possible enrollment: Bob in C# Fundamentals
Possible enrollment: Bob in LINQ Mastery
```

## Real-World Application Example

Let's build a more complex example that combines multiple joins to generate a report of student enrollments, grades, and instructors:

```csharp
// Additional classes for our scenario
class Grade
{
    public int StudentId { get; set; }
    public int CourseId { get; set; }
    public string LetterGrade { get; set; }
}

class Instructor
{
    public int InstructorId { get; set; }
    public string Name { get; set; }
}

class CourseInstructor
{
    public int CourseId { get; set; }
    public int InstructorId { get; set; }
}

// Additional sample data
List<Grade> grades = new List<Grade>
{
    new Grade { StudentId = 1, CourseId = 101, LetterGrade = "A" },
    new Grade { StudentId = 1, CourseId = 102, LetterGrade = "B+" },
    new Grade { StudentId = 2, CourseId = 101, LetterGrade = "B" },
    new Grade { StudentId = 3, CourseId = 103, LetterGrade = "A-" }
};

List<Instructor> instructors = new List<Instructor>
{
    new Instructor { InstructorId = 1, Name = "Professor Smith" },
    new Instructor { InstructorId = 2, Name = "Dr. Johnson" }
};

List<CourseInstructor> courseInstructors = new List<CourseInstructor>
{
    new CourseInstructor { CourseId = 101, InstructorId = 1 },
    new CourseInstructor { CourseId = 102, InstructorId = 2 },
    new CourseInstructor { CourseId = 103, InstructorId = 1 }
};

// Complex query to generate a student report
var studentReport = from s in students
                    join e in enrollments on s.StudentId equals e.StudentId
                    join c in courses on e.CourseId equals c.CourseId
                    join g in grades on new { e.StudentId, e.CourseId } equals new { g.StudentId, g.CourseId } into gradeInfo
                    from grade in gradeInfo.DefaultIfEmpty()
                    join ci in courseInstructors on c.CourseId equals ci.CourseId
                    join i in instructors on ci.InstructorId equals i.InstructorId
                    select new
                    {
                        StudentName = s.Name,
                        CourseName = c.Title,
                        InstructorName = i.Name,
                        Grade = grade?.LetterGrade ?? "Not Graded"
                    };

// Display the student report
Console.WriteLine("\nStudent Enrollment Report");
Console.WriteLine("------------------------");
foreach (var report in studentReport)
{
    Console.WriteLine($"Student: {report.StudentName}");
    Console.WriteLine($"Course: {report.CourseName}");
    Console.WriteLine($"Instructor: {report.InstructorName}");
    Console.WriteLine($"Grade: {report.Grade}");
    Console.WriteLine();
}
```

**Output:**
```
Student Enrollment Report
------------------------
Student: Alice
Course: C# Fundamentals
Instructor: Professor Smith
Grade: A

Student: Alice
Course: LINQ Mastery
Instructor: Dr. Johnson
Grade: B+

Student: Bob
Course: C# Fundamentals
Instructor: Professor Smith
Grade: B

Student: Charlie
Course: ASP.NET Core
Instructor: Professor Smith
Grade: A-
```

## Best Practices for LINQ Joins

1. **Choose the right join for your needs**:
   - Use inner join when you only want matching elements
   - Use group join when you need to preserve the structure of the first collection
   - Use left join when you need to keep all elements from the first collection
   - Use cross join sparingly as it can generate large result sets

2. **Consider performance**:
   - Joins can be memory-intensive operations, especially with large collections
   - Try to filter collections before joining to reduce the workload
   - Use anonymous types in the result selector to avoid creating unnecessary objects

3. **Readability matters**:
   - Choose between query syntax and method syntax based on readability for your specific scenario
   - Add comments to explain complex join operations
   - Consider breaking very complex joins into smaller steps

## Summary

LINQ joins provide powerful tools for combining data from multiple collections in C#. We've covered:

- **Inner Joins**: Combining elements with matching keys from both collections
- **Group Joins**: Preserving all elements from the first collection and grouping matching elements from the second
- **Left Outer Joins**: Keeping all elements from the first collection, even without matches
- **Cross Joins**: Creating all possible combinations between two collections

These join operations make it possible to work with related data in a concise and readable way, similar to how you would in a relational database but with the benefits of working directly with C# objects.

## Exercises

1. Create a join that finds all students who are not enrolled in any courses
2. Create a join that shows the most popular course (the one with the most student enrollments)
3. Implement a "right join" (opposite of left join) using LINQ operations
4. Create a report that shows the average grade for each course
5. Implement a join to find all instructors who don't teach any courses

## Additional Resources

- [Microsoft Documentation on LINQ Join Operations](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/join-operations)
- [C# LINQ Join Performance Best Practices](https://docs.microsoft.com/en-us/dotnet/standard/linq/optimize-join-operations)
- [101 LINQ Samples - Join Operations](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)

Happy coding!