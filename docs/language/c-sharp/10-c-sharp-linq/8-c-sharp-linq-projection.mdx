---
title: "C# LINQ Projection"
description: "Learn about LINQ projection operations in C# and how to use Select and SelectMany to transform data into new forms."

---

# C# LINQ Projection

In LINQ, projection is the process of transforming data from one form to another. It allows you to create new data structures from existing ones by selecting specific properties or applying transformations to elements in a collection. In this article, we will explore LINQ projection operations, specifically focusing on the `Select` and `SelectMany` methods.

## Understanding LINQ Projection

Projection is one of the most powerful features of LINQ. It enables you to:

- Extract specific properties from objects
- Transform data into new formats
- Create anonymous types containing only the properties you need
- Flatten nested collections

Rather than working with entire objects, projection lets you work with just the data you need, making your code more efficient and readable.

## The Select Method

The `Select` method is the primary projection operator in LINQ. It applies a transformation function to each element in a collection and returns a new collection containing the transformed elements.

### Basic Syntax

```csharp
var result = collection.Select(item => transformation);
```

### Simple Example

Let's start with a simple example. Suppose we have a list of integers and we want to square each number:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

// Project each number to its squared value
var squaredNumbers = numbers.Select(n => n * n);

// Output: 1, 4, 9, 16, 25
Console.WriteLine(string.Join(", ", squaredNumbers));
```

### Projecting into New Types

One of the most common uses of projection is to extract specific properties from complex objects:

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public string Category { get; set; }
}

// Sample product list
List<Product> products = new List<Product>
{
    new Product { Id = 1, Name = "Laptop", Price = 1200, Category = "Electronics" },
    new Product { Id = 2, Name = "Desk Chair", Price = 250, Category = "Furniture" },
    new Product { Id = 3, Name = "Coffee Maker", Price = 100, Category = "Appliances" }
};

// Project into a simple string format
var productNames = products.Select(p => p.Name);
Console.WriteLine("Product Names: " + string.Join(", ", productNames));
// Output: Product Names: Laptop, Desk Chair, Coffee Maker

// Project into a new anonymous type
var simplifiedProducts = products.Select(p => new { p.Name, p.Price });
foreach (var item in simplifiedProducts)
{
    Console.WriteLine($"{item.Name}: ${item.Price}");
}
/*
Output:
Laptop: $1200
Desk Chair: $250
Coffee Maker: $100
*/
```

### Using the Index in Select

The `Select` method provides an overload that gives you access to the index of each element:

```csharp
var numberedProducts = products.Select((p, index) => new { Number = index + 1, p.Name });
foreach (var item in numberedProducts)
{
    Console.WriteLine($"{item.Number}. {item.Name}");
}
/*
Output:
1. Laptop
2. Desk Chair
3. Coffee Maker
*/
```

## The SelectMany Method

While `Select` transforms each element into a single new element, `SelectMany` is used when you want to flatten nested collections. It projects each element to a sequence and then flattens all resulting sequences into a single sequence.

### Basic Syntax

```csharp
var result = collection.SelectMany(item => itemSequence);
```

### Example with Nested Collections

Consider a scenario where we have a list of orders, and each order contains multiple order lines:

```csharp
public class Order
{
    public int OrderId { get; set; }
    public List<OrderLine> OrderLines { get; set; }
}

public class OrderLine
{
    public string ProductName { get; set; }
    public int Quantity { get; set; }
}

// Sample orders
List<Order> orders = new List<Order>
{
    new Order {
        OrderId = 1,
        OrderLines = new List<OrderLine> {
            new OrderLine { ProductName = "Laptop", Quantity = 1 },
            new OrderLine { ProductName = "Mouse", Quantity = 1 }
        }
    },
    new Order {
        OrderId = 2,
        OrderLines = new List<OrderLine> {
            new OrderLine { ProductName = "Desk", Quantity = 1 },
            new OrderLine { ProductName = "Chair", Quantity = 4 }
        }
    }
};

// Using Select creates a collection of collections
var nestedOrderLines = orders.Select(o => o.OrderLines);
// This would require nested loops to process

// Using SelectMany flattens into a single collection
var allOrderLines = orders.SelectMany(o => o.OrderLines);
foreach (var line in allOrderLines)
{
    Console.WriteLine($"Product: {line.ProductName}, Quantity: {line.Quantity}");
}
/*
Output:
Product: Laptop, Quantity: 1
Product: Mouse, Quantity: 1
Product: Desk, Quantity: 1
Product: Chair, Quantity: 4
*/
```

### Projecting with SelectMany

You can also transform the flattened elements using a result selector function:

```csharp
var orderDetails = orders.SelectMany(
    o => o.OrderLines,
    (order, line) => new { OrderId = order.OrderId, Product = line.ProductName, line.Quantity }
);

foreach (var detail in orderDetails)
{
    Console.WriteLine($"Order #{detail.OrderId} - {detail.Product} (Qty: {detail.Quantity})");
}
/*
Output:
Order #1 - Laptop (Qty: 1)
Order #1 - Mouse (Qty: 1)
Order #2 - Desk (Qty: 1)
Order #2 - Chair (Qty: 4)
*/
```

## Real-World Applications

### Example 1: Processing File Data

Let's say we want to read multiple text files and process all lines across all files:

```csharp
string[] filePaths = { "file1.txt", "file2.txt", "file3.txt" };

// Using Select would give us IEnumerable<string[]> (collection of string arrays)
var linesNested = filePaths.Select(file => File.ReadAllLines(file));

// Using SelectMany gives us IEnumerable<string> (flattened collection of strings)
var allLines = filePaths.SelectMany(file => File.ReadAllLines(file));

// Now we can process each line directly
var processedLines = allLines.Select(line => line.Trim().ToUpper());
```

### Example 2: Data Transformation for an API

When building APIs, you often need to transform your data models into DTOs (Data Transfer Objects):

```csharp
public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public Address Address { get; set; }
    public List<Order> OrderHistory { get; set; }
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }
    public string ZipCode { get; set; }
}

// Get a list of customers from the database
List<Customer> customers = GetCustomersFromDatabase();

// Transform into a simplified DTO for the API response
var customerDtos = customers.Select(c => new {
    c.Id,
    c.Name,
    c.Email,
    Address = $"{c.Address.Street}, {c.Address.City}, {c.Address.ZipCode}",
    OrderCount = c.OrderHistory.Count
});
```

### Example 3: Data Analysis

LINQ projection is extremely useful for data analysis tasks:

```csharp
public class SalesRecord
{
    public string ProductName { get; set; }
    public DateTime SaleDate { get; set; }
    public decimal Amount { get; set; }
    public string Region { get; set; }
}

List<SalesRecord> sales = GetSalesData();

// Get monthly sales totals
var monthlySales = sales
    .GroupBy(s => new { s.SaleDate.Year, s.SaleDate.Month })
    .Select(g => new {
        Year = g.Key.Year,
        Month = g.Key.Month,
        TotalSales = g.Sum(s => s.Amount)
    })
    .OrderBy(s => s.Year)
    .ThenBy(s => s.Month);

// Get sales by product and region
var salesByProductAndRegion = sales
    .GroupBy(s => new { s.ProductName, s.Region })
    .Select(g => new {
        Product = g.Key.ProductName,
        Region = g.Key.Region,
        TotalSales = g.Sum(s => s.Amount),
        AverageAmount = g.Average(s => s.Amount)
    })
    .OrderByDescending(s => s.TotalSales);
```

## Best Practices for LINQ Projection

1. **Be specific**: Only select the data you need to improve performance and reduce memory usage.
2. **Consider readability**: Sometimes using multiple projections in sequence is more readable than complex nested transformations.
3. **Use meaningful names**: When projecting to anonymous types, use property names that clearly convey meaning.
4. **Avoid excessive transformations**: While projection is powerful, excessive transformations can impact performance.

## Common Mistakes

### Forgetting to Use SelectMany for Nested Collections

A common mistake is using `Select` when you should use `SelectMany`:

```csharp
// Incorrect - creates a nested collection
var allWords = sentences.Select(s => s.Split(' '));

// Correct - flattens into a single collection of words
var allWords = sentences.SelectMany(s => s.Split(' '));
```

### Projection to Entity Type Instead of Anonymously Typed Results

When using LINQ with Entity Framework, this can lead to unnecessary data loading:

```csharp
// May load unnecessary data
var products = dbContext.Products.Select(p => new Product { Id = p.Id, Name = p.Name });

// Better - only loads needed data
var products = dbContext.Products.Select(p => new { p.Id, p.Name });
```

## Summary

LINQ projection operations are powerful tools for transforming data in C#. The `Select` method allows you to transform each element in a collection into a new form, while `SelectMany` is ideal for flattening nested collections. By understanding these projection operations, you can write more efficient code that focuses only on the data you need.

Projection is particularly useful when:
- Working with complex object hierarchies
- Creating data transfer objects (DTOs)
- Performing data analysis tasks
- Processing nested collections

With LINQ projection, you can simplify many data manipulation tasks that would otherwise require complex loops and temporary collections.

## Exercises

1. Create a list of `Person` objects with properties for `Name`, `Age`, and `Hobbies` (a string list). Use `Select` to create a list of person names.
2. Using the same list, use `SelectMany` to create a single list containing all hobbies across all people.
3. Create a list of `Book` objects with properties for `Title`, `Author`, and `Genres` (a string list). Project this into a list of books showing only the title and first genre.
4. Taking a list of sentences (strings), use LINQ to extract all unique words across all sentences, sorted alphabetically.
5. Create a nested structure representing a file system with `Folder` objects that contain `File` objects. Use `SelectMany` to find all files with a specific extension.

## Additional Resources

- [Microsoft Documentation on LINQ Select](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.select)
- [Microsoft Documentation on LINQ SelectMany](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.selectmany)
- [101 LINQ Samples](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)
- [Effective LINQ](https://www.amazon.com/Effective-LINQ-Specific-Ways-Improve/dp/0321722752) by Bill Wagner