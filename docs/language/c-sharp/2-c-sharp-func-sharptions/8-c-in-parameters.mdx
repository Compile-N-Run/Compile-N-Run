---
title: "C# In Parameters"
description: "Learn how to use the 'in' parameter modifier in C# to pass arguments by reference but prevent their modification, improving performance for large value types."

---

# C# In Parameters

## Introduction

When developing C# applications, how we pass parameters to methods can significantly impact both functionality and performance. The `in` parameter modifier, introduced in C# 7.2, offers a unique way to pass arguments to methods that combines some benefits of both pass-by-value and pass-by-reference approaches.

In this guide, we'll explore what `in` parameters are, how they work, and when you should use them in your C# applications.

## What are 'in' Parameters?

The `in` keyword is a parameter modifier that specifies that a parameter is passed by reference but cannot be modified by the called method. This creates a read-only reference, which allows the method to access the parameter efficiently without making a copy, but prevents the method from modifying the passed argument.

Here's the basic syntax:

```csharp
void MyMethod(in int parameter)
{
    // Can read parameter but cannot modify it
    Console.WriteLine(parameter);
    
    // The following would cause a compilation error:
    // parameter = 42; 
}
```

## How 'in' Parameters Work

Let's look at the key characteristics of `in` parameters:

1. **Passed by reference**: The parameter is passed as a reference to the original value, not a copy.
2. **Read-only**: The method cannot modify the value through that reference.
3. **Performance optimization**: Avoids copying large value types, which can be expensive.

### Basic Example

```csharp
using System;

class Program
{
    static void Main()
    {
        int number = 42;
        DisplayValue(in number);
        Console.WriteLine($"After method call: {number}");
    }

    static void DisplayValue(in int value)
    {
        // We can read the value
        Console.WriteLine($"The value is: {value}");
        
        // But we cannot modify it:
        // value = 100; // This would cause a compilation error
    }
}
```

**Output:**
```
The value is: 42
After method call: 42
```

## When to Use 'in' Parameters

The `in` modifier is particularly useful in the following scenarios:

### 1. Large Value Types

For large value types like large structs, passing by value creates a copy, which can affect performance. Using `in` avoids this copying while still preventing modifications.

```csharp
struct LargeStruct
{
    public long Field1;
    public long Field2;
    public long Field3;
    public double Field4;
    public double Field5;
    // Imagine many more fields...
}

void ProcessLargeStruct(in LargeStruct data)
{
    // Process the data without modifying it
    Console.WriteLine($"Field1: {data.Field1}");
}
```

### 2. High-Performance Scenarios

In performance-critical code, especially when dealing with math operations or graphics processing:

```csharp
struct Vector3D
{
    public double X;
    public double Y;
    public double Z;
}

double CalculateDistance(in Vector3D point1, in Vector3D point2)
{
    double dx = point2.X - point1.X;
    double dy = point2.Y - point1.Y;
    double dz = point2.Z - point1.Z;
    
    return Math.Sqrt(dx * dx + dy * dy + dz * dz);
}
```

## Comparing Parameter Modifiers

| Feature | Regular (by value) | `ref` | `in` | `out` |
|---------|-------------------|-------|------|-------|
| Creates copy | Yes | No | No | No |
| Can modify | Yes | Yes | No | Yes (must assign) |
| Must be initialized before call | Yes | Yes | Yes | No |
| Optimization purpose | - | Bidirectional | Read-only access | Output only |

## Real-World Application: Game Development

In game development, efficiently handling physics calculations is crucial for performance. Here's how `in` parameters can be used:

```csharp
struct GameEntity
{
    public Vector3D Position;
    public Vector3D Velocity;
    public float Mass;
    public float Radius;
    // Many more properties...
}

class PhysicsEngine
{
    public bool CheckCollision(in GameEntity entity1, in GameEntity entity2)
    {
        // Calculate distance between entities
        double dx = entity2.Position.X - entity1.Position.X;
        double dy = entity2.Position.Y - entity1.Position.Y;
        double dz = entity2.Position.Z - entity1.Position.Z;
        
        double distance = Math.Sqrt(dx * dx + dy * dy + dz * dz);
        
        // Check if distance is less than combined radii
        return distance < (entity1.Radius + entity2.Radius);
    }
    
    // Many more physics methods that use entities without modifying them...
}
```

## Common Issues and Best Practices

### Be Careful with Properties

When using `in` with properties, be aware that property getters still execute, which might have side effects:

```csharp
class MyClass
{
    private int _counter = 0;
    
    public int Counter
    {
        get
        {
            Console.WriteLine("Getter called");
            return _counter++;  // Side effect: increments counter
        }
    }
}

void ProcessValue(in int value)
{
    Console.WriteLine($"Value: {value}");
    Console.WriteLine($"Value again: {value}");  // Value might be different!
}

// Usage
MyClass obj = new MyClass();
ProcessValue(in obj.Counter);  // Getter is called each time the value is accessed
```

### Use with Immutable Types

`in` parameters work best with immutable types or when you're sure you won't need to modify the parameter:

```csharp
// Good practice with readonly struct
readonly struct Point3D
{
    public readonly double X;
    public readonly double Y;
    public readonly double Z;
    
    public Point3D(double x, double y, double z)
    {
        X = x;
        Y = y;
        Z = z;
    }
}

double CalculateDistance(in Point3D point1, in Point3D point2)
{
    // Implementation...
}
```

## When Not to Use 'in' Parameters

Avoid using `in` for:

1. **Small value types** (int, bool, etc.) - The overhead of reference handling might outweigh the benefits.
2. **Reference types** - These are already passed as references, so `in` only adds the read-only constraint.
3. **Methods that need to modify the parameter** - Use `ref` instead.

## Summary

The `in` parameter modifier in C# provides an efficient way to pass large value types to methods without the performance overhead of copying, while ensuring that the method cannot modify the parameter. This makes it particularly useful for performance-critical code dealing with large structs.

Key points to remember:
- Use `in` for large value types to avoid copying
- Parameters are passed by reference but are read-only
- Perfect for math operations, physics calculations, and other scenarios where you need efficient read-only access
- Consider using `readonly struct` with `in` parameters for even better optimization

## Additional Resources

- [Microsoft Docs on in parameter modifier](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier)
- [C# 7.2 Features](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2)

## Exercises

1. Create a `ComplexNumber` struct and implement methods for addition and multiplication that use `in` parameters.
2. Compare the performance of passing a large struct (>100 bytes) by value versus using the `in` modifier.
3. Implement a 3D transformation function that takes multiple `in Vector3D` parameters.