---
title: "C# Optional Parameters"
description: "Learn how to use optional parameters in C# functions to make your code more flexible and reduce function overloading"

---

# C# Optional Parameters

## Introduction

When designing functions in C#, you may encounter situations where some parameters should be required while others could be optional. Optional parameters allow you to define default values for function parameters, making them optional when the function is called.

This feature helps you write cleaner, more flexible code and reduces the need for method overloading (creating multiple versions of the same method with different parameters).

## Understanding Optional Parameters

In C#, optional parameters are created by specifying a default value for the parameter in the method declaration. When calling the method, you can either provide a value for this parameter or omit it, in which case the default value will be used.

Let's see how optional parameters work:

```csharp
void DisplayMessage(string message, bool addTimestamp = false)
{
    if (addTimestamp)
    {
        Console.WriteLine($"[{DateTime.Now}] {message}");
    }
    else
    {
        Console.WriteLine(message);
    }
}
```

In this example, `addTimestamp` is an optional parameter with a default value of `false`. You can call this method in two ways:

```csharp
// Using the default value for addTimestamp (false)
DisplayMessage("Hello, world!");

// Providing a value for addTimestamp
DisplayMessage("Hello, world!", true);
```

**Output:**
```
Hello, world!
[5/15/2023 3:45:21 PM] Hello, world!
```

## Rules for Optional Parameters

When working with optional parameters in C#, there are some important rules to follow:

1. **Optional parameters must come after required parameters**. This means you cannot have a required parameter following an optional one.

```csharp
// Correct
void Process(int required, string optional = "default")
{
    // Method body
}

// Incorrect - won't compile
void Process(int optional = 0, string required)
{
    // Method body
}
```

2. **You can have multiple optional parameters**. When calling the method, you can skip any or all optional parameters from right to left.

```csharp
void Configure(string name, string color = "blue", int size = 10, bool enabled = true)
{
    Console.WriteLine($"Name: {name}, Color: {color}, Size: {size}, Enabled: {enabled}");
}
```

You can call this method in various ways:

```csharp
Configure("Button");                             // Use all defaults
Configure("Button", "red");                      // Specify color, use defaults for size and enabled
Configure("Button", "red", 20);                  // Specify color and size, use default for enabled
Configure("Button", "red", 20, false);           // Specify all parameters
```

**Output:**
```
Name: Button, Color: blue, Size: 10, Enabled: True
Name: Button, Color: red, Size: 10, Enabled: True
Name: Button, Color: red, Size: 20, Enabled: True
Name: Button, Color: red, Size: 20, Enabled: False
```

3. **Default values must be compile-time constants** or expressions that can be evaluated at compile time.

```csharp
// Valid default values
void Process(int a = 10, string b = "default", char c = 'A', bool d = false)
{
    // Method body
}

// The following would NOT be valid:
// void Process(int a = GetDefaultValue()) // Not a compile-time constant
```

## Named Arguments with Optional Parameters

When calling a method with multiple optional parameters, you might want to specify only certain optional parameters while using default values for others. C# allows you to use named arguments to achieve this:

```csharp
void SetupUser(string username, string email = "none", bool isAdmin = false, int accessLevel = 1)
{
    Console.WriteLine($"User: {username}, Email: {email}, Admin: {isAdmin}, Access Level: {accessLevel}");
}
```

Using named arguments, you can specify only the parameters you want to change:

```csharp
// Setting only username and isAdmin, using defaults for other parameters
SetupUser("john_doe", isAdmin: true);

// Setting username, email, and accessLevel (skipping isAdmin)
SetupUser("jane_doe", email: "jane@example.com", accessLevel: 3);
```

**Output:**
```
User: john_doe, Email: none, Admin: True, Access Level: 1
User: jane_doe, Email: jane@example.com, Admin: False, Access Level: 3
```

## Real-World Applications

### 1. Configuration Functions

Optional parameters are excellent for configuration functions where many settings have sensible defaults:

```csharp
void InitializeApplication(
    string appName, 
    string logLevel = "INFO", 
    bool useCache = true, 
    int timeoutSeconds = 30, 
    string dataSource = "default")
{
    Console.WriteLine($"Initializing {appName}");
    Console.WriteLine($"Log Level: {logLevel}");
    Console.WriteLine($"Cache Enabled: {useCache}");
    Console.WriteLine($"Timeout: {timeoutSeconds} seconds");
    Console.WriteLine($"Data Source: {dataSource}");
}

// Basic initialization with defaults
InitializeApplication("MyApp");

// Custom configuration
InitializeApplication("MyApp", logLevel: "DEBUG", timeoutSeconds: 60);
```

**Output:**
```
Initializing MyApp
Log Level: INFO
Cache Enabled: True
Timeout: 30 seconds
Data Source: default

Initializing MyApp
Log Level: DEBUG
Cache Enabled: True
Timeout: 60 seconds
Data Source: default
```

### 2. Format Utility Functions

Optional parameters can make utility functions more flexible:

```csharp
string FormatCurrency(decimal amount, string currencySymbol = "$", int decimalPlaces = 2)
{
    return string.Format("{0}{1}", currencySymbol, Math.Round(amount, decimalPlaces));
}

Console.WriteLine(FormatCurrency(499.95m));              // Default symbol and decimal places
Console.WriteLine(FormatCurrency(499.95m, "€"));         // Custom symbol
Console.WriteLine(FormatCurrency(499.95m, "£", 0));      // Custom symbol and decimal places
```

**Output:**
```
$499.95
€499.95
£500
```

### 3. Default Parameter Values in Constructors

Optional parameters can be used in constructors to provide default values:

```csharp
public class Customer
{
    public string Name { get; set; }
    public string Email { get; set; }
    public string PhoneNumber { get; set; }
    public CustomerType Type { get; set; }

    public Customer(string name, string email, string phoneNumber = "Unknown", CustomerType type = CustomerType.Regular)
    {
        Name = name;
        Email = email;
        PhoneNumber = phoneNumber;
        Type = type;
    }

    public void DisplayInfo()
    {
        Console.WriteLine($"Customer: {Name}");
        Console.WriteLine($"Email: {Email}");
        Console.WriteLine($"Phone: {PhoneNumber}");
        Console.WriteLine($"Type: {Type}");
        Console.WriteLine();
    }
}

public enum CustomerType
{
    Regular,
    Premium,
    VIP
}

// Create customers with different levels of information
Customer customer1 = new Customer("John Doe", "john@example.com");
Customer customer2 = new Customer("Jane Smith", "jane@example.com", "555-1234");
Customer customer3 = new Customer("Bob Johnson", "bob@example.com", "555-5678", CustomerType.VIP);

customer1.DisplayInfo();
customer2.DisplayInfo();
customer3.DisplayInfo();
```

**Output:**
```
Customer: John Doe
Email: john@example.com
Phone: Unknown
Type: Regular

Customer: Jane Smith
Email: jane@example.com
Phone: 555-1234
Type: Regular

Customer: Bob Johnson
Email: bob@example.com
Phone: 555-5678
Type: VIP
```

## Optional Parameters vs. Method Overloading

Before optional parameters were introduced in C# 4.0, developers used method overloading to achieve similar functionality. Let's compare both approaches:

**Using Method Overloading:**

```csharp
void SendEmail(string recipient, string subject, string body)
{
    SendEmail(recipient, subject, body, false, 0);
}

void SendEmail(string recipient, string subject, string body, bool isHtml)
{
    SendEmail(recipient, subject, body, isHtml, 0);
}

void SendEmail(string recipient, string subject, string body, bool isHtml, int priority)
{
    // Implementation
    Console.WriteLine($"Sending {(isHtml ? "HTML" : "text")} email to {recipient}");
    Console.WriteLine($"Subject: {subject}");
    Console.WriteLine($"Body: {body}");
    Console.WriteLine($"Priority: {priority}");
}
```

**Using Optional Parameters:**

```csharp
void SendEmail(string recipient, string subject, string body, bool isHtml = false, int priority = 0)
{
    // Implementation
    Console.WriteLine($"Sending {(isHtml ? "HTML" : "text")} email to {recipient}");
    Console.WriteLine($"Subject: {subject}");
    Console.WriteLine($"Body: {body}");
    Console.WriteLine($"Priority: {priority}");
}
```

Benefits of optional parameters:
- Less code to maintain
- Clearer function signatures
- Easier to add new optional parameters later

However, method overloading can still be useful in certain scenarios:
- When you need different method implementations based on parameter types
- For backward compatibility with existing code
- When working with languages that don't support optional parameters

## Summary

Optional parameters in C# provide a clean way to define function parameters that don't always need to be specified when calling the function. They allow for:

- More flexible method signatures
- Reduction in the number of overloaded methods
- Better code readability and maintenance
- Easier API design with sensible defaults

Remember the key rules:
- Optional parameters must come after required parameters
- You can skip optional parameters from right to left
- Default values must be compile-time constants
- Named arguments can be used to specify only specific optional parameters

By using optional parameters effectively, you can write more concise, maintainable code while providing flexibility to your method callers.

## Exercises

1. Create a `CalculateTotal` method that calculates the total cost of an item with optional parameters for tax rate (default 8.5%) and discount (default 0%).

2. Design a `FormatName` function that accepts a first name and last name as required parameters, with optional parameters for middle name, title (e.g., "Mr.", "Dr."), and a boolean to control whether the last name comes first.

3. Create a `Logger` class with a `Log` method that has optional parameters for log level, timestamp inclusion, and source component.

4. Refactor the following overloaded methods into a single method using optional parameters:
   ```csharp
   void SaveDocument(string filename, string content) { /* ... */ }
   void SaveDocument(string filename, string content, bool createBackup) { /* ... */ }
   void SaveDocument(string filename, string content, bool createBackup, bool overwrite) { /* ... */ }
   ```

## Additional Resources

- [Microsoft Docs: Named and Optional Arguments](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments)
- [C# Optional Parameters Best Practices](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments#best-practices)
- [C# Default Parameter Values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/method-parameters#optional-parameters)