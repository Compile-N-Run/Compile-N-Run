---
title: "C# Extension Methods"
description: "Learn how to create and use extension methods in C# to add functionality to existing types without modifying them directly."

---

# C# Extension Methods

## Introduction

Extension methods are a powerful feature in C# that allow you to "add" methods to existing types without modifying their source code or creating a derived type. This feature was introduced in C# 3.0 as part of the .NET Framework 3.5 and has become an essential tool for C# developers.

Extension methods are particularly useful when you want to add functionality to types that you cannot modify directly, such as built-in types like `string` or `int`, or types from third-party libraries.

## How Extension Methods Work

Extension methods are defined as static methods but are called as if they were instance methods on the extended type. The first parameter of the method specifies which type the method operates on, and is preceded by the `this` keyword.

Let's break down the syntax and understand how extension methods work:

### Basic Syntax

```csharp
public static class ExtensionClassName
{
    public static ReturnType MethodName(this TypeToExtend obj, otherParameters...)
    {
        // Method implementation
    }
}
```

The key components are:
1. A static class to contain the extension method(s)
2. A static method with the `this` keyword before the first parameter
3. The first parameter is the type you want to extend

## Creating Your First Extension Method

Let's start with a simple example: adding a method to the `string` class that counts the number of words in a string.

```csharp
using System;

// Extension methods must be defined in a static class
public static class StringExtensions
{
    // The 'this' keyword before the first parameter indicates an extension method
    public static int WordCount(this string str)
    {
        if (string.IsNullOrWhiteSpace(str))
            return 0;
            
        // Split the string by spaces and count the resulting array
        return str.Split(new[] { ' ', '\t', '\n', '\r' }, 
            StringSplitOptions.RemoveEmptyEntries).Length;
    }
}

// Using the extension method
class Program
{
    static void Main()
    {
        string text = "Hello, world! Welcome to C# extension methods.";
        
        // Call the extension method as if it were part of the string class
        int count = text.WordCount();
        
        Console.WriteLine($"The text contains {count} words.");
        // Output: The text contains 6 words.
    }
}
```

In this example, we've "added" a `WordCount()` method to the `string` class without modifying its source code. We can call this method on any string instance just as if it were a built-in method.

## Important Rules for Extension Methods

1. Extension methods must be defined in a static class.
2. The method itself must be static.
3. The first parameter must be prefixed with the `this` keyword.
4. Extension methods can only access the public members of the type they're extending.
5. You must include the namespace containing the extension method in your `using` directives.

## Practical Examples

### Example 1: Making Collections More Useful

Let's create extension methods for the `IEnumerable<T>` interface to add functionality similar to LINQ but with our own implementation:

```csharp
using System;
using System.Collections.Generic;

public static class EnumerableExtensions
{
    public static void ForEach<T>(this IEnumerable<T> source, Action<T> action)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));
            
        if (action == null)
            throw new ArgumentNullException(nameof(action));
            
        foreach (var item in source)
        {
            action(item);
        }
    }
    
    public static IEnumerable<T> TakeEveryNth<T>(this IEnumerable<T> source, int n)
    {
        if (source == null)
            throw new ArgumentNullException(nameof(source));
            
        if (n <= 0)
            throw new ArgumentException("N must be a positive integer", nameof(n));
            
        int i = 0;
        foreach (var item in source)
        {
            if (i % n == 0)
                yield return item;
            i++;
        }
    }
}

class Program
{
    static void Main()
    {
        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        
        // Using the ForEach extension method
        numbers.ForEach(n => Console.Write(n + " "));
        // Output: 1 2 3 4 5 6 7 8 9 10
        
        Console.WriteLine();
        
        // Using the TakeEveryNth extension method
        var everyThirdNumber = numbers.TakeEveryNth(3);
        foreach (var num in everyThirdNumber)
        {
            Console.Write(num + " ");
        }
        // Output: 1 4 7 10
    }
}
```

### Example 2: Adding Utility Methods to DateTime

Extension methods are great for adding utility methods to types like `DateTime`:

```csharp
using System;

public static class DateTimeExtensions
{
    public static bool IsWeekend(this DateTime date)
    {
        return date.DayOfWeek == DayOfWeek.Saturday || 
               date.DayOfWeek == DayOfWeek.Sunday;
    }
    
    public static DateTime NextWorkday(this DateTime date)
    {
        DateTime next = date.AddDays(1);
        
        while (next.IsWeekend())
        {
            next = next.AddDays(1);
        }
        
        return next;
    }
    
    public static int Age(this DateTime birthDate)
    {
        var today = DateTime.Today;
        var age = today.Year - birthDate.Year;
        
        // If birthday hasn't occurred yet this year, subtract one year
        if (birthDate.Date > today.AddYears(-age))
            age--;
            
        return age;
    }
}

class Program
{
    static void Main()
    {
        DateTime today = DateTime.Now;
        
        Console.WriteLine($"Today is {today:D}");
        Console.WriteLine($"Is today a weekend? {today.IsWeekend()}");
        
        DateTime nextWork = today.NextWorkday();
        Console.WriteLine($"Next workday is: {nextWork:D}");
        
        DateTime birthDate = new DateTime(1990, 5, 15);
        Console.WriteLine($"Age of someone born on {birthDate:d}: {birthDate.Age()} years");
    }
}
```

### Example 3: Extension Methods with Generic Constraints

We can use generic constraints with extension methods to make them more specific:

```csharp
using System;

public interface IEntity
{
    int Id { get; set; }
    DateTime CreatedDate { get; set; }
}

public static class EntityExtensions
{
    public static bool IsNew<T>(this T entity) where T : IEntity
    {
        return entity.Id == 0;
    }
    
    public static bool IsCreatedRecently<T>(this T entity, int days = 7) where T : IEntity
    {
        return (DateTime.Now - entity.CreatedDate).TotalDays <= days;
    }
}

public class User : IEntity
{
    public int Id { get; set; }
    public DateTime CreatedDate { get; set; }
    public string Name { get; set; }
}

class Program
{
    static void Main()
    {
        var newUser = new User
        {
            Name = "John",
            CreatedDate = DateTime.Now
        };
        
        Console.WriteLine($"Is user new? {newUser.IsNew()}");
        // Output: Is user new? True
        
        var existingUser = new User
        {
            Id = 42,
            Name = "Alice",
            CreatedDate = DateTime.Now.AddDays(-10)
        };
        
        Console.WriteLine($"Is existing user new? {existingUser.IsNew()}");
        // Output: Is existing user new? False
        
        Console.WriteLine($"Was existing user created in the last week? {existingUser.IsCreatedRecently()}");
        // Output: Was existing user created in the last week? False
        
        Console.WriteLine($"Was existing user created in the last 2 weeks? {existingUser.IsCreatedRecently(14)}");
        // Output: Was existing user created in the last 2 weeks? True
    }
}
```

## Best Practices for Extension Methods

While extension methods are powerful, they should be used thoughtfully:

1. **Don't overuse them**: Just because you can add methods to existing types doesn't mean you should. Consider whether a regular static method or a new class might be clearer.

2. **Keep them focused**: Extension methods should perform a single, well-defined function related to the type they extend.

3. **Don't change expected behavior**: Avoid creating extension methods that behave differently from the type's existing methods or from similar extension methods.

4. **Use meaningful names**: The method name should clearly indicate what the extension does, especially since it's "extending" an existing type.

5. **Organize extensions**: Group related extension methods in a single static class that's well-named.

6. **Consider performance**: Extension methods should be efficient, especially if they extend frequently used types.

## When to Use Extension Methods

Extension methods are particularly useful when:

- You need to add functionality to a type you can't modify (built-in types or types from third-party libraries).
- You want to organize utility methods in a way that makes them easier to discover and use.
- You're implementing a fluent interface or method chaining pattern.
- You want to add specialized functionality to an interface.

## When Not to Use Extension Methods

Avoid extension methods when:

- You can modify the original type directly.
- The functionality would be better encapsulated in a different class.
- The extension doesn't conceptually "belong" to the type it extends.
- You need access to private members of the extended type (which isn't possible with extension methods).

## Summary

Extension methods are a powerful feature in C# that allow you to add methods to existing types without modifying their source code. They're especially useful for adding utility methods to built-in types or types from third-party libraries.

Key points to remember:
- Extension methods must be defined in static classes
- They must be static methods themselves
- The first parameter must use the `this` keyword and specifies the type to extend
- Extension methods can only access public members of the extended type
- You must include the namespace containing the extension method to use it

By using extension methods appropriately, you can write cleaner, more intuitive code and build more expressive APIs.

## Exercises

1. Create an extension method for `int` that determines if the number is prime.
2. Write extension methods for `List<T>` that return the first half and second half of the list.
3. Create an extension method for `string` that converts a camelCase or PascalCase string to snake_case.
4. Implement a set of extension methods for `FileInfo` that make it easier to read and write text files.
5. Create an extension method for any collection that checks if all elements are unique.

## Additional Resources

- [Microsoft Documentation on Extension Methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
- [C# Extension Methods Best Practices](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/extension-methods)
- [LINQ Implementation with Extension Methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/)