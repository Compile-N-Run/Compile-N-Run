---
title: C# Enumeration
description: Learn about C# enumeration techniques to iterate through collections, including foreach loops, IEnumerable, IEnumerator, and custom enumerators.

---

# C# Enumeration

## Introduction

Enumeration is a fundamental concept in C# programming that allows us to iterate through collections of data such as arrays, lists, dictionaries, and other data structures. It provides a standard way to access elements in a collection one at a time without needing to know the underlying structure of the collection. 

In C#, enumeration is primarily supported through the `IEnumerable` and `IEnumerator` interfaces, which form the foundation of the powerful `foreach` loop. Understanding enumeration is essential for effective collection manipulation and processing.

## The Basics of Enumeration

### The foreach Loop

The most common way to enumerate through collections in C# is by using the `foreach` loop. This loop provides a simple, readable syntax for iterating through any collection that implements the `IEnumerable` interface.

```csharp
// Example of foreach loop with an array
string[] fruits = { "Apple", "Banana", "Cherry", "Date" };

// Iterating through the array with foreach
Console.WriteLine("Fruits in my basket:");
foreach (string fruit in fruits)
{
    Console.WriteLine($"- {fruit}");
}
```

**Output:**
```
Fruits in my basket:
- Apple
- Banana
- Cherry
- Date
```

### IEnumerable and IEnumerator Interfaces

Behind the scenes, the `foreach` loop uses two important interfaces:

1. `IEnumerable` - Contains a single method `GetEnumerator()` that returns an `IEnumerator`
2. `IEnumerator` - Provides methods and properties to iterate through a collection

These interfaces are defined as follows:

```csharp
// IEnumerable interface (simplified)
public interface IEnumerable
{
    IEnumerator GetEnumerator();
}

// IEnumerator interface (simplified)
public interface IEnumerator
{
    bool MoveNext();
    object Current { get; }
    void Reset();
}
```

The `foreach` loop can be rewritten using these interfaces explicitly:

```csharp
string[] fruits = { "Apple", "Banana", "Cherry", "Date" };

// Explicit use of IEnumerator
IEnumerator enumerator = fruits.GetEnumerator();
while (enumerator.MoveNext())
{
    string fruit = (string)enumerator.Current;
    Console.WriteLine(fruit);
}
```

## Generic Enumeration with `IEnumerable<T>`

C# provides generic versions of these interfaces (`IEnumerable<T>` and `IEnumerator<T>`), which offer type safety and eliminate the need for casting:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };

// Using generic IEnumerator<T>
IEnumerator<int> enumerator = numbers.GetEnumerator();
while (enumerator.MoveNext())
{
    int number = enumerator.Current; // No casting needed
    Console.WriteLine($"Number: {number}");
}
```

**Output:**
```
Number: 1
Number: 2
Number: 3
Number: 4
Number: 5
```

## Creating Custom Enumerators

You can create your own enumerable types by implementing the `IEnumerable<T>` interface. This is useful when you have custom collection types or when you want to provide a specific way to iterate through data.

Here's an example of a custom collection with an enumerator:

```csharp
using System;
using System.Collections;
using System.Collections.Generic;

public class Fibonacci : IEnumerable<int>
{
    private readonly int _count;

    public Fibonacci(int count)
    {
        _count = count;
    }

    public IEnumerator<int> GetEnumerator()
    {
        return new FibonacciEnumerator(_count);
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    private class FibonacciEnumerator : IEnumerator<int>
    {
        private readonly int _count;
        private int _current;
        private int _next;
        private int _position;

        public FibonacciEnumerator(int count)
        {
            _count = count;
            Reset();
        }

        public int Current => _current;

        object IEnumerator.Current => Current;

        public bool MoveNext()
        {
            if (_position < 0)
            {
                _position++;
                _current = 0;
                _next = 1;
                return true;
            }

            if (_position < _count - 1)
            {
                int temp = _current + _next;
                _current = _next;
                _next = temp;
                _position++;
                return true;
            }

            return false;
        }

        public void Reset()
        {
            _position = -1;
            _current = 0;
            _next = 1;
        }

        public void Dispose()
        {
            // No resources to dispose
        }
    }
}
```

Usage example:

```csharp
// Generate the first 10 Fibonacci numbers
Fibonacci fib = new Fibonacci(10);

Console.WriteLine("First 10 Fibonacci numbers:");
foreach (int number in fib)
{
    Console.Write($"{number} ");
}
```

**Output:**
```
First 10 Fibonacci numbers:
0 1 1 2 3 5 8 13 21 34
```

## Yield Return: Simplified Enumeration

C# provides the `yield` keyword to simplify creating enumerators. It allows you to create an iterator method that returns elements one at a time without having to implement the full `IEnumerator` interface:

```csharp
public class SimpleFibonacci
{
    private readonly int _count;

    public SimpleFibonacci(int count)
    {
        _count = count;
    }

    public IEnumerable<int> GetSequence()
    {
        int current = 0;
        int next = 1;

        yield return current; // First Fibonacci number

        for (int i = 1; i < _count; i++)
        {
            int temp = current + next;
            current = next;
            next = temp;
            yield return current;
        }
    }
}
```

Usage:

```csharp
SimpleFibonacci fib = new SimpleFibonacci(10);

Console.WriteLine("First 10 Fibonacci numbers using yield:");
foreach (int number in fib.GetSequence())
{
    Console.Write($"{number} ");
}
```

**Output:**
```
First 10 Fibonacci numbers using yield:
0 1 1 2 3 5 8 13 21 34
```

## LINQ and Enumeration

LINQ (Language-Integrated Query) is built on top of the enumeration concept and provides powerful query capabilities:

```csharp
List<string> names = new List<string> { "Alice", "Bob", "Charlie", "David", "Eva" };

// Using LINQ to filter and transform data
var filteredNames = names
    .Where(name => name.Length > 3)
    .Select(name => name.ToUpper());

Console.WriteLine("Names with more than 3 characters (uppercase):");
foreach (string name in filteredNames)
{
    Console.WriteLine(name);
}
```

**Output:**
```
Names with more than 3 characters (uppercase):
ALICE
CHARLIE
DAVID
```

## Practical Applications

### Lazy Evaluation

One significant benefit of C# enumeration is lazy evaluation. Elements are processed only when needed, which can improve performance when working with large collections:

```csharp
// This generates numbers from 1 to 1,000,000 but doesn't store them all in memory at once
IEnumerable<int> largeNumberSequence = Enumerable.Range(1, 1000000);

// This only takes the first 5 numbers and stops generating the rest
var firstFive = largeNumberSequence.Take(5);

Console.WriteLine("First 5 numbers:");
foreach (int num in firstFive)
{
    Console.WriteLine(num);
}
```

### Custom Data Processing Pipeline

Enumeration allows you to create data processing pipelines that can handle large amounts of data efficiently:

```csharp
public static class DataProcessor
{
    // Reads data from a source (could be a file, database, etc.)
    public static IEnumerable<string> ReadData(string source)
    {
        // Simulating reading data
        string[] lines = {
            "John,25,Developer",
            "Jane,30,Designer",
            "Mike,28,Manager",
            "Sarah,35,Director"
        };

        foreach (string line in lines)
        {
            yield return line;
        }
    }

    // Transforms data into a more useful format
    public static IEnumerable<Person> ParseData(IEnumerable<string> lines)
    {
        foreach (string line in lines)
        {
            string[] parts = line.Split(',');
            yield return new Person
            {
                Name = parts[0],
                Age = int.Parse(parts[1]),
                Role = parts[2]
            };
        }
    }

    // Filters data based on criteria
    public static IEnumerable<Person> FilterByAge(IEnumerable<Person> people, int minAge)
    {
        foreach (Person person in people)
        {
            if (person.Age >= minAge)
            {
                yield return person;
            }
        }
    }
}

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Role { get; set; }

    public override string ToString()
    {
        return $"{Name} ({Age}) - {Role}";
    }
}
```

Usage of the pipeline:

```csharp
// Create a data processing pipeline
var dataSource = "sample-data";
var pipeline = DataProcessor
    .ReadData(dataSource)
    .ParseData()
    .FilterByAge(30);

Console.WriteLine("People aged 30 or older:");
foreach (var person in pipeline)
{
    Console.WriteLine(person);
}
```

**Output:**
```
People aged 30 or older:
Jane (30) - Designer
Sarah (35) - Director
```

## Common Enumeration Patterns

### Breaking Early

Sometimes you need to exit a foreach loop early:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

Console.WriteLine("Numbers until we find 5:");
foreach (int number in numbers)
{
    Console.Write($"{number} ");
    
    if (number == 5)
    {
        break; // Exit the loop when we find 5
    }
}
```

**Output:**
```
Numbers until we find 5:
1 2 3 4 5
```

### Skipping Elements

To skip certain elements during iteration:

```csharp
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

Console.WriteLine("Only printing odd numbers:");
foreach (int number in numbers)
{
    if (number % 2 == 0)
    {
        continue; // Skip even numbers
    }
    
    Console.Write($"{number} ");
}
```

**Output:**
```
Only printing odd numbers:
1 3 5 7 9
```

## Summary

Enumeration in C# provides a flexible and powerful way to work with collections of data. Key points to remember:

- The `foreach` loop is the most common and readable way to enumerate collections
- Behind the scenes, enumeration uses the `IEnumerable` and `IEnumerator` interfaces
- Generic versions (`IEnumerable<T>` and `IEnumerator<T>`) provide type safety
- You can create custom enumerators by implementing these interfaces
- The `yield` keyword simplifies creating custom enumerators
- Enumeration supports lazy evaluation, improving performance with large datasets
- LINQ is built on the enumeration concept and provides powerful query capabilities

Understanding enumeration is essential for effectively working with collections in C# and is the foundation for more advanced collection operations.

## Exercises

1. Create a custom enumerator that generates prime numbers up to a specified limit
2. Implement a method that uses `yield return` to generate a sequence of dates (one for each day in a given month)
3. Create a data processing pipeline using custom enumerators to read, filter, and transform data from a text file
4. Implement a custom collection class that provides multiple different ways to enumerate its elements (e.g., forwards, backwards, only even/odd indices)

## Additional Resources

- [Microsoft Documentation: Iterators](https://docs.microsoft.com/en-us/dotnet/csharp/iterators)
- [C# IEnumerable Interface](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable)
- [C# IEnumerator Interface](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator)
- [C# Yield Statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield)
- [LINQ Overview](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/)