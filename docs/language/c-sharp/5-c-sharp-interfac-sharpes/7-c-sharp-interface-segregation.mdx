---
title: C# Interface Segregation
description: Learn about the Interface Segregation Principle in C# and how to design better interfaces by keeping them focused and cohesive.

---

# C# Interface Segregation

## Introduction

Interface Segregation is one of the five SOLID principles of object-oriented design. The Interface Segregation Principle (ISP) states that "clients should not be forced to depend upon interfaces that they do not use." In simpler terms, it's better to have many small, specific interfaces rather than one large, general-purpose interface.

This principle was first formulated by Robert C. Martin and helps us create more maintainable and flexible code by designing interfaces that are focused on specific functionality. In this tutorial, we'll learn how to apply the Interface Segregation Principle in C# to improve our interface designs.

## Why Interface Segregation Matters

Imagine you're at a restaurant. Would you prefer:
1. A single, giant menu with hundreds of options, most of which you don't care about
2. A well-organized set of smaller menus (appetizers, main courses, desserts)

Most people would prefer the second option because it's easier to navigate and focus on what you actually want. Interface segregation follows the same logic but for code interfaces.

When you create large interfaces with many methods, classes implementing those interfaces are forced to provide implementations for methods they might not need. This leads to:

- Bloated implementations
- More complex maintenance
- Tighter coupling between components
- Increased risk when making changes

## Identifying Interface Segregation Problems

Let's look at an example of a poorly designed interface:

```csharp
public interface IMultiFunction
{
    void Print(Document document);
    void Scan(Document document);
    void Fax(Document document);
    void Copy(Document document);
}

public class Document
{
    public string Content { get; set; }
}
```

This interface represents a multi-function printer. But what if we want to implement a basic printer that can only print? We would be forced to implement all other methods with empty or throw-exception implementations:

```csharp
public class BasicPrinter : IMultiFunction
{
    public void Print(Document document)
    {
        Console.WriteLine($"Printing: {document.Content}");
    }

    public void Scan(Document document)
    {
        // Cannot scan
        throw new NotImplementedException("This printer cannot scan");
    }

    public void Fax(Document document)
    {
        // Cannot fax
        throw new NotImplementedException("This printer cannot fax");
    }

    public void Copy(Document document)
    {
        // Cannot copy
        throw new NotImplementedException("This printer cannot copy");
    }
}
```

This violates the Interface Segregation Principle because the `BasicPrinter` class is forced to implement methods it doesn't use.

## Applying Interface Segregation

Let's refactor the previous example to follow the Interface Segregation Principle:

```csharp
public interface IPrinter
{
    void Print(Document document);
}

public interface IScanner
{
    void Scan(Document document);
}

public interface IFax
{
    void Fax(Document document);
}

public interface ICopier
{
    void Copy(Document document);
}

// For convenience, we can define a combined interface
public interface IMultiFunctionDevice : IPrinter, IScanner, IFax, ICopier
{
    // No additional methods needed
}
```

Now we can implement only the interfaces that we need:

```csharp
public class BasicPrinter : IPrinter
{
    public void Print(Document document)
    {
        Console.WriteLine($"Printing: {document.Content}");
    }
}

public class Scanner : IScanner
{
    public void Scan(Document document)
    {
        Console.WriteLine($"Scanning: {document.Content}");
    }
}

public class MultiFunctionPrinter : IMultiFunctionDevice
{
    public void Print(Document document)
    {
        Console.WriteLine($"Multi-function device printing: {document.Content}");
    }

    public void Scan(Document document)
    {
        Console.WriteLine($"Multi-function device scanning: {document.Content}");
    }

    public void Fax(Document document)
    {
        Console.WriteLine($"Multi-function device faxing: {document.Content}");
    }

    public void Copy(Document document)
    {
        Console.WriteLine($"Multi-function device copying: {document.Content}");
    }
}
```

## Complete Example with Execution

Here's a complete example showing how the interfaces are used:

```csharp
using System;

public class Program
{
    public static void Main()
    {
        Document document = new Document
        {
            Content = "Hello, Interface Segregation!"
        };

        // Using a basic printer
        IPrinter basicPrinter = new BasicPrinter();
        basicPrinter.Print(document);
        
        // Using a scanner
        IScanner scanner = new Scanner();
        scanner.Scan(document);
        
        // Using a multi-function device
        IMultiFunctionDevice multiFunctionPrinter = new MultiFunctionPrinter();
        multiFunctionPrinter.Print(document);
        multiFunctionPrinter.Scan(document);
        multiFunctionPrinter.Fax(document);
        multiFunctionPrinter.Copy(document);
        
        // We can also use the multi-function device as just a printer
        IPrinter printer = multiFunctionPrinter;
        printer.Print(document);
    }
}
```

Output:
```
Printing: Hello, Interface Segregation!
Scanning: Hello, Interface Segregation!
Multi-function device printing: Hello, Interface Segregation!
Multi-function device scanning: Hello, Interface Segregation!
Multi-function device faxing: Hello, Interface Segregation!
Multi-function device copying: Hello, Interface Segregation!
Multi-function device printing: Hello, Interface Segregation!
```

## Real-World Application: Building a Music Player

Let's see a more practical example of interface segregation in a music player application:

```csharp
// Before interface segregation
public interface IMusicPlayer
{
    void Play(Song song);
    void Pause();
    void Stop();
    void CreatePlaylist(string name);
    void AddToPlaylist(Song song, string playlistName);
    void RemoveFromPlaylist(Song song, string playlistName);
    void DownloadSong(Song song);
    void SyncWithCloud();
    void AdjustEqualizer(int[] bands);
}
```

This interface is doing too much. A basic player might not need playlist management or cloud syncing. Let's apply interface segregation:

```csharp
// Core playback functionality
public interface IPlayback
{
    void Play(Song song);
    void Pause();
    void Stop();
}

// Playlist management
public interface IPlaylistManager
{
    void CreatePlaylist(string name);
    void AddToPlaylist(Song song, string playlistName);
    void RemoveFromPlaylist(Song song, string playlistName);
}

// Music library management
public interface IMusicLibrary
{
    void DownloadSong(Song song);
    void SyncWithCloud();
}

// Audio enhancement
public interface IAudioEnhancer
{
    void AdjustEqualizer(int[] bands);
}

public class Song
{
    public string Title { get; set; }
    public string Artist { get; set; }
}
```

Now we can create different types of players that implement only what they need:

```csharp
// Basic music player with just playback functionality
public class BasicMusicPlayer : IPlayback
{
    public void Play(Song song)
    {
        Console.WriteLine($"Playing: {song.Title} by {song.Artist}");
    }

    public void Pause()
    {
        Console.WriteLine("Playback paused");
    }

    public void Stop()
    {
        Console.WriteLine("Playback stopped");
    }
}

// Advanced player with more features
public class AdvancedMusicPlayer : IPlayback, IPlaylistManager, IAudioEnhancer
{
    public void Play(Song song)
    {
        Console.WriteLine($"Playing in high quality: {song.Title} by {song.Artist}");
    }

    public void Pause()
    {
        Console.WriteLine("Playback paused");
    }

    public void Stop()
    {
        Console.WriteLine("Playback stopped");
    }

    public void CreatePlaylist(string name)
    {
        Console.WriteLine($"Created playlist: {name}");
    }

    public void AddToPlaylist(Song song, string playlistName)
    {
        Console.WriteLine($"Added '{song.Title}' to playlist '{playlistName}'");
    }

    public void RemoveFromPlaylist(Song song, string playlistName)
    {
        Console.WriteLine($"Removed '{song.Title}' from playlist '{playlistName}'");
    }

    public void AdjustEqualizer(int[] bands)
    {
        Console.WriteLine("Equalizer adjusted");
    }
}

// Premium player with all features
public class PremiumMusicPlayer : IPlayback, IPlaylistManager, IMusicLibrary, IAudioEnhancer
{
    // All implementations...
    public void Play(Song song)
    {
        Console.WriteLine($"Playing premium quality: {song.Title} by {song.Artist}");
    }

    public void Pause()
    {
        Console.WriteLine("Premium playback paused");
    }

    public void Stop()
    {
        Console.WriteLine("Premium playback stopped");
    }

    public void CreatePlaylist(string name)
    {
        Console.WriteLine($"Created premium playlist: {name}");
    }

    public void AddToPlaylist(Song song, string playlistName)
    {
        Console.WriteLine($"Added '{song.Title}' to premium playlist '{playlistName}'");
    }

    public void RemoveFromPlaylist(Song song, string playlistName)
    {
        Console.WriteLine($"Removed '{song.Title}' from premium playlist '{playlistName}'");
    }

    public void DownloadSong(Song song)
    {
        Console.WriteLine($"Downloaded '{song.Title}' for offline listening");
    }

    public void SyncWithCloud()
    {
        Console.WriteLine("Synced music library with cloud");
    }

    public void AdjustEqualizer(int[] bands)
    {
        Console.WriteLine("Premium equalizer adjusted with AI enhancement");
    }
}
```

Usage example:

```csharp
public static void TestMusicPlayers()
{
    Song song = new Song { Title = "Interface Segregation", Artist = "SOLID Principles" };
    
    // Using a basic player
    IPlayback basicPlayer = new BasicMusicPlayer();
    basicPlayer.Play(song);
    basicPlayer.Pause();
    basicPlayer.Stop();
    
    Console.WriteLine();
    
    // Using an advanced player
    AdvancedMusicPlayer advancedPlayer = new AdvancedMusicPlayer();
    advancedPlayer.Play(song);
    advancedPlayer.CreatePlaylist("My Favorites");
    advancedPlayer.AddToPlaylist(song, "My Favorites");
    advancedPlayer.AdjustEqualizer(new int[] { 5, 4, 3, 2, 1 });
    
    // We can also use the advanced player as just a playback device
    IPlayback playbackOnly = advancedPlayer;
    playbackOnly.Play(song);
}
```

Output:
```
Playing: Interface Segregation by SOLID Principles
Playback paused
Playback stopped

Playing in high quality: Interface Segregation by SOLID Principles
Created playlist: My Favorites
Added 'Interface Segregation' to playlist 'My Favorites'
Equalizer adjusted
Playing in high quality: Interface Segregation by SOLID Principles
```

## Benefits of Interface Segregation

Applying interface segregation provides several benefits:

1. **Focused implementations**: Classes implement only the methods they need.
2. **Better maintainability**: Changes to one aspect don't affect unrelated classes.
3. **Improved readability**: Smaller interfaces are easier to understand.
4. **Enhanced flexibility**: You can compose interfaces to create more complex behaviors.
5. **Better testability**: Smaller interfaces are easier to mock for testing.

## When to Apply Interface Segregation

Consider applying interface segregation when:

- An interface has groups of methods that some implementations might not need
- Clients use only a subset of the interface's methods
- You find yourself implementing methods with empty bodies or throwing exceptions
- You notice that changes to one part of an interface affect classes that don't use that part

## Common Pitfalls

1. **Over-segregation**: Creating too many tiny interfaces can make the system harder to understand. Aim for cohesive interfaces that represent meaningful capabilities.

2. **Missing the big picture**: Sometimes a set of operations naturally belongs together. Don't segregate interfaces just for the sake of making them smaller.

3. **Inconsistent naming**: As you create more interfaces, maintaining a consistent naming convention becomes even more important.

## Summary

The Interface Segregation Principle is a powerful guideline for creating clean, maintainable code. By designing focused interfaces that serve specific purposes, you:

- Reduce unnecessary dependencies
- Make your code more flexible and adaptable
- Create implementations that are easier to understand and maintain
- Improve testability and reusability

Remember: "Clients should not be forced to depend upon interfaces that they do not use."

## Additional Resources

1. [SOLID Design Principles Explained](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design)
2. [Clean Code by Robert C. Martin](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
3. [C# Interface Documentation](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)

## Exercises

1. Identify a violation of the Interface Segregation Principle in an existing codebase and refactor it.
2. Design interfaces for a food delivery application with the following components: customer accounts, restaurant management, order processing, and delivery tracking.
3. Take a large interface from a project you're familiar with and segregate it into smaller, more focused interfaces.
4. Implement a document management system with interfaces for document creation, editing, sharing, and versioning. Apply interface segregation principles.
5. Discuss the trade-offs between having many small interfaces versus fewer larger interfaces in a team setting.