---
title: "C# IDisposable Interface"
description: "Learn about the IDisposable interface in C#, how to implement it correctly, and best practices for managing unmanaged resources"

---

# C# IDisposable Interface

## Introduction

In C#, memory management is primarily handled by the .NET Garbage Collector (GC), which automatically cleans up unused objects. However, some resources like file handles, database connections, and network sockets aren't managed by the GC. These "unmanaged resources" need explicit cleanup to avoid resource leaks. This is where the `IDisposable` interface comes into play.

The `IDisposable` interface provides a standardized way to release unmanaged resources when they're no longer needed. It's a simple interface with just one method:

```csharp
public interface IDisposable
{
    void Dispose();
}
```

By implementing this interface, your classes can provide a clear and consistent way to clean up resources, ensuring efficient resource management in your applications.

## When to Use IDisposable

You should implement `IDisposable` when your class:

1. Directly uses unmanaged resources (file handles, network connections, etc.)
2. Holds references to other disposable objects
3. Allocates large objects or large amounts of memory that should be released as soon as possible

## Basic Implementation

Here's a simple example of a class that implements `IDisposable`:

```csharp
using System;
using System.IO;

public class FileReader : IDisposable
{
    private StreamReader _reader;
    private bool _disposed = false;

    public FileReader(string filePath)
    {
        _reader = new StreamReader(filePath);
    }

    public string ReadLine()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(FileReader));
        }

        return _reader.ReadLine();
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            // Dispose managed resources
            _reader?.Dispose();
            
            // Mark as disposed
            _disposed = true;
        }
    }
}
```

### Usage Example:

```csharp
// Example of using the FileReader class
using (FileReader reader = new FileReader("example.txt"))
{
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        Console.WriteLine(line);
    }
} // Dispose is automatically called here when the using block ends
```

## The Dispose Pattern

For more complex scenarios, Microsoft recommends the "Dispose Pattern," which provides a more robust implementation with these key features:

1. A public `Dispose()` method from `IDisposable`
2. A protected virtual `Dispose(bool disposing)` method for the actual cleanup
3. A finalizer (destructor) as a safety net

Here's how to implement the full Dispose Pattern:

```csharp
using System;
using System.IO;

public class CompleteFileReader : IDisposable
{
    private StreamReader _reader;
    private bool _disposed = false;

    public CompleteFileReader(string filePath)
    {
        _reader = new StreamReader(filePath);
    }

    // Public implementation of Dispose
    public void Dispose()
    {
        Dispose(true);
        // Tell the garbage collector not to call the finalizer
        GC.SuppressFinalize(this);
    }

    // Protected implementation of Dispose pattern
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;

        if (disposing)
        {
            // Free any managed objects here
            _reader?.Dispose();
        }

        // Free any unmanaged objects here
        
        _disposed = true;
    }

    // Finalizer (destructor)
    ~CompleteFileReader()
    {
        Dispose(false);
    }

    public string ReadLine()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(nameof(CompleteFileReader));
        }

        return _reader.ReadLine();
    }
}
```

### Key Points about the Dispose Pattern:

- The `Dispose(bool disposing)` method separates managed and unmanaged resource cleanup
- When `disposing` is `true`, both managed and unmanaged resources are cleaned up
- When `disposing` is `false` (called from finalizer), only unmanaged resources are cleaned up
- The finalizer serves as a safety net in case `Dispose()` isn't called
- `GC.SuppressFinalize(this)` prevents the finalizer from running if proper disposal occurred

## Using Statement in C#

The `using` statement in C# provides an elegant way to work with `IDisposable` objects:

```csharp
// Traditional using block
using (SqlConnection connection = new SqlConnection(connectionString))
{
    connection.Open();
    // Work with the connection
} // Dispose is automatically called here
```

In C# 8.0 and later, you can use the simplified using declaration:

```csharp
// C# 8.0+ simplified using declaration
using SqlConnection connection = new SqlConnection(connectionString);
connection.Open();
// Work with the connection
// Dispose is called at the end of the enclosing scope
```

## Real-World Example: Database Connection Management

Here's a practical example showing how `IDisposable` helps manage database connections:

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

public class CustomerRepository : IDisposable
{
    private SqlConnection _connection;
    private bool _disposed = false;

    public CustomerRepository(string connectionString)
    {
        _connection = new SqlConnection(connectionString);
        _connection.Open();
    }

    public Customer GetCustomerById(int id)
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(CustomerRepository));

        using (SqlCommand command = _connection.CreateCommand())
        {
            command.CommandText = "SELECT Name, Email FROM Customers WHERE Id = @Id";
            command.Parameters.AddWithValue("@Id", id);

            using (SqlDataReader reader = command.ExecuteReader())
            {
                if (reader.Read())
                {
                    return new Customer
                    {
                        Id = id,
                        Name = reader.GetString(0),
                        Email = reader.GetString(1)
                    };
                }
                return null;
            }
        }
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                _connection?.Dispose();
            }

            _disposed = true;
        }
    }
}

public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}
```

### Using the CustomerRepository:

```csharp
// Example of using the CustomerRepository class
string connectionString = "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;";

using (var repository = new CustomerRepository(connectionString))
{
    Customer customer = repository.GetCustomerById(123);
    if (customer != null)
    {
        Console.WriteLine($"Found customer: {customer.Name} ({customer.Email})");
    }
    else
    {
        Console.WriteLine("Customer not found.");
    }
} // Connection is automatically closed here
```

## Best Practices for IDisposable

1. **Implement IDisposable correctly**: Follow the Dispose Pattern for types with unmanaged resources.

2. **Always call Dispose explicitly**: Use `using` statements or `try/finally` blocks to ensure Dispose is called.

3. **Check disposal state**: Throw `ObjectDisposedException` if methods are called after disposal.

4. **Make Dispose idempotent**: Ensure Dispose can be called multiple times without errors.

5. **Implement finalizers carefully**: Only use finalizers when absolutely necessary (for unmanaged resources).

6. **Consider inheritance**: Make `Dispose(bool)` virtual if your class will be inherited.

7. **Avoid returning disposable objects**: If you return disposable objects from methods, document who's responsible for disposal.

## Common Mistakes

1. **Not implementing IDisposable when using unmanaged resources**
2. **Forgetting to dispose of resources in all code paths**
3. **Accessing disposed objects**
4. **Not making Dispose methods threadsafe if needed**
5. **Implementing a finalizer unnecessarily** (when only managed resources are used)

## Summary

The `IDisposable` interface provides a standardized mechanism for releasing resources in C#. Proper implementation ensures that both managed and unmanaged resources are released promptly, preventing resource leaks and improving application performance.

Key takeaways:
- Implement `IDisposable` when your class uses unmanaged resources or other disposable objects
- Follow the Dispose Pattern for robust resource management
- Use `using` statements to ensure proper disposal
- Check disposal state before operations on potentially disposed objects
- Make dispose operations idempotent and thread-safe

## Additional Resources

- [Microsoft Docs: IDisposable Interface](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable)
- [Microsoft Docs: Implementing a Dispose Method](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose)
- [C# in Depth: IDisposable, Finalizers and using](http://csharpindepth.com/Articles/General/Disposal.aspx)

## Exercises

1. Create a simple `FileLogger` class that implements `IDisposable` and writes log messages to a file.

2. Modify an existing class that uses unmanaged resources to implement the full Dispose Pattern.

3. Write a class that holds multiple disposable resources and properly disposes of all of them.

4. Create a base class with `IDisposable` implementation and a derived class that adds its own resources to dispose.