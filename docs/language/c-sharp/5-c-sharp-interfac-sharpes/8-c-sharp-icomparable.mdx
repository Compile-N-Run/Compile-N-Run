---
title: "C# IComparable"
description: "Learn how to implement and use the IComparable interface in C# for custom object comparison and sorting"

---

# C# IComparable Interface

## Introduction

When working with custom classes in C#, you'll often need to compare instances of these classes to one another. How should the program know which customer is "greater than" another, or how to sort a list of your custom `Product` objects?

The `IComparable` interface provides a standard way to define the "natural order" of objects in your classes. It's a fundamental interface in C# that enables your objects to be sorted and compared using standard sorting mechanisms like `Array.Sort()` and `List<T>.Sort()`.

## Understanding IComparable

The `IComparable` interface contains just one method:

```csharp
int CompareTo(object obj);
```

And if you're using the strongly-typed generic version, `IComparable<T>`:

```csharp
int CompareTo(T other);
```

The `CompareTo` method returns an integer that indicates the relative order of the objects being compared:

- Less than zero: The current instance precedes the object specified by the parameter
- Zero: The current instance is in the same position as the object specified
- Greater than zero: The current instance follows the object specified

## Basic Implementation Example

Let's look at a simple example of implementing `IComparable<T>` for a `Person` class that compares based on age:

```csharp
using System;
using System.Collections.Generic;

public class Person : IComparable<Person>
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    
    // Implementation of IComparable<Person> interface
    public int CompareTo(Person other)
    {
        if (other == null)
            return 1; // Any non-null object is greater than null
            
        // Compare based on age
        return this.Age.CompareTo(other.Age);
    }
    
    public override string ToString()
    {
        return $"{Name}, {Age} years old";
    }
}
```

Now let's see how we can use this implementation to sort a list of `Person` objects:

```csharp
using System;
using System.Collections.Generic;

class Program
{
    static void Main(string[] args)
    {
        List<Person> people = new List<Person>
        {
            new Person("Alice", 25),
            new Person("Bob", 20),
            new Person("Charlie", 30),
            new Person("Diana", 22)
        };
        
        Console.WriteLine("Before sorting:");
        foreach (var person in people)
        {
            Console.WriteLine(person);
        }
        
        // Sort using the IComparable implementation
        people.Sort();
        
        Console.WriteLine("\nAfter sorting by age:");
        foreach (var person in people)
        {
            Console.WriteLine(person);
        }
    }
}
```

**Output:**
```
Before sorting:
Alice, 25 years old
Bob, 20 years old
Charlie, 30 years old
Diana, 22 years old

After sorting by age:
Bob, 20 years old
Diana, 22 years old
Alice, 25 years old
Charlie, 30 years old
```

Notice how the list is now sorted by age in ascending order, based on our `CompareTo` implementation.

## Implementing the Non-Generic IComparable

While the generic version (`IComparable<T>`) is preferred in modern C# code, you might encounter the non-generic version in older codebases. Here's how to implement both:

```csharp
public class Student : IComparable, IComparable<Student>
{
    public string Name { get; set; }
    public double GPA { get; set; }

    // Non-generic IComparable implementation
    public int CompareTo(object obj)
    {
        if (obj == null) return 1;
        
        if (!(obj is Student otherStudent))
            throw new ArgumentException("Object is not a Student");
            
        return CompareTo(otherStudent);
    }
    
    // Generic IComparable<T> implementation
    public int CompareTo(Student other)
    {
        if (other == null) return 1;
        
        // Compare by GPA
        return this.GPA.CompareTo(other.GPA);
    }
}
```

The non-generic version requires type checking and casting, which the generic version avoids, making the latter more type-safe and usually preferred.

## Comparing Multiple Properties

Often, you'll want to compare objects based on multiple properties. Let's enhance our `Person` class to compare by age and then by name if ages are equal:

```csharp
public class Person : IComparable<Person>
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    
    public int CompareTo(Person other)
    {
        if (other == null) return 1;
        
        // First compare by age
        int ageComparison = this.Age.CompareTo(other.Age);
        if (ageComparison != 0)
        {
            return ageComparison;
        }
        
        // If ages are equal, compare by name
        return this.Name.CompareTo(other.Name);
    }
    
    public override string ToString()
    {
        return $"{Name}, {Age} years old";
    }
}
```

Now, if two persons have the same age, they'll be sorted alphabetically by name.

## Real-World Example: Product Catalog

Let's look at a more practical example where we implement `IComparable` for a `Product` class in an e-commerce application:

```csharp
using System;
using System.Collections.Generic;

public class Product : IComparable<Product>
{
    public int ProductId { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int StockQuantity { get; set; }
    
    public Product(int id, string name, decimal price, int stock)
    {
        ProductId = id;
        Name = name;
        Price = price;
        StockQuantity = stock;
    }
    
    // By default, we'll sort products by price
    public int CompareTo(Product other)
    {
        if (other == null) return 1;
        
        return this.Price.CompareTo(other.Price);
    }
    
    public override string ToString()
    {
        return $"ID: {ProductId}, {Name}, ${Price:F2}, In stock: {StockQuantity}";
    }
}

class Program
{
    static void Main(string[] args)
    {
        List<Product> catalog = new List<Product>
        {
            new Product(101, "Laptop", 1200.00m, 10),
            new Product(102, "Headphones", 99.99m, 50),
            new Product(103, "Mouse", 25.50m, 100),
            new Product(104, "Keyboard", 45.99m, 30)
        };
        
        // Sort by price (using IComparable implementation)
        catalog.Sort();
        
        Console.WriteLine("Products sorted by price (ascending):");
        foreach (var product in catalog)
        {
            Console.WriteLine(product);
        }
    }
}
```

**Output:**
```
Products sorted by price (ascending):
ID: 103, Mouse, $25.50, In stock: 100
ID: 104, Keyboard, $45.99, In stock: 30
ID: 102, Headphones, $99.99, In stock: 50
ID: 101, Laptop, $1200.00, In stock: 10
```

## IComparable vs. IComparer

While `IComparable` defines a default sort order for a class, `IComparer` allows you to define alternative comparison strategies without modifying the original class. This is very useful when you need multiple ways to sort the same objects.

Here's a quick example:

```csharp
// Define a comparer for sorting products by stock quantity
public class ProductStockComparer : IComparer<Product>
{
    public int Compare(Product x, Product y)
    {
        if (x == null && y == null) return 0;
        if (x == null) return -1;
        if (y == null) return 1;
        
        return x.StockQuantity.CompareTo(y.StockQuantity);
    }
}

// Using it:
catalog.Sort(new ProductStockComparer());
```

This gives you flexibility to sort your objects in different ways based on context.

## Common Pitfalls and Best Practices

1. **Always handle null**: Check if the parameter is `null` and decide how to handle it (usually, non-null objects are considered greater than `null`).

2. **Be consistent with equality**: Make sure your `CompareTo` method is consistent with `Equals`. If `x.Equals(y)` returns `true`, then `x.CompareTo(y)` should return 0.

3. **Consider implementing `IEquatable<T>`**: When implementing `IComparable<T>`, consider also implementing `IEquatable<T>` for consistency.

4. **Handle special values**: Be careful comparing floating-point numbers or special values that might cause unexpected results.

5. **Order matters**: In multiple property comparisons, the order in which you compare properties affects the final sort order.

## Summary

The `IComparable` interface is a powerful tool in C# for enabling custom object comparison and sorting. By implementing this interface, you define the natural order of your objects, allowing them to be sorted using standard collection methods.

Key points to remember:

- `IComparable<T>` is the generic, strongly-typed version which is preferred in modern C#
- The `CompareTo` method returns an integer indicating relative order
- You can use it to define complex sorting rules based on multiple properties
- For alternative sorting strategies, use `IComparer<T>` instead of adding complexity to your `IComparable` implementation

## Exercises

1. Create a `Book` class with properties for `Title`, `Author`, and `PublicationYear`. Implement `IComparable<Book>` to sort books by publication year, and then by title if the years are the same.

2. Implement a `BankAccount` class with properties for `AccountNumber`, `Balance`, and `AccountType`. Make it implement `IComparable<BankAccount>` to sort accounts by balance in descending order.

3. Create a `Student` class with properties for `Name`, `Grade`, and `AttendancePercentage`. Implement `IComparable<Student>` to sort students by grade, but if two students have the same grade, sort by attendance percentage.

## Additional Resources

- [Microsoft Documentation: IComparable Interface](https://docs.microsoft.com/en-us/dotnet/api/system.icomparable)
- [Microsoft Documentation: IComparer Interface](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icomparer-1)
- [C# Guidelines: Implementing Comparison Interfaces](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/implementing-comparison-interfaces)