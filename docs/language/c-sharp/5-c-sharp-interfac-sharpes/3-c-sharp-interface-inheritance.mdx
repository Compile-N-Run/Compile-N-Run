---
title: "C# Interface Inheritance"
description: "Learn how interface inheritance works in C#, how to create and implement interfaces that inherit from other interfaces, and best practices for designing interface hierarchies."

---

# C# Interface Inheritance

## Introduction

Interface inheritance is a powerful concept in C# that allows you to create hierarchies of related interfaces. Just like classes, interfaces can inherit from other interfaces, which enables you to build more specialized interfaces based on more general ones. This feature helps in organizing your code better and designing more flexible and extensible applications.

In this tutorial, we'll explore how interface inheritance works in C#, learn how to create and use interface hierarchies, and see practical examples that demonstrate the benefits of this approach.

## Understanding Interface Inheritance

Interface inheritance follows a simple principle: when an interface inherits from another interface, it includes all the members of the parent interface, plus any additional members it defines itself. Any class that implements a child interface must provide implementations for members from both the child and parent interfaces.

### Basic Syntax

Here's the basic syntax for interface inheritance:

```csharp
public interface IParentInterface
{
    void ParentMethod();
}

public interface IChildInterface : IParentInterface
{
    void ChildMethod();
}
```

In this example, `IChildInterface` inherits from `IParentInterface`. Any class implementing `IChildInterface` must implement both `ParentMethod()` and `ChildMethod()`.

## Interface Inheritance vs. Class Inheritance

Although interface inheritance might look similar to class inheritance, there are important differences:

1. **Multiple Inheritance**: Unlike classes, interfaces can inherit from multiple interfaces.
2. **No Implementation**: Interfaces only define members, not their implementation.
3. **No Constructor Chain**: Interfaces don't have constructors to be called in a chain.

Let's see an example of multiple interface inheritance:

```csharp
public interface IDrawable
{
    void Draw();
}

public interface IResizable
{
    void Resize(int width, int height);
}

public interface IGraphicalComponent : IDrawable, IResizable
{
    void Move(int x, int y);
}
```

A class implementing `IGraphicalComponent` must implement `Draw()`, `Resize()`, and `Move()` methods.

## Implementing Interface Hierarchies

Let's look at a complete example of how to implement interface hierarchies:

```csharp
using System;

// Base interface
public interface IAnimal
{
    string Name { get; set; }
    void Eat();
}

// Derived interface
public interface IMammal : IAnimal
{
    void Breathe();
    int LegCount { get; }
}

// Another derived interface with multiple inheritance
public interface IPet : IAnimal
{
    void Play();
}

// Class implementing a derived interface
public class Dog : IMammal, IPet
{
    public string Name { get; set; }
    public int LegCount => 4;

    public void Eat()
    {
        Console.WriteLine($"{Name} is eating dog food.");
    }

    public void Breathe()
    {
        Console.WriteLine($"{Name} is breathing.");
    }

    public void Play()
    {
        Console.WriteLine($"{Name} is playing fetch!");
    }
    
    public void Bark()
    {
        Console.WriteLine($"{Name} says: Woof!");
    }
}

class Program
{
    static void Main()
    {
        Dog dog = new Dog { Name = "Buddy" };
        
        // All methods are accessible
        dog.Eat();
        dog.Breathe();
        dog.Play();
        dog.Bark();
        
        Console.WriteLine($"{dog.Name} has {dog.LegCount} legs.");
        
        // We can use the dog instance with any of the interfaces it implements
        UseAnimal(dog);
        UseMammal(dog);
        UsePet(dog);
    }
    
    static void UseAnimal(IAnimal animal)
    {
        Console.WriteLine($"Using as animal: {animal.Name}");
        animal.Eat();
    }
    
    static void UseMammal(IMammal mammal)
    {
        Console.WriteLine($"Using as mammal: {mammal.Name}");
        mammal.Breathe();
        Console.WriteLine($"Has {mammal.LegCount} legs.");
    }
    
    static void UsePet(IPet pet)
    {
        Console.WriteLine($"Using as pet: {pet.Name}");
        pet.Play();
    }
}
```

**Output:**
```
Buddy is eating dog food.
Buddy is breathing.
Buddy is playing fetch!
Buddy says: Woof!
Buddy has 4 legs.
Using as animal: Buddy
Buddy is eating dog food.
Using as mammal: Buddy
Buddy is breathing.
Has 4 legs.
Using as pet: Buddy
Buddy is playing fetch!
```

In this example:
1. We have a base interface `IAnimal` with basic animal properties
2. Two interfaces `IMammal` and `IPet` inherit from `IAnimal` and add their own members
3. The `Dog` class implements both `IMammal` and `IPet` interfaces
4. We demonstrate how a `Dog` instance can be used with any of the interfaces it implements

## Real-World Applications

Interface inheritance is commonly used in real-world applications to design flexible and modular systems. Let's look at a practical example: a simplified document management system.

```csharp
using System;
using System.Collections.Generic;

// Document interface hierarchy
public interface IDocument
{
    string Title { get; set; }
    string Content { get; set; }
    DateTime CreatedDate { get; }
}

public interface IEditableDocument : IDocument
{
    void Edit(string newContent);
    List<string> GetRevisionHistory();
}

public interface IPrintableDocument : IDocument
{
    void Print();
    bool SupportsColor { get; }
}

public interface IExportableDocument : IDocument
{
    byte[] ExportToPdf();
    byte[] ExportToWord();
}

// Comprehensive document interface
public interface IOfficeDocument : IEditableDocument, IPrintableDocument, IExportableDocument
{
    string Author { get; set; }
}

// Implementation
public class WordDocument : IOfficeDocument
{
    private List<string> _revisionHistory = new List<string>();
    
    public string Title { get; set; }
    public string Content { get; set; }
    public DateTime CreatedDate { get; private set; }
    public string Author { get; set; }
    public bool SupportsColor => true;
    
    public WordDocument(string title, string author, string initialContent)
    {
        Title = title;
        Author = author;
        Content = initialContent;
        CreatedDate = DateTime.Now;
        _revisionHistory.Add(initialContent);
    }
    
    public void Edit(string newContent)
    {
        Content = newContent;
        _revisionHistory.Add(newContent);
        Console.WriteLine($"Document '{Title}' edited. Revision #{_revisionHistory.Count}");
    }
    
    public List<string> GetRevisionHistory()
    {
        return new List<string>(_revisionHistory);
    }
    
    public void Print()
    {
        Console.WriteLine($"Printing document: {Title}");
        Console.WriteLine($"By: {Author}");
        Console.WriteLine(Content);
    }
    
    public byte[] ExportToPdf()
    {
        Console.WriteLine($"Exporting '{Title}' to PDF format...");
        // Simulated export
        return new byte[100];
    }
    
    public byte[] ExportToWord()
    {
        Console.WriteLine($"Exporting '{Title}' to Word format...");
        // Simulated export
        return new byte[100];
    }
}

class Program
{
    static void Main()
    {
        var document = new WordDocument(
            "Quarterly Report",
            "John Smith",
            "This is the initial draft of the quarterly report."
        );
        
        // Use as an editable document
        document.Edit("This is the revised quarterly report with updated figures.");
        
        // Use as a printable document
        document.Print();
        
        // Use as an exportable document
        document.ExportToPdf();
        
        // Show revision history
        Console.WriteLine("\nRevision History:");
        var history = document.GetRevisionHistory();
        for (int i = 0; i < history.Count; i++)
        {
            Console.WriteLine($"Revision {i+1}: {history[i].Substring(0, Math.Min(20, history[i].Length))}...");
        }
    }
}
```

**Output:**
```
Document 'Quarterly Report' edited. Revision #2
Printing document: Quarterly Report
By: John Smith
This is the revised quarterly report with updated figures.
Exporting 'Quarterly Report' to PDF format...

Revision History:
Revision 1: This is the initial d...
Revision 2: This is the revised q...
```

In this example:
1. We create a hierarchy of document-related interfaces
2. Each interface adds specific functionality (editing, printing, exporting)
3. A comprehensive interface (`IOfficeDocument`) inherits from multiple interfaces
4. The `WordDocument` class implements this comprehensive interface
5. The client code can work with the document at different abstraction levels

## Best Practices for Interface Inheritance

When working with interface inheritance, keep these best practices in mind:

1. **Interface Segregation Principle (ISP)**: Keep interfaces focused and cohesive; clients shouldn't be forced to depend on methods they don't use.

2. **Prefer Composition Over Inheritance**: In many cases, composing multiple small interfaces is better than creating deep inheritance hierarchies.

3. **Avoid Redundancy**: Don't repeat the same members in derived interfaces that are already defined in base interfaces.

4. **Name Consistently**: Use consistent naming conventions (like `I` prefix in C#) for all interfaces.

5. **Design for Extension**: Design interfaces with future extensions in mind.

Let's see an example of good vs. poor interface design:

```csharp
// Poor design - violates Interface Segregation Principle
public interface IVehicleOperations
{
    void Drive();
    void Fly();
    void Float();
    void LoadCargo(int weight);
    int FuelLevel { get; }
    void RefillFuel();
}

// Better design - segregated interfaces
public interface IDriveable
{
    void Drive();
    int WheelCount { get; }
}

public interface IFlyable
{
    void Fly();
    int MaxAltitude { get; }
}

public interface IFloatable
{
    void Float();
    int Displacement { get; }
}

public interface IFuelable
{
    int FuelLevel { get; }
    void RefillFuel();
}

// Combined interface for specific use case
public interface IAmphibiousVehicle : IDriveable, IFloatable, IFuelable
{
    void SwitchMode(string mode);
}
```

In the better design, classes can implement only the interfaces they need, leading to more flexible and maintainable code.

## Summary

Interface inheritance in C# is a powerful mechanism that allows you to:

1. Create hierarchies of related interfaces
2. Build specialized interfaces based on more general ones
3. Implement multiple interface inheritance for more flexibility
4. Design modular systems with clearly defined responsibilities

By using interface inheritance effectively, you can create more maintainable, extensible, and flexible code. Remember to follow the Interface Segregation Principle and keep your interfaces focused and cohesive.

## Exercise Ideas

1. Create an interface hierarchy for a basic media player system with interfaces like `IMediaItem`, `IAudioPlayable`, `IVideoPlayable`, and then implement classes like `AudioFile`, `VideoFile`, and `MultimediaFile`.

2. Design an interface hierarchy for a simple e-commerce system with interfaces for products, services, and payment methods.

3. Refactor an existing codebase to use interface inheritance instead of concrete dependencies.

## Additional Resources

- [Microsoft Docs: Interface Inheritance](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/inheritance)
- [SOLID Principles: Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
- [Design Patterns: Elements of Reusable Object-Oriented Software](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612) (Gang of Four book)

Happy coding with C# interfaces!