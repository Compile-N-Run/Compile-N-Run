---
title: C# Goto Statement
description: Learn about the goto statement in C#, how it works, when to use it (and when not to), with practical examples and best practices.

---

# C# Goto Statement

## Introduction

The `goto` statement is one of the control flow mechanisms available in C#. It allows you to jump to a labeled statement elsewhere in your code, which can change the normal sequence of program execution. While it's one of the most controversial control flow statements in modern programming, understanding how it works is important for C# developers, especially when reading legacy code.

In this tutorial, we'll explore:
- What the `goto` statement is and its syntax
- How to use the `goto` statement properly
- Common use cases and scenarios
- Why many developers avoid using it
- Alternative approaches to achieve the same results

## Basic Syntax and Functionality

The syntax for the `goto` statement in C# consists of two parts:

1. A label declaration (ending with a colon)
2. The `goto` statement that jumps to that label

```csharp
// Syntax
goto LabelName;
// ...
LabelName:
// Code to execute after the goto
```

Here's a simple example demonstrating how the `goto` statement works:

```csharp
using System;

class Program
{
    static void Main()
    {
        Console.WriteLine("Starting the program");
        
        goto JumpHere;
        
        Console.WriteLine("This line will be skipped");
        
        JumpHere:
        Console.WriteLine("Jumped to this line");
        
        Console.WriteLine("End of the program");
    }
}
```

**Output:**
```
Starting the program
Jumped to this line
End of the program
```

Notice how the line "This line will be skipped" is completely bypassed because the `goto` statement changes the flow of execution.

## Using `goto` with Conditional Statements

The `goto` statement is often used with conditional statements to create more complex control flow:

```csharp
using System;

class Program
{
    static void Main()
    {
        Console.Write("Enter a number: ");
        int number = Convert.ToInt32(Console.ReadLine());
        
        if (number > 10)
        {
            goto GreaterThanTen;
        }
        else if (number < 0)
        {
            goto NegativeNumber;
        }
        
        Console.WriteLine("Number is between 0 and 10");
        goto End;
        
        GreaterThanTen:
        Console.WriteLine("Number is greater than 10");
        goto End;
        
        NegativeNumber:
        Console.WriteLine("Number is negative");
        
        End:
        Console.WriteLine("Program complete");
    }
}
```

If you enter "15", the output will be:
```
Enter a number: 15
Number is greater than 10
Program complete
```

## The `goto` Statement in Switch Cases

One of the few places where `goto` is commonly used in modern C# is within `switch` statements, where it can be used to jump between cases:

```csharp
using System;

class Program
{
    static void Main()
    {
        Console.Write("Enter a day number (1-7): ");
        int day = Convert.ToInt32(Console.ReadLine());
        
        switch (day)
        {
            case 1:
                Console.WriteLine("Monday");
                break;
            case 2:
                Console.WriteLine("Tuesday");
                break;
            case 3:
                goto case 1; // This will execute the code for Monday
            case 4:
                Console.WriteLine("Thursday");
                break;
            case 5:
                Console.WriteLine("Friday");
                goto case 7; // After printing "Friday", it will also execute the code for Sunday
            case 6:
                Console.WriteLine("Saturday");
                break;
            case 7:
                Console.WriteLine("Sunday");
                break;
            default:
                Console.WriteLine("Invalid day number");
                break;
        }
    }
}
```

If you enter "3", the output will be:
```
Enter a day number (1-7): 3
Monday
```

If you enter "5", the output will be:
```
Enter a day number (1-7): 5
Friday
Sunday
```

## Use Case: Breaking Out of Nested Loops

One practical use of the `goto` statement is to break out of deeply nested loops when a specific condition is met:

```csharp
using System;

class Program
{
    static void Main()
    {
        int[,] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        // Search for the number 5 in the matrix
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                if (matrix[i, j] == 5)
                {
                    Console.WriteLine($"Found 5 at position [{i}, {j}]");
                    goto FoundNumber;
                }
            }
        }
        
        Console.WriteLine("Number 5 not found");
        
        FoundNumber:
        Console.WriteLine("Search complete");
    }
}
```

**Output:**
```
Found 5 at position [1, 1]
Search complete
```

## Why `goto` is Often Discouraged

Despite its functionality, there are several reasons why the `goto` statement is generally discouraged in modern programming:

1. **Readability Issues**: Code with many `goto` statements can become difficult to follow, creating what's often called "spaghetti code."

2. **Maintenance Problems**: Programs using many `goto` statements can be harder to debug, maintain, and modify.

3. **Structured Programming Principles**: Modern programming emphasizes structured approaches using loops, conditionals, and functions rather than arbitrary jumps.

4. **Better Alternatives**: Most use cases for `goto` can be implemented more clearly using other control structures.

## Alternatives to Using `goto`

For most cases where you might consider using `goto`, there are cleaner alternatives:

### Instead of breaking out of nested loops:

```csharp
using System;

class Program
{
    static void Main()
    {
        int[,] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        bool found = false;
        
        // Search for the number 5 in the matrix
        for (int i = 0; i < 3 && !found; i++)
        {
            for (int j = 0; j < 3 && !found; j++)
            {
                if (matrix[i, j] == 5)
                {
                    Console.WriteLine($"Found 5 at position [{i}, {j}]");
                    found = true;
                }
            }
        }
        
        if (!found)
        {
            Console.WriteLine("Number 5 not found");
        }
        
        Console.WriteLine("Search complete");
    }
}
```

### Refactoring complex logic:

Instead of using multiple `goto` statements for complex logic, consider using:

- Methods or functions to encapsulate logic
- More descriptive if-else structures
- Early returns from methods
- State machines for complex state transitions

## Practical Example: Error Handling in Resource Management

One legitimate use of `goto` can be in resource management with multiple cleanup steps:

```csharp
using System;
using System.IO;

class Program
{
    static void ProcessFile(string path)
    {
        // Resource declarations
        FileStream fileStream = null;
        StreamReader reader = null;
        
        try
        {
            fileStream = new FileStream(path, FileMode.Open);
            if (fileStream.Length == 0)
            {
                Console.WriteLine("File is empty");
                goto CleanupFileStream;
            }
            
            reader = new StreamReader(fileStream);
            string content = reader.ReadToEnd();
            
            if (string.IsNullOrWhiteSpace(content))
            {
                Console.WriteLine("File contains only whitespace");
                goto CleanupAll;
            }
            
            // Process the content
            Console.WriteLine($"File contents: {content}");
            
            CleanupAll:
            if (reader != null)
            {
                reader.Close();
            }
            
            CleanupFileStream:
            if (fileStream != null)
            {
                fileStream.Close();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
            goto CleanupAll;
        }
    }
    
    static void Main()
    {
        ProcessFile("sample.txt");
    }
}
```

However, in modern C#, this is better handled using the `using` statement or try-finally blocks.

## Summary

The `goto` statement in C# provides a way to jump to labeled sections of code. While it has legitimate uses, particularly in switch statements and occasionally for breaking out of deeply nested structures, it's generally recommended to use other control flow mechanisms for most scenarios.

Key takeaways:

- The `goto` statement allows you to jump to a labeled statement elsewhere in your code
- It's commonly used in `switch` statements to jump between cases
- It can be useful for breaking out of deeply nested loops
- In most cases, structured programming alternatives provide clearer, more maintainable code
- Many developers avoid using `goto` due to readability and maintenance concerns

## Practice Exercises

1. Write a program that uses `goto` to implement a simple menu system where users can select from different options.

2. Refactor an existing program that uses `goto` statements to use structured programming constructs instead.

3. Implement a state machine using both `goto` statements and an alternative approach. Compare the readability and maintainability of both versions.

## Additional Resources

- [Microsoft Docs: goto Statement (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/jump-statements#the-goto-statement)
- [Structured Programming Principles](https://en.wikipedia.org/wiki/Structured_programming)
- [C# Corner: Understanding goto Statement in C#](https://www.c-sharpcorner.com/article/understanding-goto-statement-in-C-Sharp/)

Remember, understanding how `goto` works is valuable for reading existing code and specific edge cases, but for new code development, it's generally better to use more structured approaches to control flow.