---
title: "C# Break Continue"
description: "Learn how to control loop execution flow in C# with the break and continue statements. Discover when to use them and how they can make your code more efficient."

---

# C# Break and Continue

When working with loops in C#, there will be times when you want to either exit a loop early or skip some iterations. This is where the `break` and `continue` statements come in handy. These powerful keywords give you finer control over your loops and can make your code more efficient.

## What are Break and Continue?

- **Break**: Immediately exits the current loop or switch statement.
- **Continue**: Skips the current iteration of a loop and proceeds to the next iteration.

Let's dive deeper and see how these statements work in practice.

## The Break Statement

The `break` statement allows you to exit a loop immediately, regardless of whether the loop's condition has been met or not.

### Basic Syntax

```csharp
for (int i = 0; i < 10; i++)
{
    if (someCondition)
    {
        break; // Exit the loop immediately
    }
    // Rest of the loop code
}
// Execution continues here after break
```

### Example 1: Finding a Number in an Array

```csharp
int[] numbers = { 1, 3, 5, 7, 9, 11, 13 };
int searchTarget = 7;
bool found = false;

for (int i = 0; i < numbers.Length; i++)
{
    if (numbers[i] == searchTarget)
    {
        Console.WriteLine($"Found {searchTarget} at position {i}");
        found = true;
        break; // No need to check the rest of the array
    }
}

if (!found)
{
    Console.WriteLine($"{searchTarget} not found in the array");
}
```

**Output:**
```
Found 7 at position 3
```

In this example, once we find the number we're looking for, there's no need to continue checking the rest of the array. The `break` statement helps us exit the loop early, making our code more efficient.

### Example 2: Menu System

```csharp
bool exitProgram = false;

while (!exitProgram)
{
    Console.WriteLine("\nMenu Options:");
    Console.WriteLine("1. View Data");
    Console.WriteLine("2. Add New Entry");
    Console.WriteLine("3. Delete Entry");
    Console.WriteLine("4. Exit Program");
    Console.Write("Enter your choice: ");
    
    string input = Console.ReadLine();
    
    switch (input)
    {
        case "1":
            Console.WriteLine("Viewing data...");
            break;  // Exits the switch (not the while loop)
            
        case "2":
            Console.WriteLine("Adding new entry...");
            break;  // Exits the switch (not the while loop)
            
        case "3":
            Console.WriteLine("Deleting entry...");
            break;  // Exits the switch (not the while loop)
            
        case "4":
            Console.WriteLine("Exiting program...");
            exitProgram = true;  // This will cause the while loop to exit
            break;  // Exits the switch
            
        default:
            Console.WriteLine("Invalid option. Please try again.");
            break;  // Exits the switch (not the while loop)
    }
}
```

This example shows how `break` is used in a `switch` statement within a loop. Each `case` uses `break` to exit the `switch` statement, but the program only exits the `while` loop when the user selects option 4.

## The Continue Statement

The `continue` statement skips the current iteration of a loop and moves directly to the next iteration. Unlike `break`, it doesn't exit the loop entirely.

### Basic Syntax

```csharp
for (int i = 0; i < 10; i++)
{
    if (someCondition)
    {
        continue; // Skip the rest of this iteration
    }
    // This code is skipped if continue is executed
}
```

### Example 1: Processing Only Even Numbers

```csharp
for (int i = 1; i <= 10; i++)
{
    // Skip odd numbers
    if (i % 2 != 0)
    {
        continue;
    }
    
    Console.WriteLine($"Processing even number: {i}");
    // More processing code would go here
}
```

**Output:**
```
Processing even number: 2
Processing even number: 4
Processing even number: 6
Processing even number: 8
Processing even number: 10
```

In this example, we're only interested in processing even numbers. When we encounter an odd number, we use `continue` to skip to the next iteration without executing the rest of the loop body.

### Example 2: Filtering User Input

```csharp
List<int> validScores = new List<int>();
Console.WriteLine("Enter student test scores (0-100) or -1 to finish:");

while (true)
{
    Console.Write("Score: ");
    if (!int.TryParse(Console.ReadLine(), out int score))
    {
        Console.WriteLine("Invalid input. Please enter a number.");
        continue;  // Skip to the next iteration
    }
    
    if (score == -1)
    {
        break;  // Exit the loop when user enters -1
    }
    
    if (score < 0 || score > 100)
    {
        Console.WriteLine("Score must be between 0 and 100.");
        continue;  // Skip invalid scores
    }
    
    // If we get here, the score is valid
    validScores.Add(score);
    Console.WriteLine($"Added score: {score}");
}

Console.WriteLine($"You entered {validScores.Count} valid scores.");
```

This example demonstrates how to use `continue` to handle invalid inputs without exiting the entire input collection process. It also shows how to combine `break` and `continue` in the same loop.

## Common Gotchas with Break and Continue

### 1. Watch Out for Infinite Loops

```csharp
int i = 0;
while (i < 10)
{
    if (i == 5)
    {
        continue;  // DANGER: This creates an infinite loop!
    }
    Console.WriteLine(i);
    i++;
}
```

In this example, when `i` equals 5, the `continue` statement skips the increment operation, so `i` stays at 5 forever, creating an infinite loop.

### 2. Nested Loops

```csharp
for (int i = 0; i < 3; i++)
{
    Console.WriteLine($"Outer loop i = {i}");
    
    for (int j = 0; j < 3; j++)
    {
        if (i == 1 && j == 1)
        {
            break;  // This only breaks out of the inner loop
        }
        Console.WriteLine($"  Inner loop j = {j}");
    }
}
```

**Output:**
```
Outer loop i = 0
  Inner loop j = 0
  Inner loop j = 1
  Inner loop j = 2
Outer loop i = 1
  Inner loop j = 0
Outer loop i = 2
  Inner loop j = 0
  Inner loop j = 1
  Inner loop j = 2
```

The `break` statement only exits the innermost loop that contains it. If you need to exit multiple nested loops, you'll need a different approach (like using a flag variable or encapsulating the loops in a method that you can return from).

## Real-World Applications

### 1. Input Validation

```csharp
public static int GetValidAge()
{
    while (true)
    {
        Console.Write("Please enter your age (18-100): ");
        if (int.TryParse(Console.ReadLine(), out int age))
        {
            if (age >= 18 && age <= 100)
            {
                return age;  // Valid input, return the age
            }
            else
            {
                Console.WriteLine("Age must be between 18 and 100.");
                continue;  // Skip to the next iteration
            }
        }
        else
        {
            Console.WriteLine("Invalid input. Please enter a number.");
            // continue is implied here (at the end of the loop)
        }
    }
}
```

This method uses an infinite loop with `continue` and an early return (which acts like a `break`) to ensure we get valid input from the user.

### 2. Processing Files with Exception Handling

```csharp
string[] filePaths = { "file1.txt", "file2.txt", "file3.txt" };

foreach (string path in filePaths)
{
    try
    {
        Console.WriteLine($"Processing file {path}...");
        
        // Check if file exists
        if (!File.Exists(path))
        {
            Console.WriteLine($"File {path} not found. Skipping.");
            continue;  // Skip to the next file
        }
        
        // Read and process the file
        string content = File.ReadAllText(path);
        Console.WriteLine($"File {path} processed successfully.");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error processing file {path}: {ex.Message}");
        // Decide whether to continue or break based on the error
        continue;  // Try the next file despite the error
    }
}

Console.WriteLine("All files processed.");
```

This example shows how to use `continue` in combination with exception handling to process multiple files, skipping any files that can't be processed correctly.

## Summary

- The `break` statement exits a loop or switch statement completely.
- The `continue` statement skips the current iteration and moves to the next one.
- Use `break` when you find what you're looking for or need to exit a loop early.
- Use `continue` when you want to skip certain iterations based on specific conditions.
- Be careful not to create infinite loops when using `continue`.
- Remember that `break` and `continue` only affect the innermost loop they are directly contained in.

These statements give you fine-grained control over your loop execution and can make your code more efficient and readable when used correctly.

## Exercises

1. Write a program that prints all numbers from 1 to 20, but skips multiples of 3.
2. Create a guessing game where the user has to guess a number between 1 and 100. Use `break` to exit when they guess correctly.
3. Write a program that reads a list of numbers and finds the first prime number larger than 20.
4. Implement a simple calculator program with a menu system. Use `break` and `continue` for input validation and program flow control.

## Additional Resources

- [Microsoft Documentation on Jump Statements](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/jump-statements)
- [C# Control Flow in Depth](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/statements)
- [Efficient Loop Processing Techniques](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/standard-query-operators-overview)