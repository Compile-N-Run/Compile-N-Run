---
title: "C# Namespaces"
description: "Learn about C# namespaces, how they organize code, prevent naming conflicts, and how to use them effectively in your C# programs."

---

# C# Namespaces

## Introduction

Namespaces are a fundamental concept in C# that help you organize your code and avoid naming conflicts. Think of namespaces as containers or "folders" for your code elements like classes, interfaces, and structs. Just as your computer's file system organizes files into folders to keep related items together, C# uses namespaces to organize related code elements.

In this tutorial, we'll learn why namespaces are important, how to create and use them, and common practices for namespace organization.

## Why Use Namespaces?

Namespaces solve two major problems:

1. **Organization** - They group related code elements together
2. **Name Collision Prevention** - They prevent naming conflicts between classes with the same name

For example, you might have two classes named `Logger` - one for console logging and another for file logging. Without namespaces, C# wouldn't know which `Logger` you're referring to. By placing them in different namespaces like `ConsoleUtils.Logger` and `FileUtils.Logger`, you can distinguish between them.

## Declaring and Using Namespaces

### Declaring a Namespace

To create a namespace, use the `namespace` keyword followed by the namespace name and a code block containing your classes:

```csharp
namespace MyCompany.MyProject
{
    public class MyClass
    {
        public void SayHello()
        {
            Console.WriteLine("Hello from MyClass!");
        }
    }
}
```

### Accessing Classes with Fully Qualified Names

You can access classes from other namespaces using their fully qualified name:

```csharp
class Program
{
    static void Main(string[] args)
    {
        // Using fully qualified name
        MyCompany.MyProject.MyClass myObject = new MyCompany.MyProject.MyClass();
        myObject.SayHello(); // Output: Hello from MyClass!
    }
}
```

### The using Directive

Writing fully qualified names can be cumbersome. The `using` directive allows you to use types from a namespace without specifying the full namespace path:

```csharp
using MyCompany.MyProject;

class Program
{
    static void Main(string[] args)
    {
        // After "using" directive, we can use the class directly
        MyClass myObject = new MyClass();
        myObject.SayHello(); // Output: Hello from MyClass!
    }
}
```

## Nested Namespaces

You can nest namespaces inside one another to create a hierarchical organization:

```csharp
namespace MyCompany
{
    namespace MyProject
    {
        public class MyClass
        {
            // class implementation
        }
    }
}
```

This is equivalent to the dot notation we saw earlier:

```csharp
namespace MyCompany.MyProject
{
    public class MyClass
    {
        // class implementation
    }
}
```

## Namespace Alias

If two namespaces contain classes with the same name, you can create an alias to avoid ambiguity:

```csharp
using ConsoleLog = ConsoleUtils.Logger;
using FileLog = FileUtils.Logger;

class Program
{
    static void Main(string[] args)
    {
        ConsoleLog consoleLogger = new ConsoleLog();
        FileLog fileLogger = new FileLog();
        
        consoleLogger.Log("Using console logger");  // Uses ConsoleUtils.Logger
        fileLogger.Log("Using file logger");        // Uses FileUtils.Logger
    }
}
```

## Global Namespace

If you don't specify a namespace, your types are placed in the global namespace. This is generally not recommended for anything beyond small programs as it can lead to naming conflicts.

```csharp
// No namespace declaration - this class is in the global namespace
public class GlobalClass
{
    // class implementation
}
```

## The global::Alias

Sometimes you need to explicitly refer to something in the global namespace. The `global::` alias lets you do this:

```csharp
namespace System
{
    class Program
    {
        static void Main()
        {
            // This refers to the String class in the System namespace
            String systemString = "Hello";
            
            // This refers to the String class in the global namespace
            global::System.String globalString = "World";
        }
    }
}
```

## Best Practices for Namespaces

1. **Use a hierarchical naming convention** - A common pattern is `CompanyName.TechnologyName.Feature`
2. **Keep related types in the same namespace**
3. **Use PascalCase for namespace names**
4. **Avoid extremely deep namespace hierarchies** - They can become unwieldy
5. **Organize namespaces to match your project structure**

## File Scoped Namespaces (C# 10 and later)

Starting with C# 10, you can use file-scoped namespaces which use less indentation:

```csharp
// Traditional namespace declaration
namespace MyCompany.MyProject
{
    public class MyClass
    {
        // class implementation
    }
}

// C# 10 file-scoped namespace (no brackets, applies to entire file)
namespace MyCompany.MyProject;

public class MyClass
{
    // class implementation
}
```

## Practical Examples

### Example 1: Organizing a Library Management System

```csharp
namespace LibrarySystem.Models
{
    public class Book
    {
        public string Title { get; set; }
        public string Author { get; set; }
        public string ISBN { get; set; }
    }
    
    public class Member
    {
        public string Name { get; set; }
        public int MemberId { get; set; }
    }
}

namespace LibrarySystem.Services
{
    using LibrarySystem.Models;
    
    public class BookService
    {
        public void AddBook(Book book)
        {
            Console.WriteLine($"Added book: {book.Title} by {book.Author}");
            // Database code to add book would go here
        }
    }
    
    public class MemberService
    {
        public void RegisterMember(Member member)
        {
            Console.WriteLine($"Registered member: {member.Name} with ID {member.MemberId}");
            // Database code to register member would go here
        }
    }
}

// In the main program file
using LibrarySystem.Models;
using LibrarySystem.Services;

class Program
{
    static void Main(string[] args)
    {
        // Create a new book
        Book csharpBook = new Book
        {
            Title = "C# Programming",
            Author = "John Doe",
            ISBN = "123-456-789"
        };
        
        // Create a new member
        Member newMember = new Member
        {
            Name = "Jane Smith",
            MemberId = 12345
        };
        
        // Use the services
        BookService bookService = new BookService();
        MemberService memberService = new MemberService();
        
        bookService.AddBook(csharpBook);
        memberService.RegisterMember(newMember);
        
        // Output:
        // Added book: C# Programming by John Doe
        // Registered member: Jane Smith with ID 12345
    }
}
```

### Example 2: Resolving Name Conflicts Between Namespaces

```csharp
namespace DataProcessing
{
    public class Logger
    {
        public void Log(string message)
        {
            Console.WriteLine($"Data Processing: {message}");
        }
    }
}

namespace UserInterface
{
    public class Logger
    {
        public void Log(string message)
        {
            Console.WriteLine($"UI: {message}");
        }
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Use fully qualified names
        DataProcessing.Logger dataLogger = new DataProcessing.Logger();
        UserInterface.Logger uiLogger = new UserInterface.Logger();
        
        dataLogger.Log("Processing data...");
        uiLogger.Log("Updating interface...");
        
        // Output:
        // Data Processing: Processing data...
        // UI: Updating interface...
        
        // Alternatively, use namespace aliases
        using DPLogger = DataProcessing.Logger;
        using UILogger = UserInterface.Logger;
        
        DPLogger dataLogger2 = new DPLogger();
        UILogger uiLogger2 = new UILogger();
        
        dataLogger2.Log("Using alias");
        uiLogger2.Log("Using alias too");
        
        // Output:
        // Data Processing: Using alias
        // UI: Using alias too
    }
}
```

## Summary

Namespaces are an essential part of organizing C# code. They allow you to:

- Group related classes and types together
- Prevent naming conflicts between different parts of your code
- Create a logical hierarchy for your application's components

Understanding namespaces is fundamental to working effectively with C# and .NET. As your projects grow in size and complexity, good namespace organization becomes increasingly important for maintaining clean, readable, and well-structured code.

## Exercises

1. Create a console application with at least two different namespaces containing classes with the same name. Write code that uses both classes.

2. Design a namespace hierarchy for a hypothetical e-commerce application. Think about different modules like user management, product catalog, order processing, etc.

3. Take an existing project and reorganize its classes into a more logical namespace hierarchy.

4. Research and explore the namespaces in the .NET Framework. How are they organized? What patterns do you notice?

## Additional Resources

- [Microsoft Docs: Namespaces](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/namespaces/)
- [C# Corner: Namespaces in C#](https://www.c-sharpcorner.com/article/namespaces-in-C-Sharp/)
- [File Scoped Namespaces in C# 10](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#file-scoped-namespace-declaration)