---
title: C# Data Adapters
description: Learn how to use C# Data Adapters to act as a bridge between your DataSets and data sources, managing connections and executing commands efficiently.

---

# C# Data Adapters

Data adapters are a crucial component in ADO.NET that act as a bridge between your application and the database. They provide a way to retrieve and manipulate data without maintaining an active connection to the database. In this tutorial, we'll explore how data adapters work in C# and how you can use them effectively for database operations.

## What Are Data Adapters?

A data adapter is an object that connects a DataSet (an in-memory cache of data) to a data source like a database. It contains a set of commands and a database connection that are used to:

- Fill a DataSet with data from a database
- Update the database with changes made to the DataSet
- Manage connections automatically (opening and closing them as needed)

Data adapters are particularly useful for disconnected operations where you want to retrieve data, work with it in memory, and then update the database only when necessary.

## Common Data Adapter Classes in ADO.NET

ADO.NET provides different data adapter classes for different database providers:

- `SqlDataAdapter`: For SQL Server databases
- `OleDbDataAdapter`: For databases with OLE DB providers
- `OdbcDataAdapter`: For databases with ODBC drivers
- `MySqlDataAdapter`: For MySQL databases (requires MySQL connector)

## Basic Usage of a Data Adapter

Let's create a simple example of using a `SqlDataAdapter` to fill a DataSet with data from a SQL Server database:

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

public class DataAdapterExample
{
    public static void Main()
    {
        // Connection string
        string connectionString = "Data Source=ServerName;Initial Catalog=DatabaseName;Integrated Security=True";
        
        // SQL query
        string query = "SELECT * FROM Customers";
        
        // Create a DataSet to hold the data
        DataSet customersDataSet = new DataSet();
        
        try
        {
            // Create the SqlDataAdapter
            using (SqlDataAdapter adapter = new SqlDataAdapter(query, connectionString))
            {
                // Fill the DataSet with data from the database
                adapter.Fill(customersDataSet, "Customers");
                
                // Now we have the data in memory, disconnected from the database
                Console.WriteLine($"Retrieved {customersDataSet.Tables["Customers"].Rows.Count} customers");
                
                // Display the customer data
                foreach (DataRow row in customersDataSet.Tables["Customers"].Rows)
                {
                    Console.WriteLine($"ID: {row["CustomerID"]}, Name: {row["CompanyName"]}");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}
```

**Output**:
```
Retrieved 91 customers
ID: ALFKI, Name: Alfreds Futterkiste
ID: ANATR, Name: Ana Trujillo Emparedados y helados
ID: ANTON, Name: Antonio Moreno Taquer√≠a
...and so on
```

In this example:
1. We created a connection string and defined a SQL query
2. We initialized a DataSet to store our data
3. We created a `SqlDataAdapter` with our query and connection string
4. We used the adapter's `Fill()` method to populate the DataSet
5. We accessed and displayed the data from the DataSet

Note that the adapter automatically opened the connection, executed the query, filled the DataSet, and then closed the connection.

## Setting Up Command Objects

One of the powerful features of data adapters is the ability to set up different SQL commands for different operations. Each data adapter has four command properties:

- `SelectCommand`: Retrieves data from the database
- `InsertCommand`: Adds new records
- `UpdateCommand`: Modifies existing records
- `DeleteCommand`: Removes records

Here's how to set up these commands:

```csharp
// Create connection and adapter
SqlConnection connection = new SqlConnection(connectionString);
SqlDataAdapter adapter = new SqlDataAdapter();

// Set up SelectCommand
adapter.SelectCommand = new SqlCommand("SELECT * FROM Products", connection);

// Set up InsertCommand
adapter.InsertCommand = new SqlCommand(
    "INSERT INTO Products (ProductName, UnitPrice) VALUES (@Name, @Price)", 
    connection);
adapter.InsertCommand.Parameters.Add("@Name", SqlDbType.NVarChar, 40, "ProductName");
adapter.InsertCommand.Parameters.Add("@Price", SqlDbType.Money, 8, "UnitPrice");

// Set up UpdateCommand
adapter.UpdateCommand = new SqlCommand(
    "UPDATE Products SET ProductName = @Name, UnitPrice = @Price " +
    "WHERE ProductID = @ID", 
    connection);
adapter.UpdateCommand.Parameters.Add("@Name", SqlDbType.NVarChar, 40, "ProductName");
adapter.UpdateCommand.Parameters.Add("@Price", SqlDbType.Money, 8, "UnitPrice");
adapter.UpdateCommand.Parameters.Add("@ID", SqlDbType.Int, 4, "ProductID");

// Set up DeleteCommand
adapter.DeleteCommand = new SqlCommand(
    "DELETE FROM Products WHERE ProductID = @ID", 
    connection);
adapter.DeleteCommand.Parameters.Add("@ID", SqlDbType.Int, 4, "ProductID");
```

## Updating the Database with Data Adapters

Once you've made changes to your DataSet, you can use the data adapter to update the database:

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

public class DataAdapterUpdateExample
{
    public static void Main()
    {
        string connectionString = "Data Source=ServerName;Initial Catalog=DatabaseName;Integrated Security=True";
        
        // Create DataSet and adapter
        DataSet productsDataSet = new DataSet();
        SqlDataAdapter adapter = new SqlDataAdapter("SELECT * FROM Products", connectionString);
        
        try
        {
            // Configure the command builder to auto-generate commands
            SqlCommandBuilder commandBuilder = new SqlCommandBuilder(adapter);
            
            // Fill the DataSet
            adapter.Fill(productsDataSet, "Products");
            
            // Make changes to the DataSet
            DataTable productsTable = productsDataSet.Tables["Products"];
            
            // Add a new product
            DataRow newRow = productsTable.NewRow();
            newRow["ProductName"] = "New Product";
            newRow["UnitPrice"] = 19.99;
            newRow["UnitsInStock"] = 50;
            productsTable.Rows.Add(newRow);
            
            // Update an existing product
            productsTable.Rows[0]["UnitPrice"] = Convert.ToDecimal(productsTable.Rows[0]["UnitPrice"]) + 1;
            
            // Update the database with our changes
            int rowsAffected = adapter.Update(productsDataSet, "Products");
            
            Console.WriteLine($"Updated {rowsAffected} rows in the database.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error: {ex.Message}");
        }
    }
}
```

**Output**:
```
Updated 2 rows in the database.
```

In this example:
1. We created a DataSet and filled it using the adapter
2. We created a `SqlCommandBuilder` to automatically generate the Insert, Update, and Delete commands
3. We made changes to the DataSet (adding a new row and modifying an existing one)
4. We called the adapter's `Update()` method to synchronize the changes with the database

## CommandBuilder for Automatic Command Generation

As you saw in the previous example, instead of manually creating all command objects, you can use a `CommandBuilder`:

```csharp
// Create adapter with select command
SqlDataAdapter adapter = new SqlDataAdapter("SELECT * FROM Products", connectionString);

// Create command builder to auto-generate the other commands
SqlCommandBuilder builder = new SqlCommandBuilder(adapter);

// Now the adapter has automatically generated InsertCommand, UpdateCommand, and DeleteCommand
```

A `CommandBuilder` automatically creates the insert, update, and delete commands based on your select command. While convenient, this approach has limitations:

- It requires that your select query references only one table
- The table must have a primary key
- Your select query must include all primary key columns

## Working with Stored Procedures

Data adapters can also work with stored procedures:

```csharp
string connectionString = "Data Source=ServerName;Initial Catalog=DatabaseName;Integrated Security=True";
SqlConnection connection = new SqlConnection(connectionString);

// Create adapter with a stored procedure for SelectCommand
SqlDataAdapter adapter = new SqlDataAdapter();
adapter.SelectCommand = new SqlCommand("GetCustomersByCountry", connection);
adapter.SelectCommand.CommandType = CommandType.StoredProcedure;
adapter.SelectCommand.Parameters.Add("@Country", SqlDbType.NVarChar, 15).Value = "USA";

// Fill the DataSet
DataSet customersDataSet = new DataSet();
adapter.Fill(customersDataSet, "Customers");

// Display results
foreach (DataRow row in customersDataSet.Tables["Customers"].Rows)
{
    Console.WriteLine($"{row["CustomerID"]}: {row["CompanyName"]}");
}
```

## Real-World Example: Customer Order Management

Let's build a more comprehensive example of using data adapters in a customer order management scenario:

```csharp
using System;
using System.Data;
using System.Data.SqlClient;

public class OrderManagementSystem
{
    private string connectionString;
    private SqlDataAdapter customersAdapter;
    private SqlDataAdapter ordersAdapter;
    private DataSet dataSet;
    
    public OrderManagementSystem(string connString)
    {
        connectionString = connString;
        dataSet = new DataSet("OrdersDB");
        InitializeAdapters();
    }
    
    private void InitializeAdapters()
    {
        // Set up customers adapter
        customersAdapter = new SqlDataAdapter(
            "SELECT CustomerID, CompanyName, ContactName, Phone FROM Customers", 
            connectionString);
            
        SqlCommandBuilder customersCmdBuilder = new SqlCommandBuilder(customersAdapter);
        
        // Set up orders adapter with relation to customers
        ordersAdapter = new SqlDataAdapter(
            "SELECT OrderID, CustomerID, OrderDate, ShippedDate, Freight FROM Orders",
            connectionString);
            
        SqlCommandBuilder ordersCmdBuilder = new SqlCommandBuilder(ordersAdapter);
    }
    
    public void LoadData()
    {
        // Fill the DataSet with both tables
        customersAdapter.Fill(dataSet, "Customers");
        ordersAdapter.Fill(dataSet, "Orders");
        
        // Create a relation between the tables
        DataRelation relation = dataSet.Relations.Add("CustomerOrders",
            dataSet.Tables["Customers"].Columns["CustomerID"],
            dataSet.Tables["Orders"].Columns["CustomerID"]);
            
        Console.WriteLine($"Loaded {dataSet.Tables["Customers"].Rows.Count} customers");
        Console.WriteLine($"Loaded {dataSet.Tables["Orders"].Rows.Count} orders");
    }
    
    public void DisplayCustomerOrders(string customerId)
    {
        // Find the customer
        DataRow customerRow = dataSet.Tables["Customers"].Rows.Find(customerId);
        
        if (customerRow == null)
        {
            Console.WriteLine($"Customer {customerId} not found.");
            return;
        }
        
        Console.WriteLine($"Customer: {customerRow["CompanyName"]}");
        Console.WriteLine($"Contact: {customerRow["ContactName"]}");
        Console.WriteLine("Orders:");
        
        // Get related orders using the relation
        DataRow[] orderRows = customerRow.GetChildRows("CustomerOrders");
        
        foreach (DataRow orderRow in orderRows)
        {
            Console.WriteLine($"  Order ID: {orderRow["OrderID"]}, " +
                              $"Date: {orderRow["OrderDate"]}, " +
                              $"Shipped: {orderRow["ShippedDate"]}, " +
                              $"Freight: ${orderRow["Freight"]}");
        }
    }
    
    public void AddOrder(string customerId, DateTime orderDate)
    {
        // Create a new order row
        DataRow newOrder = dataSet.Tables["Orders"].NewRow();
        newOrder["CustomerID"] = customerId;
        newOrder["OrderDate"] = orderDate;
        newOrder["Freight"] = 0;
        
        // Add the row to the Orders table
        dataSet.Tables["Orders"].Rows.Add(newOrder);
        
        Console.WriteLine("Order added to DataSet (not yet saved to database).");
    }
    
    public void SaveChanges()
    {
        // Update both tables
        int customerChanges = customersAdapter.Update(dataSet, "Customers");
        int orderChanges = ordersAdapter.Update(dataSet, "Orders");
        
        Console.WriteLine($"Saved {customerChanges} customer changes and {orderChanges} order changes.");
    }
    
    public static void Main()
    {
        string connectionString = "Data Source=ServerName;Initial Catalog=Northwind;Integrated Security=True";
        
        OrderManagementSystem oms = new OrderManagementSystem(connectionString);
        oms.LoadData();
        
        // Display orders for a specific customer
        oms.DisplayCustomerOrders("ALFKI");
        
        // Add a new order
        oms.AddOrder("ALFKI", DateTime.Now);
        
        // Save changes to database
        oms.SaveChanges();
    }
}
```

**Output**:
```
Loaded 91 customers
Loaded 830 orders
Customer: Alfreds Futterkiste
Contact: Maria Anders
Orders:
  Order ID: 10643, Date: 8/25/1997, Shipped: 9/2/1997, Freight: $29.46
  Order ID: 10692, Date: 10/3/1997, Shipped: 10/13/1997, Freight: $61.02
  Order ID: 10702, Date: 10/13/1997, Shipped: 10/21/1997, Freight: $23.94
  Order ID: 10835, Date: 1/15/1998, Shipped: 1/21/1998, Freight: $69.53
  Order ID: 10952, Date: 3/16/1998, Shipped: 3/24/1998, Freight: $40.42
  Order ID: 11011, Date: 4/9/1998, Shipped: 4/13/1998, Freight: $1.21
Order added to DataSet (not yet saved to database).
Saved 0 customer changes and 1 order changes.
```

This comprehensive example demonstrates:

1. Setting up multiple data adapters for different tables
2. Creating relationships between DataSet tables
3. Adding new records to the DataSet
4. Navigating between related tables
5. Saving changes back to the database

## Best Practices for Using Data Adapters

To get the most out of data adapters, follow these best practices:

1. **Use parameters for all variable inputs**: Always use parameterized commands to prevent SQL injection and improve performance.

2. **Explicitly open and close connections for large operations**:
   ```csharp
   adapter.SelectCommand.Connection.Open();
   adapter.Fill(dataSet, "LargeTable");
   adapter.SelectCommand.Connection.Close();
   ```

3. **Set appropriate batch sizes**: For large updates, you can control performance with batch sizes:
   ```csharp
   adapter.UpdateBatchSize = 100; // Update 100 rows at a time
   ```

4. **Handle concurrency conflicts**: Use optimistic concurrency with timestamps or version columns:
   ```csharp
   adapter.UpdateCommand.Parameters.Add("@original_LastModified", SqlDbType.DateTime).SourceVersion = DataRowVersion.Original;
   ```

5. **Dispose adapters and connections properly**: Use `using` statements or explicitly call `Dispose()`.

6. **Consider using transactions for multi-table updates**:
   ```csharp
   using (SqlTransaction transaction = connection.BeginTransaction())
   {
       adapter.SelectCommand.Transaction = transaction;
       adapter.InsertCommand.Transaction = transaction;
       adapter.UpdateCommand.Transaction = transaction;
       adapter.DeleteCommand.Transaction = transaction;
       
       try
       {
           adapter.Update(dataSet, "Table");
           transaction.Commit();
       }
       catch
       {
           transaction.Rollback();
           throw;
       }
   }
   ```

## When to Use Data Adapters vs. DataReaders

Data adapters are ideal when:
- You need a disconnected architecture
- You want to cache and manipulate data in memory before saving changes
- You need to bind data to UI controls

DataReaders are better when:
- You need forward-only, read-only access to data
- Performance and memory usage are critical concerns
- You're processing large amounts of data sequentially

## Summary

Data adapters serve as a crucial bridge between your application and databases in ADO.NET. They provide a flexible way to work with data in a disconnected fashion, which is especially important for applications where database connections are expensive or limited.

Key points to remember:
- Data adapters connect DataSets to data sources
- They manage connections automatically (opening/closing as needed)
- They provide commands for selecting, inserting, updating, and deleting data
- Command builders can auto-generate SQL commands
- Data adapters support working with multiple tables and relationships

By mastering data adapters, you'll be able to create efficient, scalable database applications that manage connections wisely and provide a great user experience.

## Exercises

1. Create a simple application that uses a data adapter to display a list of products from a database, allows editing the prices, and saves changes back to the database.

2. Extend the previous application to support adding new products and deleting existing ones.

3. Build a master-detail view application using two data adapters and a relation between tables (e.g., Categories and Products).

4. Create a batch processing application that updates multiple records with a single data adapter operation, controlling the batch size.

5. Implement optimistic concurrency in a data adapter scenario to handle potential conflicts when multiple users edit the same data.

## Additional Resources

- [Microsoft Documentation on Data Adapters](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/dataadapters-and-datareaders)
- [ADO.NET Architecture](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ado-net-architecture)
- [Working with DataSets in ADO.NET](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/dataset-datatable-dataview/)
- [Handling ADO.NET Concurrency](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/optimistic-concurrency)