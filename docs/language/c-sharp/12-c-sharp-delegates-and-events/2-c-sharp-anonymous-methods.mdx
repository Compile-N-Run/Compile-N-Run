---
title: C# Anonymous Methods
description: Learn about C# anonymous methods, their syntax, usage patterns, advantages, and real-world applications within the delegates and events ecosystem.

---

# C# Anonymous Methods

## Introduction

Anonymous methods in C# provide a way to create inline method definitions that can be passed around as delegate instances without formally declaring a separate method. Introduced in C# 2.0, anonymous methods simplify code by allowing you to write delegate implementations directly at the point where they're needed, reducing code verbosity and improving readability.

Before diving into anonymous methods, you should be familiar with the concept of delegates in C#, as anonymous methods are essentially a shorthand syntax for creating delegate instances.

## Understanding Anonymous Methods

### Basic Syntax

An anonymous method is declared using the `delegate` keyword followed by a parameter list and a method body:

```csharp
delegate (parameters) { method_body }
```

This anonymous method can be assigned to any compatible delegate type.

### Simple Example

Here's a basic example showing how to use an anonymous method with a delegate:

```csharp
// Declare a delegate type
delegate void PrintDelegate(string message);

// Create an instance using an anonymous method
PrintDelegate printer = delegate(string message)
{
    Console.WriteLine("Message: " + message);
};

// Invoke the delegate
printer("Hello from anonymous method!");
```

**Output:**
```
Message: Hello from anonymous method!
```

In this example, instead of creating a separate named method and then assigning it to the delegate, we directly defined the method logic inline.

## Benefits of Anonymous Methods

1. **Reduced Code Clutter**: No need to define separate methods for simple operations
2. **Local Variable Access**: Access variables in the containing method (closure)
3. **Improved Readability**: Code is more compact and the implementation is directly visible where it's used
4. **Simplified Event Handling**: Makes attaching event handlers more straightforward

## Anonymous Methods vs. Regular Methods

Let's compare using a regular method with using an anonymous method:

```csharp
// Using a regular method
public void ProcessData()
{
    List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };
    
    // Regular method approach
    List<int> evenNumbers = numbers.FindAll(IsEven);
    Console.WriteLine("Even numbers (regular method):");
    foreach (int num in evenNumbers)
    {
        Console.Write(num + " ");
    }
    Console.WriteLine();
    
    // Anonymous method approach
    List<int> oddNumbers = numbers.FindAll(
        delegate(int number) { return number % 2 != 0; }
    );
    Console.WriteLine("Odd numbers (anonymous method):");
    foreach (int num in oddNumbers)
    {
        Console.Write(num + " ");
    }
    Console.WriteLine();
}

// Helper method for regular approach
private bool IsEven(int number)
{
    return number % 2 == 0;
}
```

**Output:**
```
Even numbers (regular method):
2 4 6 
Odd numbers (anonymous method):
1 3 5 
```

The anonymous method approach eliminates the need for defining a separate method, making the code more concise.

## Accessing Outer Variables (Closures)

A powerful feature of anonymous methods is their ability to access variables from the containing method:

```csharp
public void DemonstrateClosure()
{
    string greeting = "Hello";
    
    Action DisplayGreeting = delegate()
    {
        // Accessing the outer variable 'greeting'
        Console.WriteLine($"{greeting} from the anonymous method!");
        
        // We can even modify the outer variable
        greeting = "Greetings updated";
    };
    
    DisplayGreeting(); // Outputs: Hello from the anonymous method!
    
    Console.WriteLine($"Greeting is now: {greeting}"); // Outputs: Greeting is now: Greetings updated
}
```

**Output:**
```
Hello from the anonymous method!
Greeting is now: Greetings updated
```

This behavior, known as a closure, allows the anonymous method to "capture" and use variables from its surrounding scope.

## Using Anonymous Methods with Events

Anonymous methods are particularly useful when working with events:

```csharp
public class ButtonSimulator
{
    // Define an event using a built-in delegate type
    public event EventHandler ButtonClicked;
    
    public void SimulateClick()
    {
        // Raise the event
        ButtonClicked?.Invoke(this, EventArgs.Empty);
    }
}

public void SetupButton()
{
    ButtonSimulator button = new ButtonSimulator();
    
    // Attach an event handler using an anonymous method
    button.ButtonClicked += delegate(object sender, EventArgs e)
    {
        Console.WriteLine("Button was clicked!");
        // Additional handling logic can go here
    };
    
    // Simulate a button click
    button.SimulateClick();
}
```

**Output:**
```
Button was clicked!
```

This approach is much cleaner than creating a separate method when the event handling logic is simple.

## Anonymous Methods with Parameters and Return Values

Anonymous methods can have parameters and return values just like regular methods:

```csharp
public void CalculationExample()
{
    // Delegate that takes two integers and returns their sum
    Func<int, int, int> add = delegate(int x, int y)
    {
        return x + y;
    };
    
    // Delegate that takes two integers and returns their product
    Func<int, int, int> multiply = delegate(int x, int y)
    {
        return x * y;
    };
    
    int sum = add(5, 7);
    int product = multiply(5, 7);
    
    Console.WriteLine($"Sum: {sum}");       // Output: Sum: 12
    Console.WriteLine($"Product: {product}"); // Output: Product: 35
}
```

**Output:**
```
Sum: 12
Product: 35
```

## Real-World Application: Data Processing Pipeline

Let's see a practical example of using anonymous methods in a data processing scenario:

```csharp
public class DataProcessor
{
    public delegate bool FilterDelegate(string item);
    public delegate string TransformDelegate(string item);
    
    public List<string> Process(List<string> input, FilterDelegate filter, TransformDelegate transform)
    {
        List<string> result = new List<string>();
        
        foreach (string item in input)
        {
            if (filter(item))
            {
                result.Add(transform(item));
            }
        }
        
        return result;
    }
}

public void ProcessCustomerData()
{
    List<string> customers = new List<string> 
    { 
        "John:NY:Active", 
        "Mary:CA:Inactive", 
        "Bob:TX:Active", 
        "Alice:NY:Inactive" 
    };
    
    DataProcessor processor = new DataProcessor();
    
    // Process only active customers from NY using anonymous methods
    var result = processor.Process(
        customers,
        // Filter delegate using anonymous method
        delegate(string customer) 
        { 
            string[] parts = customer.Split(':');
            return parts[1] == "NY" && parts[2] == "Active";
        },
        // Transform delegate using anonymous method
        delegate(string customer)
        {
            return "Customer: " + customer.Split(':')[0] + " (New York)";
        }
    );
    
    Console.WriteLine("Processed customer data:");
    foreach (string processedCustomer in result)
    {
        Console.WriteLine(processedCustomer);
    }
}
```

**Output:**
```
Processed customer data:
Customer: John (New York)
```

In this example, we use anonymous methods to create reusable data processing logic that can filter and transform data without creating named methods for these specific operations.

## Evolution to Lambda Expressions

While anonymous methods are powerful, C# 3.0 introduced lambda expressions, which provide an even more concise syntax. Here's the same example from earlier using lambda expressions:

```csharp
// Using anonymous method
Func<int, int, int> addAnonymous = delegate(int x, int y) { return x + y; };

// Using lambda expression (more concise)
Func<int, int, int> addLambda = (x, y) => x + y;

Console.WriteLine($"Anonymous method result: {addAnonymous(3, 4)}"); // Output: 7
Console.WriteLine($"Lambda expression result: {addLambda(3, 4)}");   // Output: 7
```

Lambda expressions have largely replaced anonymous methods in modern C# code, but understanding anonymous methods is still important for maintaining legacy code and understanding the evolution of the language.

## Summary

Anonymous methods in C# provide a way to:

- Define methods inline without creating separate named methods
- Create delegate instances with reduced syntax
- Access variables from the containing scope (closures)
- Simplify event handling and callback scenarios
- Write more concise and readable code

They're especially useful for short, one-off operations where creating a separate method would add unnecessary verbosity. While newer lambda expressions have largely superseded anonymous methods in modern C# code, the concept remains important to understand C# delegates deeply.

## Additional Resources and Exercises

### Resources
- [Microsoft Docs: Anonymous Methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-methods)
- [C# Language Specification](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/)

### Exercises

1. **Basic Practice**: Create a simple calculator application that uses anonymous methods for each operation (add, subtract, multiply, divide).

2. **Event Handling**: Create a timer class that triggers events at regular intervals, and use anonymous methods to handle different types of timer events.

3. **Advanced Closure**: Write a program that uses anonymous methods to create a counter factory, where each counter maintains its own state.

4. **Refactoring**: Take an existing program with many small utility methods and refactor it to use anonymous methods where appropriate.

5. **Comparison**: Convert a series of anonymous methods to lambda expressions and compare the readability and conciseness of both approaches.