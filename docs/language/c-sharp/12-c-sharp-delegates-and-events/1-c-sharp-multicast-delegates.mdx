---
title: C# Multicast Delegates
description: Learn how to use multicast delegates in C# to call multiple methods with a single invocation, understand delegate chaining, and see practical applications.

---

# C# Multicast Delegates

## Introduction

In our exploration of C# delegates, we've seen how they can act as type-safe function pointers. One of the most powerful features of delegates in C# is their ability to hold references to multiple methods. This capability is known as **multicast delegation**.

A multicast delegate is a delegate that points to more than one method. When you invoke a multicast delegate, it calls all the methods that it points to in sequence. This feature makes delegates particularly useful for implementing event-driven programming and the observer pattern.

In this tutorial, we'll dive into multicast delegates, understand how they work, and explore common practical applications.

## Understanding Multicast Delegates

A delegate in C# is multicast when it references more than one method. This is achieved through delegate chaining using the `+` and `+=` operators to add methods, and the `-` and `-=` operators to remove methods.

### Delegate Chaining Basics

Let's start with a simple example that demonstrates how to create and invoke a multicast delegate:

```csharp
using System;

namespace MulticastDelegateDemo
{
    // Define a delegate type that takes no parameters and returns nothing
    delegate void SimpleDelegate();

    class Program
    {
        static void Main(string[] args)
        {
            // Create delegate instance
            SimpleDelegate del = null;
            
            // Add methods to the delegate (chaining)
            del += Method1;
            del += Method2;
            del += Method3;
            
            // Invoke the multicast delegate
            Console.WriteLine("Calling multicast delegate:");
            del();
            
            Console.WriteLine("\nRemoving Method2 and calling again:");
            del -= Method2;
            del();
            
            Console.ReadKey();
        }
        
        static void Method1()
        {
            Console.WriteLine("Method1 called");
        }
        
        static void Method2()
        {
            Console.WriteLine("Method2 called");
        }
        
        static void Method3()
        {
            Console.WriteLine("Method3 called");
        }
    }
}
```

**Output:**
```
Calling multicast delegate:
Method1 called
Method2 called
Method3 called

Removing Method2 and calling again:
Method1 called
Method3 called
```

### How Delegate Chaining Works

When you use the `+=` operator with a delegate, you're essentially creating a new delegate that combines the invocation list of both delegates. The resulting delegate has a reference to all methods from both delegates.

Here's what happens behind the scenes:

1. The `+=` operator takes the original delegate and the method being added
2. It creates a new delegate that contains both invocation lists
3. It replaces the original delegate with this new combined delegate

The `-=` operator works similarly but removes a method from the invocation list.

## Working with Return Values in Multicast Delegates

When a multicast delegate has a return value, only the value from the last executed delegate in the chain is returned. This is an important consideration when working with multicast delegates.

```csharp
using System;

namespace MulticastDelegateReturnValues
{
    // Define a delegate that returns an integer
    delegate int ReturnValueDelegate();

    class Program
    {
        static void Main(string[] args)
        {
            // Create a multicast delegate
            ReturnValueDelegate del = ReturnOne;
            del += ReturnTwo;
            del += ReturnThree;
            
            // Only the last return value is captured
            int result = del();
            
            Console.WriteLine($"Result from multicast delegate: {result}");
            // Output: Result from multicast delegate: 3
            
            Console.ReadKey();
        }
        
        static int ReturnOne()
        {
            Console.WriteLine("ReturnOne method called");
            return 1;
        }
        
        static int ReturnTwo()
        {
            Console.WriteLine("ReturnTwo method called");
            return 2;
        }
        
        static int ReturnThree()
        {
            Console.WriteLine("ReturnThree method called");
            return 3;
        }
    }
}
```

**Output:**
```
ReturnOne method called
ReturnTwo method called
ReturnThree method called
Result from multicast delegate: 3
```

If you need to capture all return values, you'll need to iterate through the invocation list manually:

```csharp
using System;

namespace CaptureAllReturnValues
{
    delegate int ReturnValueDelegate();

    class Program
    {
        static void Main(string[] args)
        {
            ReturnValueDelegate del = ReturnOne;
            del += ReturnTwo;
            del += ReturnThree;

            // Get all return values by iterating through the invocation list
            Delegate[] delegates = del.GetInvocationList();
            int[] results = new int[delegates.Length];
            
            for (int i = 0; i < delegates.Length; i++)
            {
                // Cast back to original delegate type and invoke
                results[i] = ((ReturnValueDelegate)delegates[i])();
            }
            
            Console.WriteLine("All return values:");
            for (int i = 0; i < results.Length; i++)
            {
                Console.WriteLine($"Delegate {i+1} returned: {results[i]}");
            }
        }
        
        static int ReturnOne()
        {
            return 1;
        }
        
        static int ReturnTwo()
        {
            return 2;
        }
        
        static int ReturnThree()
        {
            return 3;
        }
    }
}
```

**Output:**
```
All return values:
Delegate 1 returned: 1
Delegate 2 returned: 2
Delegate 3 returned: 3
```

## Exception Handling in Multicast Delegates

When an exception occurs in one of the methods in a multicast delegate's invocation list, the execution stops at that point, and subsequent methods are not called. This is an important behavior to understand:

```csharp
using System;

namespace MulticastDelegateExceptions
{
    delegate void ExceptionDelegate();

    class Program
    {
        static void Main(string[] args)
        {
            ExceptionDelegate del = Method1;
            del += MethodWithException;
            del += Method3; // This will not be called if MethodWithException throws an exception
            
            try
            {
                del();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Exception caught: {ex.Message}");
                Console.WriteLine("Method3 was not called due to the exception.");
            }
            
            Console.ReadKey();
        }
        
        static void Method1()
        {
            Console.WriteLine("Method1 executed successfully");
        }
        
        static void MethodWithException()
        {
            Console.WriteLine("MethodWithException starting...");
            throw new InvalidOperationException("Something went wrong!");
        }
        
        static void Method3()
        {
            Console.WriteLine("Method3 executed successfully");
        }
    }
}
```

**Output:**
```
Method1 executed successfully
MethodWithException starting...
Exception caught: Something went wrong!
Method3 was not called due to the exception.
```

To handle exceptions and ensure all methods are called, you can iterate through the invocation list and handle exceptions for each method individually:

```csharp
using System;

namespace MulticastDelegateExceptionHandling
{
    delegate void ExceptionDelegate();

    class Program
    {
        static void Main(string[] args)
        {
            ExceptionDelegate del = Method1;
            del += MethodWithException;
            del += Method3;
            
            // Call each delegate individually and handle exceptions
            foreach (ExceptionDelegate handler in del.GetInvocationList())
            {
                try
                {
                    handler();
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Exception caught: {ex.Message}");
                    Console.WriteLine("Continuing to next delegate...");
                }
            }
            
            Console.ReadKey();
        }
        
        // Method definitions same as previous example
        static void Method1()
        {
            Console.WriteLine("Method1 executed successfully");
        }
        
        static void MethodWithException()
        {
            Console.WriteLine("MethodWithException starting...");
            throw new InvalidOperationException("Something went wrong!");
        }
        
        static void Method3()
        {
            Console.WriteLine("Method3 executed successfully");
        }
    }
}
```

**Output:**
```
Method1 executed successfully
MethodWithException starting...
Exception caught: Something went wrong!
Continuing to next delegate...
Method3 executed successfully
```

## Practical Applications of Multicast Delegates

### 1. Implementing an Event System

One of the most common uses of multicast delegates is for implementing an event system. The following example demonstrates a basic notification system:

```csharp
using System;

namespace EventSystemExample
{
    // Define a delegate for our notification
    delegate void NotificationDelegate(string message);

    class NotificationService
    {
        // Declare a multicast delegate field
        private NotificationDelegate _notificationHandlers;

        // Method to subscribe to notifications
        public void Subscribe(NotificationDelegate handler)
        {
            _notificationHandlers += handler;
        }

        // Method to unsubscribe from notifications
        public void Unsubscribe(NotificationDelegate handler)
        {
            _notificationHandlers -= handler;
        }

        // Method to send a notification to all subscribers
        public void SendNotification(string message)
        {
            // Check if there are any subscribers before invoking
            _notificationHandlers?.Invoke(message);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create a notification service
            NotificationService service = new NotificationService();

            // Subscribe multiple handlers
            service.Subscribe(EmailNotification);
            service.Subscribe(SMSNotification);
            service.Subscribe(PushNotification);

            // Send a notification
            Console.WriteLine("Sending notification to all subscribers:");
            service.SendNotification("System update scheduled for tomorrow at 2 AM");

            Console.WriteLine("\nUnsubscribing from SMS notifications...");
            service.Unsubscribe(SMSNotification);

            Console.WriteLine("\nSending another notification:");
            service.SendNotification("Update canceled due to technical issues");

            Console.ReadKey();
        }

        static void EmailNotification(string message)
        {
            Console.WriteLine($"EMAIL NOTIFICATION: {message}");
        }

        static void SMSNotification(string message)
        {
            Console.WriteLine($"SMS NOTIFICATION: {message}");
        }

        static void PushNotification(string message)
        {
            Console.WriteLine($"PUSH NOTIFICATION: {message}");
        }
    }
}
```

**Output:**
```
Sending notification to all subscribers:
EMAIL NOTIFICATION: System update scheduled for tomorrow at 2 AM
SMS NOTIFICATION: System update scheduled for tomorrow at 2 AM
PUSH NOTIFICATION: System update scheduled for tomorrow at 2 AM

Unsubscribing from SMS notifications...

Sending another notification:
EMAIL NOTIFICATION: Update canceled due to technical issues
PUSH NOTIFICATION: Update canceled due to technical issues
```

### 2. Implementing a Custom Event Processing Pipeline

Multicast delegates can be used to implement processing pipelines where each handler performs a specific operation:

```csharp
using System;

namespace ProcessingPipelineExample
{
    // Define delegate for processing text
    delegate string TextProcessingDelegate(string input);

    class TextProcessor
    {
        // Multicast delegate for the processing pipeline
        private TextProcessingDelegate _processingPipeline;

        // Add a processing step
        public void AddProcessingStep(TextProcessingDelegate processor)
        {
            _processingPipeline += processor;
        }

        // Process text through all steps
        public string ProcessText(string inputText)
        {
            if (_processingPipeline == null)
                return inputText;

            string result = inputText;
            
            // Process through each step individually to capture each return value
            foreach (TextProcessingDelegate processor in _processingPipeline.GetInvocationList())
            {
                result = processor(result);
            }
            
            return result;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            TextProcessor processor = new TextProcessor();
            
            // Add processing steps
            processor.AddProcessingStep(RemoveWhitespace);
            processor.AddProcessingStep(ConvertToUpperCase);
            processor.AddProcessingStep(AddTimestamp);
            
            // Process some text
            string input = "  Hello, world!  This is a test.  ";
            Console.WriteLine($"Original text: \"{input}\"");
            
            string result = processor.ProcessText(input);
            Console.WriteLine($"Processed text: \"{result}\"");
            
            Console.ReadKey();
        }
        
        static string RemoveWhitespace(string input)
        {
            string result = input.Trim();
            Console.WriteLine($"After whitespace removal: \"{result}\"");
            return result;
        }
        
        static string ConvertToUpperCase(string input)
        {
            string result = input.ToUpper();
            Console.WriteLine($"After uppercase conversion: \"{result}\"");
            return result;
        }
        
        static string AddTimestamp(string input)
        {
            string result = $"{input} [{DateTime.Now.ToString("HH:mm:ss")}]";
            Console.WriteLine($"After timestamp addition: \"{result}\"");
            return result;
        }
    }
}
```

**Output (actual time will vary):**
```
Original text: "  Hello, world!  This is a test.  "
After whitespace removal: "Hello, world!  This is a test."
After uppercase conversion: "HELLO, WORLD!  THIS IS A TEST."
After timestamp addition: "HELLO, WORLD!  THIS IS A TEST. [15:42:30]"
Processed text: "HELLO, WORLD!  THIS IS A TEST. [15:42:30]"
```

## Best Practices for Multicast Delegates

1. **Always check for null before invoking a multicast delegate**:
   ```csharp
   myDelegate?.Invoke(parameters);
   ```

2. **Be aware of return values**: Remember that only the return value of the last method is captured when invoking a multicast delegate directly.

3. **Handle exceptions appropriately**: Consider using the `GetInvocationList()` method to call each delegate individually with proper exception handling.

4. **Thread safety**: When delegates are modified by multiple threads, use appropriate synchronization mechanisms.

5. **Consider using events**: For most pub-sub scenarios, use the built-in C# event syntax rather than working with multicast delegates directly.

6. **Use null conditional operator with invocation**: When invoking a delegate that might be null, use the null conditional operator with the Invoke method:
   ```csharp
   myDelegate?.Invoke(parameters);
   ```

## Summary

Multicast delegates are a powerful feature in C# that enable a single delegate instance to reference and invoke multiple methods. Key points to remember:

- Multicast delegates allow you to chain multiple method references using the `+=` operator
- When invoked, each method in the chain is called in the order they were added
- Only the return value from the last method is captured in a direct invocation
- Exceptions in any method will prevent subsequent methods from being called
- You can use `GetInvocationList()` to manually invoke each method for better control
- Multicast delegates form the foundation of the C# event system

Multicast delegates are particularly useful for implementing event handling, notification systems, and processing pipelines. By understanding how to work with them effectively, you can build more flexible and maintainable C# applications.

## Exercises

1. Create a calculator that uses multicast delegates to perform multiple operations (addition, subtraction, multiplication, division) on a pair of numbers.

2. Build a simple logging system that can log messages to multiple destinations (console, file, database) using a multicast delegate approach.

3. Implement a validation pipeline for a user registration form where multiple validation steps are chained using multicast delegates.

4. Create a custom event system for a simple game where different actions trigger multiple responses (sound effects, visual effects, score updates).

## Additional Resources

- [Official C# Documentation on Delegates](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/)
- [C# Events and Delegates Tutorial](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)
- [C# in Depth: Events and Multicast Delegates](http://csharpindepth.com/Articles/Chapter2/Events.aspx)