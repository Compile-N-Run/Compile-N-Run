---
title: C# Performance Considerations
description: A comprehensive guide to performance considerations when writing asynchronous code in C#, understanding best practices, common pitfalls, and optimization techniques.

---

# C# Performance Considerations

When writing asynchronous code in C#, understanding performance implications is crucial to building efficient applications. This guide explores key considerations to help you write high-performance async code.

## Introduction

Asynchronous programming in C# enables responsive applications and efficient resource utilization. However, improper implementation can lead to performance issues that might be difficult to identify. This article covers essential performance considerations, common pitfalls, and best practices when working with asynchronous code.

## Understanding the Cost of Async Operations

While async operations bring many benefits, they also come with overhead that you should understand.

### State Machine Generation

When you use `async/await`, the C# compiler generates a state machine behind the scenes, which adds some overhead.

```csharp
// Regular synchronous method
public int Add(int a, int b)
{
    return a + b;
}

// Async method with state machine overhead
public async Task<int> AddAsync(int a, int b)
{
    // Artificially make this async
    await Task.Delay(1);
    return a + b;
}
```

For very simple operations, the overhead of the state machine can exceed the benefit of using async. As a rule of thumb, consider using async only when:

1. You're performing I/O operations
2. You're dealing with potentially long-running operations
3. You need to maintain UI responsiveness

## Avoiding Common Performance Pitfalls

### 1. `async void` Methods

Using `async void` instead of `async Task` can lead to unhandled exceptions and difficulty in tracking execution.

```csharp
// Bad: async void method
public async void ProcessDataVoid()
{
    await Task.Delay(100);
    throw new Exception("This exception is unhandled!");
}

// Good: async Task method
public async Task ProcessDataTask()
{
    await Task.Delay(100);
    throw new Exception("This exception can be caught by the caller");
}

// Usage:
public async Task MainMethod()
{
    try
    {
        // This exception can be caught
        await ProcessDataTask();
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Caught exception: {ex.Message}");
    }
    
    // This won't catch the exception!
    ProcessDataVoid();
}
```

### 2. Unnecessary Async/Await

Adding `async/await` when not needed adds overhead without benefits.

```csharp
// Unnecessary async/await (adds overhead)
public async Task<int> GetCountAsync()
{
    return await Task.FromResult(42);
}

// Better (no unnecessary state machine)
public Task<int> GetCountAsync()
{
    return Task.FromResult(42);
}
```

### 3. ConfigureAwait Considerations

In library code, using `ConfigureAwait(false)` can improve performance by not forcing continuation on the original context.

```csharp
// Library code with context switching overhead
public async Task LibraryMethodWithContextSwitching()
{
    // This will capture and return to the original context
    await Task.Delay(100);
    // Code here runs in the original context (UI thread in GUI apps)
}

// Library code avoiding context switching
public async Task LibraryMethodOptimized()
{
    // This avoids returning to the original context
    await Task.Delay(100).ConfigureAwait(false);
    // Code here runs in the thread pool, not necessarily the original context
}
```

## Performance Measurement and Comparison

Let's measure the performance difference between synchronous and asynchronous operations:

```csharp
using System;
using System.Diagnostics;
using System.Threading.Tasks;

class PerformanceDemo
{
    static async Task Main()
    {
        const int iterations = 10000;
        
        // Measure synchronous operations
        var sw1 = Stopwatch.StartNew();
        for (int i = 0; i < iterations; i++)
        {
            int result = SimpleAdd(5, 10);
        }
        sw1.Stop();
        Console.WriteLine($"Synchronous: {sw1.ElapsedMilliseconds}ms");
        
        // Measure asynchronous operations
        var sw2 = Stopwatch.StartNew();
        for (int i = 0; i < iterations; i++)
        {
            int result = await SimpleAddAsync(5, 10);
        }
        sw2.Stop();
        Console.WriteLine($"Asynchronous: {sw2.ElapsedMilliseconds}ms");
    }
    
    static int SimpleAdd(int a, int b) => a + b;
    
    static async Task<int> SimpleAddAsync(int a, int b)
    {
        await Task.Yield(); // Simulate minimal async overhead
        return a + b;
    }
}

// Sample output:
// Synchronous: 1ms
// Asynchronous: 157ms
```

This demonstrates that for CPU-bound operations with no real waiting, the asynchronous approach adds substantial overhead.

## Task Creation and Performance

Different ways of creating tasks have different performance implications:

```csharp
// Most expensive - creates a Task with full overhead
Task task1 = new Task(() => Console.WriteLine("Task 1"));
task1.Start();

// More efficient - Task.Factory.StartNew with default options
Task task2 = Task.Factory.StartNew(() => Console.WriteLine("Task 2"));

// Most efficient - Task.Run is a simplified version of StartNew
Task task3 = Task.Run(() => Console.WriteLine("Task 3"));

// Most efficient for results - Task.FromResult
Task<int> task4 = Task.FromResult(42);

// For already completed tasks
Task completedTask = Task.CompletedTask;
```

## Parallel Processing vs. Async/Await

Understanding when to use parallel processing vs. asynchronous programming is crucial:

```csharp
// CPU-bound work benefits from parallel processing
public void ProcessDataInParallel(List<int> items)
{
    Parallel.ForEach(items, item =>
    {
        // CPU-intensive work on each item
        DoComplexCalculation(item);
    });
}

// I/O bound work benefits from async/await
public async Task ProcessDataAsync(List<int> items)
{
    var tasks = items.Select(item => FetchDataFromDatabaseAsync(item));
    await Task.WhenAll(tasks);
}
```

## Real-World Example: Optimized Web API

Below is an example of a well-optimized ASP.NET Core controller that handles database operations asynchronously:

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repository;
    private readonly ILogger<ProductsController> _logger;

    public ProductsController(IProductRepository repository, ILogger<ProductsController> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> GetProducts()
    {
        try
        {
            // Using ConfigureAwait(false) in library/API code
            var products = await _repository.GetAllAsync().ConfigureAwait(false);
            
            // Caching consideration (example)
            Response.Headers.Add("Cache-Control", "public, max-age=60");
            
            return Ok(products);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving products");
            return StatusCode(500, "An error occurred while retrieving products");
        }
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<Product>> GetProduct(int id)
    {
        // ValueTask can be more efficient than Task when the result
        // is often synchronously available (like from cache)
        ValueTask<Product> productTask = _repository.GetByIdAsync(id);
        
        Product product = await productTask.ConfigureAwait(false);
        
        if (product == null)
        {
            return NotFound();
        }
        
        return product;
    }
}
```

## Memory Considerations with Async/Await

Asynchronous code can sometimes lead to increased memory usage due to captured variables in closures and the state machine overhead.

### Closure Captures

```csharp
// This method may cause excessive memory usage with large arrays
public async Task ProcessLargeArrayAsync(int[] hugeArray)
{
    // hugeArray is captured in the closure and stays in memory for the duration
    await Task.Delay(1000);
    int sum = hugeArray.Sum();
    return sum;
}

// Better approach - extract the calculation before async operations
public async Task<int> ProcessLargeArrayBetterAsync(int[] hugeArray)
{
    // Calculate the sum synchronously
    int sum = hugeArray.Sum();
    
    // hugeArray is no longer needed and can be garbage collected
    await Task.Delay(1000);
    
    return sum;
}
```

## Using ValueTask for Better Performance

When an operation can frequently complete synchronously, `ValueTask<T>` can improve performance by reducing allocations:

```csharp
// With regular Task - always allocates an object
public Task<int> GetValueAsync(int id)
{
    // If we have the value in cache, we still allocate a Task
    if (_cache.TryGetValue(id, out int value))
    {
        return Task.FromResult(value);
    }
    
    // Perform actual async operation
    return SlowDbLookupAsync(id);
}

// With ValueTask - avoids allocation when synchronous
public ValueTask<int> GetValueEfficientAsync(int id)
{
    // No allocation when the value is in cache
    if (_cache.TryGetValue(id, out int value))
    {
        return new ValueTask<int>(value);
    }
    
    // Only allocate when actually going async
    return new ValueTask<int>(SlowDbLookupAsync(id));
}
```

## Summary

Performance considerations for asynchronous C# code include:

1. Understanding the overhead of async state machines
2. Avoiding `async void` methods except for event handlers
3. Eliminating unnecessary `async/await` keywords
4. Using `ConfigureAwait(false)` in library code
5. Choosing the right tool: parallel processing for CPU-bound vs. async for I/O-bound
6. Using `ValueTask<T>` when operations often complete synchronously
7. Being mindful of closure captures and memory usage
8. Properly measuring and benchmarking your code

By following these guidelines, you'll write more efficient asynchronous code that performs well in real-world scenarios.

## Additional Resources

- [Microsoft Docs on Async Performance Best Practices](https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth)
- [Stephen Cleary's Blog on Async/Await Performance](https://blog.stephencleary.com/)
- [BenchmarkDotNet](https://benchmarkdotnet.org/) - A powerful .NET benchmarking tool

## Exercises

1. Compare the performance of `Task<int>` vs. `ValueTask<int>` in a scenario where results are frequently cached.
2. Benchmark the overhead of `async/await` in a tight loop compared to synchronous code.
3. Modify an existing application to use `ConfigureAwait(false)` in appropriate places and measure any performance improvements.
4. Implement and compare different strategies for processing a large collection (Parallel.ForEach vs. async/await with Task.WhenAll).