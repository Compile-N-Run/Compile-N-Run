---
title: C# Synchronization Context
description: Learn about Synchronization Context in C# asynchronous programming, how it works, and its importance in maintaining thread affinity in UI and ASP.NET applications.

---

# C# Synchronization Context

When working with asynchronous programming in C#, you'll eventually encounter the concept of `SynchronizationContext`. This powerful but sometimes confusing mechanism plays a crucial role in how asynchronous code interacts with different application models. Understanding it will help you write better asynchronous code, especially for UI applications.

## What is a Synchronization Context?

A `SynchronizationContext` is an abstraction that represents the environment or "context" where your code is executing. It provides a way to control how asynchronous continuations are executed after an `await` operation completes.

In simpler terms, it's a system that helps manage where your code runs after an `await` statement, helping to ensure that code runs on the appropriate thread.

### Key Purposes

1. **Thread Affinity**: Ensuring code executes on the correct thread (especially important for UI applications)
2. **Execution Environment**: Capturing the current execution environment so you can return to it later
3. **Continuation Control**: Managing how and where asynchronous continuations are scheduled

## Where Synchronization Context Matters

Synchronization contexts are particularly important in these environments:

- **UI Applications**: Windows Forms, WPF, UWP, and MAUI all have a UI thread that must be used for UI operations
- **ASP.NET Framework**: Has its own synchronization context to manage request context
- **ASP.NET Core**: Deliberately avoids using synchronization context for performance reasons

## How It Works in Practice

When you use `async`/`await` in C#, the following happens:

1. The current `SynchronizationContext` is captured when execution hits an `await`
2. After the awaited task completes, by default, the continuation resumes on the captured context

Let's see a basic example:

```csharp
private async void Button_Click(object sender, EventArgs e)
{
    // We're on the UI thread here, with UI SynchronizationContext
    label.Text = "Starting...";
    
    // This captures the current SynchronizationContext before awaiting
    await Task.Delay(1000);
    
    // After awaiting, we're back on the UI thread because of the captured context
    // This is safe - no cross-thread exception
    label.Text = "Completed!";
}
```

In this example, even though `Task.Delay` runs on a background thread, the continuation (the code after `await`) runs back on the UI thread because the UI's `SynchronizationContext` was captured.

## Getting the Current Synchronization Context

You can access the current synchronization context using:

```csharp
var context = SynchronizationContext.Current;
```

This will return:
- An application-specific `SynchronizationContext` if one exists
- `null` if there isn't one (like in console applications)

## Controlling Synchronization Context Behavior

Sometimes you want to change the default behavior. Here are common ways to do that:

### Running Code Without Context Resumption

To avoid returning to the captured context:

```csharp
await SomeAsyncOperation().ConfigureAwait(false);
```

This is a common optimization pattern in library code:

```csharp
public async Task ProcessDataAsync()
{
    // First part runs on the caller's context
    var data = PrepareData();
    
    // Use ConfigureAwait(false) to avoid unnecessary context switches
    var result = await FetchDataFromDatabaseAsync().ConfigureAwait(false);
    var processed = await ProcessDataInternallyAsync(result).ConfigureAwait(false);
    
    // Only switch back to the original context when needed
    // (like when updating UI or accessing context-specific data)
    return processed;
}
```

### Post vs. Send

The `SynchronizationContext` class provides two main methods for executing code:

1. **Post**: Executes the code asynchronously on the context
2. **Send**: Executes the code synchronously on the context (blocks until complete)

```csharp
// Example of using Post (non-blocking)
SynchronizationContext uiContext = SynchronizationContext.Current;
Task.Run(() => {
    // Do work on background thread
    var result = CalculateResult();
    
    // Post back to UI thread
    uiContext.Post(_ => {
        resultLabel.Text = result.ToString();
    }, null);
});

// Example of using Send (blocking)
SynchronizationContext uiContext = SynchronizationContext.Current;
Task.Run(() => {
    // Do work on background thread
    var result = CalculateResult();
    
    // Send blocks until the UI update is complete
    uiContext.Send(_ => {
        resultLabel.Text = result.ToString();
    }, null);
    
    // This line won't execute until the UI is updated
    Console.WriteLine("UI updated!");
});
```

## Custom Synchronization Context

You can create your own synchronization context by inheriting from the `SynchronizationContext` class. This is an advanced scenario but can be useful for specialized requirements.

Here's a very simple example:

```csharp
public class CustomSynchronizationContext : SynchronizationContext
{
    public override void Post(SendOrPostCallback d, object state)
    {
        Console.WriteLine("Post called");
        // Execute on a ThreadPool thread
        ThreadPool.QueueUserWorkItem(_ => d(state));
    }

    public override void Send(SendOrPostCallback d, object state)
    {
        Console.WriteLine("Send called");
        // Execute immediately on the current thread
        d(state);
    }
}

// Using the custom context
static async Task CustomContextExample()
{
    // Save the old context
    var oldContext = SynchronizationContext.Current;
    
    try {
        // Set our custom context
        var customContext = new CustomSynchronizationContext();
        SynchronizationContext.SetSynchronizationContext(customContext);
        
        // Now our custom context will be captured by await
        await Task.Delay(100);
        Console.WriteLine("After await, using custom context");
    }
    finally {
        // Restore the original context
        SynchronizationContext.SetSynchronizationContext(oldContext);
    }
}
```

## Real-World Example: A Simple UI Application

Let's see a more complete example showing how synchronization context works in a Windows Forms application:

```csharp
public partial class MainForm : Form
{
    public MainForm()
    {
        InitializeComponent();
        btnProcess.Click += BtnProcess_Click;
    }

    private async void BtnProcess_Click(object sender, EventArgs e)
    {
        btnProcess.Enabled = false;
        progressBar.Value = 0;
        statusLabel.Text = "Processing...";
        
        try
        {
            // Store the UI context for later use
            var uiContext = SynchronizationContext.Current;
            
            // Run CPU-bound work on a background thread
            var result = await Task.Run(async () => {
                // This runs on a ThreadPool thread
                int total = 0;
                
                // Simulate work
                for (int i = 0; i <= 100; i++)
                {
                    // Process data
                    total += i;
                    await Task.Delay(50);
                    
                    // Report progress back to UI thread
                    uiContext.Post(_ => {
                        progressBar.Value = i;
                    }, null);
                }
                
                return total;
            });
            
            // Back on the UI thread due to SynchronizationContext
            statusLabel.Text = $"Completed! Result: {result}";
        }
        catch (Exception ex)
        {
            statusLabel.Text = $"Error: {ex.Message}";
        }
        finally
        {
            btnProcess.Enabled = true;
        }
    }
}
```

This example demonstrates:
1. Capturing the UI context explicitly
2. Running CPU-intensive work on a background thread
3. Reporting progress back to the UI thread using the stored context
4. Automatic return to the UI thread for the final update

## Common Pitfalls

### Deadlocks

One of the most common issues with synchronization contexts is deadlocks, which can occur when mixing synchronous and asynchronous code:

```csharp
// DON'T DO THIS:
public void ButtonClick()
{
    // This will deadlock if called from UI thread!
    var result = GetDataAsync().Result;
    DisplayData(result);
}

private async Task<string> GetDataAsync()
{
    // This will try to return to UI thread,
    // but UI thread is blocked waiting for Result above
    await Task.Delay(1000);
    return "Data";
}
```

### Context Switching Overhead

Excessive context switching can hurt performance:

```csharp
// Inefficient - switches context after each operation
public async Task<int> ProcessDataInefficient(List<int> items)
{
    int total = 0;
    foreach (var item in items)
    {
        total += await ProcessItemAsync(item); // Context switch on each iteration!
    }
    return total;
}

// More efficient
public async Task<int> ProcessDataEfficient(List<int> items)
{
    int total = 0;
    foreach (var item in items)
    {
        // Avoid unnecessary context resumption for internal operations
        total += await ProcessItemAsync(item).ConfigureAwait(false);
    }
    return total;
}
```

## When to Use ConfigureAwait(false)

A good rule of thumb:

- **Library Code**: Almost always use `ConfigureAwait(false)` for better performance and to avoid potential deadlocks
- **Application Code**: Usually don't need `ConfigureAwait(false)` if you need to access UI or request-specific context

```csharp
// In library code
public async Task<Data> GetDataFromApiAsync()
{
    var response = await httpClient.GetAsync("api/data").ConfigureAwait(false);
    var json = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
    return JsonSerializer.Deserialize<Data>(json);
}

// In UI code
private async void UpdateButton_Click(object sender, EventArgs e)
{
    // Don't use ConfigureAwait(false) here, we need the UI context
    var data = await dataService.GetDataFromApiAsync();
    dataGridView.DataSource = data; // Requires UI thread
}
```

## ASP.NET Core and No SynchronizationContext

ASP.NET Core deliberately doesn't provide a `SynchronizationContext` for performance reasons. This means:

1. Continuations automatically run on the thread pool
2. You generally don't need to use `ConfigureAwait(false)` for performance (though it's still a good practice for library code)

```csharp
// ASP.NET Core controller action
[HttpGet]
public async Task<IActionResult> GetData()
{
    // In ASP.NET Core, there's no SynchronizationContext
    // so this continuation runs on the thread pool automatically
    var data = await _repository.GetDataAsync();
    
    // No need to worry about thread affinity for UI updates
    return Ok(data);
}
```

## Summary

Understanding `SynchronizationContext` is crucial for writing efficient and correct asynchronous code in C#:

- It helps maintain thread affinity for environments that need it (primarily UI applications)
- It controls where code runs after an `await` operation
- `ConfigureAwait(false)` can be used to avoid unnecessary context switches
- Different application models have different synchronization context behaviors
- Proper use can help avoid deadlocks and performance issues

Mastering this concept will make you much more effective when writing asynchronous code across different .NET application types.

## Further Resources

- [Microsoft Docs: SynchronizationContext Class](https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext)
- [Stephen Cleary's Blog: AsyncEx Library](https://blog.stephencleary.com/2013/05/announcement-asyncex-v1.html) - A library with useful async utilities
- [Async/Await Best Practices](https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming)

## Exercises

1. Create a simple WPF or Windows Forms application that performs a long-running calculation on a background thread while updating a progress bar on the UI thread.

2. Write a method that captures the current synchronization context, then posts work to it after a delay.

3. Create a custom synchronization context that logs all operations and use it in a simple console application.

4. Experiment with and without `ConfigureAwait(false)` in a simple library method and observe any differences in behavior when called from a UI application.