---
title: "C# Type Conversions"
description: "Learn how to convert between different data types in C#, including implicit conversions, explicit casting, and helper methods like Parse, TryParse, and Convert classes."

---

# C# Type Conversions

In C# programming, you'll frequently need to convert values from one data type to another. Understanding how type conversions work is crucial for writing robust code. This article explores the different types of conversions in C# and how to use them effectively.

## Introduction to Type Conversions

Type conversion is the process of changing a value from one data type to another. In C#, conversions can be:

- **Implicit** - Automatic conversions that are type-safe and don't result in data loss
- **Explicit** - Conversions that require explicit syntax (casting) and may result in data loss
- **User-defined** - Custom conversions defined by types
- **Conversions with helper classes** - Using methods like `Parse()`, `TryParse()`, and the `Convert` class

Let's explore each of these approaches with examples.

## Implicit Type Conversions

Implicit conversions happen automatically when there's no risk of data loss. C# allows these conversions without requiring any special syntax.

### Common Implicit Conversions

- `int` to `long`
- `float` to `double`
- Any numeric type to `decimal`
- Derived class to base class

### Example of Implicit Conversion

```csharp
// Integer to double conversion (implicit)
int intValue = 42;
double doubleValue = intValue;  // No explicit cast needed

Console.WriteLine($"Int value: {intValue}");
Console.WriteLine($"Double value: {doubleValue}");

// Short to int conversion (implicit)
short shortValue = 1000;
int intFromShort = shortValue;

Console.WriteLine($"Short value: {shortValue}");
Console.WriteLine($"Int from short: {intFromShort}");

// Derived class to base class (implicit)
class Animal { }
class Dog : Animal { }

Dog myDog = new Dog();
Animal myAnimal = myDog;  // Implicit conversion from derived to base
```

**Output:**
```
Int value: 42
Double value: 42
Short value: 1000
Int from short: 1000
```

Implicit conversions are safe because the target type can always accommodate the source type's value without losing data.

## Explicit Type Conversions (Casting)

When a conversion might result in data loss or when the compiler can't guarantee type safety, you need to use explicit conversion, also known as casting.

### Common Scenarios for Explicit Casting

- `double` to `int` (potential loss of decimal portion)
- `long` to `int` (potential overflow if value too large)
- Base class to derived class (requires runtime check)

### Syntax for Explicit Casting

```csharp
(targetType)sourceValue
```

### Example of Explicit Casting

```csharp
// Double to int (explicit - potential loss of precision)
double doubleValue = 42.87;
int intValue = (int)doubleValue;  // Decimal portion is truncated

Console.WriteLine($"Double value: {doubleValue}");
Console.WriteLine($"Int value after cast: {intValue}");

// Long to int (explicit - potential overflow)
long longValue = 2147483648;  // This value is too large for int
try
{
    int intFromLong = (int)longValue;
    Console.WriteLine($"Int from long: {intFromLong}");  // Will display a negative number due to overflow
}
catch (Exception ex)
{
    Console.WriteLine($"Error: {ex.Message}");
}

// Base class to derived class (requires runtime check)
Animal myAnimal = new Dog();
// Dog myDog = (Dog)myAnimal;  // This works because myAnimal is actually a Dog

// But this would fail:
Animal genericAnimal = new Animal();
try
{
    Dog anotherDog = (Dog)genericAnimal;  // Will throw InvalidCastException
}
catch (InvalidCastException ex)
{
    Console.WriteLine($"Invalid cast: {ex.Message}");
}
```

**Output:**
```
Double value: 42.87
Int value after cast: 42
Int from long: -2147483648
Invalid cast: Unable to cast object of type 'Animal' to type 'Dog'.
```

Be cautious with explicit casts, as they can lead to runtime exceptions or unexpected data loss.

## Type Conversion Methods: Parse and TryParse

For converting strings to other data types, C# provides `Parse` and `TryParse` methods.

### Parse Method

The `Parse` method attempts to convert a string to a specific data type. If parsing fails, it throws an exception.

```csharp
// Converting strings to numeric types using Parse
string numberString = "123";
int parsedInt = int.Parse(numberString);

string decimalString = "123.45";
double parsedDouble = double.Parse(decimalString);

Console.WriteLine($"Parsed int: {parsedInt}");
Console.WriteLine($"Parsed double: {parsedDouble}");

// Parse will throw an exception for invalid conversions
try
{
    int invalidNumber = int.Parse("abc");
}
catch (FormatException ex)
{
    Console.WriteLine($"Parse error: {ex.Message}");
}
```

**Output:**
```
Parsed int: 123
Parsed double: 123.45
Parse error: Input string was not in a correct format.
```

### TryParse Method

`TryParse` is a safer alternative that doesn't throw exceptions. It returns a boolean indicating success or failure and outputs the converted value through an `out` parameter.

```csharp
// Using TryParse for safer conversions
string validNumber = "123";
if (int.TryParse(validNumber, out int result))
{
    Console.WriteLine($"Successfully parsed: {result}");
}
else
{
    Console.WriteLine("Failed to parse");
}

// TryParse with invalid input
string invalidInput = "123abc";
if (double.TryParse(invalidInput, out double doubleResult))
{
    Console.WriteLine($"Successfully parsed: {doubleResult}");
}
else
{
    Console.WriteLine($"Failed to parse '{invalidInput}' to double");
}
```

**Output:**
```
Successfully parsed: 123
Failed to parse '123abc' to double
```

## The Convert Class

C# offers a powerful `Convert` class that provides methods for converting between various base types.

```csharp
// Using the Convert class
string boolString = "True";
bool convertedBool = Convert.ToBoolean(boolString);
Console.WriteLine($"Converted boolean: {convertedBool}");

// Convert between numeric types
double doubleToConvert = 123.45;
int convertedInt = Convert.ToInt32(doubleToConvert);  // Rounds to nearest integer!
Console.WriteLine($"Double {doubleToConvert} converted to int: {convertedInt}");

// Convert from object
object objValue = 42;
long convertedLong = Convert.ToInt64(objValue);
Console.WriteLine($"Object converted to long: {convertedLong}");

// Convert date to string
DateTime now = DateTime.Now;
string dateString = Convert.ToString(now);
Console.WriteLine($"DateTime converted to string: {dateString}");

// Convert supports null values (unlike direct casting)
object nullObj = null;
string nullString = Convert.ToString(nullObj);  // Returns empty string instead of throwing exception
Console.WriteLine($"Null object converted to string: '{nullString}'");
```

**Output:**
```
Converted boolean: True
Double 123.45 converted to int: 123
Object converted to long: 42
DateTime converted to string: 7/15/2023 3:45:21 PM
Null object converted to string: ''
```

## Type Checking With `is` and `as` Operators

C# provides two useful operators for type checking and safe casting:

### The `is` Operator

The `is` operator checks if an object is compatible with a given type, returning a boolean.

```csharp
// Using the 'is' operator for type checking
object mixedValue = "Hello, world!";

if (mixedValue is string)
{
    Console.WriteLine("mixedValue is a string");
}

if (mixedValue is int)
{
    Console.WriteLine("mixedValue is an int");
}
```

**Output:**
```
mixedValue is a string
```

### The `as` Operator

The `as` operator attempts to cast an object to a specified type. If the cast is not possible, it returns `null` instead of throwing an exception.

```csharp
// Using the 'as' operator for safe casting
object stringObject = "Hello, C#";
string safeString = stringObject as string;  // Works, returns the string
Console.WriteLine($"Safe string: {safeString}");

object numberObject = 42;
string nullString = numberObject as string;  // Cannot cast, returns null
Console.WriteLine($"Null string is null: {nullString == null}");
```

**Output:**
```
Safe string: Hello, C#
Null string is null: True
```

## Pattern Matching with Type Conversions

C# offers elegant pattern matching syntax for type checking and conversion:

```csharp
// Pattern matching with type conversions
object item = "123";

// Type pattern
if (item is string str)
{
    // str is available as a string in this scope
    Console.WriteLine($"String value: {str}, Length: {str.Length}");
}

// Switch expression with patterns
string GetDescription(object obj)
{
    return obj switch
    {
        string s => $"String: {s}",
        int i => $"Integer: {i}",
        double d => $"Double: {d}",
        _ => "Unknown type"
    };
}

Console.WriteLine(GetDescription("Hello"));
Console.WriteLine(GetDescription(42));
Console.WriteLine(GetDescription(3.14));
Console.WriteLine(GetDescription(new object()));
```

**Output:**
```
String value: 123, Length: 3
String: Hello
Integer: 42
Double: 3.14
Unknown type
```

## Real-World Example: Data Processing Application

Let's put these concepts together in a practical example of a data processing application:

```csharp
// A simple data processing example using various type conversions
public static void ProcessUserData(string userInput)
{
    Console.WriteLine("Processing user data...");
    
    // Try to parse as integer first
    if (int.TryParse(userInput, out int intValue))
    {
        Console.WriteLine($"Integer detected: {intValue}");
        Console.WriteLine($"Doubled: {intValue * 2}");
        return;
    }
    
    // Try to parse as double
    if (double.TryParse(userInput, out double doubleValue))
    {
        Console.WriteLine($"Decimal number detected: {doubleValue}");
        Console.WriteLine($"With tax (20%): {doubleValue * 1.2:F2}");
        return;
    }
    
    // Try to parse as DateTime
    if (DateTime.TryParse(userInput, out DateTime dateValue))
    {
        Console.WriteLine($"Date detected: {dateValue:d}");
        Console.WriteLine($"Day of week: {dateValue.DayOfWeek}");
        Console.WriteLine($"Days until end of month: {DateTime.DaysInMonth(dateValue.Year, dateValue.Month) - dateValue.Day}");
        return;
    }
    
    // Try to parse as boolean
    if (bool.TryParse(userInput, out bool boolValue))
    {
        Console.WriteLine($"Boolean detected: {boolValue}");
        Console.WriteLine($"Inverse: {!boolValue}");
        return;
    }
    
    // Default to string processing
    Console.WriteLine($"Text detected: {userInput}");
    Console.WriteLine($"Character count: {userInput.Length}");
    Console.WriteLine($"Uppercase: {userInput.ToUpper()}");
}

// Test our function with different inputs
ProcessUserData("42");
Console.WriteLine();
ProcessUserData("3.14159");
Console.WriteLine();
ProcessUserData("2023-07-15");
Console.WriteLine();
ProcessUserData("true");
Console.WriteLine();
ProcessUserData("Hello, C# developers!");
```

**Output:**
```
Processing user data...
Integer detected: 42
Doubled: 84

Processing user data...
Decimal number detected: 3.14159
With tax (20%): 3.77

Processing user data...
Date detected: 7/15/2023
Day of week: Saturday
Days until end of month: 16

Processing user data...
Boolean detected: True
Inverse: False

Processing user data...
Text detected: Hello, C# developers!
Character count: 20
Uppercase: HELLO, C# DEVELOPERS!
```

## Summary

Type conversions are a fundamental concept in C# programming. We've explored:

- **Implicit conversions** - Automatic and type-safe conversions
- **Explicit conversions (casting)** - Conversions that require explicit syntax
- **Parse and TryParse methods** - Converting strings to other data types
- **Convert class** - A versatile utility for type conversions
- **is and as operators** - For type checking and safe casting
- **Pattern matching** - Modern C# syntax for type checking and conversion

Understanding these conversion techniques will help you write more robust and flexible C# code. Always consider potential data loss or exceptions when performing conversions, and choose the most appropriate technique for your specific scenario.

## Exercises

1. Write a program that asks for user input and determines whether the input is an integer, double, date, or text.
2. Create a function that safely converts any numeric type to decimal.
3. Write a method that takes an object parameter and returns different messages based on its type.
4. Create a simple calculator that converts string inputs to appropriate numeric types before performing operations.
5. Implement a custom conversion between two of your own classes using implicit and explicit operators.

## Additional Resources

- [Microsoft Documentation on Type Conversion](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions)
- [C# Language Specification - Conversions](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/conversions)
- [Pattern Matching in C#](https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching)

Happy coding!