---
title: "C# Value Types"
description: "A comprehensive guide to understanding value types in C#, their behavior, and practical applications with code examples."

---

# C# Value Types

## Introduction

Value types are fundamental building blocks in C# that store data directly. Unlike reference types, which store a reference to data, value types contain the actual data. This distinction affects how they behave when copied, passed to methods, or compared.

In C#, value types are derived from `System.ValueType`, which itself inherits from `System.Object`. Understanding value types is essential for writing efficient C# code and avoiding common pitfalls related to memory management and assignment operations.

## What Are Value Types?

Value types in C# are types that directly contain their data. When you declare a variable of a value type, the memory to store its actual value is allocated on the stack (though there are exceptions we'll discuss later).

Here's a list of common value types in C#:

- **Simple types**: `int`, `float`, `double`, `bool`, `char`, etc.
- **Struct types**: Custom structures defined with the `struct` keyword
- **Enum types**: Enumeration types defined with the `enum` keyword
- **Nullable value types**: Value types that can also represent `null` (e.g., `int?`)

## Key Characteristics of Value Types

### 1. Stored on the Stack (Usually)

Value types are typically stored on the stack, which provides faster access than the heap. This makes value types efficient for small data structures.

```csharp
// Stored on the stack
int number = 42;
bool isValid = true;
double price = 19.99;
```

### 2. Assignment Creates a Copy

When you assign a value type to another variable, C# makes a complete copy of the value.

```csharp
int x = 10;
int y = x;  // y gets a copy of x's value
x = 20;     // Modifying x doesn't affect y

Console.WriteLine($"x: {x}, y: {y}");
// Output:
// x: 20, y: 10
```

### 3. Default Values

Value types always have a default value and cannot be `null` (unless you use nullable value types). For numeric types, the default is 0; for `bool`, it's `false`; for `char`, it's `\0`.

```csharp
int defaultInt;     // Initialized to 0
bool defaultBool;   // Initialized to false
char defaultChar;   // Initialized to '\0'

Console.WriteLine($"Default int: {defaultInt}, Default bool: {defaultBool}");
// Output:
// Default int: 0, Default bool: False
```

## Common Built-in Value Types

### Numeric Types

C# provides various numeric value types to handle different sizes and precision requirements:

```csharp
// Integer types
sbyte mySignedByte = 127;    // 8-bit signed integer (-128 to 127)
byte myByte = 255;           // 8-bit unsigned integer (0 to 255)
short myShort = 32767;       // 16-bit signed integer
ushort myUShort = 65535;     // 16-bit unsigned integer
int myInt = 2147483647;      // 32-bit signed integer
uint myUInt = 4294967295;    // 32-bit unsigned integer
long myLong = 9223372036854775807;         // 64-bit signed integer
ulong myULong = 18446744073709551615;      // 64-bit unsigned integer

// Floating-point types
float myFloat = 3.14159f;    // 32-bit floating-point (note the f suffix)
double myDouble = 3.141592653589793;       // 64-bit floating-point
decimal myDecimal = 3.1415926535897932m;   // 128-bit decimal (note the m suffix)

Console.WriteLine($"int max value: {myInt}");
Console.WriteLine($"decimal precision example: {myDecimal}");
```

### Boolean Type

```csharp
bool isComplete = true;
bool hasErrors = false;

if (isComplete && !hasErrors)
{
    Console.WriteLine("Operation completed successfully!");
}
```

### Character Type

```csharp
char grade = 'A';
char symbol = '#';
char newLine = '\n';

Console.WriteLine($"Grade: {grade}");
// Output:
// Grade: A
```

## Custom Value Types: Structs

Structs are user-defined value types that can contain multiple fields, properties, methods, and events.

```csharp
public struct Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y)
    {
        X = x;
        Y = y;
    }

    public double DistanceFromOrigin()
    {
        return Math.Sqrt(X * X + Y * Y);
    }

    public override string ToString()
    {
        return $"({X}, {Y})";
    }
}

// Using the struct
Point p1 = new Point(3, 4);
Point p2 = p1;  // Creates a complete copy of p1
p1.X = 10;      // Doesn't affect p2

Console.WriteLine($"p1: {p1}, p2: {p2}");
Console.WriteLine($"Distance from origin: {p2.DistanceFromOrigin()}");

// Output:
// p1: (10, 4), p2: (3, 4)
// Distance from origin: 5
```

### When to Use Structs

- For small, simple data structures (typically less than 16 bytes)
- When value equality is more natural than reference equality
- When frequent allocation/deallocation can be avoided
- When the data is immutable or rarely changes

## Enum Types

Enums are distinct value types that define a set of named constants.

```csharp
public enum DayOfWeek
{
    Sunday,     // 0
    Monday,     // 1
    Tuesday,    // 2
    Wednesday,  // 3
    Thursday,   // 4
    Friday,     // 5
    Saturday    // 6
}

// Using an enum
DayOfWeek today = DayOfWeek.Wednesday;
Console.WriteLine($"Today is {today}");

// You can cast enums to their underlying type (int by default)
int dayNumber = (int)today;
Console.WriteLine($"Day number: {dayNumber}");

// Output:
// Today is Wednesday
// Day number: 3
```

You can also specify a different underlying type and custom values:

```csharp
public enum FileAccess : byte
{
    Read = 1,
    Write = 2,
    Execute = 4,
    ReadWrite = Read | Write  // 3
}

FileAccess access = FileAccess.ReadWrite;
Console.WriteLine($"Access level: {access} ({(byte)access})");
// Output:
// Access level: ReadWrite (3)
```

## Nullable Value Types

Value types cannot normally be assigned `null`. However, C# provides nullable value types to represent the absence of a value:

```csharp
// Non-nullable - cannot be null
int regularInt = 10;
// regularInt = null;  // This would cause a compiler error

// Nullable - can be null
int? nullableInt = 10;
nullableInt = null;  // This is valid

// Check if nullable type has a value
if (nullableInt.HasValue)
{
    Console.WriteLine($"Value: {nullableInt.Value}");
}
else
{
    Console.WriteLine("No value");
}

// Using the null-coalescing operator
int result = nullableInt ?? 0;  // Use 0 if nullableInt is null
Console.WriteLine($"Result: {result}");
// Output:
// No value
// Result: 0
```

## Value Types vs. Reference Types

Understanding the difference between value types and reference types is crucial:

```csharp
// Value type example
struct PointStruct
{
    public int X, Y;
}

// Reference type example
class PointClass
{
    public int X, Y;
}

// Value type behavior
PointStruct ps1 = new PointStruct { X = 1, Y = 2 };
PointStruct ps2 = ps1;  // Full copy
ps1.X = 10;             // Only changes ps1

// Reference type behavior
PointClass pc1 = new PointClass { X = 1, Y = 2 };
PointClass pc2 = pc1;   // Both variables reference the same object
pc1.X = 10;             // Changes are visible through pc2 as well

Console.WriteLine($"Value type: ps1.X = {ps1.X}, ps2.X = {ps2.X}");
Console.WriteLine($"Reference type: pc1.X = {pc1.X}, pc2.X = {pc2.X}");

// Output:
// Value type: ps1.X = 10, ps2.X = 1
// Reference type: pc1.X = 10, pc2.X = 10
```

## Performance Considerations

Value types can offer performance benefits in certain scenarios:

1. **No heap allocations**: Value types avoid garbage collection overhead
2. **Memory locality**: Value types stored in arrays or collections are contiguous in memory, improving cache performance
3. **No reference tracking**: Value types don't need reference tracking

However, they also have disadvantages:

1. **Copy overhead**: Large value types can be expensive to copy
2. **Boxing operations**: Converting value types to reference types (boxing) creates heap allocations

## Boxing and Unboxing

Boxing occurs when you convert a value type to a reference type (specifically, to `object` or an interface type):

```csharp
int value = 42;
object boxed = value;  // Boxing: value type â†’ heap-allocated object

// Unboxing: converting back to a value type
int unboxed = (int)boxed;

Console.WriteLine($"Original: {value}, Boxed: {boxed}, Unboxed: {unboxed}");
// Output:
// Original: 42, Boxed: 42, Unboxed: 42
```

Boxing is an expensive operation because:
1. It allocates memory on the heap
2. It copies the value to the heap
3. It creates pressure on the garbage collector

## Real-World Applications

### Example 1: 2D Game Coordinates

Value types are perfect for representing coordinates in games:

```csharp
public struct Vector2D
{
    public float X { get; set; }
    public float Y { get; set; }

    public Vector2D(float x, float y)
    {
        X = x;
        Y = y;
    }

    public float Magnitude => (float)Math.Sqrt(X * X + Y * Y);

    public static Vector2D operator +(Vector2D a, Vector2D b)
        => new Vector2D(a.X + b.X, a.Y + b.Y);
}

// In a game loop
Vector2D position = new Vector2D(10, 20);
Vector2D velocity = new Vector2D(1, 2);

// Update position
position = position + velocity;  // Efficient, no heap allocations

Console.WriteLine($"New position: ({position.X}, {position.Y})");
Console.WriteLine($"Magnitude: {position.Magnitude}");
// Output:
// New position: (11, 22)
// Magnitude: 24.596748
```

### Example 2: Money Calculations with Decimal

The `decimal` type is perfect for financial calculations where precision is crucial:

```csharp
public struct Money
{
    public decimal Amount { get; }
    public string Currency { get; }

    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }

    public static Money operator +(Money a, Money b)
    {
        if (a.Currency != b.Currency)
            throw new InvalidOperationException("Cannot add different currencies");

        return new Money(a.Amount + b.Amount, a.Currency);
    }

    public override string ToString() => $"{Amount:C} {Currency}";
}

// Financial calculation
Money payment1 = new Money(125.37m, "USD");
Money payment2 = new Money(25.99m, "USD");
Money total = payment1 + payment2;

Console.WriteLine($"Total payment: {total}");
// Output:
// Total payment: $151.36 USD
```

### Example 3: Status Flags with Enums

Enums are great for representing sets of flags or options:

```csharp
[Flags]
public enum UserPermissions
{
    None = 0,
    Read = 1,
    Write = 2,
    Delete = 4,
    Admin = 8,
    All = Read | Write | Delete | Admin
}

// Checking and setting permissions
UserPermissions userAccess = UserPermissions.Read | UserPermissions.Write;

// Add a permission
userAccess |= UserPermissions.Delete;

// Check if user has specific permission
bool canWrite = (userAccess & UserPermissions.Write) == UserPermissions.Write;

// Remove a permission
userAccess &= ~UserPermissions.Delete;

Console.WriteLine($"User permissions: {userAccess}");
Console.WriteLine($"Can write: {canWrite}");
// Output:
// User permissions: Read, Write
// Can write: True
```

## Common Mistakes and Best Practices

### Mistake 1: Using Structs for Large Data

Large structs can lead to performance problems due to copy overhead. Prefer classes for complex data structures.

### Mistake 2: Creating Mutable Structs

Mutable structs (where properties or fields can change after creation) can lead to unexpected behavior:

```csharp
// PROBLEMATIC: Mutable struct
public struct MutablePoint
{
    public int X;
    public int Y;

    public void MoveBy(int deltaX, int deltaY)
    {
        X += deltaX;  // Can lead to unexpected behavior
        Y += deltaY;
    }
}

// BETTER: Immutable struct
public readonly struct ImmutablePoint
{
    public int X { get; }
    public int Y { get; }

    public ImmutablePoint(int x, int y)
    {
        X = x;
        Y = y;
    }

    // Returns a new instance instead of modifying this one
    public ImmutablePoint MoveBy(int deltaX, int deltaY)
        => new ImmutablePoint(X + deltaX, Y + deltaY);
}
```

### Best Practices

1. **Keep value types small**: Aim for less than 16 bytes
2. **Make structs immutable**: Use readonly fields/properties and methods that return new instances
3. **Avoid boxing**: Be careful with generic collections and methods that use Object
4. **Use enums with [Flags] attribute** for bit flags
5. **Consider performance implications**: Benchmark when unsure

## Summary

Value types in C# are fundamental components that store data directly instead of referencing it. They include simple types like `int` and `bool`, as well as more complex user-defined types like `struct` and `enum`.

Key points to remember:
- Value types store their data directly, typically on the stack
- Assignment creates a complete copy of the data
- Value types cannot be null (unless they're nullable value types)
- Custom value types can be created using `struct` and `enum`
- Value types are efficient for small, simple data but can cause performance issues if misused

Understanding value types helps you make better decisions about your data structures and can lead to more efficient, predictable C# code.

## Additional Resources

- [Microsoft Docs: Value Types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)
- [C# Structs Best Practices](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct)
- [Enumeration Types in C#](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum)

## Exercises

1. Create a `Temperature` struct that can store temperature in different units (Celsius, Fahrenheit, Kelvin) and convert between them.

2. Define a `PlayingCard` struct representing a card in a standard deck, with Suit and Rank enums.

3. Implement a `Fraction` struct that represents a mathematical fraction with operations for addition, subtraction, multiplication, and division.

4. Create a `Color` struct that stores RGB values and provides methods to brighten, darken, and convert to grayscale.

5. Design an immutable `DateRange` struct that represents a period between two dates and implements methods to check if dates are within the range and if two ranges overlap.