---
title: "C# Boxing and Unboxing"
description: "Learn about boxing and unboxing operations in C# and how value types can be converted to reference types and vice versa"

---

# C# Boxing and Unboxing

In C#, types are divided into two categories: value types (like `int`, `float`, `struct`) and reference types (like `string`, `class`, `interface`). Boxing and unboxing are operations that bridge these two type systems, allowing value types to be treated as reference types and vice versa.

## What is Boxing?

**Boxing** is the process of converting a value type to a reference type by wrapping it inside an object. This operation happens automatically when you assign a value type to a variable of type `object` or any interface type implemented by the value type.

Let's see boxing in action:

```csharp
// Boxing: Value type to reference type conversion
int number = 42;  // Value type
object boxedNumber = number;  // Boxing operation, number is copied to the heap
```

### What Happens During Boxing

When boxing occurs:

1. Memory is allocated on the managed heap to store the value
2. The value is copied from the stack to the newly allocated heap memory
3. A reference to this heap memory is returned

## What is Unboxing?

**Unboxing** is the opposite process - extracting the value type from an object reference. This requires an explicit cast and can throw an `InvalidCastException` if the object reference doesn't contain the correct value type.

```csharp
// Unboxing: Reference type back to value type
object boxedValue = 42;  // A boxed integer
int unboxedValue = (int)boxedValue;  // Unboxing operation with explicit cast
```

### What Happens During Unboxing

When unboxing occurs:

1. The runtime checks if the object reference contains a boxed value of the specified value type
2. If the check succeeds, the value is copied from the heap back to the stack
3. If the check fails, an InvalidCastException is thrown

## Boxing and Unboxing in Action

Let's see a complete example showing both operations:

```csharp
using System;

class BoxingUnboxingDemo
{
    static void Main()
    {
        // Value type
        int originalValue = 100;
        Console.WriteLine($"Original value: {originalValue}");
        Console.WriteLine($"Type: {originalValue.GetType()}");
        
        // Boxing - implicit conversion to object
        object boxedValue = originalValue;
        Console.WriteLine($"Boxed value: {boxedValue}");
        Console.WriteLine($"Boxed type: {boxedValue.GetType()}");
        
        // Unboxing - explicit conversion back to int
        int unboxedValue = (int)boxedValue;
        Console.WriteLine($"Unboxed value: {unboxedValue}");
        Console.WriteLine($"Unboxed type: {unboxedValue.GetType()}");
        
        // Failed unboxing example
        try
        {
            object stringObject = "This is not an integer";
            int invalidCast = (int)stringObject; // This will throw InvalidCastException
        }
        catch (InvalidCastException ex)
        {
            Console.WriteLine($"Error during unboxing: {ex.Message}");
        }
    }
}
```

**Output:**
```
Original value: 100
Type: System.Int32
Boxed value: 100
Boxed type: System.Int32
Unboxed value: 100
Unboxed type: System.Int32
Error during unboxing: Unable to cast object of type 'System.String' to type 'System.Int32'.
```

## Performance Implications

Boxing and unboxing have performance implications that you should be aware of:

1. **Memory Allocation**: Boxing operations allocate memory on the heap, which can lead to increased garbage collection pressure.
2. **CPU Time**: Both operations require copying data and type checking, which takes CPU time.
3. **Multiple Operations**: Repeated boxing and unboxing in loops can severely impact performance.

Let's measure the performance impact:

```csharp
using System;
using System.Diagnostics;

class BoxingPerformanceDemo
{
    static void Main()
    {
        const int iterations = 10000000;
        Stopwatch stopwatch = new Stopwatch();
        
        // Without boxing
        stopwatch.Start();
        int sum1 = 0;
        for (int i = 0; i < iterations; i++)
        {
            sum1 += i;
        }
        stopwatch.Stop();
        Console.WriteLine($"Without boxing: {stopwatch.ElapsedMilliseconds} ms");
        
        // With boxing and unboxing
        stopwatch.Restart();
        int sum2 = 0;
        for (int i = 0; i < iterations; i++)
        {
            object boxed = i;     // Boxing
            sum2 += (int)boxed;   // Unboxing
        }
        stopwatch.Stop();
        Console.WriteLine($"With boxing/unboxing: {stopwatch.ElapsedMilliseconds} ms");
    }
}
```

**Output (approximate):**
```
Without boxing: 8 ms
With boxing/unboxing: 475 ms
```

The example shows how boxing and unboxing can make your code significantly slower.

## Common Scenarios for Boxing and Unboxing

Boxing and unboxing commonly occur in these situations:

### 1. Working with Collections that Store Objects

When adding value types to non-generic collections:

```csharp
// Non-generic collection causes boxing
ArrayList list = new ArrayList();
list.Add(42);    // Boxing occurs here
int value = (int)list[0];  // Unboxing occurs here

// Generic collection avoids boxing
List<int> genericList = new List<int>();
genericList.Add(42);    // No boxing
int genericValue = genericList[0];  // No unboxing
```

### 2. Using Methods that Accept Object Parameters

```csharp
// This causes boxing because Console.WriteLine has overloads that accept object
int number = 100;
Console.WriteLine(number);  // Boxing occurs internally

// Using string interpolation also boxes value types
Console.WriteLine($"The value is {number}");  // Boxing occurs for number
```

### 3. Working with Interfaces

When a value type implements an interface:

```csharp
int number = 42;
IComparable comparable = number;  // Boxing occurs
int result = comparable.CompareTo(50);  // Uses the boxed value
```

## How to Avoid Unnecessary Boxing and Unboxing

### 1. Use Generics

Generics allow you to create type-safe code without boxing:

```csharp
// Without generics - causes boxing
ArrayList normalList = new ArrayList();
normalList.Add(10);  // Boxing occurs
int value = (int)normalList[0];  // Unboxing occurs

// With generics - no boxing
List<int> genericList = new List<int>();
genericList.Add(10);  // No boxing
int genericValue = genericList[0];  // No unboxing
```

### 2. Use Specific Method Overloads

Many framework methods have specific overloads for common value types:

```csharp
int number = 42;

// Causes boxing
string result1 = Convert.ToString((object)number);

// No boxing - uses specific overload
string result2 = number.ToString();
```

### 3. Use Value Type Constraints in Generic Methods

```csharp
// T can be any type, might cause boxing for value types
public void ProcessItem<T>(T item) 
{ 
    object obj = item;  // Boxing if T is a value type
    // Process obj
}

// T must be a struct (value type), prevents boxing in some cases
public void ProcessValueType<T>(T item) where T : struct 
{ 
    // Process item directly without boxing
}
```

## Summary

Boxing and unboxing are essential concepts in C# that allow for a unified type system where value types can be treated as objects when needed. However, they come with performance costs:

- **Boxing**: Converts value types to reference types by wrapping them in an object on the heap
- **Unboxing**: Extracts the value type from a boxed object using an explicit cast
- Both operations have performance implications due to memory allocation and copying
- Modern C# code minimizes boxing and unboxing through features like generics

Understanding boxing and unboxing helps you write more efficient code by recognizing potential performance bottlenecks, especially in high-performance or high-volume applications.

## Exercises

1. Write a program that demonstrates the difference in memory usage between boxed and unboxed value types.
2. Create a function that counts how many boxing operations occur in a given code block.
3. Refactor a method that uses `ArrayList` to use `List<T>` instead to avoid boxing.
4. Write a benchmark comparing the performance of generic and non-generic collections with value types.

## Additional Resources

- [Microsoft Documentation on Boxing and Unboxing](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing)
- [C# Performance Tips: Avoiding Boxing and Unboxing](https://docs.microsoft.com/en-us/dotnet/framework/performance/performance-tips)
- [Memory management in .NET](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/memory-management-and-gc)