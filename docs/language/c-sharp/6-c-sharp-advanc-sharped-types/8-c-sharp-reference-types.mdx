---
title: C# Reference Types
description: Learn all about reference types in C#, how they work in memory, and how to properly use them in your programs

---

# C# Reference Types

## Introduction

In C#, types are categorized into two main categories: value types and reference types. Understanding reference types is fundamental to becoming proficient in C# programming as they behave differently from value types in terms of memory allocation, assignment operations, and method parameters.

Reference types don't store their data directly in the variable. Instead, they store a reference (or address) to a location in memory where the actual data is kept. This key distinction impacts how they behave throughout your application.

## What Are Reference Types?

In C#, the following are reference types:

- Classes
- Interfaces
- Delegates
- Arrays
- Records (reference type record)
- String

When you create an instance of a reference type, the memory for the actual data is allocated on the **heap**, while the reference to this memory is stored on the **stack** (for local variables) or in the heap (for fields of other objects).

## How Reference Types Work in Memory

Let's understand the memory allocation of reference types with a simple example:

```csharp
// Declaring a reference type variable
Person person1;  // At this point, person1 contains null

// Creating a new instance of Person class
person1 = new Person("John", 30);  // Memory is allocated on heap, address stored in person1
```

When you declare a reference type variable without initializing it, it contains a special value called `null`. The `null` value indicates that the variable doesn't refer to any object yet.

When you create a new instance using the `new` keyword, C# allocates memory on the heap for the object and stores the memory address in your variable.

## Reference Types vs. Value Types

Let's compare reference types with value types to understand the differences:

```csharp
// Reference type example
Person person1 = new Person("John", 30);
Person person2 = person1;  // Both variables reference the same object

person2.Name = "Jane";  // Changes the Name property for both variables
Console.WriteLine(person1.Name);  // Output: "Jane"

// Value type example
int number1 = 10;
int number2 = number1;  // The value is copied

number2 = 20;  // Only number2 is changed
Console.WriteLine(number1);  // Output: 10
```

In this example:
- When we assign `person1` to `person2`, both variables point to the same object.
- When we assign `number1` to `number2`, the value is copied.

This is the fundamental difference between reference types and value types.

## Common Reference Types in C#

### Classes

Classes are the most common reference types in C#:

```csharp
public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    
    public void Greet()
    {
        Console.WriteLine($"Hello, my name is {Name} and I'm {Age} years old.");
    }
}

// Using the class
Person person = new Person("Alice", 25);
person.Greet();  // Output: Hello, my name is Alice and I'm 25 years old.
```

### Strings

Although strings are immutable, they are reference types:

```csharp
string message1 = "Hello";
string message2 = message1;

// Despite being a reference type, strings behave uniquely due to immutability
message2 = "World";

Console.WriteLine(message1);  // Output: Hello
Console.WriteLine(message2);  // Output: World
```

Despite `string` being a reference type, it behaves similar to value types in this example due to its immutability. When we change `message2`, a new string is created rather than modifying the original.

### Arrays

Arrays are always reference types, even when they store value types:

```csharp
int[] numbers1 = { 1, 2, 3 };
int[] numbers2 = numbers1;  // Both variables reference the same array

numbers2[0] = 100;  // Changes the first element in both arrays
Console.WriteLine(numbers1[0]);  // Output: 100
```

### Interfaces

Interfaces are reference types that define a contract for classes:

```csharp
public interface IDrawable
{
    void Draw();
}

public class Circle : IDrawable
{
    public void Draw()
    {
        Console.WriteLine("Drawing a circle");
    }
}

// Using an interface reference
IDrawable shape = new Circle();
shape.Draw();  // Output: Drawing a circle
```

## The `null` Value

Reference types can be assigned the `null` value, which means they don't reference any object:

```csharp
Person person = null;

// This would cause a NullReferenceException at runtime
// person.Greet();

// Safe way to check before using the object
if (person != null)
{
    person.Greet();
}

// Using the null-conditional operator (C# 6.0+)
person?.Greet();  // No exception, method simply isn't called

// Using the null-coalescing operator (C# 8.0+)
Person defaultPerson = new Person("Default", 0);
(person ?? defaultPerson).Greet();  // Uses defaultPerson if person is null
```

## Reference Types as Method Parameters

When passing reference types to methods, changes to the object's properties inside the method will affect the original object:

```csharp
public static void ModifyPerson(Person p)
{
    p.Name = "Modified";  // This changes the original object
}

Person person = new Person("Original", 30);
Console.WriteLine(person.Name);  // Output: Original

ModifyPerson(person);
Console.WriteLine(person.Name);  // Output: Modified
```

However, reassigning the parameter itself doesn't affect the original variable:

```csharp
public static void ReassignPerson(Person p)
{
    p = new Person("New Person", 40);  // Reassignment only affects local variable p
}

Person person = new Person("Original", 30);
ReassignPerson(person);
Console.WriteLine(person.Name);  // Output: Original (unchanged)
```

## Reference Type Best Practices

1. **Always check for null before using a reference type:**

```csharp
if (person != null)
{
    person.Greet();
}
// Or use the null-conditional operator
person?.Greet();
```

2. **Consider making classes immutable when appropriate:**

```csharp
public class ImmutablePerson
{
    public string Name { get; }
    public int Age { get; }
    
    public ImmutablePerson(string name, int age)
    {
        Name = name;
        Age = age;
    }
    
    // Creates a new instance instead of modifying
    public ImmutablePerson WithName(string newName)
    {
        return new ImmutablePerson(newName, this.Age);
    }
}
```

3. **Implement proper disposal patterns for reference types that use unmanaged resources:**

```csharp
public class ResourceHandler : IDisposable
{
    private bool disposed = false;
    private IntPtr resource; // Unmanaged resource
    
    public ResourceHandler()
    {
        // Acquire resource
        resource = AllocateResource();
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!disposed)
        {
            if (disposing)
            {
                // Free managed resources
            }
            
            // Free unmanaged resources
            FreeResource(resource);
            disposed = true;
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    ~ResourceHandler()
    {
        Dispose(false);
    }
    
    // Simulated methods for resource management
    private IntPtr AllocateResource() => IntPtr.Zero;
    private void FreeResource(IntPtr ptr) { }
}

// Using the disposable reference type
using (var handler = new ResourceHandler())
{
    // Use handler
} // handler.Dispose() called automatically
```

## Real-World Example: Building a Task Management System

Let's look at a practical example of reference types in a task management application:

```csharp
public class Task
{
    public string Title { get; set; }
    public string Description { get; set; }
    public DateTime DueDate { get; set; }
    public bool IsCompleted { get; set; }
    
    public Task(string title, DateTime dueDate)
    {
        Title = title;
        DueDate = dueDate;
        IsCompleted = false;
    }
}

public class TaskList
{
    private List<Task> tasks = new List<Task>();
    
    public void AddTask(Task task)
    {
        tasks.Add(task);
    }
    
    public void MarkAsCompleted(int index)
    {
        if (index >= 0 && index < tasks.Count)
        {
            tasks[index].IsCompleted = true;
        }
    }
    
    public void DisplayTasks()
    {
        Console.WriteLine("Task List:");
        for (int i = 0; i < tasks.Count; i++)
        {
            string status = tasks[i].IsCompleted ? "[X]" : "[ ]";
            Console.WriteLine($"{i+1}. {status} {tasks[i].Title} (Due: {tasks[i].DueDate.ToShortDateString()})");
        }
    }
}
```

Usage:

```csharp
// Create a task list
TaskList myTasks = new TaskList();

// Add tasks
Task task1 = new Task("Learn C# reference types", DateTime.Now.AddDays(1));
myTasks.AddTask(task1);
myTasks.AddTask(new Task("Complete programming assignment", DateTime.Now.AddDays(3)));

// Display tasks
myTasks.DisplayTasks();

// Mark a task as completed
myTasks.MarkAsCompleted(0);

// Display updated tasks
myTasks.DisplayTasks();
```

Output:
```
Task List:
1. [ ] Learn C# reference types (Due: 5/15/2023)
2. [ ] Complete programming assignment (Due: 5/17/2023)
Task List:
1. [X] Learn C# reference types (Due: 5/15/2023)
2. [ ] Complete programming assignment (Due: 5/17/2023)
```

In this example, `Task` and `TaskList` are reference types. When we mark a task as completed, we're modifying the original `Task` object, and this change is reflected when we display the tasks again.

## Summary

Understanding reference types is crucial for C# developers:

- Reference types store a reference to data on the heap rather than the data itself
- Multiple variables can reference the same object, so changes through one variable affect all references
- Common reference types include classes, interfaces, arrays, delegates, and strings
- Reference types can be `null`, requiring checks before use to prevent exceptions
- When passing reference types to methods, changes to the object's properties affect the original object

This understanding forms the foundation for more advanced topics like inheritance, polymorphism, and working with collections in C#.

## Exercises

1. Create a `Book` class with properties for title, author, and publication year. Then write code that demonstrates how changes to a book object through one reference affect other references to the same object.

2. Implement a simple `ShoppingCart` class that uses a list of `Product` objects. Add methods to add products, remove products, and calculate the total price.

3. Create a method that takes a reference type parameter and try to understand what happens when you reassign the parameter inside the method versus changing its properties.

## Additional Resources

- [Official Microsoft Documentation on Reference Types](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/reference-types)
- [C# Memory Management for Reference Types](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/)
- [C# Programming Guide: Classes](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/classes)