---
title: C# Type Testing
description: Learn how to test and verify types in C# using operators like is, as, typeof, and GetType() to write safer and more robust code.

---

# C# Type Testing

In C# programming, understanding the type of an object at runtime is a powerful capability. Type testing allows you to verify an object's type, perform safe type conversions, and build flexible code that handles different data types appropriately. This knowledge is especially important when working with inheritance, polymorphism, and collections of mixed types.

## Introduction to Type Testing

Type testing in C# refers to the techniques used to:
- Determine if an object is of a specific type
- Check compatibility between types
- Convert objects from one type to another safely
- Make decisions based on an object's actual type at runtime

The .NET framework provides several mechanisms for type testing, each with specific use cases and behaviors:
- The `is` operator
- The `as` operator
- The `typeof` operator
- The `GetType()` method
- Pattern matching (introduced in newer versions of C#)

## The `is` Operator

The `is` operator checks if an object is compatible with a given type. It returns `true` if the object is of the specified type or can be converted to that type; otherwise, it returns `false`.

### Basic Usage

```csharp
object data = "Hello, World!";
bool isString = data is string;  // true
bool isInt = data is int;        // false

Console.WriteLine($"Is data a string? {isString}");
Console.WriteLine($"Is data an integer? {isInt}");
```

Output:
```
Is data a string? True
Is data an integer? False
```

### Type Testing with Inheritance

```csharp
// Base class
class Animal 
{
    public string Name { get; set; }
}

// Derived classes
class Dog : Animal 
{
    public void Bark() => Console.WriteLine("Woof!");
}

class Cat : Animal 
{
    public void Meow() => Console.WriteLine("Meow!");
}

// Usage
Animal myPet = new Dog { Name = "Rex" };

if (myPet is Dog)
{
    Console.WriteLine($"{myPet.Name} is a dog");
    Dog dog = (Dog)myPet;
    dog.Bark();
}
else if (myPet is Cat)
{
    Console.WriteLine($"{myPet.Name} is a cat");
    Cat cat = (Cat)myPet;
    cat.Meow();
}
```

Output:
```
Rex is a dog
Woof!
```

## Pattern Matching with `is` (C# 7.0+)

C# 7.0 enhanced the `is` operator with pattern matching capabilities, allowing you to test and extract values in a single operation:

```csharp
object value = "Hello";

// Type pattern with variable declaration
if (value is string message)
{
    // Variable 'message' is in scope and already cast to string
    Console.WriteLine($"Length of the string: {message.Length}");
}

// Combined with null check
if (value is string text && text.Length > 5)
{
    Console.WriteLine("This is a string longer than 5 characters");
}
```

Output:
```
Length of the string: 5
```

## The `as` Operator

The `as` operator attempts to cast an object to a specified type, returning `null` if the cast is not possible (instead of throwing an exception like a traditional cast).

### Basic Usage

```csharp
object data = "Hello, World!";

string message = data as string;  // Works, returns "Hello, World!"
int? number = data as int?;      // Returns null (can't convert string to int)

Console.WriteLine($"String value: {message ?? "null"}");
Console.WriteLine($"Integer value: {number?.ToString() ?? "null"}");
```

Output:
```
String value: Hello, World!
Integer value: null
```

### Safe Type Conversion Pattern

```csharp
object obj = new Dog { Name = "Buddy" };

// Safer alternative to direct casting
Dog dog = obj as Dog;
if (dog != null)
{
    Console.WriteLine($"Dog's name: {dog.Name}");
    dog.Bark();
}

// This would throw an exception if obj isn't a Cat
// Cat cat = (Cat)obj;  // Avoid this!

// Instead, use the safer approach:
Cat cat = obj as Cat;
if (cat != null)
{
    Console.WriteLine($"Cat's name: {cat.Name}");
    cat.Meow();
}
else
{
    Console.WriteLine("The object is not a cat");
}
```

Output:
```
Dog's name: Buddy
Woof!
The object is not a cat
```

## The `typeof` Operator

The `typeof` operator returns the `System.Type` object representing a specific type. It's useful for comparing types and reflection operations.

### Comparing Types

```csharp
Type stringType = typeof(string);
Type intType = typeof(int);

Console.WriteLine($"Type name: {stringType.Name}");
Console.WriteLine($"Full name: {stringType.FullName}");
Console.WriteLine($"Is string a value type? {stringType.IsValueType}");
Console.WriteLine($"Is int a value type? {intType.IsValueType}");
```

Output:
```
Type name: String
Full name: System.String
Is string a value type? False
Is int a value type? True
```

### Using `typeof` with Generics

```csharp
void PrintTypeInfo<T>()
{
    Type type = typeof(T);
    Console.WriteLine($"Type: {type.Name}");
    Console.WriteLine($"Is reference type: {!type.IsValueType}");
    Console.WriteLine($"Namespace: {type.Namespace}");
}

// Usage
PrintTypeInfo<int>();
PrintTypeInfo<List<string>>();
```

Output:
```
Type: Int32
Is reference type: False
Namespace: System

Type: List`1
Is reference type: True
Namespace: System.Collections.Generic
```

## The `GetType()` Method

The `GetType()` method returns the runtime type of an object. Unlike `typeof`, which requires a compile-time type, `GetType()` works with the actual type of an object at runtime.

### Basic Usage

```csharp
object obj1 = "Hello";
object obj2 = 42;
object obj3 = new List<int>();

Console.WriteLine($"obj1 type: {obj1.GetType().Name}");
Console.WriteLine($"obj2 type: {obj2.GetType().Name}");
Console.WriteLine($"obj3 type: {obj3.GetType().Name}");
```

Output:
```
obj1 type: String
obj2 type: Int32
obj3 type: List`1
```

### Comparing `typeof` vs `GetType()`

```csharp
Animal myPet = new Dog();

// GetType() returns the actual runtime type
Console.WriteLine($"myPet.GetType(): {myPet.GetType().Name}");  // Dog

// typeof returns the compile-time type
Console.WriteLine($"typeof(Animal): {typeof(Animal).Name}");    // Animal

// Type comparison
bool isExactlyDogType = myPet.GetType() == typeof(Dog);      // true
bool isAnimalType = myPet.GetType() == typeof(Animal);        // false

Console.WriteLine($"Is exactly Dog type? {isExactlyDogType}");
Console.WriteLine($"Is exactly Animal type? {isAnimalType}");
```

Output:
```
myPet.GetType(): Dog
typeof(Animal): Animal
Is exactly Dog type? True
Is exactly Animal type? False
```

## Practical Applications

### Safe Casting in Collections

```csharp
List<Animal> pets = new List<Animal>
{
    new Dog { Name = "Buddy" },
    new Cat { Name = "Whiskers" },
    new Dog { Name = "Rex" }
};

foreach (Animal pet in pets)
{
    Console.WriteLine($"Processing {pet.Name}...");
    
    // Using is operator with pattern matching
    if (pet is Dog dog)
    {
        Console.WriteLine("This is a dog!");
        dog.Bark();
    }
    else if (pet is Cat cat)
    {
        Console.WriteLine("This is a cat!");
        cat.Meow();
    }
    
    Console.WriteLine();
}
```

Output:
```
Processing Buddy...
This is a dog!
Woof!

Processing Whiskers...
This is a cat!
Meow!

Processing Rex...
This is a dog!
Woof!
```

### Factory Method Pattern

```csharp
public class ShapeFactory
{
    public static Shape CreateShape(string shapeType)
    {
        return shapeType.ToLower() switch
        {
            "circle" => new Circle(),
            "rectangle" => new Rectangle(),
            "triangle" => new Triangle(),
            _ => throw new ArgumentException($"Unknown shape: {shapeType}")
        };
    }
}

public abstract class Shape
{
    public abstract void Draw();
}

public class Circle : Shape
{
    public override void Draw() => Console.WriteLine("Drawing a circle");
}

public class Rectangle : Shape
{
    public override void Draw() => Console.WriteLine("Drawing a rectangle");
}

public class Triangle : Shape
{
    public override void Draw() => Console.WriteLine("Drawing a triangle");
}

// Usage
var shapes = new List<string> { "Circle", "Rectangle", "Triangle" };

foreach (var shapeName in shapes)
{
    Shape shape = ShapeFactory.CreateShape(shapeName);
    
    // Use type testing to provide additional functionality
    if (shape is Circle)
    {
        Console.WriteLine("This is a round shape");
    }
    else if (shape is Rectangle rect)
    {
        Console.WriteLine("This is a four-sided shape");
    }
    
    shape.Draw();
    Console.WriteLine();
}
```

Output:
```
This is a round shape
Drawing a circle

This is a four-sided shape
Drawing a rectangle

Drawing a triangle
```

### Plugin System

```csharp
public interface IPlugin
{
    string Name { get; }
    void Execute();
}

public class TextPlugin : IPlugin
{
    public string Name => "Text Plugin";
    public void Execute() => Console.WriteLine("Processing text...");
}

public class ImagePlugin : IPlugin
{
    public string Name => "Image Plugin";
    public void Execute() => Console.WriteLine("Processing image...");
}

// Plugin manager
public class PluginManager
{
    private List<IPlugin> _plugins = new List<IPlugin>();
    
    public void RegisterPlugin(IPlugin plugin)
    {
        _plugins.Add(plugin);
        Console.WriteLine($"Registered: {plugin.Name}");
    }
    
    public void ExecutePlugins(Type pluginType)
    {
        foreach (var plugin in _plugins)
        {
            // Check if plugin is of the requested type
            if (pluginType.IsInstanceOfType(plugin))
            {
                Console.WriteLine($"Executing {plugin.Name}");
                plugin.Execute();
            }
        }
    }
}

// Usage
PluginManager manager = new PluginManager();
manager.RegisterPlugin(new TextPlugin());
manager.RegisterPlugin(new ImagePlugin());

Console.WriteLine("\nExecuting all text plugins:");
manager.ExecutePlugins(typeof(TextPlugin));

Console.WriteLine("\nExecuting all plugins:");
manager.ExecutePlugins(typeof(IPlugin));
```

Output:
```
Registered: Text Plugin
Registered: Image Plugin

Executing all text plugins:
Executing Text Plugin
Processing text...

Executing all plugins:
Executing Text Plugin
Processing text...
Executing Image Plugin
Processing image...
```

## Summary

Type testing in C# is a fundamental technique for writing flexible, robust code that can adapt to different types of data at runtime. Here's a recap of the key type testing mechanisms:

- **`is` operator**: Tests if an object is compatible with a given type, returning a boolean result.
- **Pattern matching with `is`**: Combines type testing with variable declaration for cleaner code.
- **`as` operator**: Performs safe type conversion, returning null instead of throwing exceptions.
- **`typeof` operator**: Returns the System.Type of a compile-time type.
- **`GetType()` method**: Returns the actual runtime type of an object.

By mastering these type testing mechanisms, you can write more flexible code that handles different types safely and effectively. Type testing is particularly valuable when working with inheritance hierarchies, polymorphism, and collections of heterogeneous objects.

## Additional Resources

- [C# Documentation: is operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/is)
- [C# Documentation: as operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#as-operator)
- [C# Documentation: typeof operator](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#typeof-operator)
- [Pattern Matching in C#](https://docs.microsoft.com/en-us/dotnet/csharp/pattern-matching)

## Exercises

1. Create a class hierarchy with at least 3 levels of inheritance, then write code that uses the `is` operator to identify objects at each level.
2. Write a function that takes an `object` parameter and returns different results based on whether it's a string, number, or collection type.
3. Implement a simple plugin system where plugins can be registered and executed based on their type.
4. Create a generic method that uses `typeof(T)` to print information about the generic type parameter.
5. Write a program that demonstrates the difference between `is` operator and direct type casting with exceptions handling.