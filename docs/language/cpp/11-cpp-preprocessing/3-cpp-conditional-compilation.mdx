---
title: C++ Conditional Compilation
description: Learn how to use preprocessor directives for conditional compilation in C++. Master #ifdef, #ifndef, #if, #elif, #else, and #endif to create flexible code that can adapt to different platforms, configurations, and debugging needs.

---

# C++ Conditional Compilation

## Introduction

Conditional compilation is a powerful feature in C++ that allows you to selectively include or exclude portions of your code during the compilation process. This is made possible through preprocessor directives, which are commands that tell the preprocessor how to handle your code before the actual compilation begins.

Conditional compilation serves several important purposes in C++ development:

- **Platform-specific code**: Write code that works across different operating systems
- **Debug/Release variants**: Include debugging code only in development builds
- **Feature toggles**: Enable or disable features based on configuration options
- **Optimizing code**: Change implementation details based on compiler or architecture

In this guide, we'll explore the various preprocessor directives used for conditional compilation and learn how to apply them effectively in your C++ projects.

## Basic Preprocessor Directives for Conditional Compilation

Before diving into examples, let's understand the key directives used for conditional compilation:

| Directive | Purpose |
|-----------|---------|
| `#ifdef` | Checks if a macro has been defined |
| `#ifndef` | Checks if a macro has not been defined |
| `#if` | Evaluates an expression and includes code if it's true (non-zero) |
| `#else` | Provides an alternative block of code |
| `#elif` | Combines `#else` and `#if` for multiple conditions |
| `#endif` | Marks the end of a conditional block |
| `#define` | Defines a macro |
| `#undef` | Undefines a previously defined macro |

## Using `#ifdef` and `#ifndef`

The simplest form of conditional compilation uses `#ifdef` (if defined) and `#ifndef` (if not defined) to check whether a particular macro has been defined.

### Example: Simple Debug Code

```cpp
#include <iostream>

// Define DEBUG macro (typically done via compiler flags)
#define DEBUG

int main() {
    int x = 5;
    
    // This code will only be compiled if DEBUG is defined
    #ifdef DEBUG
    std::cout << "Debug mode is enabled" << std::endl;
    std::cout << "Variable x = " << x << std::endl;
    #endif
    
    std::cout << "Program running..." << std::endl;
    
    return 0;
}
```

**Output**:
```
Debug mode is enabled
Variable x = 5
Program running...
```

If you were to comment out or remove the `#define DEBUG` line, the debug output would not be included in the compiled program.

### Example: Header Guards with `#ifndef`

One of the most common uses of conditional compilation is in header guards, which prevent a header file from being included multiple times:

```cpp
// math_utils.h
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

// All declarations and definitions go here
double square(double x) {
    return x * x;
}

double cube(double x) {
    return x * x * x;
}

#endif // MATH_UTILS_H
```

The first time this header is included, `MATH_UTILS_H` is not defined, so the preprocessor enters the conditional block, defines `MATH_UTILS_H`, and includes the content. If the header is included again in the same compilation unit, `MATH_UTILS_H` is already defined, so the content is skipped.

## Using `#if`, `#elif`, and `#else`

The `#if` directive is more flexible than `#ifdef` as it can evaluate expressions, not just check if a macro is defined.

### Example: Platform-Specific Code

```cpp
#include <iostream>

int main() {
    #if defined(_WIN32) || defined(_WIN64)
        std::cout << "Running on Windows" << std::endl;
        const char* path_separator = "\\";
    #elif defined(__APPLE__)
        std::cout << "Running on macOS" << std::endl;
        const char* path_separator = "/";
    #elif defined(__linux__)
        std::cout << "Running on Linux" << std::endl;
        const char* path_separator = "/";
    #else
        std::cout << "Running on an unknown operating system" << std::endl;
        const char* path_separator = "/";
    #endif
    
    std::cout << "Path separator: " << path_separator << std::endl;
    
    return 0;
}
```

When compiled on different platforms, this program will include different code blocks based on predefined macros that indicate the operating system.

### Example: Version-Dependent Features

```cpp
#include <iostream>

// Define a version number
#define VERSION 201

int main() {
    std::cout << "Application version: " << VERSION << std::endl;
    
    #if VERSION < 100
        std::cout << "Using legacy algorithm" << std::endl;
        // Legacy code here
    #elif VERSION < 200
        std::cout << "Using standard algorithm" << std::endl;
        // Standard implementation
    #else
        std::cout << "Using optimized algorithm" << std::endl;
        // New optimized implementation
    #endif
    
    return 0;
}
```

**Output**:
```
Application version: 201
Using optimized algorithm
```

This approach allows you to maintain backward compatibility while adding new features.

## Predefined Macros

C++ compilers define various macros that provide information about the compilation environment. These can be used with conditional compilation to adapt your code accordingly:

```cpp
#include <iostream>

int main() {
    std::cout << "Compilation information:" << std::endl;
    
    #ifdef __cplusplus
        std::cout << "C++ version: " << __cplusplus << std::endl;
    #endif
    
    #ifdef __GNUC__
        std::cout << "GCC version: " << __GNUC__ << "." << __GNUC_MINOR__ << "." << __GNUC_PATCHLEVEL__ << std::endl;
    #endif
    
    #ifdef _MSC_VER
        std::cout << "Microsoft Visual C++ version: " << _MSC_VER << std::endl;
    #endif
    
    #ifdef __clang__
        std::cout << "Clang version: " << __clang_major__ << "." << __clang_minor__ << std::endl;
    #endif
    
    return 0;
}
```

When compiled with different compilers, this program will show different outputs based on the available predefined macros.

## Creating Flexible Feature Toggles

Conditional compilation can be used to create feature toggles that can be easily enabled or disabled:

```cpp
#include <iostream>

// Feature toggles
#define ENABLE_LOGGING
#define ADVANCED_MATH
//#define EXPERIMENTAL_FEATURES

// Utility functions based on toggles
#ifdef ENABLE_LOGGING
void log(const std::string& message) {
    std::cout << "[LOG] " << message << std::endl;
}
#else
void log(const std::string&) {
    // Do nothing when logging is disabled
}
#endif

int main() {
    log("Application started");
    
    #ifdef ADVANCED_MATH
    std::cout << "Advanced math features are enabled" << std::endl;
    // Advanced math implementation
    #endif
    
    #ifdef EXPERIMENTAL_FEATURES
    std::cout << "WARNING: Experimental features are enabled!" << std::endl;
    // Experimental code
    #endif
    
    log("Application finished");
    
    return 0;
}
```

**Output**:
```
[LOG] Application started
Advanced math features are enabled
[LOG] Application finished
```

## Advanced Conditional Compilation Techniques

### Using `defined()` Operator

The `defined()` operator can be used within `#if` directives to check if a macro is defined:

```cpp
#include <iostream>

// Define some feature flags
#define FEATURE_A
//#define FEATURE_B

int main() {
    #if defined(FEATURE_A) && !defined(FEATURE_B)
        std::cout << "Feature A is enabled, but Feature B is disabled" << std::endl;
    #elif defined(FEATURE_A) && defined(FEATURE_B)
        std::cout << "Both Feature A and Feature B are enabled" << std::endl;
    #elif !defined(FEATURE_A) && defined(FEATURE_B)
        std::cout << "Feature A is disabled, but Feature B is enabled" << std::endl;
    #else
        std::cout << "Both Feature A and Feature B are disabled" << std::endl;
    #endif
    
    return 0;
}
```

**Output**:
```
Feature A is enabled, but Feature B is disabled
```

### Checking Macro Values

You can also check the values of macros in conditional compilation:

```cpp
#include <iostream>

#define LOGGING_LEVEL 2

int main() {
    #if LOGGING_LEVEL == 0
        std::cout << "Logging disabled" << std::endl;
        #define LOG(msg)
    #elif LOGGING_LEVEL == 1
        std::cout << "Basic logging enabled" << std::endl;
        #define LOG(msg) std::cout << "LOG: " << msg << std::endl
    #elif LOGGING_LEVEL >= 2
        std::cout << "Verbose logging enabled" << std::endl;
        #define LOG(msg) std::cout << "LOG [" << __FILE__ << ":" << __LINE__ << "]: " << msg << std::endl
    #endif
    
    // Usage
    LOG("Testing the logging system");
    
    return 0;
}
```

**Output**:
```
Verbose logging enabled
LOG [main.cpp:19]: Testing the logging system
```

## Real-World Applications

### Cross-Platform Development

```cpp
#include <iostream>
#include <string>

std::string getTempDirectory() {
    #if defined(_WIN32) || defined(_WIN64)
        return "C:\\Windows\\Temp\\";
    #elif defined(__APPLE__)
        return "/private/tmp/";
    #elif defined(__linux__)
        return "/tmp/";
    #else
        #error "Unsupported platform"
    #endif
}

int main() {
    std::cout << "Temporary directory: " << getTempDirectory() << std::endl;
    return 0;
}
```

### Debug vs. Release Builds

```cpp
#include <iostream>
#include <vector>
#include <chrono>

#ifdef NDEBUG
    // Release mode - NDEBUG is defined by the compiler in release builds
    #define ASSERT(condition) ((void)0)
    #define MEASURE_TIME(func) func
#else
    // Debug mode
    #define ASSERT(condition) \
        if (!(condition)) { \
            std::cerr << "Assertion failed: " << #condition << " at " << __FILE__ << ":" << __LINE__ << std::endl; \
            std::terminate(); \
        }
    
    #define MEASURE_TIME(func) \
        { \
            auto start = std::chrono::high_resolution_clock::now(); \
            func; \
            auto end = std::chrono::high_resolution_clock::now(); \
            std::chrono::duration<double, std::milli> duration = end - start; \
            std::cout << "Execution time of " << #func << ": " << duration.count() << " ms" << std::endl; \
        }
#endif

std::vector<int> createAndSortVector(int size) {
    std::vector<int> vec;
    for (int i = 0; i < size; ++i) {
        vec.push_back(size - i);
    }
    
    ASSERT(vec.size() == static_cast<size_t>(size));
    
    // Sort the vector
    std::sort(vec.begin(), vec.end());
    
    return vec;
}

int main() {
    MEASURE_TIME(auto vec = createAndSortVector(10000));
    return 0;
}
```

In debug mode, this program will include assertions and time measurements, while in release mode (when `NDEBUG` is defined), these debugging features are stripped out.

## Practical Tips and Best Practices

1. **Keep conditional blocks small**: Large blocks of conditional code can make your codebase harder to read and maintain
2. **Use meaningful macro names**: Choose clear, descriptive names for macros to make your code self-documenting
3. **Document your macros**: Add comments explaining what each macro does and how it affects the compilation
4. **Don't nest too deeply**: Excessive nesting of conditional directives can make code difficult to follow
5. **Consider alternatives**: For runtime decisions, regular if/else statements might be more appropriate
6. **Be careful with macro definitions**: Macros can cause unexpected behavior if not used carefully
7. **Use header guards consistently**: Always protect header files from multiple inclusion

## Summary

Conditional compilation is an essential tool in C++ that allows you to create flexible, adaptable code that can:

- Work across different platforms and environments
- Include or exclude debugging features
- Toggle functionality based on configuration options
- Optimize code for different compilers or architectures

By mastering preprocessor directives like `#ifdef`, `#ifndef`, `#if`, `#elif`, `#else`, and `#endif`, you can write more versatile C++ programs that adapt to various compilation environments.

## Additional Resources

- [cppreference - Conditionals](https://en.cppreference.com/w/cpp/preprocessor/conditional)
- [C++ Core Guidelines: Pre.7-10 (Preprocessor rules)](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#pre7-use-the-preprocessor-sparingly)
- [Microsoft: Preprocessor Directives](https://docs.microsoft.com/en-us/cpp/preprocessor/preprocessor-directives)

## Exercises

1. Create a simple program that uses conditional compilation to print different messages based on the current day of the week (define a `WEEKDAY` macro).

2. Implement a logging system with different levels (ERROR, WARNING, INFO, DEBUG) using conditional compilation.

3. Write a cross-platform function that returns the user's home directory path for Windows, macOS, and Linux.

4. Create a header file with proper include guards and use it in multiple source files to ensure it works correctly.

5. Build a program with optional features that can be enabled or disabled using preprocessor directives, and experiment with different combinations of features.