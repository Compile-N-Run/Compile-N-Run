---
title: "JavaScript Reflect"
description: "Learn about JavaScript's Reflect API, a built-in object that provides methods for interceptable JavaScript operations and works as a companion to Proxy objects."

---

# JavaScript Reflect

## Introduction to the Reflect API

The Reflect API was introduced in ES6 (ES2015) as part of JavaScript's enhanced metaprogramming capabilities. It provides a collection of static methods that expose JavaScript's internal operations, allowing you to perform various tasks that were previously done through less direct means.

The Reflect object serves as a companion to the Proxy object, making it easier to create proxies and forwarding default operations from the handler to the target. Unlike most global objects, Reflect is not a constructor - you can't use it with the `new` operator or invoke it as a function.

## Why Use Reflect?

There are several reasons to use the Reflect API:

1. **Cleaner metaprogramming** - More reliable ways to perform operations like property lookup, property assignment, and function invocation
2. **Fallback operations** with Proxy handlers
3. **More intuitive function application** than `Function.prototype.apply()`
4. **More reliable versions** of certain Object methods
5. **Predictable return values** that are more consistent than their Object method equivalents

## Basic Reflect Methods

Let's explore some of the most commonly used Reflect methods:

### Reflect.get()

This method retrieves a property from an object. It's like using dot notation or bracket notation, but as a function.

```js
const person = {
  name: 'Alice',
  age: 30
};

// Traditional property access
console.log(person.name); // Output: Alice

// Using Reflect.get()
console.log(Reflect.get(person, 'name')); // Output: Alice
console.log(Reflect.get(person, 'age')); // Output: 30
```

### Reflect.set()

This method sets a property on an object. It's like assignment using dot or bracket notation.

```js
const person = {
  name: 'Alice',
  age: 30
};

// Traditional property assignment
person.age = 31;
console.log(person.age); // Output: 31

// Using Reflect.set()
Reflect.set(person, 'name', 'Bob');
console.log(person.name); // Output: Bob

// Reflect.set() returns a boolean indicating success
const success = Reflect.set(person, 'age', 32);
console.log(success); // Output: true
console.log(person.age); // Output: 32
```

### Reflect.has()

Checks if an object has a specific property. This is the functional equivalent of the `in` operator.

```js
const person = {
  name: 'Alice',
  age: 30
};

// Traditional 'in' operator
console.log('name' in person); // Output: true

// Using Reflect.has()
console.log(Reflect.has(person, 'name')); // Output: true
console.log(Reflect.has(person, 'address')); // Output: false
```

### Reflect.deleteProperty()

Deletes a property from an object. This is the functional equivalent of the `delete` operator.

```js
const person = {
  name: 'Alice',
  age: 30,
  address: '123 Main St'
};

// Traditional delete operator
delete person.address;
console.log(person.address); // Output: undefined

// Using Reflect.deleteProperty()
const deleted = Reflect.deleteProperty(person, 'age');
console.log(deleted); // Output: true
console.log(person.age); // Output: undefined
```

### Reflect.apply()

Calls a function with specified arguments and `this` value.

```js
function greet(greeting) {
  return `${greeting}, ${this.name}!`;
}

const person = { name: 'Alice' };

// Traditional Function.prototype.apply()
console.log(greet.apply(person, ['Hello'])); // Output: Hello, Alice!

// Using Reflect.apply()
console.log(Reflect.apply(greet, person, ['Hi'])); // Output: Hi, Alice!
```

## Advanced Reflect Methods

### Reflect.construct()

Creates a new instance of a constructor function, similar to the `new` operator.

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

// Traditional new operator
const alice = new Person('Alice', 30);
console.log(alice); // Output: Person { name: 'Alice', age: 30 }

// Using Reflect.construct()
const bob = Reflect.construct(Person, ['Bob', 25]);
console.log(bob); // Output: Person { name: 'Bob', age: 25 }
```

### Reflect.defineProperty()

Defines a new property on an object, or modifies an existing one. Similar to `Object.defineProperty()` but returns a boolean instead of the object.

```js
const person = {};

// Traditional Object.defineProperty()
Object.defineProperty(person, 'name', {
  value: 'Alice',
  writable: true,
  enumerable: true,
  configurable: true
});

// Using Reflect.defineProperty()
const success = Reflect.defineProperty(person, 'age', {
  value: 30,
  writable: true,
  enumerable: true,
  configurable: true
});

console.log(success); // Output: true
console.log(person); // Output: { name: 'Alice', age: 30 }
```

### Reflect.getOwnPropertyDescriptor()

Returns the property descriptor of a property if it exists on the object directly.

```js
const person = { name: 'Alice' };

// Traditional Object.getOwnPropertyDescriptor()
const descriptor1 = Object.getOwnPropertyDescriptor(person, 'name');
console.log(descriptor1);
// Output: { value: 'Alice', writable: true, enumerable: true, configurable: true }

// Using Reflect.getOwnPropertyDescriptor()
const descriptor2 = Reflect.getOwnPropertyDescriptor(person, 'name');
console.log(descriptor2);
// Output: { value: 'Alice', writable: true, enumerable: true, configurable: true }
```

### Reflect.ownKeys()

Returns an array of all own property keys (enumerable or not) of an object.

```js
const person = { name: 'Alice', age: 30 };
Object.defineProperty(person, 'ssn', { value: '123-45-6789', enumerable: false });

// Traditional approach using Object methods
console.log(Object.keys(person)); // Output: ['name', 'age'] (only enumerable)

// Using Reflect.ownKeys()
console.log(Reflect.ownKeys(person)); // Output: ['name', 'age', 'ssn'] (all properties)
```

## Reflect with Proxies

One of the primary use cases for Reflect is to work alongside Proxies. Reflect methods correspond directly to the trap methods in Proxy handlers, making it easy to forward operations to the target object.

```js
const target = {
  name: 'Alice',
  age: 30
};

const handler = {
  get(target, property, receiver) {
    console.log(`Getting property: ${property}`);
    return Reflect.get(target, property, receiver);
  },
  set(target, property, value, receiver) {
    console.log(`Setting property: ${property} to ${value}`);
    return Reflect.set(target, property, value, receiver);
  }
};

const proxy = new Proxy(target, handler);

// Using the proxy
proxy.name; // Logs: Getting property: name
// Output: Alice

proxy.age = 31; // Logs: Setting property: age to 31
// Output: true

console.log(proxy.age); // Logs: Getting property: age
// Output: 31
```

## Real-world Application: Form Validation

Here's a practical example showing how Reflect and Proxy can be used together to create a simple form validation system:

```js
function createFormValidator(initialData) {
  const validators = {
    username: value => value.length >= 3 ? '' : 'Username must be at least 3 characters',
    email: value => /@/.test(value) ? '' : 'Email must contain @',
    password: value => value.length >= 6 ? '' : 'Password must be at least 6 characters'
  };

  const errors = {};
  
  return new Proxy(initialData, {
    set(target, property, value, receiver) {
      // Validate if we have a validator for this field
      if (Reflect.has(validators, property)) {
        const error = validators[property](value);
        if (error) {
          console.log(`Validation error: ${error}`);
          errors[property] = error;
          return true; // We still want to set the value even if invalid
        } else {
          // Clear any previous error
          if (Reflect.has(errors, property)) {
            Reflect.deleteProperty(errors, property);
          }
        }
      }
      
      // Set the value using Reflect
      return Reflect.set(target, property, value, receiver);
    },
    
    get(target, property, receiver) {
      if (property === 'isValid') {
        return Object.keys(errors).length === 0;
      }
      if (property === 'errors') {
        return errors;
      }
      return Reflect.get(target, property, receiver);
    }
  });
}

// Usage
const formData = createFormValidator({
  username: '',
  email: '',
  password: ''
});

formData.username = 'Jo'; // Logs: Validation error: Username must be at least 3 characters
formData.email = 'invalid-email'; // Logs: Validation error: Email must contain @
formData.password = 'abc'; // Logs: Validation error: Password must be at least 6 characters

console.log(formData.isValid); // Output: false
console.log(formData.errors); // Shows all validation errors

// Fix the values
formData.username = 'John';
formData.email = 'john@example.com';
formData.password = 'secret123';

console.log(formData.isValid); // Output: true
console.log(formData.errors); // Output: {}
```

## Performance Considerations

While Reflect methods are powerful, they can introduce some performance overhead compared to direct object operations. For performance-critical code sections, you might want to stick with traditional approaches.

```js
// Performance test for property access
const obj = { prop: 'value' };
const iterations = 1000000;

// Using direct access
console.time('Direct');
for (let i = 0; i < iterations; i++) {
  const value = obj.prop;
}
console.timeEnd('Direct');

// Using Reflect.get
console.time('Reflect');
for (let i = 0; i < iterations; i++) {
  const value = Reflect.get(obj, 'prop');
}
console.timeEnd('Reflect');
```

In most applications, this performance difference is negligible, and the benefits of using Reflect often outweigh the slight performance cost.

## Summary

The JavaScript Reflect API provides powerful metaprogramming capabilities that complement the Proxy API. It offers various methods that give you programmatic access to actions like property access, property definition, and function invocation.

Key benefits of using Reflect include:

1. Better return values (booleans for success/failure instead of throwing errors)
2. Formalized reflection operations that were previously done with less consistent methods
3. Perfect pairing with Proxy handlers, allowing you to easily forward operations
4. More reliable function application than older approaches

As you grow as a JavaScript developer, incorporating Reflect into your toolkit will enable cleaner, more maintainable metaprogramming patterns.

## Further Learning

- Experiment with combining Reflect and Proxy for advanced object manipulation
- Create a data binding system using Reflect and Proxy
- Implement object validation schemas using Reflect methods
- Compare performance between traditional methods and Reflect methods for various operations

## Exercises

1. Create a simple object logging system using Reflect and Proxy that logs all property reads and writes
2. Implement a "frozen array" that uses Reflect to prevent modifications but allows reads
3. Create an object with default values that get applied when a property doesn't exist using Reflect.get with a receiver
4. Build a simple schema validation system for JavaScript objects using Reflect methods

## Additional Resources

- [MDN Web Docs on Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)
- [JavaScript Proxy and Reflect](https://javascript.info/proxy)
- [ES6 In Depth: Proxies and Reflect](https://hacks.mozilla.org/2015/07/es6-in-depth-proxies-and-reflect/)