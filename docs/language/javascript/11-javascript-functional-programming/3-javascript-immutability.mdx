---
title: JavaScript Immutability
description: Learn about immutability in JavaScript, why it's important in functional programming, and how to implement immutable data structures and patterns in your code.

---

# JavaScript Immutability

## Introduction

In JavaScript, immutability refers to the concept of not changing data after it's created. Once an immutable object is created, its state cannot be modified. If you need to make changes, you create a new object with the desired changes instead of altering the original object.

Immutability is a core principle in functional programming that helps write more predictable, testable, and maintainable code. It's especially important in modern JavaScript frameworks like React, Redux, and other state management solutions where tracking changes and avoiding unintended side effects is crucial.

## Why Immutability Matters

Before diving into implementation details, let's understand why immutability is so valuable:

1. **Predictability**: When data cannot change, code behavior becomes more predictable
2. **Debugging**: Easier to track when and where data changes occur
3. **Concurrency**: Safer in multi-threaded environments (though JavaScript is single-threaded, this concept applies to async operations)
4. **Change Detection**: Enables efficient equality checks (reference comparison)
5. **Undo/Redo**: Makes implementing history features simpler

## The Problem with Mutability

Let's start by looking at why mutable data can cause problems:

```javascript
const user = {
  name: 'Alice',
  preferences: {
    theme: 'dark',
    notifications: true
  }
};

function enableNotifications(user) {
  // Mutating the original object!
  user.preferences.notifications = true;
  return user;
}

const updatedUser = enableNotifications(user);

console.log(user === updatedUser); // true - references are the same
console.log(user.preferences.notifications); // true

// Later in code...
// Did 'user' get changed somewhere? Hard to track!
```

In the example above, we mutate the original `user` object. This can lead to unexpected behaviors and bugs that are difficult to track down, especially in larger applications.

## Implementing Immutability in JavaScript

JavaScript doesn't have built-in immutable data structures, but there are several approaches to achieve immutability:

### 1. Using Object Spread Operator

The spread operator (`...`) provides a simple way to create new objects with modifications:

```javascript
const user = {
  name: 'Alice',
  preferences: {
    theme: 'dark',
    notifications: false
  }
};

// Immutable update - creates a new object
function enableNotifications(user) {
  return {
    ...user,
    preferences: {
      ...user.preferences,
      notifications: true
    }
  };
}

const updatedUser = enableNotifications(user);

console.log(user === updatedUser); // false - different objects
console.log(user.preferences === updatedUser.preferences); // false - different objects
console.log(user.preferences.notifications); // false - original unchanged
console.log(updatedUser.preferences.notifications); // true
```

### 2. Using Object.assign()

`Object.assign()` is another way to create copies with modifications:

```javascript
const product = { id: 123, name: 'Laptop', price: 999 };

// Immutable price update
const discountedProduct = Object.assign({}, product, { price: 899 });

console.log(product); // { id: 123, name: 'Laptop', price: 999 }
console.log(discountedProduct); // { id: 123, name: 'Laptop', price: 899 }
```

### 3. Immutable Array Operations

Arrays in JavaScript have both mutable methods (like `push`, `splice`, `sort`) and immutable methods (like `map`, `filter`, `reduce`). For immutable operations:

```javascript
// Original array
const numbers = [1, 2, 3, 4, 5];

// ❌ Mutable operations
// numbers.push(6);
// numbers.splice(1, 1);

// ✅ Immutable alternatives
const added = [...numbers, 6];
const removed = numbers.filter(num => num !== 2);
const doubled = numbers.map(num => num * 2);

console.log('Original:', numbers); // [1, 2, 3, 4, 5]
console.log('Added 6:', added); // [1, 2, 3, 4, 5, 6]
console.log('Removed 2:', removed); // [1, 3, 4, 5]
console.log('Doubled:', doubled); // [2, 4, 6, 8, 10]
```

## Deep Immutability and Nested Objects

The spread operator only performs shallow copying. For nested objects, you need to recursively create new copies:

```javascript
const state = {
  user: {
    id: 42,
    profile: {
      name: 'John',
      address: {
        city: 'New York',
        zipCode: '10001'
      }
    }
  },
  settings: {
    darkMode: true
  }
};

// Immutably updating a nested property
function updateZipCode(state, newZipCode) {
  return {
    ...state,
    user: {
      ...state.user,
      profile: {
        ...state.user.profile,
        address: {
          ...state.user.profile.address,
          zipCode: newZipCode
        }
      }
    }
  };
}

const newState = updateZipCode(state, '10002');

console.log(state.user.profile.address.zipCode); // 10001
console.log(newState.user.profile.address.zipCode); // 10002
```

As you can see, updating deeply nested objects becomes verbose and error-prone. This is where immutability libraries can help.

## Immutability Libraries

Several libraries make working with immutable data structures easier:

### Immer

[Immer](https://immerjs.github.io/immer/) allows you to work with immutable data as if it were mutable, while handling all the copying behind the scenes:

```javascript
import produce from 'immer';

const state = {
  users: [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' }
  ],
  settings: { darkMode: false }
};

const newState = produce(state, draft => {
  // Looks like mutation, but Immer handles immutability
  draft.users.push({ id: 3, name: 'Carol' });
  draft.settings.darkMode = true;
});

console.log(state.users.length); // 2
console.log(newState.users.length); // 3
console.log(state.settings.darkMode); // false
console.log(newState.settings.darkMode); // true
```

### Immutable.js

[Immutable.js](https://immutable-js.com/) provides persistent immutable data structures:

```javascript
import { Map } from 'immutable';

const map1 = Map({ a: 1, b: 2 });
const map2 = map1.set('b', 50);

console.log(map1.get('b')); // 2
console.log(map2.get('b')); // 50
```

## Practical Example: Todo List Application

Let's build a simple immutable todo list manager:

```javascript
// Todo list with immutable operations

const initialTodos = [
  { id: 1, text: 'Learn JavaScript', completed: true },
  { id: 2, text: 'Learn React', completed: false },
  { id: 3, text: 'Build a project', completed: false }
];

// Immutable operations for todos
const todoOperations = {
  // Add new todo
  addTodo: (todos, text) => {
    const newTodo = {
      id: Math.max(0, ...todos.map(t => t.id)) + 1,
      text,
      completed: false
    };
    return [...todos, newTodo];
  },

  // Toggle completed status
  toggleTodo: (todos, id) => {
    return todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    );
  },

  // Remove todo
  removeTodo: (todos, id) => {
    return todos.filter(todo => todo.id !== id);
  },

  // Edit todo text
  editTodo: (todos, id, text) => {
    return todos.map(todo =>
      todo.id === id ? { ...todo, text } : todo
    );
  }
};

// Usage examples
let currentTodos = initialTodos;

// Add a todo
const todosAfterAdd = todoOperations.addTodo(currentTodos, 'Learn TypeScript');
console.log('After adding:', todosAfterAdd);

// Toggle a todo
const todosAfterToggle = todoOperations.toggleTodo(currentTodos, 2);
console.log('After toggle:', todosAfterToggle);

// Both operations combined (chained)
const finalTodos = todoOperations.removeTodo(
  todoOperations.toggleTodo(
    todoOperations.addTodo(currentTodos, 'Learn TypeScript'),
    2
  ),
  1
);

console.log('Final todos:', finalTodos);
console.log('Original todos (unchanged):', currentTodos);
```

## Performance Considerations

While immutability brings many benefits, it's important to understand its performance implications:

1. **Memory Usage**: Creating new copies can increase memory usage, especially with large data structures
2. **Garbage Collection**: More object creation leads to more garbage collection
3. **Structural Sharing**: Modern immutability libraries use techniques like structural sharing to mitigate these costs

In practice, for most web applications, the benefits of immutability outweigh the performance costs, and browsers are increasingly optimized for this pattern.

## Immutability and React

React works best with immutable data patterns. When you use immutable data in component state or props, React can perform efficient equality checks and avoid unnecessary re-renders:

```jsx
import React, { useState } from 'react';

function Counter() {
  const [counter, setCounter] = useState({
    count: 0,
    lastUpdated: new Date()
  });
  
  // Immutable update
  const increment = () => {
    setCounter({
      ...counter,
      count: counter.count + 1,
      lastUpdated: new Date()
    });
  };
  
  return (
    <div>
      <p>Count: {counter.count}</p>
      <p>Last Updated: {counter.lastUpdated.toLocaleTimeString()}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

## Summary

Immutability is a cornerstone of functional programming in JavaScript that helps create more predictable, testable, and maintainable code. By avoiding direct mutations of objects and arrays, we can:

- Track data changes more easily
- Avoid unexpected side effects
- Enable efficient change detection
- Create safer concurrent code

While JavaScript doesn't provide built-in immutable data structures, we can achieve immutability using:

1. Spread operator and object/array literals
2. Native methods like `Object.assign()` and array methods (`map`, `filter`, etc.)
3. Specialized libraries like Immer or Immutable.js

As you continue your journey in functional programming, embracing immutability will help you write cleaner, more robust applications.

## Exercises

1. Refactor a mutable function to be immutable:
   ```javascript
   // Convert this function to be immutable
   function addToCart(cart, item) {
     cart.items.push(item);
     cart.total += item.price;
     return cart;
   }
   ```

2. Create an immutable function that updates a user's address in a nested object structure.

3. Implement an immutable "undo" functionality for a simple text editor using an array of history states.

## Additional Resources

- [Mozilla Developer Network (MDN) - Object.assign()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
- [Immer Documentation](https://immerjs.github.io/immer/)
- [Immutable.js Documentation](https://immutable-js.com/)
- [Redux Documentation - Immutable Update Patterns](https://redux.js.org/usage/structuring-reducers/immutable-update-patterns)
- ["Professor Frisby's Mostly Adequate Guide to Functional Programming"](https://mostly-adequate.gitbook.io/mostly-adequate-guide/) - A free online book on functional programming in JavaScript