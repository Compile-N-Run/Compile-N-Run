---
title: JavaScript Currying
description: Learn about currying in JavaScript - a powerful functional programming technique that transforms functions with multiple arguments into a sequence of functions each with a single argument.

---

# JavaScript Currying

## Introduction

Currying is a fundamental concept in functional programming that might seem complex at first, but once understood, it becomes an incredibly powerful tool in your JavaScript arsenal. Named after mathematician Haskell Curry, currying is the technique of transforming a function that takes multiple arguments into a sequence of functions that each take a single argument.

In simpler terms, instead of a function like `f(a, b, c)`, currying gives you `f(a)(b)(c)`. This transformation allows for greater flexibility, code reusability, and function composition.

## Understanding Currying

Let's start with a basic example to illustrate the difference between a regular function and its curried version:

```javascript
// Regular function
function add(x, y) {
  return x + y;
}

// Curried version
function curriedAdd(x) {
  return function(y) {
    return x + y;
  };
}

// Using the regular function
console.log(add(2, 3)); // Output: 5

// Using the curried function
console.log(curriedAdd(2)(3)); // Output: 5
```

In the curried version, we first call `curriedAdd(2)` which returns a new function. We then call this returned function with the argument `3`, which gives us our final result of `5`.

## Benefits of Currying

1. **Partial Application**: You can create specialized functions from more general ones.
2. **Function Composition**: Curried functions are easier to compose.
3. **Avoiding Repetition**: You can "pre-load" a function with some arguments.
4. **Pure Functional Style**: It promotes a cleaner, more functional coding style.

## Creating Curried Functions

### Manual Currying

You can manually curry a function like we did above, but that becomes tedious for functions with many parameters. Let's create a more complex example:

```javascript
// Manual currying for a function with three parameters
function multiply(a) {
  return function(b) {
    return function(c) {
      return a * b * c;
    };
  };
}

// Using our curried multiply function
const step1 = multiply(2);    // Returns a function waiting for parameter b
const step2 = step1(3);       // Returns a function waiting for parameter c
const result = step2(4);      // Returns the final result: 2 * 3 * 4 = 24

console.log(result); // Output: 24

// Or we can call it all at once
console.log(multiply(2)(3)(4)); // Output: 24
```

### Automatic Currying

For functions with many parameters, we can create a helper function to curry them automatically:

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    }
    
    return function(...args2) {
      return curried.apply(this, args.concat(args2));
    };
  };
}

// A regular function with multiple parameters
function add(a, b, c) {
  return a + b + c;
}

// Creating a curried version
const curriedAdd = curry(add);

// Different ways to call it
console.log(curriedAdd(1)(2)(3));  // Output: 6
console.log(curriedAdd(1, 2)(3));  // Output: 6
console.log(curriedAdd(1)(2, 3));  // Output: 6
console.log(curriedAdd(1, 2, 3));  // Output: 6
```

This `curry` function is more flexible - it allows you to provide arguments one at a time or in groups.

## Practical Uses of Currying

### Example 1: Creating Specialized Functions

```javascript
const multiply = (a) => (b) => a * b;

// Create specialized functions
const double = multiply(2);
const triple = multiply(3);

console.log(double(5));  // Output: 10
console.log(triple(5));  // Output: 15
```

Here, `double` and `triple` are specialized functions created from the more general `multiply` function.

### Example 2: Event Handling

Currying is particularly useful in event handling scenarios:

```javascript
// A generic event logger
const logEvent = (eventType) => (event) => {
  console.log(`Event type: ${eventType}`);
  console.log('Event data:', event);
};

// Create specialized event loggers
const logClickEvent = logEvent('click');
const logKeyEvent = logEvent('keypress');

// Later in your code
document.getElementById('myButton').addEventListener('click', logClickEvent);
document.getElementById('myInput').addEventListener('keypress', logKeyEvent);
```

### Example 3: Data Transformation Pipeline

Currying helps in creating clean data transformation pipelines:

```javascript
// Curried filter function
const filter = (predicate) => (array) => array.filter(predicate);

// Curried map function
const map = (transformer) => (array) => array.map(transformer);

// Predicates and transformers
const isEven = x => x % 2 === 0;
const double = x => x * 2;

// Creating specialized functions
const filterEvens = filter(isEven);
const doubleValues = map(double);

// Sample data
const numbers = [1, 2, 3, 4, 5, 6];

// Using the pipeline
const result = doubleValues(filterEvens(numbers));

console.log(result); // Output: [4, 8, 12]
```

This code first filters out even numbers, then doubles each of them. The curried functions make the code more readable and reusable.

## Advanced Currying Patterns

### Placeholder Currying

Sometimes you want to provide arguments out of order. Libraries like Lodash provide placeholder currying:

```javascript
// A simplified version of placeholder currying
function advancedCurry(fn, arity = fn.length) {
  return function curried(...args) {
    // If we have enough arguments that aren't placeholders
    const realArgs = args.filter(arg => arg !== '_');
    
    if (realArgs.length >= arity) {
      return fn.apply(this, args);
    }
    
    return function(...moreArgs) {
      // Replace placeholders with corresponding arguments
      const newArgs = args.map(arg => 
        arg === '_' && moreArgs.length ? moreArgs.shift() : arg
      ).concat(moreArgs);
      
      return curried.apply(this, newArgs);
    };
  };
}

// Example usage (simplified)
const divide = advancedCurry((a, b) => a / b);
const divideBy2 = divide('_', 2); // _ is a placeholder

console.log(divideBy2(10)); // Output: 5
```

## Common Pitfalls and Considerations

1. **Readability**: Heavily curried code can be difficult for beginners to understand
2. **Debugging**: Curried functions can be harder to debug
3. **Performance**: Creating multiple function closures has a small performance cost
4. **`this` context**: Care must be taken when using currying with methods that depend on `this`

## Summary

Currying is a powerful functional programming technique that transforms functions with multiple arguments into a sequence of functions, each taking a single argument. This approach offers significant benefits:

- Improved code reusability through partial application
- Enhanced function composition
- Cleaner, more modular code
- Flexibility in function application

While currying might seem complex at first, it's a skill that becomes more intuitive with practice and can significantly improve the quality and maintainability of your JavaScript code.

## Additional Resources and Exercises

### Resources

1. [Functional Programming in JavaScript](https://mostly-adequate.gitbook.io/mostly-adequate-guide/) - A book that covers currying in depth
2. [Lodash's curry function](https://lodash.com/docs/#curry) - A robust implementation of currying
3. [JavaScript.info article on currying](https://javascript.info/currying-partials)

### Exercises

1. Convert the following function to a curried version:
   ```javascript
   function formatName(title, firstName, lastName) {
     return `${title} ${firstName} ${lastName}`;
   }
   ```

2. Create a curried function for calculating the area of different shapes (circle, rectangle, triangle).

3. Implement a curried version of `Array.prototype.reduce` that allows you to specify the callback and initial value separately from the array.

4. Build a simple string templating engine using currying that allows you to create reusable templates.

Happy currying!