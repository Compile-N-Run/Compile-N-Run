---
title: JavaScript IIFE
description: Learn about Immediately Invoked Function Expressions (IIFE) in JavaScript - what they are, how to use them, and their practical applications.

---

# JavaScript IIFE

## Introduction

An IIFE, or Immediately Invoked Function Expression, is a JavaScript function that runs as soon as it's defined. It's a design pattern that's particularly useful for creating private scopes, avoiding global namespace pollution, and executing code immediately after defining it.

The syntax might look a bit strange at first, but IIFEs are a powerful tool in JavaScript programming that you'll encounter in many codebases.

## What is an IIFE?

A standard JavaScript function is defined and then called separately:

```javascript
// Standard function definition
function sayHello() {
  console.log('Hello, world!');
}

// Function invocation
sayHello(); // Output: Hello, world!
```

An IIFE, however, combines the function definition and execution into a single step:

```javascript
// IIFE - Function is defined and executed immediately
(function() {
  console.log('Hello, world!');
})(); // Output: Hello, world!
```

## Basic IIFE Syntax

The basic syntax of an IIFE involves wrapping a function in parentheses and then adding another pair of parentheses to invoke it:

```javascript
(function() {
  // Your code here
})();
```

Let's break down the parts:
1. `(function() { ... })` - This is a function expression wrapped in parentheses
2. `()` - This immediately invokes (calls) the function

## Why Use Parentheses?

You might wonder why we need the first set of parentheses. In JavaScript, when the keyword `function` appears at the beginning of a statement, it's interpreted as a function declaration, not a function expression. The parentheses trick the parser into treating it as an expression that can be immediately invoked.

Without the parentheses, you'd get a syntax error:

```javascript
// This would cause a syntax error
function() {
  console.log('This causes an error');
}();
```

## Passing Parameters to an IIFE

You can pass arguments to an IIFE just like any other function:

```javascript
(function(name) {
  console.log('Hello, ' + name);
})('John'); // Output: Hello, John
```

## Alternative IIFE Syntax

There's an alternative syntax where the invocation parentheses are placed inside the outer parentheses:

```javascript
(function() {
  console.log('Alternative syntax');
}());  // Output: Alternative syntax
```

Both styles are functionally identical, and it mostly comes down to personal preference.

## Using Arrow Functions

With modern JavaScript, you can also create IIFEs using arrow functions:

```javascript
(() => {
  console.log('IIFE with arrow function');
})(); // Output: IIFE with arrow function
```

## Practical Uses of IIFE

### 1. Creating Private Scope

One of the most common uses of IIFEs is to create a private scope for variables:

```javascript
// Variables defined inside the IIFE cannot be accessed from outside
(function() {
  const privateVar = "I'm private";
  console.log(privateVar); // Output: I'm private
})();

// This would cause an error
// console.log(privateVar); // ReferenceError: privateVar is not defined
```

### 2. Avoiding Global Namespace Pollution

IIFEs help prevent polluting the global namespace:

```javascript
// Without IIFE - adds to global scope
function setupApp() {
  const version = '1.0.0';
  // More initialization code...
}
// version might conflict with other libraries

// With IIFE - doesn't pollute global scope
(function() {
  const version = '1.0.0';
  // More initialization code...
})();
// version is safely contained inside the IIFE
```

### 3. The Module Pattern

IIFEs can be used to create modules with private and public members:

```javascript
const counter = (function() {
  let count = 0; // Private variable
  
  // Return an object with public methods
  return {
    increment: function() {
      count++;
    },
    decrement: function() {
      count--;
    },
    getCount: function() {
      return count;
    }
  };
})();

console.log(counter.getCount()); // Output: 0
counter.increment();
console.log(counter.getCount()); // Output: 1
// console.log(count); // Error: count is not defined (it's private)
```

### 4. Capturing the Current State in Loops

IIFEs are useful for capturing the current state in loops, especially before ES6 block-scoped variables:

```javascript
// Problem with closures in loops
for (var i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Outputs: 3, 3, 3
  }, 100);
}

// Solution with IIFE
for (var i = 0; i < 3; i++) {
  (function(currentI) {
    setTimeout(function() {
      console.log(currentI); // Outputs: 0, 1, 2
    }, 100);
  })(i);
}

// Modern solution using let (block scope)
for (let i = 0; i < 3; i++) {
  setTimeout(function() {
    console.log(i); // Outputs: 0, 1, 2
  }, 100);
}
```

### 5. Executing Async Functions

IIFEs are useful for executing async functions immediately:

```javascript
(async function() {
  try {
    const data = await fetch('https://api.example.com/data');
    const json = await data.json();
    console.log(json);
  } catch (error) {
    console.error('Error fetching data:', error);
  }
})();
```

## Real-World Example: Library Initialization

Many JavaScript libraries use IIFEs to initialize themselves while keeping their implementation details private:

```javascript
// Simple library implementation
const MyLibrary = (function() {
  // Private variables and functions
  const version = '1.0.0';
  
  function initialize() {
    console.log('Library initialized');
  }
  
  // Call private initialization function
  initialize();
  
  // Return public API
  return {
    getVersion: function() {
      return version;
    },
    doSomething: function() {
      console.log('Doing something...');
    }
  };
})();

// Using the library
console.log(MyLibrary.getVersion()); // Output: 1.0.0
MyLibrary.doSomething(); // Output: Doing something...
```

## Summary

Immediately Invoked Function Expressions (IIFEs) are a powerful JavaScript pattern that allows you to:

- Execute functions as soon as they're defined
- Create private scopes to avoid variable name collisions
- Prevent global namespace pollution
- Implement the module pattern
- Capture the current state in loops and closures

Although modern JavaScript features like block-scoped variables (`let` and `const`), modules, and classes have reduced some of the need for IIFEs, understanding this pattern is still important as it appears frequently in existing codebases and remains useful in many scenarios.

## Practice Exercises

1. Create an IIFE that calculates and logs the sum of numbers from 1 to 10.
2. Build a counter module using the IIFE pattern that has `increment`, `decrement`, and `reset` methods.
3. Create a simple calculator module with add, subtract, multiply, and divide operations using IIFE.
4. Refactor a piece of code that adds multiple variables to the global scope to use an IIFE instead.

## Additional Resources

- [MDN Web Docs on IIFE](https://developer.mozilla.org/en-US/docs/Glossary/IIFE)
- [JavaScript Design Patterns by Addy Osmani](https://addyosmani.com/resources/essentialjsdesignpatterns/book/)
- [You Don't Know JS: Scope & Closures](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/README.md)