---
title: JavaScript Module Imports
description: Learn how to import functionality from other JavaScript modules to build modular applications

---

# JavaScript Module Imports

## Introduction

JavaScript modules allow you to break up your code into separate files, making your projects more organized and maintainable. The import statement is a key feature that lets you use functionality from other modules in your current file. This helps avoid polluting the global namespace and enables better code organization.

In this tutorial, we'll explore how to use module imports in JavaScript, from basic imports to more advanced techniques.

## Prerequisites

To follow along with this tutorial, you should:
- Have a basic understanding of JavaScript
- Be familiar with ES6 syntax
- Have a development environment that supports ES modules (modern browsers or Node.js)

## Basic Import Syntax

The most common way to import from a module is using the `import` statement followed by what you want to import and where it's coming from.

### Importing a Default Export

When a module has a default export, you can import it like this:

```javascript
// Importing a default export
import User from './user.js';

// Using the imported functionality
const newUser = new User('John');
console.log(newUser.name); // Output: John
```

In this example, we're importing the default export from the `user.js` file. The name `User` is assigned to whatever is exported as default from that module.

### Importing Named Exports

Modules can also export specific named values, functions, or objects. To import these named exports:

```javascript
// Importing named exports
import { add, subtract } from './math.js';

// Using the imported functions
console.log(add(5, 3));      // Output: 8
console.log(subtract(10, 4)); // Output: 6
```

Here, we're importing the `add` and `subtract` functions that were specifically exported from the `math.js` file.

## Renaming Imports

Sometimes you might want to rename an import to avoid naming conflicts or to make your code more readable:

```javascript
// Renaming imports
import { add as sum, subtract as minus } from './math.js';

// Using the renamed imports
console.log(sum(5, 3));     // Output: 8
console.log(minus(10, 4));  // Output: 6
```

The `as` keyword lets you create aliases for your imports, which can be useful when working with multiple modules that might have similar function names.

## Importing Everything from a Module

If you want to import all exports from a module, you can use the `*` syntax with a namespace:

```javascript
// Importing all exports
import * as MathUtils from './math.js';

// Using the namespace to access exports
console.log(MathUtils.add(5, 3));      // Output: 8
console.log(MathUtils.subtract(10, 4)); // Output: 6
console.log(MathUtils.PI);             // Output: 3.14159
```

This approach creates a namespace object (`MathUtils` in this case) containing all the exports from the module.

## Dynamic Imports

Sometimes you might want to load a module conditionally or on demand. Dynamic imports allow you to load modules at runtime:

```javascript
// Regular code...

// Later, when we need the module:
if (userClickedButton) {
  import('./feature.js')
    .then((module) => {
      // Use the module functionality
      module.doSomething();
    })
    .catch(error => {
      console.error('Failed to load module:', error);
    });
}
```

Dynamic imports return a Promise, making them useful for code-splitting and lazy-loading features. This can significantly improve your application's performance by loading code only when needed.

## Real-World Example: Building a Todo App

Let's see how we might structure imports in a real-world todo application:

```javascript
// main.js
import TodoApp from './components/TodoApp.js';
import { saveToLocalStorage, loadFromLocalStorage } from './utils/storage.js';
import * as validators from './utils/validators.js';

// Initialize the application
const savedTodos = loadFromLocalStorage('todos') || [];
const app = new TodoApp(savedTodos);

document.getElementById('new-todo-form').addEventListener('submit', (event) => {
  event.preventDefault();
  const input = document.getElementById('new-todo-input');
  const todoText = input.value.trim();
  
  if (validators.isNotEmpty(todoText)) {
    app.addTodo(todoText);
    saveToLocalStorage('todos', app.getTodos());
    input.value = '';
  }
});
```

In this example:
1. We import the `TodoApp` class as a default export
2. We import specific utility functions from a storage module
3. We import all validators from a validators module

This showcases how proper import organization can make your code more modular and maintainable.

## Common Import Patterns and Best Practices

### Barrel Files (Index Exports)

A common pattern is to create "barrel" files (usually named `index.js`) that re-export from multiple files:

```javascript
// utils/index.js
export { default as formatDate } from './date-formatter.js';
export { default as formatCurrency } from './currency-formatter.js';
export { validateEmail, validatePassword } from './validators.js';
```

This allows you to import from a directory instead of individual files:

```javascript
// Instead of multiple imports:
// import formatDate from './utils/date-formatter.js';
// import formatCurrency from './utils/currency-formatter.js';
// import { validateEmail } from './utils/validators.js';

// You can do:
import { formatDate, formatCurrency, validateEmail } from './utils';
```

This approach reduces import clutter and makes refactoring easier.

### Prefer Named Imports

When possible, prefer named imports over namespace imports. This allows bundlers to better tree-shake your code, removing unused imports:

```javascript
// Good - allows tree-shaking
import { useState, useEffect } from 'react';

// Less optimal - imports everything
import * as React from 'react';
```

### Avoid Side Effects

Be aware that modules are executed when imported. Try to keep your modules free of side effects:

```javascript
// Bad practice - has side effect on import
console.log('Module loaded!');
export function helper() { /* ... */ }

// Better - side effect only happens when function is called
export function initialize() {
  console.log('Module initialized!');
  // Setup code...
}
```

## Browser Support and Compatibility

Modern browsers support ES modules natively. To use them in the browser, you need to specify the type in your script tag:

```html
<script type="module" src="main.js"></script>
```

For older browsers, you'll need to use a bundler like Webpack, Rollup, or Parcel to transform your modular code into compatible JavaScript.

Node.js has supported ES modules since version 13.2.0, but you may need to:
- Use the `.mjs` extension
- Set `"type": "module"` in your package.json
- Or use a transpiler like Babel

## Summary

JavaScript module imports are a powerful way to organize your code into reusable, maintainable pieces. In this tutorial, we've covered:

- Basic import syntax for default and named exports
- Renaming imports to avoid conflicts
- Importing all exports with namespace imports
- Dynamic imports for lazy loading
- Real-world examples and best practices

By effectively using module imports, you can build more organized, efficient, and scalable JavaScript applications.

## Additional Resources

- [MDN Web Docs: JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
- [JavaScript.info: Modules](https://javascript.info/modules)
- [Exploring JS: Modules](https://exploringjs.com/es6/ch_modules.html)

## Exercises

1. Create a simple calculator module with functions for addition, subtraction, multiplication, and division. Then import and use these functions in another file.

2. Build a utility module with various helper functions (e.g., formatting dates, validating emails). Create a barrel file that re-exports all these functions, then import them in a main file.

3. Experiment with dynamic imports by creating a feature that only loads certain code when a button is clicked.

4. Create a module with both default and named exports, then practice different ways of importing them in another file.