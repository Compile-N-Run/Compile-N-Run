---
title: JavaScript Callbacks
description: Learn about callback functions in JavaScript, how they work, and their role in asynchronous programming.

---

# JavaScript Callbacks

## Introduction

In JavaScript, a callback is a function that is passed as an argument to another function and is executed after the completion of that function. Callbacks are a fundamental concept in JavaScript, especially when dealing with asynchronous operations.

JavaScript is single-threaded, meaning it can only execute one operation at a time. However, through callbacks, JavaScript can handle operations that might take some time (like fetching data from a server or reading a file) without blocking the entire program's execution flow.

## What Are Callback Functions?

A callback function is simply a function that gets passed as an argument to another function. The function receiving the callback then calls (or "calls back") this function at an appropriate time, such as when an asynchronous operation completes.

Let's look at a simple example:

```javascript
function greeting(name) {
  console.log(`Hello, ${name}!`);
}

function processUserInput(callback) {
  const name = prompt("Please enter your name:");
  callback(name);
}

// Pass the greeting function as a callback
processUserInput(greeting);
```

In this example:
1. We define a `greeting` function that takes a name parameter
2. We define a `processUserInput` function that takes a callback parameter
3. Inside `processUserInput`, we get the user's name and then call the callback function with that name
4. When we call `processUserInput(greeting)`, we're passing the `greeting` function as the callback

The output would be "Hello, [whatever name was entered]!" displayed in the console.

## Synchronous Callbacks

Callbacks can be used in both synchronous and asynchronous contexts. In a synchronous callback, the function is executed immediately:

```javascript
// Synchronous callback example with Array.map()
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(function(number) {
  return number * 2;
});

console.log(doubled); // Output: [2, 4, 6, 8, 10]
```

Here, the callback function passed to `map()` is executed synchronously for each element in the array.

Other common synchronous callback examples include:

```javascript
// Array.filter()
const evenNumbers = numbers.filter(function(number) {
  return number % 2 === 0;
});
console.log(evenNumbers); // Output: [2, 4]

// Array.forEach()
numbers.forEach(function(number) {
  console.log(number);
});
// Output: 1, 2, 3, 4, 5 (each on a new line)
```

## Asynchronous Callbacks

Asynchronous callbacks are executed at a later point in time, after some operation has completed. These are more common when dealing with operations like:
- Fetching data from an API
- Reading files
- Setting timers

Let's see an example using `setTimeout`:

```javascript
console.log("Start");

setTimeout(function() {
  console.log("This executes later, after 2 seconds");
}, 2000);

console.log("End");

// Output:
// Start
// End
// This executes later, after 2 seconds
```

Notice how "End" appears before the callback message, even though it comes after in the code. This is because `setTimeout` is asynchronous - it doesn't block the execution flow.

## Event-Based Callbacks

One of the most common uses of callbacks in web development is for handling events:

```javascript
const button = document.querySelector('#myButton');

button.addEventListener('click', function() {
  console.log('Button was clicked!');
});
```

In this example, the callback function is executed whenever the button is clicked.

## The Callback Pattern for Asynchronous Operations

Before Promises and async/await were introduced in JavaScript, callbacks were the primary way to handle asynchronous operations:

```javascript
function fetchData(url, callback) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  
  xhr.onload = function() {
    if (xhr.status === 200) {
      callback(null, JSON.parse(xhr.responseText));
    } else {
      callback(new Error(`Request failed with status ${xhr.status}`));
    }
  };
  
  xhr.onerror = function() {
    callback(new Error('Network error'));
  };
  
  xhr.send();
}

// Using the fetchData function
fetchData('https://api.example.com/data', function(error, data) {
  if (error) {
    console.error('Error:', error);
  } else {
    console.log('Data received:', data);
  }
});
```

This pattern, where the callback takes an error as its first argument and the result as its second, is known as the "error-first callback" pattern or "Node.js callback pattern".

## Callback Hell

One of the main drawbacks of using callbacks for asynchronous operations is what's known as "callback hell" or the "pyramid of doom" - when you have multiple nested callbacks, making the code hard to read and maintain:

```javascript
fetchData('https://api.example.com/users', function(error, users) {
  if (error) {
    console.error('Error fetching users:', error);
  } else {
    fetchData(`https://api.example.com/users/${users[0].id}/posts`, function(error, posts) {
      if (error) {
        console.error('Error fetching posts:', error);
      } else {
        fetchData(`https://api.example.com/posts/${posts[0].id}/comments`, function(error, comments) {
          if (error) {
            console.error('Error fetching comments:', error);
          } else {
            console.log('Comments:', comments);
          }
        });
      }
    });
  }
});
```

This nested structure quickly becomes unwieldy. Modern JavaScript provides better alternatives like Promises and async/await, but understanding callbacks is still essential as they form the foundation of these more advanced patterns.

## Practical Real-World Example: Loading Script Dynamically

Here's a practical example where you might use callbacks - loading a script dynamically:

```javascript
function loadScript(src, callback) {
  const script = document.createElement('script');
  script.src = src;
  
  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Script load error for ${src}`));
  
  document.head.append(script);
}

// Usage
loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js', function(error, script) {
  if (error) {
    console.error(error);
  } else {
    // The script is loaded, and we can use functions from it
    console.log(_.random(1, 100)); // Using lodash's random function
    console.log('Script loaded:', script.src);
  }
});
```

This function loads a script and calls the callback when it's either loaded successfully or fails.

## Best Practices for Working with Callbacks

1. **Keep your code shallow**: Try to avoid nesting too many callbacks.

2. **Use named functions**: Instead of anonymous functions, define named functions and pass them as callbacks for better readability:

```javascript
function handleResponse(error, data) {
  if (error) {
    console.error(error);
  } else {
    console.log(data);
  }
}

fetchData('https://api.example.com/data', handleResponse);
```

3. **Error handling**: Always handle errors in your callbacks to prevent silent failures.

4. **Consider alternatives**: For complex asynchronous flows, consider using Promises or async/await.

## Summary

Callbacks are functions passed as arguments to other functions to be executed later. They are fundamental to JavaScript's asynchronous programming model:

- They allow you to execute code after an asynchronous operation completes
- They're used extensively in event handling, timers, and data fetching
- They can lead to complex nested code ("callback hell") when overused
- Modern alternatives like Promises and async/await build upon the callback concept

Though newer asynchronous patterns have emerged, callbacks remain an essential concept in JavaScript. Understanding callbacks provides a strong foundation for mastering more advanced asynchronous patterns.

## Exercises

1. Write a function `calculateAndDisplay` that takes two numbers and a callback function. The function should perform a calculation on the numbers and then use the callback to display the result.

2. Create a simple polling function that checks a condition every second using `setTimeout` and calls a callback when the condition is met.

3. Refactor the "callback hell" example above using named functions to make it more readable.

## Additional Resources

- [MDN Web Docs: Callback function](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function)
- [JavaScript.info: Callbacks](https://javascript.info/callbacks)
- [Callback vs. Promises vs. Async/Await](https://www.freecodecamp.org/news/javascript-callback-functions-what-are-callbacks-in-js-and-how-to-use-them/)

In the next lesson, we'll explore Promises, which provide a more elegant way to handle asynchronous operations in JavaScript.