---
title: Swift In-Out Parameters
description: Learn how to modify function parameters using Swift's in-out parameters, allowing functions to modify variables passed as arguments

---

# Swift In-Out Parameters

## Introduction

In Swift, function parameters are constants by default, meaning you cannot modify their values within the function's body. This behavior supports functional programming principles and helps prevent unexpected side effects. However, there are situations where you need a function to modify the value of a variable that was passed in as a parameter.

This is where Swift's **in-out parameters** come into play. In-out parameters provide a way to modify a variable from outside the function's scope, allowing the function to make changes that persist after the function call completes.

## Understanding In-Out Parameters

### Basic Concept

When you use an in-out parameter, here's what happens:

1. When the function is called, the value of the argument is copied
2. The function can modify the copy during its execution
3. When the function returns, the original value is replaced with the modified copy

This mechanism allows functions to modify the original variables passed to them, creating a side effect that persists beyond the function's execution.

## How to Define and Use In-Out Parameters

### Syntax

To define an in-out parameter, you place the `inout` keyword before the parameter type:

```swift
func functionName(parameterName: inout Type) {
    // Function body
}
```

When calling a function that has an in-out parameter, you must place an ampersand (`&`) directly before the variable name, which explicitly indicates that you're aware this variable might be modified:

```swift
var someVariable = value
functionName(parameterName: &someVariable)
```

### Simple Example: Swapping Values

Let's start with a classic example of using in-out parameters - swapping the values of two variables:

```swift
func swapValues<T>(a: inout T, b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}

var first = 10
var second = 20

print("Before swap: first = \(first), second = \(second)")
swapValues(a: &first, b: &second)
print("After swap: first = \(first), second = \(second)")
```

**Output:**
```
Before swap: first = 10, second = 20
After swap: first = 20, second = 10
```

In this example, the `swapValues` function takes two in-out parameters of the same type and exchanges their values. The `<T>` syntax makes this a generic function that can work with any type.

## Rules and Restrictions

There are several important rules to keep in mind when using in-out parameters:

1. You cannot pass a constant or literal value as an in-out parameter
2. You cannot use in-out parameters with default values
3. You cannot use variadic parameters as in-out parameters
4. Functions with in-out parameters cannot be used with operators like `+` or `-`

Let's see some examples of these restrictions:

```swift
// ❌ This will cause a compile-time error
let constant = 5
swapValues(a: &constant, b: &10) // Error: Cannot pass immutable value as inout parameter

// ❌ This will also cause a compile-time error
func invalidFunction(value: inout Int = 10) { } // Error: Default argument not permitted for parameter of type 'inout Int'
```

## Practical Examples

### Example 1: Incrementing a Counter

```swift
func incrementByAmount(counter: inout Int, amount: Int) {
    counter += amount
}

var score = 10
print("Initial score: \(score)")

incrementByAmount(counter: &score, amount: 5)
print("Score after increment: \(score)")
```

**Output:**
```
Initial score: 10
Score after increment: 15
```

### Example 2: Modifying Arrays

In-out parameters are particularly useful for functions that modify collections like arrays:

```swift
func removeOddNumbers(numbers: inout [Int]) {
    numbers = numbers.filter { $0 % 2 == 0 }
}

var myNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print("Original array: \(myNumbers)")

removeOddNumbers(numbers: &myNumbers)
print("After removing odd numbers: \(myNumbers)")
```

**Output:**
```
Original array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
After removing odd numbers: [2, 4, 6, 8, 10]
```

### Example 3: Working with Custom Types

In-out parameters work well with custom types like structs:

```swift
struct User {
    var name: String
    var age: Int
}

func celebrateBirthday(for user: inout User) {
    user.age += 1
    print("Happy Birthday, \(user.name)! You are now \(user.age) years old.")
}

var john = User(name: "John", age: 29)
print("Before: \(john.name) is \(john.age) years old")

celebrateBirthday(for: &john)
print("After: \(john.name) is \(john.age) years old")
```

**Output:**
```
Before: John is 29 years old
Happy Birthday, John! You are now 30 years old.
After: John is 30 years old
```

## Real-World Application: Form Validation

In-out parameters can be useful for form validation where you need to track and modify multiple error states:

```swift
struct ValidationResult {
    var isValid: Bool = true
    var errors: [String] = []
}

func validateUsername(username: String, result: inout ValidationResult) {
    if username.count < 4 {
        result.isValid = false
        result.errors.append("Username must be at least 4 characters long")
    }
    
    if username.contains(" ") {
        result.isValid = false
        result.errors.append("Username cannot contain spaces")
    }
}

func validatePassword(password: String, result: inout ValidationResult) {
    if password.count < 8 {
        result.isValid = false
        result.errors.append("Password must be at least 8 characters long")
    }
    
    if !password.contains(where: { $0.isNumber }) {
        result.isValid = false
        result.errors.append("Password must contain at least one number")
    }
}

// Usage
var validationResult = ValidationResult()

let username = "jo"
let password = "weakpwd"

validateUsername(username: username, result: &validationResult)
validatePassword(password: password, result: &validationResult)

if validationResult.isValid {
    print("Form is valid!")
} else {
    print("Form validation failed with the following errors:")
    for error in validationResult.errors {
        print("- \(error)")
    }
}
```

**Output:**
```
Form validation failed with the following errors:
- Username must be at least 4 characters long
- Password must be at least 8 characters long
- Password must contain at least one number
```

## How In-Out Parameters Work Behind the Scenes

While it might seem like in-out parameters use pass-by-reference semantics, the actual implementation in Swift is a bit more nuanced:

1. When you pass an argument as an in-out parameter, Swift makes a copy of it
2. The function operates on that copy
3. When the function returns, Swift copies the modified value back to the original variable

This approach is sometimes called "copy-in copy-out" or "call by value result." It gives the same end result as pass-by-reference while providing additional safety guarantees in some edge cases.

## When to Use In-Out Parameters

In-out parameters are useful in several scenarios:

- When you need a function to modify one or more of its input values
- When implementing algorithms that need to mutate their inputs (like sorting or filtering in place)
- When you want to avoid returning multiple values from a function
- For operations that need to report both a result and success/failure status

However, they should be used judiciously since they can make code harder to reason about and introduce side effects.

## Summary

Swift's in-out parameters provide a powerful mechanism for modifying variables outside a function's scope. By using the `inout` keyword in function declarations and the `&` prefix when calling functions, you can write concise code that modifies values in place.

Remember these key points:

- In-out parameters allow functions to modify the original variables passed to them
- Use the `inout` keyword in the parameter declaration
- Use the `&` prefix when passing arguments to in-out parameters
- In-out parameters have some restrictions (can't use constants, default values, etc.)
- They're implemented as "copy-in copy-out" rather than true pass-by-reference

When used appropriately, in-out parameters can lead to cleaner and more efficient code, especially when dealing with complex data manipulation tasks.

## Exercises

1. Write a function that doubles all values in an integer array using an in-out parameter
2. Create a function that normalizes a string (converts to lowercase and trims whitespace) using an in-out parameter
3. Implement a function that takes a dictionary of scores by name and adds bonus points to each person's score
4. Write a function that uses in-out parameters to round all decimal values in an array to a specified number of places

## Additional Resources

- [Swift Documentation: In-Out Parameters](https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID173)
- [Swift by Sundell: Utilizing value semantics in Swift](https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift/)
- [WWDC Session 416: Understanding Swift Performance](https://developer.apple.com/videos/play/wwdc2016/416/)