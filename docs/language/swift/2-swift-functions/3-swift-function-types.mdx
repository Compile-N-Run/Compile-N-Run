---
title: Swift Function Types
description: Learn about Swift function types, how to use functions as variables, and pass them as arguments to other functions

---

# Swift Function Types

## Introduction

In Swift, functions are not just procedures but first-class citizens, which means they can be treated like any other type such as integers, strings, or arrays. Function types allow you to use functions as variables, pass them as arguments to other functions, and return them from other functions.

This concept may seem advanced at first, but understanding function types opens up powerful programming patterns that make your code more flexible and reusable.

## What are Function Types?

In Swift, every function has a specific type, defined by the function's parameter types and return type. For example, a function that takes an integer and returns a string has the type `(Int) -> String`.

Let's see this in action:

```swift
func greet(name: String) -> String {
    return "Hello, \(name)!"
}
```

The type of the `greet` function is `(String) -> String`, meaning it takes a String parameter and returns a String value.

## Using Functions as Variables

Since functions have types, you can assign them to variables or constants:

```swift
// Define a function
func add(a: Int, b: Int) -> Int {
    return a + b
}

// Assign the function to a variable
let mathOperation: (Int, Int) -> Int = add

// Use the variable to call the function
let result = mathOperation(5, 3)
print(result) // Output: 8
```

In this example, `mathOperation` is a variable that holds the `add` function. The type annotation `(Int, Int) -> Int` tells Swift that this variable can hold any function that takes two Int parameters and returns an Int.

## Passing Functions as Arguments

One powerful feature of function types is the ability to pass functions as arguments to other functions:

```swift
func applyOperation(_ a: Int, _ b: Int, operation: (Int, Int) -> Int) -> Int {
    return operation(a, b)
}

// Pass the add function as an argument
let sum = applyOperation(10, 5, operation: add)
print(sum) // Output: 15

// Define a subtract function
func subtract(a: Int, b: Int) -> Int {
    return a - b
}

// Pass the subtract function as an argument
let difference = applyOperation(10, 5, operation: subtract)
print(difference) // Output: 5
```

This pattern is extremely useful for customizing the behavior of functions at runtime.

## Returning Functions from Functions

Swift also allows functions to return other functions:

```swift
func chooseOperation(isAddition: Bool) -> (Int, Int) -> Int {
    if isAddition {
        return add
    } else {
        return subtract
    }
}

// Get an add function
let operation = chooseOperation(isAddition: true)
let result = operation(20, 10)
print(result) // Output: 30
```

This creates a "factory" pattern where functions can produce specialized functions based on certain conditions.

## Function Types with Multiple Parameters

Function types can have any number of parameters:

```swift
// Function that takes three parameters
func calculate(a: Int, b: Int, c: Int) -> Int {
    return a + b * c
}

// Function type with three parameters
let calculator: (Int, Int, Int) -> Int = calculate

print(calculator(2, 3, 4)) // Output: 14 (2 + 3 * 4)
```

## Function Types with No Parameters or Return Values

Functions that don't take parameters have the type `() -> ReturnType`:

```swift
func generateRandomNumber() -> Int {
    return Int.random(in: 1...100)
}

let generator: () -> Int = generateRandomNumber
print(generator()) // Output: Random number between 1 and 100
```

Functions that don't return anything have a return type of `Void`:

```swift
func printHello() -> Void {
    print("Hello, world!")
}

// The -> Void part can be omitted
let printer: () -> Void = printHello
printer() // Output: Hello, world!
```

## Practical Example: Sorting with Function Types

Let's see a real-world example using function types to customize sorting behavior:

```swift
struct Person {
    let name: String
    let age: Int
}

let people = [
    Person(name: "Alice", age: 25),
    Person(name: "Bob", age: 20),
    Person(name: "Charlie", age: 30)
]

// Define a sorting function type
func sortByAge(person1: Person, person2: Person) -> Bool {
    return person1.age < person2.age
}

func sortByName(person1: Person, person2: Person) -> Bool {
    return person1.name < person2.name
}

// Array's sorted method takes a function of type (Element, Element) -> Bool
let sortedByAge = people.sorted(by: sortByAge)
// Output: [{name: "Bob", age: 20}, {name: "Alice", age: 25}, {name: "Charlie", age: 30}]

let sortedByName = people.sorted(by: sortByName)
// Output: [{name: "Alice", age: 25}, {name: "Bob", age: 20}, {name: "Charlie", age: 30}]

// Print the results
for person in sortedByAge {
    print("\(person.name): \(person.age)")
}
// Output:
// Bob: 20
// Alice: 25
// Charlie: 30
```

This demonstrates how function types enable you to customize the behavior of existing functions like `sorted(by:)`.

## Using Type Aliases for Function Types

When function types get complex, you can use typealias to create a simpler name:

```swift
typealias ArithmeticOperation = (Int, Int) -> Int

func performOperation(a: Int, b: Int, operation: ArithmeticOperation) -> Int {
    return operation(a, b)
}

// Now the function looks cleaner
let result = performOperation(a: 10, b: 5, operation: add)
print(result) // Output: 15
```

## Function Types and Closures

Swift closures work seamlessly with function types, allowing you to create inline anonymous functions:

```swift
// Using a closure instead of a named function
let multiply: (Int, Int) -> Int = { (a, b) in
    return a * b
}

print(multiply(4, 5)) // Output: 20

// Passing a closure directly as an argument
let product = applyOperation(6, 7, operation: { (a, b) in
    return a * b
})
print(product) // Output: 42
```

## Summary

Function types in Swift are a powerful feature that allows you to:
- Treat functions as values that can be assigned to variables
- Pass functions as arguments to other functions
- Return functions from other functions
- Create more flexible and reusable code

By understanding function types, you can unlock more advanced patterns in Swift programming and write more expressive and flexible code.

## Additional Resources and Exercises

### Resources:
- [Apple Swift Documentation on Functions](https://docs.swift.org/swift-book/LanguageGuide/Functions.html)
- [Swift by Sundell: Function Types](https://www.swiftbysundell.com/basics/function-types/)

### Exercises:

1. Create a function that takes two numbers and a function type parameter to perform different mathematical operations.
2. Implement a function that filters an array using a function type to specify the filtering condition.
3. Build a simple calculator app that uses function types to perform different operations based on user input.
4. Create a function that can sort an array of custom objects by different properties using function type parameters.