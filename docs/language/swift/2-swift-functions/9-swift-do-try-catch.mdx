---
title: "Swift Do Try Catch"
description: "Learn how to handle errors in Swift using do-try-catch blocks, understand error handling patterns, and implement robust error handling in your Swift applications."

---

# Swift Do Try Catch

Error handling is an essential aspect of writing robust and reliable Swift applications. No matter how well-designed your code is, errors can occur due to various reasons like invalid user input, network failures, or file access issues. Swift provides an elegant error handling mechanism using `do`, `try`, and `catch` keywords that allow you to detect and respond to errors gracefully.

## Introduction to Error Handling in Swift

In Swift, error handling follows a pattern where functions can "throw" errors, and the calling code can "catch" and handle these errors appropriately. This pattern helps separate the error detection logic from the error handling logic, making your code cleaner and more maintainable.

The main components of Swift's error handling system are:

- **Error Protocol**: Custom error types conform to the `Error` protocol
- **throw**: Used to generate an error from a function
- **throws**: Indicates a function can generate errors
- **do**: Creates a scope for error handling
- **try**: Marks code that might throw an error
- **catch**: Handles errors that are thrown

## Defining Custom Error Types

Before diving into `do-try-catch`, let's understand how to define custom error types in Swift. Errors are typically represented as enumerations that conform to the `Error` protocol.

```swift
enum CalculationError: Error {
    case divisionByZero
    case negativeValue
    case overflow
}
```

This enum defines three different types of errors that might occur during calculations.

## Throwing Functions

Functions that can generate errors are marked with the `throws` keyword. These functions can use the `throw` statement to indicate when an error has occurred.

```swift
func divide(_ a: Int, by b: Int) throws -> Int {
    guard b != 0 else {
        throw CalculationError.divisionByZero
    }
    
    return a / b
}
```

In this example, the `divide(_:by:)` function throws a `divisionByZero` error if someone attempts to divide by zero.

## Do-Try-Catch Basics

Now, let's see how to call a throwing function and handle potential errors using `do-try-catch`.

```swift
do {
    let result = try divide(10, by: 2)
    print("Result: \(result)") // Output: Result: 5
} catch {
    print("An error occurred: \(error)")
}
```

Here's how it works:

1. The `do` block creates a scope for error handling
2. The `try` keyword is used before calling any function that might throw an error
3. If an error occurs, execution immediately jumps to the `catch` block
4. The `catch` block receives the error and can handle it appropriately

## Handling Specific Error Types

You can have multiple `catch` blocks to handle different types of errors differently:

```swift
do {
    // Try to perform a division that will cause an error
    let result = try divide(10, by: 0)
    print("Result: \(result)") // This line will never be executed
} catch CalculationError.divisionByZero {
    print("Error: Cannot divide by zero!") // Output: Error: Cannot divide by zero!
} catch CalculationError.negativeValue {
    print("Error: Negative values are not allowed!")
} catch {
    print("An unknown error occurred: \(error)")
}
```

This pattern allows you to handle specific error cases with targeted responses.

## Try? and Try! Operators

Swift provides two variations of the `try` keyword for different scenarios:

### try?

The `try?` operator attempts to execute a throwing function and returns an optional value. If the function succeeds, the optional contains the returned value; if it throws an error, the result is `nil`.

```swift
// Using try? to handle errors by converting them to optionals
let safeResult = try? divide(10, by: 0)
if let result = safeResult {
    print("The division was successful: \(result)")
} else {
    print("The division failed") // Output: The division failed
}
```

### try!

The `try!` operator attempts to execute a throwing function but assumes the function will not throw an error. If an error is thrown, your program will crash with a runtime error.

```swift
// Only use try! when you are absolutely certain no error will occur
let guaranteedResult = try! divide(10, by: 5) // This works fine
print("Result: \(guaranteedResult)") // Output: Result: 2

// This would crash your program at runtime:
// let crashResult = try! divide(10, by: 0)
```

⚠️ **Warning**: Use `try!` only when you are absolutely certain that a function will not throw an error in a specific context. Otherwise, your app might crash.

## Rethrowing Errors

Sometimes you might want to pass an error up the call stack. For this, you can use the `rethrows` keyword for higher-order functions that don't generate errors themselves but might pass along errors from their function parameters.

```swift
func performOperation(_ a: Int, _ b: Int, operation: (Int, Int) throws -> Int) rethrows -> Int {
    return try operation(a, b)
}

do {
    let result = try performOperation(10, 2, operation: divide)
    print("Operation result: \(result)") // Output: Operation result: 5
} catch {
    print("Operation failed: \(error)")
}
```

## A Real-World Example: File Operations

Let's see a more practical example using file operations, which commonly need error handling:

```swift
enum FileError: Error {
    case fileNotFound
    case readPermissionDenied
    case invalidData
}

func readFile(at path: String) throws -> String {
    // Check if file exists
    guard FileManager.default.fileExists(atPath: path) else {
        throw FileError.fileNotFound
    }
    
    // Check read permissions (simplified)
    guard FileManager.default.isReadableFile(atPath: path) else {
        throw FileError.readPermissionDenied
    }
    
    // Try to read the file
    guard let contents = try? String(contentsOfFile: path) else {
        throw FileError.invalidData
    }
    
    return contents
}

// Using the function
let filePath = "/path/to/some/file.txt"

do {
    let fileContents = try readFile(at: filePath)
    print("File contents: \(fileContents)")
} catch FileError.fileNotFound {
    print("Error: The file does not exist")
} catch FileError.readPermissionDenied {
    print("Error: You don't have permission to read this file")
} catch FileError.invalidData {
    print("Error: The file contains invalid data")
} catch {
    print("An unknown error occurred: \(error)")
}
```

## Creating Clean Error Handling Patterns

As your applications grow in complexity, it's helpful to develop clean patterns for error handling. Here's an example of a network request with comprehensive error handling:

```swift
enum NetworkError: Error {
    case invalidURL
    case requestFailed(statusCode: Int)
    case noData
    case decodingFailed
}

func fetchUser(id: Int, completion: @escaping (Result<User, NetworkError>) -> Void) {
    // Construct the URL
    guard let url = URL(string: "https://api.example.com/users/\(id)") else {
        completion(.failure(.invalidURL))
        return
    }
    
    // Perform the request
    URLSession.shared.dataTask(with: url) { data, response, error in
        // Check for valid response
        if let httpResponse = response as? HTTPURLResponse, 
           !(200...299).contains(httpResponse.statusCode) {
            completion(.failure(.requestFailed(statusCode: httpResponse.statusCode)))
            return
        }
        
        // Check for data
        guard let data = data else {
            completion(.failure(.noData))
            return
        }
        
        // Attempt to decode the data
        do {
            let user = try JSONDecoder().decode(User.self, from: data)
            completion(.success(user))
        } catch {
            completion(.failure(.decodingFailed))
        }
    }.resume()
}

// Usage
fetchUser(id: 123) { result in
    switch result {
    case .success(let user):
        print("Retrieved user: \(user.name)")
    case .failure(let error):
        switch error {
        case .invalidURL:
            print("Error: Invalid URL")
        case .requestFailed(let statusCode):
            print("Error: Request failed with status code \(statusCode)")
        case .noData:
            print("Error: No data received")
        case .decodingFailed:
            print("Error: Could not decode the data")
        }
    }
}
```

This pattern uses Swift's `Result` type, which integrates well with the error handling system and provides a clean way to handle both success and failure cases.

## Summary

Swift's `do-try-catch` error handling mechanism provides a robust way to handle errors in your applications:

1. Define custom error types using enumerations that conform to the `Error` protocol
2. Mark functions that can throw errors with the `throws` keyword
3. Use `throw` to generate errors when appropriate conditions are met
4. Use `do-try-catch` blocks to call throwing functions and handle potential errors
5. Handle specific error types with targeted catch blocks
6. Use `try?` to convert errors to optional values
7. Use `try!` when you're absolutely certain no error will occur (but use with caution)
8. Use `rethrows` for higher-order functions that might pass through errors from their function parameters

Effective error handling makes your applications more robust and provides better user experiences by gracefully responding to unexpected situations instead of crashing.

## Exercises

To practice your understanding of Swift's error handling, try these exercises:

1. Create a `BankAccount` class with methods for deposit and withdrawal that use error handling to prevent negative balances
2. Implement a JSON parsing function that provides detailed errors for different parsing failures
3. Write a resource manager that uses error handling to safely acquire and release resources
4. Create a validation system for user input that provides specific error messages for different validation failures
5. Extend the file operations example to include writing to files with appropriate error handling

## Additional Resources

- [Swift Documentation on Error Handling](https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html)
- [WWDC Session: Using Errors as Control Flow](https://developer.apple.com/videos/play/wwdc2018/721/)
- [Swift Evolution proposal for error handling](https://github.com/apple/swift-evolution/blob/master/proposals/0018-flexible-memberwise-initialization.md)

By mastering Swift's error handling system, you'll write more resilient code that gracefully handles unexpected situations and provides better feedback to users.