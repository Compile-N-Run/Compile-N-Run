---
title: Swift Generic Types
description: Learn how to create and use generic types in Swift to write flexible, reusable code that works with any data type.

---

# Swift Generic Types

## Introduction

Generic types are one of the most powerful features in Swift, allowing you to write flexible, reusable components that can work with any type while maintaining type safety. Instead of writing separate implementations for each data type, you can define a single generic type that can adapt to different types at compile time.

In this tutorial, we'll explore how to create and use generic types in Swift, from basic examples to more advanced use cases.

## What Are Generic Types?

Generic types are classes, structures, or enumerations that can work with any type, rather than being restricted to a single data type. They allow you to define placeholders (type parameters) that will be replaced with actual types when the code is used.

The core benefits of generic types include:

- **Code Reusability**: Write once, use with multiple types
- **Type Safety**: Maintain Swift's strong type checking
- **Performance**: No runtime casting overhead as types are determined at compile time

## Creating Your First Generic Type

Let's start by creating a simple generic type - a stack data structure that can hold any type of element:

```swift
struct Stack<Element> {
    private var items: [Element] = []
    
    mutating func push(_ item: Element) {
        items.append(item)
    }
    
    mutating func pop() -> Element? {
        return items.isEmpty ? nil : items.removeLast()
    }
    
    var topItem: Element? {
        return items.last
    }
}
```

In this example, `Element` is a type parameter that acts as a placeholder for the actual type. When you create an instance of `Stack`, you specify what `Element` should be:

```swift
// Creating a stack of strings
var stringStack = Stack<String>()
stringStack.push("Hello")
stringStack.push("World")
print(stringStack.topItem ?? "")  // Output: World

// Creating a stack of integers
var intStack = Stack<Int>()
intStack.push(42)
intStack.push(73)
print(intStack.topItem ?? 0)  // Output: 73
```

## Type Constraints

Sometimes you'll want to restrict your generic types to only work with certain types. Type constraints let you specify that a type parameter must inherit from a specific class or conform to a particular protocol.

### Example with Protocol Constraint

Let's create a generic `Pair` type that requires its elements to be `Equatable`:

```swift
struct Pair<T: Equatable> {
    let first: T
    let second: T
    
    func areEqual() -> Bool {
        return first == second
    }
}

let numberPair = Pair(first: 10, second: 10)
print(numberPair.areEqual())  // Output: true

let stringPair = Pair(first: "Swift", second: "Generics")
print(stringPair.areEqual())  // Output: false
```

## Multiple Type Parameters

Generic types aren't limited to a single type parameter. You can use multiple placeholders when needed:

```swift
struct Dictionary<Key, Value> {
    // Implementation would go here
}

struct KeyValuePair<K, V> {
    let key: K
    let value: V
    
    func describe() -> String {
        return "Key: \(key), Value: \(value)"
    }
}

let pair = KeyValuePair(key: "language", value: "Swift")
print(pair.describe())  // Output: Key: language, Value: Swift
```

## Associated Types in Protocols

When creating protocols, you can use associated types instead of concrete types. This allows for flexible protocol requirements:

```swift
protocol Container {
    associatedtype Item
    mutating func add(_ item: Item)
    var count: Int { get }
    subscript(i: Int) -> Item { get }
}

struct GenericArray<T>: Container {
    var items = [T]()
    
    mutating func add(_ item: T) {
        items.append(item)
    }
    
    var count: Int {
        return items.count
    }
    
    subscript(i: Int) -> T {
        return items[i]
    }
}

var intArray = GenericArray<Int>()
intArray.add(1)
intArray.add(2)
print(intArray.count)    // Output: 2
print(intArray[0])       // Output: 1
```

## Generic Type Extension

You can extend generic types to add functionality:

```swift
extension Stack {
    var isEmpty: Bool {
        return items.isEmpty
    }
    
    func peek() -> Element? {
        return items.last
    }
}

var bookStack = Stack<String>()
print(bookStack.isEmpty)  // Output: true
bookStack.push("Swift Programming")
print(bookStack.peek() ?? "")  // Output: Swift Programming
```

## Real-World Example: Result Type

One practical example of generics is a `Result` type that can represent either a success with an associated value or a failure with an error:

```swift
enum NetworkError: Error {
    case badURL
    case serverError(Int)
    case dataError
}

enum Result<Success, Failure: Error> {
    case success(Success)
    case failure(Failure)
}

func fetchData(from url: String, completion: @escaping (Result<String, NetworkError>) -> Void) {
    // Simulate network request
    if url.hasPrefix("https") {
        completion(.success("Data received successfully"))
    } else {
        completion(.failure(.badURL))
    }
}

fetchData(from: "https://example.com") { result in
    switch result {
    case .success(let data):
        print("Success: \(data)")
    case .failure(let error):
        print("Error: \(error)")
    }
}

// Output: Success: Data received successfully
```

## Type Erasure with Generics

Type erasure is an advanced pattern that helps solve protocol conformance issues:

```swift
// A type-erased container
struct AnyContainer<T>: Container {
    typealias Item = T
    
    private var _add: (T) -> Void
    private var _count: () -> Int
    private var _subscript: (Int) -> T
    
    init<C: Container>(_ container: C) where C.Item == T {
        _add = { container.add($0) }
        _count = { container.count }
        _subscript = { container[$0] }
    }
    
    mutating func add(_ item: T) {
        _add(item)
    }
    
    var count: Int {
        return _count()
    }
    
    subscript(i: Int) -> T {
        return _subscript(i)
    }
}
```

## Best Practices for Generic Types

1. **Use Meaningful Names**: Instead of using single letters like `T`, use descriptive names like `Element` or `Value` for better readability.

2. **Consider Type Constraints**: Use type constraints to enforce requirements when needed, but keep them as minimal as possible.

3. **Don't Over-Generalize**: Use generics only when you truly need to support multiple types.

4. **Document Your Generic Types**: Clearly explain what types are expected and what constraints apply.

## Summary

Generic types are a powerful feature in Swift that enables you to write reusable, type-safe code that works with any data type. We've covered:

- Creating basic generic types with type parameters
- Adding type constraints to restrict which types can be used
- Using multiple type parameters
- Working with associated types in protocols
- Extending generic types
- Real-world examples and advanced patterns

By mastering generic types, you'll be able to write more flexible, reusable Swift code while still maintaining the safety and efficiency that Swift provides.

## Exercises

1. Create a generic `Queue<T>` type with `enqueue()` and `dequeue()` methods.
2. Implement a generic `LinkedList<T>` with basic operations.
3. Create a `Result<Success, Failure>` type with methods to transform success and failure cases.
4. Implement a generic `Cache<Key: Hashable, Value>` that stores values associated with keys.
5. Create a `Pair<T, U>` type that holds two values of potentially different types.

## Additional Resources

- [Swift Documentation: Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)
- [WWDC Session: Swift Generics](https://developer.apple.com/videos/play/wwdc2018/406/)
- [Advanced Swift](https://www.objc.io/books/advanced-swift/) - Book with excellent coverage of generics