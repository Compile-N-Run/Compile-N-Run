---
title: Swift Generic Functions
description: Learn how to write flexible and reusable functions using Swift generics, with clear examples and practical applications.
slug: swift-generic-functions

---

# Swift Generic Functions

## Introduction

Generic functions are a powerful feature in Swift that allows you to write flexible and reusable code that works with different types. Instead of writing separate functions for each data type, you can write a single generic function that can handle multiple types while maintaining type safety.

In this tutorial, we'll explore how to create and use generic functions in Swift, understand their benefits, and see some practical examples of how they can be applied in real-world scenarios.

## What are Generic Functions?

Generic functions allow you to write a function that can work with any type, rather than a specific one. This enables you to write code that is more reusable, flexible, and maintainable.

Here's the basic syntax for defining a generic function in Swift:

```swift
func functionName<T>(parameter: T) -> T {
    // Function body
    return parameter
}
```

The `<T>` syntax introduces a type parameter which acts as a placeholder for a type that will be determined when the function is called. The letter `T` is conventionally used, but you can use any name.

## Your First Generic Function

Let's start with a simple example: a function that swaps two values.

```swift
func swapValues<T>(a: inout T, b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}

// Using the function with integers
var firstNumber = 10
var secondNumber = 20
print("Before swap: firstNumber = \(firstNumber), secondNumber = \(secondNumber)")
swapValues(a: &firstNumber, b: &secondNumber)
print("After swap: firstNumber = \(firstNumber), secondNumber = \(secondNumber)")

// Using the function with strings
var firstString = "Hello"
var secondString = "World"
print("Before swap: firstString = \(firstString), secondString = \(secondString)")
swapValues(a: &firstString, b: &secondString)
print("After swap: firstString = \(firstString), secondString = \(secondString)")
```

Output:
```
Before swap: firstNumber = 10, secondNumber = 20
After swap: firstNumber = 20, secondNumber = 10
Before swap: firstString = Hello, secondString = World
After swap: firstString = World, secondString = Hello
```

In this example, our `swapValues` function works with both integers and strings. Swift determines the actual type to use for `T` when the function is called, based on the type of the arguments passed.

## Multiple Type Parameters

You can use multiple type parameters in a generic function. Let's create a function that converts values from one type to another:

```swift
func convert<T, U>(value: T, converter: (T) -> U) -> U {
    return converter(value)
}

// Converting an integer to a string
let stringValue = convert(value: 42, converter: { String($0) })
print("Converted integer to string: \(stringValue)")

// Converting a string to an integer
let intValue = convert(value: "100", converter: { Int($0) ?? 0 })
print("Converted string to integer: \(intValue)")
```

Output:
```
Converted integer to string: 42
Converted string to integer: 100
```

Here, `T` and `U` represent two different types. The function takes a value of type `T` and a converter function that transforms a value of type `T` into a value of type `U`.

## Type Constraints

Sometimes you need to ensure that the generic types you're working with have certain capabilities. You can add type constraints to restrict the types that can be used with your generic function:

```swift
func findMax<T: Comparable>(values: [T]) -> T? {
    guard !values.isEmpty else {
        return nil
    }
    
    var maxValue = values[0]
    for value in values {
        if value > maxValue {
            maxValue = value
        }
    }
    
    return maxValue
}

// Finding maximum in an array of integers
let numbers = [3, 1, 7, 4, 5]
if let maxNumber = findMax(values: numbers) {
    print("Maximum number: \(maxNumber)")
}

// Finding maximum in an array of strings
let strings = ["apple", "banana", "orange", "pear"]
if let maxString = findMax(values: strings) {
    print("Alphabetically last string: \(maxString)")
}
```

Output:
```
Maximum number: 7
Alphabetically last string: pear
```

In this example, the `<T: Comparable>` syntax restricts the generic type `T` to types that conform to the `Comparable` protocol, which ensures that we can use the `>` operator to compare values.

## Protocol Constraints

You can use protocol constraints to specify that a type must conform to multiple protocols:

```swift
func printDescription<T: CustomStringConvertible & Equatable>(value: T) {
    print("Description: \(value.description)")
    if value == value {  // This works because T conforms to Equatable
        print("Value is equal to itself")
    }
}

struct Person: CustomStringConvertible, Equatable {
    let name: String
    let age: Int
    
    var description: String {
        return "\(name), \(age) years old"
    }
}

let person = Person(name: "John", age: 30)
printDescription(value: person)
```

Output:
```
Description: John, 30 years old
Value is equal to itself
```

Here, we require the type `T` to conform to both `CustomStringConvertible` and `Equatable` protocols.

## Where Clauses

For more complex type constraints, you can use a `where` clause:

```swift
func findCommonElements<T, U>(array1: [T], array2: [U]) -> [T] where T: Equatable, U: Equatable, T == U {
    var common: [T] = []
    for item1 in array1 {
        for item2 in array2 {
            if item1 == item2 && !common.contains(item1) {
                common.append(item1)
            }
        }
    }
    return common
}

let firstArray = [1, 2, 3, 4, 5]
let secondArray = [3, 4, 5, 6, 7]
let commonNumbers = findCommonElements(array1: firstArray, array2: secondArray)
print("Common elements: \(commonNumbers)")
```

Output:
```
Common elements: [3, 4, 5]
```

In this example, the `where` clause specifies that `T` and `U` must be equatable and that they must be the same type.

## Real-World Example: Generic Data Storage

Let's create a more practical example with a generic cache that can store any type of value:

```swift
class Cache<Key: Hashable, Value> {
    private var storage: [Key: Value] = [:]
    
    func setValue(_ value: Value, forKey key: Key) {
        storage[key] = value
    }
    
    func getValue(forKey key: Key) -> Value? {
        return storage[key]
    }
    
    func removeValue(forKey key: Key) {
        storage.removeValue(forKey: key)
    }
    
    func clear() {
        storage.removeAll()
    }
}

// Using the cache with strings and integers
let userScores = Cache<String, Int>()
userScores.setValue(100, forKey: "Alice")
userScores.setValue(85, forKey: "Bob")
userScores.setValue(95, forKey: "Charlie")

if let aliceScore = userScores.getValue(forKey: "Alice") {
    print("Alice's score: \(aliceScore)")
}

// Using the cache with integers and custom objects
class User {
    let name: String
    let email: String
    
    init(name: String, email: String) {
        self.name = name
        self.email = email
    }
}

let userCache = Cache<Int, User>()
userCache.setValue(User(name: "Alice", email: "alice@example.com"), forKey: 1)
userCache.setValue(User(name: "Bob", email: "bob@example.com"), forKey: 2)

if let user = userCache.getValue(forKey: 1) {
    print("User ID 1: \(user.name), \(user.email)")
}
```

Output:
```
Alice's score: 100
User ID 1: Alice, alice@example.com
```

This example shows how a generic cache can be reused with different types, providing a flexible and type-safe way to store and retrieve data.

## When to Use Generic Functions

Generic functions are particularly useful in the following scenarios:

1. **Creating reusable algorithms and data structures** that work with various types
2. **Avoiding code duplication** by writing a function once that works with different types
3. **Ensuring type safety** while maintaining flexibility
4. **Building libraries and frameworks** that can be used with any type

## Common Pitfalls and Best Practices

### Pitfalls to Avoid:

1. **Overcomplicating your code** - Don't use generics if a simple solution would suffice
2. **Too many type parameters** - Keep your generic functions focused
3. **Missing constraints** - Without proper constraints, you might not be able to perform necessary operations

### Best Practices:

1. **Use descriptive type parameter names** - Instead of `T`, use names like `Element` or `Key` when appropriate
2. **Add constraints only when needed** - Don't constrain types unnecessarily
3. **Consider providing non-generic alternatives** for common use cases

## Summary

Generic functions are a powerful feature of Swift that allows you to write flexible, reusable code while maintaining type safety. We've covered:

- Basic syntax and usage of generic functions
- Working with multiple type parameters
- Adding type constraints to ensure functionality
- Using protocol constraints and where clauses
- Real-world examples of generic functions

By leveraging generics, you can write more efficient, reusable, and maintainable code in Swift.

## Additional Resources

- [Swift Language Guide: Generics](https://docs.swift.org/swift-book/LanguageGuide/Generics.html)
- [Apple Developer Documentation](https://developer.apple.com/documentation/swift/generics)

## Exercises

1. Write a generic function that finds the minimum and maximum values in an array.
2. Create a generic function that filters an array based on a given predicate.
3. Implement a generic function that zips two arrays together into an array of tuples.
4. Write a generic function that safely casts values from one type to another, returning `nil` if the cast fails.
5. Create a generic caching system that can expire entries after a certain time period.

Happy coding with Swift generics!