---
title: Swift Opaque Types
description: Learn about opaque types in Swift, how they differ from protocols and generics, and their practical applications in your code.

---

# Swift Opaque Types

## Introduction

When working with generics in Swift, you sometimes want to hide the specific type that a function returns while still preserving type identity. This is where opaque types come in. Introduced in Swift 5.1, opaque types allow you to hide concrete return types behind type abstractions while maintaining the underlying type information.

In this tutorial, you'll learn:
- What opaque types are
- How they differ from protocols and generics
- How to use the `some` keyword
- Real-world applications of opaque types

## Understanding Opaque Types

### What are Opaque Types?

An opaque type is a way to hide the concrete return type of a function or property while still maintaining its type identity. Instead of exposing the exact type, you only expose the protocol it conforms to.

The key advantage: **the compiler still knows the exact type**, even though the calling code doesn't.

### The `some` Keyword

Opaque types are declared using the `some` keyword, followed by a protocol name:

```swift
func createShape() -> some Shape {
    // Returns a specific Shape type
}
```

In this example, `createShape()` returns a type that conforms to the `Shape` protocol, but the specific type is hidden from the caller.

## Opaque Types vs. Protocol Return Types

Let's understand the difference between returning a protocol type and an opaque type:

### Protocol Return Type

```swift
protocol Shape {
    func draw() -> String
}

struct Circle: Shape {
    func draw() -> String {
        return "○"
    }
}

// Returns a protocol type
func createProtocolShape() -> Shape {
    return Circle()
}

let shape = createProtocolShape()
print(shape.draw()) // Output: ○
```

### Opaque Return Type

```swift
// Returns an opaque type
func createOpaqueShape() -> some Shape {
    return Circle()
}

let opaqueShape = createOpaqueShape()
print(opaqueShape.draw()) // Output: ○
```

Both functions appear similar, but there's a crucial difference:

1. With the protocol return type (`-> Shape`), the exact type information is lost.
2. With the opaque return type (`-> some Shape`), the compiler preserves the exact type.

## Why Use Opaque Types?

### 1. Type Identity Preservation

The most significant benefit is that opaque types maintain type identity. Consider this example:

```swift
protocol Equatable {
    static func ==(lhs: Self, rhs: Self) -> Bool
}

// DOES NOT COMPILE
func createEqualShapes() -> Equatable {
    let shape = Circle()
    // Error: Protocol 'Equatable' can only be used as a generic constraint
    return shape
}

// COMPILES SUCCESSFULLY
func createEqualOpaqueShapes() -> some Equatable {
    let shape = Circle()
    // Works fine because 'some' preserves type identity
    return shape
}

let shape1 = createEqualOpaqueShapes()
let shape2 = createEqualOpaqueShapes()
// We can compare them because the compiler knows they're the same type
let areEqual = shape1 == shape2
```

### 2. Implementation Hiding

Opaque types allow you to hide the implementation details while preserving the type's capabilities:

```swift
func getRandomGenerator() -> some RandomNumberGenerator {
    // The caller doesn't need to know which specific generator we're using
    if Bool.random() {
        return LinearCongruentialGenerator()
    } else {
        return SystemRandomNumberGenerator()
    }
}

let generator = getRandomGenerator()
let randomNumber = generator.next()
```

The caller can use the generator without knowing its specific type.

## Practical Applications

### Example 1: SwiftUI Views

SwiftUI heavily uses opaque types with its view builders. Here's a simplified example:

```swift
import SwiftUI

struct ContentView: View {
    // This returns an opaque type that conforms to View
    var body: some View {
        VStack {
            Text("Hello, Swift!")
            Button("Tap me") {
                print("Button tapped")
            }
        }
    }
}
```

The `body` property returns `some View`, hiding the complex return type created by combining `VStack`, `Text`, and `Button`.

### Example 2: Custom Collection

Let's implement a simplified array wrapper with an opaque return type for its iterator:

```swift
struct MyCollection<T> {
    private var items: [T] = []
    
    mutating func add(_ item: T) {
        items.append(item)
    }
    
    // Returns an opaque type that conforms to IteratorProtocol
    func makeIterator() -> some IteratorProtocol {
        return MyIterator(items: items)
    }
    
    struct MyIterator: IteratorProtocol {
        var items: [T]
        var currentIndex = 0
        
        mutating func next() -> T? {
            guard currentIndex < items.count else {
                return nil
            }
            
            let item = items[currentIndex]
            currentIndex += 1
            return item
        }
    }
}

// Usage
var collection = MyCollection<Int>()
collection.add(1)
collection.add(2)
collection.add(3)

var iterator = collection.makeIterator()
while let item = iterator.next() {
    print(item)
}

// Output:
// 1
// 2
// 3
```

### Example 3: Factory Pattern

Opaque types are useful in factory patterns:

```swift
protocol Database {
    func connect() -> Bool
    func query(sql: String) -> [String]
}

struct SQLiteDatabase: Database {
    func connect() -> Bool {
        print("Connecting to SQLite...")
        return true
    }
    
    func query(sql: String) -> [String] {
        return ["SQLite Result 1", "SQLite Result 2"]
    }
}

struct MySQLDatabase: Database {
    func connect() -> Bool {
        print("Connecting to MySQL...")
        return true
    }
    
    func query(sql: String) -> [String] {
        return ["MySQL Result 1", "MySQL Result 2"]
    }
}

enum DatabaseType {
    case sqlite
    case mysql
}

func createDatabase(type: DatabaseType) -> some Database {
    switch type {
    case .sqlite:
        return SQLiteDatabase()
    case .mysql:
        return MySQLDatabase()
    }
}

// Usage
let database = createDatabase(type: .sqlite)
_ = database.connect() // Output: Connecting to SQLite...
let results = database.query(sql: "SELECT * FROM users")
print(results) // Output: ["SQLite Result 1", "SQLite Result 2"]
```

## Limitations of Opaque Types

1. **Function must return a single type**: A function with an opaque return type must return the same concrete type from all code paths.

```swift
// DOES NOT COMPILE
func incorrectOpaque(condition: Bool) -> some Equatable {
    if condition {
        return 5 // Int
    } else {
        return "Hello" // String
        // Error: Function declares an opaque return type, but the return statements
        // in its body do not have matching underlying types
    }
}
```

2. **Opaque types can't currently be used for properties in non-generic contexts** (although this restriction is likely to be lifted in future Swift versions).

## When to Use Opaque Types

Use opaque types when:

1. You want to hide implementation details but preserve type identity
2. You need to return a type that conforms to a protocol with Self requirements
3. You want to ensure that calling code can only interact with your API through a specified protocol
4. You need to leverage the compiler's knowledge of the exact return type

## Summary

Opaque types in Swift provide a powerful way to abstract your code while maintaining type identity. By using the `some` keyword, you can hide implementation details without losing the benefits of static typing.

Key takeaways:
- Opaque types are declared using the `some` keyword
- Unlike protocol return types, opaque types preserve type identity
- They're particularly useful with protocols that have `Self` requirements
- All code paths in a function with an opaque return type must return the same concrete type
- SwiftUI and other modern Swift frameworks make heavy use of opaque types

## Exercises

1. Create a function that returns an opaque collection type containing integers.
2. Implement a `ShapeFactory` that produces different shapes using opaque return types.
3. Refactor an existing function that returns a protocol type to use an opaque type instead.
4. Write a function that combines two opaque types that conform to the same protocol.

## Additional Resources

- [Swift Documentation on Opaque Types](https://docs.swift.org/swift-book/LanguageGuide/OpaqueTypes.html)
- [WWDC 2019: Modern Swift API Design](https://developer.apple.com/videos/play/wwdc2019/415/)
- [Swift Evolution Proposal SE-0244: Opaque Result Types](https://github.com/apple/swift-evolution/blob/master/proposals/0244-opaque-result-types.md)

Happy coding with opaque types!