---
title: Swift Collection Performance
description: Learn about the performance characteristics of different Swift collections, understanding time complexity, and making informed decisions about which collection types to use in your apps.

---

# Swift Collection Performance

When building apps, choosing the right collection type can significantly impact your app's performance. Understanding how Swift collections perform different operations lets you make better decisions about which collection to use for specific scenarios.

## Introduction to Collection Performance

Collection performance is typically measured using **Big O notation**, which describes how the operation time grows relative to the input size. Common notations include:

- **O(1)** - Constant time: The operation takes the same amount of time regardless of collection size
- **O(log n)** - Logarithmic time: The operation time increases logarithmically with collection size
- **O(n)** - Linear time: The operation time increases linearly with collection size
- **O(n²)** - Quadratic time: The operation time increases with the square of collection size

Let's explore the performance characteristics of Swift's primary collection types: Arrays, Dictionaries, and Sets.

## Array Performance

Arrays in Swift are ordered collections that store elements in contiguous memory locations.

### Key Performance Characteristics

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Accessing element by index | O(1) | Direct memory access makes this very fast |
| Appending to end | O(1) amortized | Usually fast, but may require reallocation |
| Inserting/removing at arbitrary position | O(n) | Requires shifting elements |
| Search (without sorting) | O(n) | Must check each element |
| Search (sorted array) | O(log n) | Using binary search |

### Example: Accessing vs. Searching

```swift
let numbers = [1, 5, 3, 9, 7, 2, 8, 4, 6]

// O(1) operation - direct access
let fourthNumber = numbers[3]
print("Fourth number: \(fourthNumber)")

// O(n) operation - searching
func linearSearch(for value: Int, in array: [Int]) -> Int? {
    for (index, element) in array.enumerated() {
        if element == value {
            return index
        }
    }
    return nil
}

if let index = linearSearch(for: 7, in: numbers) {
    print("Found 7 at index \(index)")
} else {
    print("Value not found")
}
```

Output:
```
Fourth number: 9
Found 7 at index 4
```

### Best Practices for Arrays

1. **Reserving capacity**: When you know how many elements you'll add to an array, reserve capacity to avoid multiple reallocations:

```swift
var names = [String]()
names.reserveCapacity(100) // Reserves space for 100 strings
```

2. **Avoid inserting at the beginning**: Use data structures like `Deque` from Swift Collections package if you need frequent insertions at the start.

## Dictionary Performance

Dictionaries provide key-based access to values, using hash tables internally.

### Key Performance Characteristics

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Accessing, inserting, updating, removing | O(1) average | Hash-based lookup makes these operations fast |
| Iterating all elements | O(n) | Must visit each key-value pair |

### Example: Using a Dictionary for Fast Lookup

```swift
// Creating a dictionary of student scores
var studentScores = [
    "Emma": 95,
    "James": 88,
    "Sophia": 92,
    "Michael": 79,
    "Olivia": 84
]

// O(1) lookup operation
if let emmaScore = studentScores["Emma"] {
    print("Emma's score: \(emmaScore)")
} else {
    print("Emma not found")
}

// O(1) insertion
studentScores["William"] = 91
print("After adding William: \(studentScores)")

// O(1) update
studentScores["Michael"] = 82
print("After updating Michael's score: \(studentScores)")
```

Output:
```
Emma's score: 95
After adding William: ["James": 88, "William": 91, "Emma": 95, "Michael": 79, "Sophia": 92, "Olivia": 84]
After updating Michael's score: ["James": 88, "William": 91, "Emma": 95, "Michael": 82, "Sophia": 92, "Olivia": 84]
```

## Set Performance

Sets store unique, unordered elements, also using hash tables internally.

### Key Performance Characteristics

| Operation | Time Complexity | Notes |
|-----------|----------------|-------|
| Inserting, contains, removing | O(1) average | Hash-based operations |
| Set operations (union, intersection) | O(n) | Where n is the size of the smaller set |
| Iterating | O(n) | Must visit each element |

### Example: Using a Set for Unique Values and Fast Membership Testing

```swift
// Creating sets of student interests
let scienceStudents: Set = ["Alex", "Casey", "Taylor", "Morgan", "Jordan"]
let mathStudents: Set = ["Casey", "Riley", "Jordan", "Avery", "Cameron"]

// O(1) contains operation
let newStudent = "Taylor"
if scienceStudents.contains(newStudent) {
    print("\(newStudent) is in the science class")
}

// Set operations
let studentsInBothClasses = scienceStudents.intersection(mathStudents)
print("Students taking both science and math: \(studentsInBothClasses)")

let allStudents = scienceStudents.union(mathStudents)
print("Total unique students: \(allStudents.count)")

let onlyScienceStudents = scienceStudents.subtracting(mathStudents)
print("Students in science only: \(onlyScienceStudents)")
```

Output:
```
Taylor is in the science class
Students taking both science and math: ["Casey", "Jordan"]
Total unique students: 8
Students in science only: ["Alex", "Morgan", "Taylor"]
```

## Practical Performance Comparison

Let's compare the performance of these collections with a real-world example: finding duplicate elements.

```swift
import Foundation

// Sample data
let sampleSize = 10000
var randomNumbers = (1...sampleSize).map { _ in Int.random(in: 1...1000) }

// Using Array approach (slow)
func findDuplicatesWithArray(_ array: [Int]) -> [Int] {
    var duplicates = [Int]()
    var processed = [Int]()
    
    for number in array {
        if processed.contains(number) && !duplicates.contains(number) {
            duplicates.append(number)
        } else {
            processed.append(number)
        }
    }
    
    return duplicates
}

// Using Set approach (fast)
func findDuplicatesWithSet(_ array: [Int]) -> [Int] {
    var seen = Set<Int>()
    var duplicates = Set<Int>()
    
    for number in array {
        if !seen.insert(number).inserted {
            duplicates.insert(number)
        }
    }
    
    return Array(duplicates)
}

// Time measurement function
func measureTime(for operation: () -> Void) -> TimeInterval {
    let start = Date()
    operation()
    return Date().timeIntervalSince(start)
}

// Comparing performance
let arrayTime = measureTime {
    let _ = findDuplicatesWithArray(randomNumbers)
}

let setTime = measureTime {
    let _ = findDuplicatesWithSet(randomNumbers)
}

print("Array approach time: \(arrayTime) seconds")
print("Set approach time: \(setTime) seconds")
print("Set approach is \(arrayTime/setTime)x faster")
```

Output (will vary):
```
Array approach time: 3.9852104187011719 seconds
Set approach time: 0.0064129829406738281 seconds
Set approach is 621.3984103697365x faster
```

## When to Use Each Collection Type

Based on performance characteristics, here are guidelines for choosing collections:

### Use Arrays When:
- You need ordered data
- You frequently access elements by position
- You're working with a small number of elements
- You rarely need to search/insert/remove at arbitrary positions

### Use Dictionaries When:
- You need key-value mapping
- Fast lookups are important
- You don't need ordered data
- You frequently update or remove elements

### Use Sets When:
- You need uniqueness constraint
- You frequently check for membership
- You perform set operations (union, intersection)
- Order doesn't matter

## Memory Considerations

Performance isn't just about speed—memory usage is important too, especially on mobile devices:

- **Arrays**: Most memory-efficient for simple value types, stored contiguously
- **Dictionaries/Sets**: Have overhead for hash table structure, usually use more memory than arrays
- **Copy-on-Write**: Swift collections use this optimization to avoid unnecessary copying

## Summary

Understanding the performance characteristics of Swift collections helps you make the right choices in your code:

- Arrays provide fast indexed access but slow searches
- Dictionaries provide fast key-based lookup
- Sets offer fast uniqueness checking and membership testing

When optimizing your code, consider:
1. The operations you'll perform most frequently
2. The size of your data
3. Whether you need ordering or key-based access

Always measure actual performance in your specific use case before making optimization decisions.

## Additional Resources

- [Swift Collection Protocols Documentation](https://developer.apple.com/documentation/swift/swift_standard_library/collections)
- [Apple's Swift Collections Package](https://github.com/apple/swift-collections)
- [Big O Notation Explained](https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/)

## Exercises

1. Compare the performance of finding an element in an Array vs. a Set for collections of different sizes.
2. Implement a frequency counter that counts occurrences of words in a text file, comparing Dictionary and Array approaches.
3. Create a function that removes duplicates from an array, and compare the performance of approaches using Array, Set, and Dictionary.
4. Experiment with `reserveCapacity` on an Array to see how it affects performance when adding many elements.

Happy coding!