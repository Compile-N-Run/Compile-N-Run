---
title: Swift Collection Bridging
description: Learn how Swift collections can interoperate with Objective-C collection types through bridging, enabling seamless integration between Swift and Objective-C code.

---

# Swift Collection Bridging

In Swift development, particularly when working with Apple platforms, you'll often need to interact with existing Objective-C APIs. Swift provides a powerful feature called "bridging" that enables seamless integration between Swift's native collection types and their Objective-C counterparts. This bridging mechanism allows Swift collections to be used with Objective-C APIs and vice versa without requiring complex conversion code.

## Understanding Collection Bridging

Collection bridging refers to the automatic conversion between Swift's collection types and their Foundation/Objective-C equivalents:

- `Array<Element>` ↔️ `NSArray` / `NSMutableArray`
- `Dictionary<Key, Value>` ↔️ `NSDictionary` / `NSMutableDictionary`
- `Set<Element>` ↔️ `NSSet` / `NSMutableSet`

This bridging happens automatically when needed, allowing Swift collections to be used where Objective-C collections are expected.

## How Bridging Works

When you pass a Swift collection to an Objective-C API, the Swift runtime automatically bridges it to its Objective-C counterpart. Similarly, when an Objective-C collection is returned to Swift code, it's automatically bridged to the appropriate Swift collection type.

### Example: Bridging Swift Array to NSArray

```swift
// Creating a Swift Array
let swiftArray = ["Apple", "Banana", "Orange"]

// This Swift array can be passed to a method expecting NSArray
let joined = (swiftArray as NSArray).componentsJoined(by: ", ")
print(joined) // Output: "Apple, Banana, Orange"

// Using NSArray methods directly on Swift Array through bridging
let uppercase = swiftArray.map { ($0 as NSString).uppercased() }
print(uppercase) // Output: ["APPLE", "BANANA", "ORANGE"]
```

## Bridgeable Types

For bridging to work correctly, the elements in your Swift collections must themselves be bridgeable to Objective-C types:

### Common Bridgeable Types:
- Swift `String` ↔️ `NSString`
- Swift `Int`, `Double`, etc. ↔️ `NSNumber`
- Swift `Data` ↔️ `NSData`
- Swift `Date` ↔️ `NSDate`
- Swift `URL` ↔️ `NSURL`

### Non-Bridgeable Types:
- Swift enums (unless they have a `@objc` attribute)
- Swift structs
- Swift tuples
- Swift functions

## Working with Bridged Collections

### Dictionary Bridging

Swift `Dictionary` types bridge to `NSDictionary` or `NSMutableDictionary`:

```swift
// Creating a Swift Dictionary
let swiftDict = ["name": "John", "age": 30, "city": "New York"]

// Using NSDictionary methods
let keys = (swiftDict as NSDictionary).allKeys
print(keys) // Output: ["name", "age", "city"] (order may vary)

// Bridging back from Objective-C to Swift
func getObjCDictionary() -> NSDictionary {
    return ["status": "success", "code": 200]
}

let result = getObjCDictionary() as! [String: Any]
print("Status: \(result["status"] ?? "unknown")") // Output: "Status: success"
```

### Set Bridging

Swift `Set` types bridge to `NSSet` or `NSMutableSet`:

```swift
// Creating a Swift Set
let swiftSet: Set = [1, 2, 3, 4, 5]

// Using NSSet methods
let containsThree = (swiftSet as NSSet).contains(3)
print(containsThree) // Output: true

// Creating a set from an NSSet
let nsSet = NSSet(array: [7, 8, 9])
let backToSwift = Set(nsSet as! Set<Int>)
print(backToSwift) // Output: [7, 8, 9] (order may vary)
```

## Type Casting and Bridging

Sometimes you'll need to explicitly cast between Swift and Objective-C collection types:

```swift
let swiftArray = [1, 2, 3]

// Explicit bridging to NSArray
let nsArray = swiftArray as NSArray

// Explicit bridging back to Swift Array (with type information)
let bridgedBack = nsArray as! [Int]

// If you're not sure of the element type
let unknownArray = nsArray as! [Any]
```

## Mutability Considerations

Swift collections are value types with clear mutability semantics (using `var` vs `let`), while Objective-C collections come in mutable and immutable variants:

```swift
// Immutable Swift array bridged to NSArray
let immutableArray = ["One", "Two"]
let nsArray = immutableArray as NSArray
// nsArray.add("Three") // This would crash - NSArray is immutable

// Creating a mutable Objective-C array
let mutableArray = NSMutableArray(array: ["One", "Two"])
mutableArray.add("Three")
print(mutableArray) // Output: (One, Two, Three)

// Converting back to Swift
let swiftArray = mutableArray as! [String]
print(swiftArray) // Output: ["One", "Two", "Three"]
```

## Performance Implications

While bridging is convenient, it can have performance costs:

1. Converting between collection types might require copying data
2. Accessing elements in bridged collections might be slower than in native collections
3. For performance-critical code, it's best to use the appropriate native collection type

## Real-World Applications

### Working with UIKit/AppKit

Many Apple framework APIs use Objective-C collections:

```swift
// Building a UI with data from a Swift array
let fruits = ["Apple", "Banana", "Orange", "Grape"]

func configureTableView() {
    // The Swift array is automatically bridged when passed to Objective-C APIs
    tableView.dataSource = ArrayDataSource(items: fruits)
}

class ArrayDataSource: NSObject, UITableViewDataSource {
    let items: [String]
    
    init(items: [String]) {
        self.items = items
        super.init()
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return items.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "Cell", for: indexPath)
        cell.textLabel?.text = items[indexPath.row]
        return cell
    }
}
```

### Working with JSON Data

When parsing JSON data, you often need to work with bridged collections:

```swift
// Parse JSON data into Swift collections
func parseJSON(data: Data) {
    do {
        // JSONSerialization returns Objective-C collection types
        if let jsonObject = try JSONSerialization.jsonObject(with: data) as? [String: Any] {
            // Now we have a bridged Swift dictionary
            if let name = jsonObject["name"] as? String {
                print("Name: \(name)")
            }
            
            if let ages = jsonObject["ages"] as? [Int] {
                print("Ages: \(ages)")
            }
        }
    } catch {
        print("JSON parsing error: \(error)")
    }
}

// Example usage with sample data
let jsonString = """
{
    "name": "John",
    "ages": [25, 30, 35]
}
"""
if let data = jsonString.data(using: .utf8) {
    parseJSON(data: data)
    // Output: 
    // Name: John
    // Ages: [25, 30, 35]
}
```

## Common Pitfalls and Solutions

### Type Safety Issues

Bridged collections from Objective-C often lose specific type information:

```swift
// Creating a typed Swift array
let numbers: [Int] = [1, 2, 3]

// After bridging to NSArray and back, type information is lost
let nsArray = numbers as NSArray
let bridgedBack = nsArray as? [Int] // Use conditional cast for safety

// Alternative: force cast if you're sure of the types
// let bridgedBack = nsArray as! [Int]
```

### Working with Any and AnyObject

Objective-C collections can only store objects, while Swift collections can store any type:

```swift
// This works fine
let swiftArray = [1, 2, 3] // [Int]

// For bridging, these integers are automatically boxed in NSNumber
let objcArray = swiftArray as NSArray

// When bridging back, you get [NSNumber], not [Int]
let bridgedBack = objcArray as! [NSNumber]
print(bridgedBack.first!.intValue) // Output: 1
```

## Summary

Swift collection bridging provides a seamless way to work with both Swift and Objective-C collection types. This feature is essential when working with Apple's frameworks, which are often built on Objective-C foundations. Key points to remember:

- Swift's `Array`, `Dictionary`, and `Set` automatically bridge to their Objective-C counterparts (`NSArray`, `NSDictionary`, and `NSSet`)
- For bridging to work, collection elements must also be bridgeable types
- Be aware of type safety issues when bridging between Swift and Objective-C
- Consider performance implications in performance-critical code
- Understand mutability differences between Swift and Objective-C collections

## Additional Resources

- [Swift Documentation on Collection Types](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)
- [Apple's Documentation on Swift and Objective-C Interoperability](https://developer.apple.com/documentation/swift/objective-c_and_c_code_customization)
- [Using Swift with Cocoa and Objective-C](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/index.html)

## Exercises

1. Create a Swift function that takes an array of strings, bridges it to `NSArray`, uses Objective-C methods to manipulate it, and then bridges it back to a Swift array.

2. Write a program that demonstrates bidirectional bridging between `Dictionary<String, Any>` and `NSDictionary`.

3. Create a custom class that can be stored in both Swift and Objective-C collections. What requirements must it meet?

4. Practice working with JSON data by parsing a complex JSON structure into Swift collections through bridging.

5. Experiment with collection bridging performance by comparing operations on native Swift collections versus bridged collections with different sizes of data.