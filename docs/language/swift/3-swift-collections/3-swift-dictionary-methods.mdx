---
title: Swift Dictionary Methods
description: Learn about the most important methods for working with dictionaries in Swift, including how to create, access, modify, and iterate through dictionary data.

---

# Swift Dictionary Methods

Dictionaries are one of Swift's most powerful collection types, allowing you to store key-value pairs for efficient data lookup. Understanding the various methods available for dictionaries will help you manipulate data effectively in your Swift applications.

## What is a Swift Dictionary?

A dictionary is a collection that stores key-value pairs, where each value is associated with a unique key. In Swift, dictionaries are implemented as `Dictionary<Key, Value>` where:

- `Key` must conform to the `Hashable` protocol (like `String`, `Int`, etc.)
- `Value` can be any type

## Creating Dictionaries

### Basic Dictionary Creation

```swift
// Empty dictionary
var emptyDict: [String: Int] = [:]
var anotherEmptyDict = [String: Int]()

// Dictionary with initial values
var scores = ["Alice": 85, "Bob": 92, "Charlie": 78]
```

### Dictionary with Default Values

```swift
// Create a dictionary with default values for nonexistent keys
var counters = Dictionary(uniqueKeysWithValues: zip(["a", "b", "c"], [1, 2, 3]))
var defaultDict = Dictionary(grouping: [1, 2, 3, 4, 5]) { $0 % 2 == 0 ? "even" : "odd" }
print(defaultDict)
// Output: ["odd": [1, 3, 5], "even": [2, 4]]
```

## Accessing Dictionary Values

### Basic Access

```swift
let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]

// Accessing a value using its key
let aliceScore = scores["Alice"]  // Returns Optional(85)
let davidScore = scores["David"]  // Returns nil
```

### Handling Optional Values

```swift
// Using optional binding
if let bobScore = scores["Bob"] {
    print("Bob's score is \(bobScore)")
} else {
    print("No score found for Bob")
}

// Using nil coalescing operator
let eveScore = scores["Eve"] ?? 0
print("Eve's score is \(eveScore)")  // Output: Eve's score is 0
```

### Default Value

```swift
// Get a value with a default for nonexistent keys
let frankScore = scores["Frank", default: 0]
print("Frank's score is \(frankScore)")  // Output: Frank's score is 0
```

## Modifying Dictionaries

### Adding or Updating Elements

```swift
var scores = ["Alice": 85, "Bob": 92, "Charlie": 78]

// Add a new key-value pair
scores["David"] = 88
print(scores)  // ["Bob": 92, "Charlie": 78, "Alice": 85, "David": 88]

// Update an existing value
scores["Bob"] = 95
print(scores)  // ["Bob": 95, "Charlie": 78, "Alice": 85, "David": 88]
```

### Using `updateValue` Method

```swift
// Update and get the old value
if let oldScore = scores.updateValue(89, forKey: "Alice") {
    print("Alice's old score was \(oldScore)")  // Output: Alice's old score was 85
}

// Try to update a non-existent key
if let oldScore = scores.updateValue(70, forKey: "Eve") {
    print("Eve's old score was \(oldScore)")
} else {
    print("Eve had no previous score")  // Output: Eve had no previous score
}
```

### Removing Elements

```swift
var scores = ["Alice": 85, "Bob": 92, "Charlie": 78, "David": 88]

// Remove a value by setting it to nil
scores["David"] = nil
print(scores)  // ["Bob": 92, "Charlie": 78, "Alice": 85]

// Remove a value using removeValue method
if let removedScore = scores.removeValue(forKey: "Charlie") {
    print("Charlie's score of \(removedScore) was removed")
    // Output: Charlie's score of 78 was removed
}

// Try removing a non-existent key
if let removedScore = scores.removeValue(forKey: "Eve") {
    print("Eve's score was removed")
} else {
    print("No score found for Eve")  // Output: No score found for Eve
}

// Remove all elements
scores.removeAll()
print("Number of scores: \(scores.count)")  // Output: Number of scores: 0
```

### Merging Dictionaries

```swift
var firstQuarterScores = ["Alice": 85, "Bob": 92]
let secondQuarterScores = ["Bob": 95, "Charlie": 80]

// Merge two dictionaries with closure for handling duplicate keys
firstQuarterScores.merge(secondQuarterScores) { current, new in
    return max(current, new)  // Keep the higher score
}
print(firstQuarterScores)  
// Output: ["Alice": 85, "Bob": 95, "Charlie": 80]

// Create a new merged dictionary
let baseScores = ["Alice": 85, "Bob": 92]
let extraScores = ["Bob": 88, "Charlie": 80]
let mergedScores = baseScores.merging(extraScores) { (_, new) in new }
print(mergedScores)  
// Output: ["Bob": 88, "Alice": 85, "Charlie": 80]
```

## Dictionary Properties

```swift
let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]

// Get the number of elements
print("Number of students: \(scores.count)")  // Output: Number of students: 3

// Check if the dictionary is empty
print("Is scores empty? \(scores.isEmpty)")  // Output: Is scores empty? false

// Get all keys
let students = Array(scores.keys)
print("Students: \(students)")  // Output: Students: ["Alice", "Bob", "Charlie"]

// Get all values
let allScores = Array(scores.values)
print("All scores: \(allScores)")  // Output: All scores: [85, 92, 78]
```

## Iterating Through Dictionaries

### Iterating through Key-Value Pairs

```swift
let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]

// Basic for-in loop
for (student, score) in scores {
    print("\(student): \(score)")
}
// Output:
// Bob: 92
// Charlie: 78
// Alice: 85

// Using forEach
scores.forEach { (student, score) in
    print("\(student)'s score is \(score)")
}
```

### Iterating through Keys or Values Only

```swift
// Iterate through keys
for student in scores.keys {
    print("Student: \(student)")
}

// Iterate through values
for score in scores.values {
    print("Score: \(score)")
}

// Sorting and iterating
for (student, score) in scores.sorted(by: { $0.key < $1.key }) {
    print("\(student): \(score)")
}
// Output:
// Alice: 85
// Bob: 92
// Charlie: 78
```

## Filtering Dictionaries

```swift
let scores = ["Alice": 85, "Bob": 92, "Charlie": 78, "David": 95]

// Filter students with scores above 85
let highScores = scores.filter { $0.value > 85 }
print("High scoring students:")
for (student, score) in highScores {
    print("\(student): \(score)")
}
// Output:
// High scoring students:
// Bob: 92
// David: 95
```

## Transforming Dictionaries

### Mapping Dictionary Values

```swift
let scores = ["Alice": 85, "Bob": 92, "Charlie": 78]

// Create a new dictionary with the same keys but transformed values
let letterGrades = scores.mapValues { score in
    switch score {
    case 90...100: return "A"
    case 80..<90: return "B"
    case 70..<80: return "C"
    case 60..<70: return "D"
    default: return "F"
    }
}
print(letterGrades)
// Output: ["Bob": "A", "Charlie": "C", "Alice": "B"]
```

### Compact Mapping

```swift
let possibleScores: [String: String?] = ["Alice": "85", "Bob": nil, "Charlie": "78"]

// Filter out nil values and convert strings to integers
let validScores = possibleScores.compactMapValues { scoreString -> Int? in
    guard let scoreString = scoreString else { return nil }
    return Int(scoreString)
}
print(validScores)  // Output: ["Alice": 85, "Charlie": 78]
```

## Real-World Examples

### Product Inventory System

```swift
// Representing a product inventory
var inventory: [String: Int] = [
    "Apple": 50,
    "Orange": 32,
    "Banana": 15,
    "Grapes": 25
]

// Function to check if an item is in stock
func checkStock(item: String) -> Bool {
    if let quantity = inventory[item], quantity > 0 {
        return true
    }
    return false
}

// Function to process an order
func processOrder(item: String, quantity: Int) -> Bool {
    guard let currentStock = inventory[item], currentStock >= quantity else {
        print("Sorry, \(item) is out of stock or insufficient quantity")
        return false
    }
    
    inventory[item] = currentStock - quantity
    print("\(quantity) \(item)(s) has been sold. Remaining: \(inventory[item]!)")
    return true
}

// Usage
print("Is Apple in stock? \(checkStock(item: "Apple"))")
// Output: Is Apple in stock? true

processOrder(item: "Banana", quantity: 10)
// Output: 10 Banana(s) has been sold. Remaining: 5

processOrder(item: "Orange", quantity: 40)
// Output: Sorry, Orange is out of stock or insufficient quantity
```

### Contact Management System

```swift
// Define a contact structure
struct Contact {
    var name: String
    var email: String
    var phone: String
}

// Create a contacts dictionary
var contacts: [String: Contact] = [
    "john": Contact(name: "John Smith", email: "john@example.com", phone: "555-1234"),
    "jane": Contact(name: "Jane Doe", email: "jane@example.com", phone: "555-5678")
]

// Function to add or update a contact
func addOrUpdateContact(username: String, contact: Contact) {
    if contacts[username] != nil {
        print("Updating contact for \(username)")
    } else {
        print("Adding new contact: \(username)")
    }
    contacts[username] = contact
}

// Function to display contact information
func displayContact(username: String) {
    if let contact = contacts[username] {
        print("Contact: \(contact.name)")
        print("Email: \(contact.email)")
        print("Phone: \(contact.phone)")
    } else {
        print("No contact found for \(username)")
    }
}

// Usage
addOrUpdateContact(username: "sarah", 
                  contact: Contact(name: "Sarah Johnson", 
                                  email: "sarah@example.com", 
                                  phone: "555-9876"))
// Output: Adding new contact: sarah

displayContact(username: "jane")
// Output:
// Contact: Jane Doe
// Email: jane@example.com
// Phone: 555-5678

displayContact(username: "mike")
// Output: No contact found for mike
```

## Summary

Swift dictionaries provide a powerful way to store and retrieve data using key-value pairs. In this article, we've covered:

- Creating dictionaries with different initializers
- Accessing, adding, updating, and removing dictionary elements
- Working with dictionary properties
- Iterating through dictionaries
- Filtering and transforming dictionaries
- Real-world applications of dictionaries

Dictionaries are essential for many programming tasks, especially when you need to quickly look up values based on unique identifiers. They're used extensively in data processing, configuration management, caching, and many other practical applications.

## Additional Resources

- [Swift Documentation: Dictionary](https://developer.apple.com/documentation/swift/dictionary)
- [Swift Programming Language Guide: Collection Types](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)

## Exercises

1. Create a dictionary that maps country names to their capitals, then write a function that lets a user query capital cities.
2. Build a word frequency counter that takes a string and returns a dictionary with each word as a key and its frequency as the value.
3. Implement a simple shopping cart using dictionaries where the keys are product names and the values are quantities.
4. Create a function that takes two dictionaries and returns a new dictionary containing all keys from both, with values being the sum of values from the original dictionaries (treating missing values as 0).
5. Build a student grade tracker that can calculate average scores, identify the highest and lowest performers, and convert numeric grades to letter grades.