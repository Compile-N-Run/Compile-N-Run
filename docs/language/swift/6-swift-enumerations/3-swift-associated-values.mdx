---
title: Swift Associated Values
description: Learn how to enhance Swift enumerations with associated values, allowing you to attach additional information to enum cases.

---

# Swift Associated Values

In Swift, enumerations are not just simple lists of related values - they can be powerful data structures with additional capabilities. One of the most useful features of Swift enums is the ability to attach **associated values** to enum cases. This allows each case to store additional custom information alongside it, making enumerations much more versatile.

## What Are Associated Values?

Associated values let you attach one or more values to an enum case. Unlike properties that would be shared across all cases of an enum, associated values are specific to the case they're attached to, and can even have different types for different cases.

Think of associated values as small packages of data that come along with a specific enum case, giving extra context or information about that particular instance.

## Basic Syntax

Here's how you define an enum with associated values:

```swift
enum Result {
    case success(String)
    case failure(Error)
}
```

In this example:
- The `success` case has an associated `String` value
- The `failure` case has an associated `Error` value

## Creating Enum Instances with Associated Values

To create an instance of an enum with associated values, you include the value(s) when selecting the case:

```swift
let downloadResult = Result.success("Document downloaded successfully")
let uploadResult = Result.failure(NetworkError.connectionLost)
```

## Extracting Associated Values

There are several ways to access the associated values from an enum:

### 1. Using Switch Statements with Value Binding

```swift
switch downloadResult {
case .success(let message):
    print("Operation was successful: \(message)")
case .failure(let error):
    print("Operation failed with error: \(error)")
}
```

Output:
```
Operation was successful: Document downloaded successfully
```

You can also put the `let` keyword before the entire case for cleaner syntax:

```swift
switch downloadResult {
case let .success(message):
    print("Success: \(message)")
case let .failure(error):
    print("Failure: \(error)")
}
```

### 2. Using If-Case Binding

If you're only interested in one specific case, you can use an `if case` statement:

```swift
if case .success(let message) = downloadResult {
    print("Success message: \(message)")
}
```

Output:
```
Success message: Document downloaded successfully
```

## Multiple Associated Values

Enum cases can have multiple associated values, which can be organized as separate values or as a tuple:

```swift
enum ShippingStatus {
    case processing
    case shipped(trackingNumber: String, estimatedDelivery: Date)
    case delivered(deliveryDate: Date)
    case failed(reason: String, attemptCount: Int)
}
```

When working with multiple associated values, you can use labeled parameters to improve readability:

```swift
let package = ShippingStatus.shipped(
    trackingNumber: "1Z999AA10123456784", 
    estimatedDelivery: Date()
)

if case .shipped(let tracking, _) = package {
    print("Your package is on its way! Tracking number: \(tracking)")
}
```

## Practical Examples

Let's explore some real-world applications of enums with associated values:

### Example 1: Representing API Results

```swift
enum APIResult {
    case success(data: Data, statusCode: Int)
    case failure(error: Error, statusCode: Int?)
    case networkError(reason: String)
}

func processAPIResponse(_ result: APIResult) {
    switch result {
    case .success(let data, let statusCode):
        print("API call successful with status \(statusCode), data size: \(data.count) bytes")
        
    case .failure(let error, let statusCode):
        if let code = statusCode {
            print("API error: \(error.localizedDescription) with status code \(code)")
        } else {
            print("API error: \(error.localizedDescription) with unknown status code")
        }
        
    case .networkError(let reason):
        print("Network connection issue: \(reason)")
    }
}

// Example usage
let successResult = APIResult.success(data: Data([0, 1, 2, 3]), statusCode: 200)
processAPIResponse(successResult)
```

Output:
```
API call successful with status 200, data size: 4 bytes
```

### Example 2: Representing Barcode Types

```swift
enum Barcode {
    case upc(numberSystem: Int, manufacturer: Int, product: Int, check: Int)
    case qrCode(String)
}

func scanBarcode(_ barcode: Barcode) {
    switch barcode {
    case let .upc(system, manufacturer, product, check):
        print("UPC: \(system)-\(manufacturer)-\(product)-\(check)")
        
    case let .qrCode(productCode):
        print("QR code: \(productCode)")
    }
}

// Example usage
let milkBarcode = Barcode.upc(numberSystem: 8, manufacturer: 85909, product: 51226, check: 3)
let websiteQR = Barcode.qrCode("https://www.example.com/product/1234")

scanBarcode(milkBarcode)
scanBarcode(websiteQR)
```

Output:
```
UPC: 8-85909-51226-3
QR code: https://www.example.com/product/1234
```

### Example 3: Representing Different Measurement Units

```swift
enum Distance {
    case kilometers(Double)
    case miles(Double)
    case lightyears(Double)
    
    func inKilometers() -> Double {
        switch self {
        case .kilometers(let value):
            return value
        case .miles(let value):
            return value * 1.60934
        case .lightyears(let value):
            return value * 9.461e12
        }
    }
}

let marathonDistance = Distance.kilometers(42.195)
let roadTrip = Distance.miles(350)
let spaceTravel = Distance.lightyears(4.22)

print("Marathon distance: \(marathonDistance.inKilometers()) km")
print("Road trip distance: \(roadTrip.inKilometers()) km")
print("Distance to Proxima Centauri: \(spaceTravel.inKilometers()) km")
```

Output:
```
Marathon distance: 42.195 km
Road trip distance: 563.269 km
Distance to Proxima Centauri: 3.992542e+13 km
```

## When to Use Associated Values

Associated values are particularly useful when:

1. You need to categorize data but also maintain specific details about each category
2. You want to handle different types of values in a type-safe way
3. You're modeling state that requires additional context
4. You're working with results or operations that can have multiple outcomes with different data requirements

## Summary

Associated values are a powerful feature that elevate Swift enumerations beyond simple lists of options. They enable you to:

- Attach custom data to enum cases
- Store different types of data for different cases
- Create more expressive and precise domain models
- Handle complex state and results in a type-safe way

By mastering associated values, you can write more concise, type-safe, and expressive code that accurately models your application's data and behavior.

## Exercises

1. Create an enum called `Notification` that represents different types of mobile notifications (e.g., message, reminder, alert) with appropriate associated values for each.

2. Define an enum `Payment` that represents different payment methods (credit card, PayPal, bank transfer, etc.) with relevant associated data.

3. Create an enum `GameResult` for a chess game that includes cases for win, loss, draw, and abandoned, with appropriate associated values (like player names, reason for abandonment, etc.).

## Additional Resources

- [Swift Documentation: Enumerations](https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html)
- [Apple Developer: Swift Programming Language](https://developer.apple.com/swift/)
- [Swift by Sundell: Enum-driven API Development](https://www.swiftbysundell.com/articles/enum-driven-api-development-in-swift/)