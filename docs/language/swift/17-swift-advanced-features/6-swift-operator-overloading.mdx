---
title: Swift Operator Overloading
description: Learn how to customize the behavior of Swift operators for your custom types through operator overloading, allowing for more readable and expressive code.

---

# Swift Operator Overloading

## Introduction

Operator overloading is a powerful feature in Swift that allows you to define how operators (such as `+`, `-`, `*`, `/`, etc.) behave when applied to your custom types. This enables you to write more expressive and readable code by using familiar syntax with your own data types.

By default, Swift's standard operators work with built-in types like integers, floating-point numbers, and strings. With operator overloading, you can extend these operators to work with your custom classes, structures, and enumerations in ways that make sense for your specific use cases.

In this tutorial, we'll explore:
- The basics of operator overloading in Swift
- How to overload arithmetic, comparison, and other operators
- Custom operator implementation
- Best practices and real-world applications

## Understanding Operator Overloading

In Swift, operators are essentially special functions with special syntax. When you overload an operator, you're defining a function that implements the operator's behavior for your custom types.

### Types of Operators in Swift

Before diving into overloading, let's review the types of operators we can overload:

1. **Unary operators**: Act on a single operand (e.g., `-a`, `!b`)
2. **Binary operators**: Act on two operands (e.g., `a + b`, `c * d`)
3. **Ternary operator**: Swift has only one - the conditional operator `a ? b : c`

## Basic Operator Overloading

Let's start with a simple example. Imagine we have a custom `Point` structure representing a 2D point:

```swift
struct Point {
    var x: Int
    var y: Int
}
```

### Overloading the Addition Operator (+)

To enable adding two points together (which would typically add their respective coordinates), we define the `+` operator:

```swift
extension Point {
    static func + (lhs: Point, rhs: Point) -> Point {
        return Point(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
    }
}
```

Now we can use the `+` operator with our `Point` type:

```swift
let point1 = Point(x: 10, y: 20)
let point2 = Point(x: 30, y: 40)
let combinedPoint = point1 + point2

print("Combined point: (\(combinedPoint.x), \(combinedPoint.y))")
// Output: Combined point: (40, 60)
```

### Overloading the Subtraction Operator (-)

Similarly, we can implement the subtraction operator:

```swift
extension Point {
    static func - (lhs: Point, rhs: Point) -> Point {
        return Point(x: lhs.x - rhs.x, y: lhs.y - rhs.y)
    }
}
```

And use it:

```swift
let differencPoint = point1 - point2
print("Difference point: (\(differencPoint.x), \(differencPoint.y))")
// Output: Difference point: (-20, -20)
```

## Overloading Comparison Operators

Comparison operators like `==`, `!=`, `<`, `>`, `<=`, and `>=` are also commonly overloaded. Let's implement equality for our `Point` type:

```swift
extension Point: Equatable {
    static func == (lhs: Point, rhs: Point) -> Bool {
        return lhs.x == rhs.x && lhs.y == rhs.y
    }
}
```

Note that when implementing `==`, Swift automatically provides the `!=` operator for you.

With the `Equatable` protocol conformance:

```swift
let point3 = Point(x: 10, y: 20)
if point1 == point3 {
    print("Points are equal")
} else {
    print("Points are not equal")
}
// Output: Points are equal

if point1 != point2 {
    print("Points are different")
}
// Output: Points are different
```

## Overloading Compound Assignment Operators

Compound assignment operators (like `+=`, `-=`) combine an operation with assignment. Let's implement `+=` for our `Point` type:

```swift
extension Point {
    static func += (lhs: inout Point, rhs: Point) {
        lhs = Point(x: lhs.x + rhs.x, y: lhs.y + rhs.y)
    }
}
```

Notice the `inout` keyword - this allows the function to modify the parameter's value directly.

Now we can use it:

```swift
var movingPoint = Point(x: 5, y: 10)
movingPoint += Point(x: 3, y: 7)
print("Updated point: (\(movingPoint.x), \(movingPoint.y))")
// Output: Updated point: (8, 17)
```

## Overloading Unary Operators

Unary operators work on a single operand. Let's implement the unary minus operator for our `Point` type:

```swift
extension Point {
    static prefix func - (point: Point) -> Point {
        return Point(x: -point.x, y: -point.y)
    }
}
```

Now we can negate a point:

```swift
let point4 = Point(x: 25, y: 35)
let negatedPoint = -point4
print("Negated point: (\(negatedPoint.x), \(negatedPoint.y))")
// Output: Negated point: (-25, -35)
```

## Custom Operators

Swift also allows you to define entirely new operators. This should be done sparingly to avoid making your code difficult to understand.

To create a custom operator, you first need to declare it:

```swift
// Declare a custom operator
prefix operator +++

extension Point {
    static prefix func +++ (point: Point) -> Point {
        return Point(x: point.x * 2, y: point.y * 2)
    }
}
```

Now we can use our custom operator:

```swift
let doubledPoint = +++point1
print("Doubled point: (\(doubledPoint.x), \(doubledPoint.y))")
// Output: Doubled point: (20, 40)
```

## Real-World Example: Vector Operations

Let's consider a more practical example with a `Vector3D` struct representing a 3D vector:

```swift
struct Vector3D {
    var x: Double
    var y: Double
    var z: Double
    
    // Calculate the magnitude (length) of the vector
    var magnitude: Double {
        return sqrt(x * x + y * y + z * z)
    }
}

// Implement vector addition
extension Vector3D {
    static func + (lhs: Vector3D, rhs: Vector3D) -> Vector3D {
        return Vector3D(x: lhs.x + rhs.x, 
                       y: lhs.y + rhs.y, 
                       z: lhs.z + rhs.z)
    }
    
    // Dot product (scalar product)
    static func * (lhs: Vector3D, rhs: Vector3D) -> Double {
        return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z
    }
    
    // Scalar multiplication
    static func * (vector: Vector3D, scalar: Double) -> Vector3D {
        return Vector3D(x: vector.x * scalar, 
                       y: vector.y * scalar, 
                       z: vector.z * scalar)
    }
    
    // Scalar multiplication (commutative)
    static func * (scalar: Double, vector: Vector3D) -> Vector3D {
        return vector * scalar
    }
}
```

Usage example:

```swift
let force = Vector3D(x: 10.0, y: 20.0, z: 30.0)
let displacement = Vector3D(x: 5.0, y: 0.0, z: 0.0)

// Sum of vectors
let resultantForce = force + displacement
print("Resultant force: (\(resultantForce.x), \(resultantForce.y), \(resultantForce.z))")
// Output: Resultant force: (15.0, 20.0, 30.0)

// Dot product
let work = force * displacement
print("Work done: \(work)")
// Output: Work done: 50.0

// Double the force
let doubledForce = force * 2.0
print("Doubled force: (\(doubledForce.x), \(doubledForce.y), \(doubledForce.z))")
// Output: Doubled force: (20.0, 40.0, 60.0)
```

## Best Practices for Operator Overloading

1. **Maintain intuitive semantics**: Operators should behave as users would expect. For example, `+` should represent addition or combination, not subtraction or comparison.

2. **Avoid surprising behavior**: Don't make `*` perform addition or `==` perform ordering.

3. **Use custom operators sparingly**: While it's possible to define custom operators, do so only when they provide significant clarity or represent well-known mathematical or domain-specific notations.

4. **Document custom operators**: Always provide clear documentation for any custom operators.

5. **Consider using functions**: If an operator's purpose isn't immediately clear, consider using a named function instead.

## Example: Currency Operations

Let's see a practical application with a `Money` struct representing currency amounts:

```swift
struct Money {
    var amount: Decimal
    var currency: String
    
    init(amount: Decimal, currency: String) {
        self.amount = amount
        self.currency = currency
    }
}

// Addition operator - only works for same currency
extension Money {
    static func + (lhs: Money, rhs: Money) -> Money? {
        // Currency must match
        if lhs.currency == rhs.currency {
            return Money(amount: lhs.amount + rhs.amount, currency: lhs.currency)
        }
        return nil // Cannot add different currencies directly
    }
    
    static func - (lhs: Money, rhs: Money) -> Money? {
        if lhs.currency == rhs.currency {
            return Money(amount: lhs.amount - rhs.amount, currency: lhs.currency)
        }
        return nil
    }
    
    // Multiply by a scalar
    static func * (lhs: Money, rhs: Decimal) -> Money {
        return Money(amount: lhs.amount * rhs, currency: lhs.currency)
    }
}

// Add equality comparison
extension Money: Equatable {
    static func == (lhs: Money, rhs: Money) -> Bool {
        return lhs.amount == rhs.amount && lhs.currency == rhs.currency
    }
}
```

Usage example:

```swift
let price = Money(amount: 19.99, currency: "USD")
let tax = Money(amount: 1.59, currency: "USD")
let discount = Money(amount: 5.00, currency: "USD")

if let totalCost = price + tax - discount {
    print("Total cost: \(totalCost.amount) \(totalCost.currency)")
    // Output: Total cost: 16.58 USD
}

let bulkPrice = price * 5
print("Five-item price: \(bulkPrice.amount) \(bulkPrice.currency)")
// Output: Five-item price: 99.95 USD

// Attempt to add different currencies
let euroPrice = Money(amount: 18.50, currency: "EUR")
if let combined = price + euroPrice {
    print("Combined: \(combined.amount) \(combined.currency)")
} else {
    print("Cannot add different currencies directly!")
    // Output: Cannot add different currencies directly!
}
```

## Summary

Operator overloading in Swift is a powerful feature that allows you to extend the language's standard operators to work with your custom types. When used appropriately, it can make your code more readable, expressive, and intuitive.

Key points to remember:

1. You can overload most standard Swift operators for your custom types
2. When overloading operators, maintain intuitive semantics
3. Operator overloading can significantly improve readability for mathematical or domain-specific types
4. Custom operators should be used sparingly and documented thoroughly
5. Swift can automatically provide complementary operators (like `!=` when you implement `==`)

## Exercises

1. Create a `Fraction` struct with numerator and denominator properties, and implement arithmetic operators (`+`, `-`, `*`, `/`) for it.

2. Extend the `Vector3D` example to implement cross product using a custom operator.

3. Create a `Matrix2x2` struct to represent 2×2 matrices and implement appropriate operators for matrix operations.

4. Implement the spaceship operator (`<=>`) in Swift (as a custom operator) that returns -1, 0, or 1 for less than, equal to, or greater than comparisons.

5. Create a `TimeInterval` struct and implement operators to add and subtract time intervals, as well as multiply a time interval by a scalar.

## Additional Resources

- [Swift Documentation on Advanced Operators](https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html)
- [Protocol-Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/)
- [Swift Standard Library - Operators](https://developer.apple.com/documentation/swift/operator_declarations)