---
title: "Swift Dynamic Member Lookup"
description: "Learn how to use Swift's Dynamic Member Lookup feature to enable dynamic property access, making your code more flexible and expressive."

---

# Swift Dynamic Member Lookup

Swift's `@dynamicMemberLookup` attribute is a powerful feature that enables more flexible and dynamic access to properties in your code. This feature, introduced in Swift 4.2, brings some of the flexibility of dynamic languages like Python or JavaScript to Swift while maintaining type safety.

## What is Dynamic Member Lookup?

The `@dynamicMemberLookup` attribute allows instances of a type to be accessed using dot syntax for property names that aren't defined at compile time. Instead, these property accesses are resolved at runtime through a subscript method that you implement.

In simpler terms, it lets you write code like `person.name` even if `name` isn't defined as a property in the `Person` class or struct. The Swift compiler will transform this into a method call behind the scenes.

## Basic Usage

To use dynamic member lookup, you need to:

1. Apply the `@dynamicMemberLookup` attribute to your type
2. Implement at least one `subscript(dynamicMember:)` method

Let's start with a simple example:

```swift
@dynamicMemberLookup
struct Person {
    var info: [String: String]
    
    subscript(dynamicMember key: String) -> String {
        return info[key] ?? "No information available"
    }
}

// Creating a person
let john = Person(info: ["name": "John", "age": "28", "occupation": "Developer"])

// Accessing properties dynamically
print(john.name)         // "John"
print(john.age)          // "28"
print(john.occupation)   // "Developer"
print(john.address)      // "No information available"
```

In this example, `john.name` is automatically converted to `john[dynamicMember: "name"]` by the Swift compiler. This allows us to access the dictionary values using dot notation, which is more elegant and familiar.

## Type Safety with Dynamic Member Lookup

One of Swift's strengths is type safety, and dynamic member lookup maintains this feature. You can specify the return type of your subscript method, and the compiler will enforce it:

```swift
@dynamicMemberLookup
struct TypedPerson {
    var info: [String: Any]
    
    subscript<T>(dynamicMember key: String) -> T? {
        return info[key] as? T
    }
    
    subscript(dynamicMember key: String) -> String {
        return info[key] as? String ?? "No information"
    }
}

let jane = TypedPerson(info: ["name": "Jane", "age": 30, "isEmployed": true])

// Each property access uses the appropriate type
let name: String = jane.name        // "Jane"
let age: Int? = jane.age            // 30
let isEmployed: Bool? = jane.isEmployed  // true
let unknown: Double? = jane.salary  // nil
```

Notice that we've provided multiple subscript methods with different return types. Swift will choose the appropriate one based on the context where the property is used.

## Key Paths with Dynamic Member Lookup

You can also use key paths with dynamic member lookup for more complex scenarios:

```swift
@dynamicMemberLookup
struct Employee {
    let name: String
    let department: Department
    
    struct Department {
        let name: String
        let position: String
    }
    
    subscript<T>(dynamicMember keyPath: KeyPath<Department, T>) -> T {
        return department[keyPath: keyPath]
    }
}

let employee = Employee(
    name: "Alice",
    department: Employee.Department(name: "Engineering", position: "Lead Developer")
)

// Access department properties directly through employee
print(employee.name)      // "Alice"
print(employee.position)  // "Lead Developer" (from department)
```

This example shows how we can access nested properties directly, providing a cleaner API.

## Practical Applications

### 1. Working with JSON Data

Dynamic member lookup is particularly useful when working with JSON data:

```swift
@dynamicMemberLookup
struct JSON {
    private var data: [String: Any]
    
    init(data: [String: Any]) {
        self.data = data
    }
    
    subscript(dynamicMember key: String) -> JSON {
        let value = data[key]
        
        if let dict = value as? [String: Any] {
            return JSON(data: dict)
        }
        
        if let array = value as? [[String: Any]], !array.isEmpty {
            return JSON(data: ["array": array])
        }
        
        return JSON(data: [:])
    }
    
    subscript(dynamicMember key: String) -> String {
        return data[key] as? String ?? ""
    }
    
    subscript(dynamicMember key: String) -> Int {
        return data[key] as? Int ?? 0
    }
    
    subscript(dynamicMember key: String) -> Bool {
        return data[key] as? Bool ?? false
    }
}

// Example JSON data
let userData: [String: Any] = [
    "user": [
        "name": "Steve",
        "age": 35,
        "address": [
            "street": "123 Swift Street",
            "city": "Cupertino"
        ],
        "isPremium": true
    ]
]

let json = JSON(data: userData)

// Access nested values with dot syntax
print(json.user.name)                 // "Steve"
print(json.user.age)                  // 35
print(json.user.address.street)       // "123 Swift Street"
print(json.user.isPremium)            // true
print(json.user.nonExistentField)     // "" (default value)
```

### 2. Interoperability with Dynamic Languages

Dynamic member lookup can make it easier to bridge between Swift and more dynamic languages:

```swift
@dynamicMemberLookup
struct PythonObject {
    private let pythonObject: PyObject // Assume this is from a Python interop framework
    
    subscript(dynamicMember name: String) -> PythonObject {
        let attribute = PyObject_GetAttrString(pythonObject, name)
        return PythonObject(pythonObject: attribute)
    }
    
    subscript(dynamicMember name: String) -> String {
        let attribute = PyObject_GetAttrString(pythonObject, name)
        // Convert Python string to Swift string
        return String(pythonAttributeToCString(attribute))
    }
    
    // Additional implementations for other return types
}

// This would allow Python-like syntax in Swift:
// let numpy = PythonObject(importing: "numpy")
// let array = numpy.array([1, 2, 3, 4])
// let sum = array.sum()
```

## When to Use Dynamic Member Lookup

Dynamic member lookup is powerful but should be used judiciously:

1. **When working with dynamic data structures** like JSON or dictionary-based data
2. **For interoperability** with dynamic languages
3. **To create more fluent interfaces** that hide implementation details
4. **When accessing nested structures** where direct access would be clearer

## When Not to Use Dynamic Member Lookup

Avoid using dynamic member lookup when:

1. **Static, compile-time property access is sufficient** - traditional properties provide better compile-time checking
2. **When clarity is more important than flexibility** - dynamic properties may be harder to discover
3. **In performance-critical code** - there's a small overhead to the dynamic dispatch

## Summary

Swift's `@dynamicMemberLookup` attribute provides a powerful way to access properties dynamically at runtime while maintaining Swift's type safety. It allows for more flexible, expressive code and can be particularly useful when working with dynamic data sources or interoperating with more dynamic languages.

The feature enhances Swift's expressiveness without sacrificing safety, giving you the best of both worlds: the flexibility of dynamic languages when needed, with the safety and performance of a statically typed language.

## Additional Resources

- [Swift Evolution Proposal SE-0195](https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md) - The original proposal for this feature
- [Dynamic Member Lookup in Swift](https://docs.swift.org/swift-book/ReferenceManual/Attributes.html) - Official Swift documentation
- [Swift & the Objective-C Runtime](https://developer.apple.com/swift/blog/?id=19) - Apple's blog post about Swift's interoperability

## Exercises

1. Create a `Settings` class with dynamic member lookup that reads from a configuration file or user defaults
2. Implement a `Database` class that uses dynamic member lookup to access table names as properties
3. Build a more complex JSON parser with support for arrays using dynamic member lookup
4. Create a wrapper for a REST API that uses dynamic member lookup to access endpoints