---
title: Swift C Interoperability
description: Learn how Swift seamlessly interoperates with C code, allowing you to leverage existing C libraries and APIs while enjoying Swift's safety and expressiveness.

---

# Swift C Interoperability

## Introduction

One of Swift's most powerful features is its ability to interoperate with C code. This capability allows Swift developers to leverage existing C libraries and APIs while enjoying the safety and expressiveness of Swift. C interoperability is particularly valuable because it gives you access to lower-level system functionality, performance-critical code, and a vast ecosystem of established C libraries.

In this guide, we'll explore how Swift seamlessly bridges to C, allowing you to:

- Import and use C libraries in Swift code
- Work with C data types in Swift
- Call C functions from Swift
- Expose Swift code to C and Objective-C

Whether you're building performance-critical applications, working with hardware interfaces, or just need to use an existing C library, understanding Swift's C interoperability will expand your programming toolkit.

## Setting Up C Interoperability

### Creating a Bridging Header

When working with C code in a Swift project, you'll often use a bridging header. This special header file tells the Swift compiler which C declarations to make available to your Swift code.

To create a bridging header in Xcode:

1. Add a new header file to your project (File > New > File > Header File)
2. Name it `[YourProjectName]-Bridging-Header.h`
3. Configure your target's build settings to use this file:
   - Set "Objective-C Bridging Header" to the path of your bridging header

In your bridging header, you can include C header files:

```c
// MyProject-Bridging-Header.h
#include <stdio.h>
#include "my_c_library.h"
```

### Using Module Maps

For more complex C libraries, you can use module maps. A module map file defines how a collection of C headers should be imported into Swift.

Create a file named `module.modulemap`:

```
module MyCLibrary {
    header "my_c_library.h"
    export *
}
```

Then import the module in Swift:

```swift
import MyCLibrary

// Now you can use functions from my_c_library.h
```

## Working with C Types in Swift

Swift automatically imports C types and provides corresponding Swift types:

| C Type | Swift Type |
|--------|------------|
| `int`, `long` | `CInt`, `CLong` |
| `float`, `double` | `CFloat`, `CDouble` |
| `char*` | `UnsafeMutablePointer<CChar>` |
| `const char*` | `UnsafePointer<CChar>` |
| `void*` | `UnsafeMutableRawPointer` |
| `const void*` | `UnsafeRawPointer` |
| C struct | Swift struct |
| C enum | Swift enum |

### Example: Working with C Structs

Consider this C struct:

```c
// In C header
typedef struct {
    int x;
    int y;
} Point;
```

When imported into Swift, it becomes:

```swift
// Automatically available in Swift
struct Point {
    var x: CInt
    var y: CInt
}
```

You can use this struct in Swift like any other Swift type:

```swift
var point = Point(x: 10, y: 20)
print("Point coordinates: (\(point.x), \(point.y))")
// Output: Point coordinates: (10, 20)
```

## Calling C Functions from Swift

C functions are imported into Swift automatically and can be called directly.

### Basic Function Calls

```c
// In C header
int add(int a, int b);
```

In Swift:

```swift
let result = add(5, 3)
print("5 + 3 = \(result)")
// Output: 5 + 3 = 8
```

### Working with C Strings

C strings require special handling in Swift:

```c
// In C header
char* get_greeting(void);
void print_message(const char* message);
```

In Swift:

```swift
// Converting C string to Swift String
if let cString = get_greeting() {
    let swiftString = String(cString: cString)
    print(swiftString)
    // Output might be: Hello, World!
}

// Converting Swift String to C string
let message = "Hello from Swift!"
message.withCString { cString in
    print_message(cString)
}
```

### Memory Management with C Functions

When working with C functions that allocate or require memory, you need to handle memory management carefully:

```c
// In C header
void* allocate_buffer(size_t size);
void free_buffer(void* buffer);
```

In Swift:

```swift
let bufferSize = 1024
guard let buffer = allocate_buffer(bufferSize) else {
    print("Failed to allocate buffer")
    return
}

// Use the buffer
defer {
    // This will be executed when the scope exits
    free_buffer(buffer)
}

// Work with the buffer here
```

## Pointers and Memory in Swift-C Interoperability

Swift provides several pointer types to work with C APIs:

- `UnsafePointer<T>`: Equivalent to `const T*` in C
- `UnsafeMutablePointer<T>`: Equivalent to `T*` in C
- `UnsafeRawPointer`: Equivalent to `const void*` in C
- `UnsafeMutableRawPointer`: Equivalent to `void*` in C

### Allocating Memory in Swift for C Functions

```swift
// Allocate memory for an integer
let intPointer = UnsafeMutablePointer<CInt>.allocate(capacity: 1)
defer {
    intPointer.deallocate()
}

// Initialize memory
intPointer.initialize(to: 42)

// Pass to C function that takes an int*
some_c_function(intPointer)

// Read value back
let value = intPointer.pointee
print("Value: \(value)")
```

### Working with Arrays

```swift
// Create a Swift array
let numbers = [1, 2, 3, 4, 5]

// Pass array to C function expecting int*
numbers.withUnsafeBufferPointer { buffer in
    if let baseAddress = buffer.baseAddress {
        process_array(baseAddress, CInt(buffer.count))
    }
}

// For mutable arrays
var mutableNumbers = [1, 2, 3, 4, 5]
mutableNumbers.withUnsafeMutableBufferPointer { buffer in
    if let baseAddress = buffer.baseAddress {
        modify_array(baseAddress, CInt(buffer.count))
    }
}
```

## Practical Example: Using a C Library in Swift

Let's work through a complete example using the popular C library `libcurl` for making HTTP requests.

First, include the library in your bridging header:

```c
// MyProject-Bridging-Header.h
#include <curl/curl.h>
```

Now you can use curl in your Swift code:

```swift
import Foundation

// Callback function to handle received data
func writeDataCallback(
    ptr: UnsafeMutableRawPointer?, 
    size: CSize, 
    nmemb: CSize, 
    data: UnsafeMutableRawPointer?
) -> CSize {
    let realsize = size * nmemb
    let data = data?.assumingMemoryBound(to: Data.self)
    
    if let ptr = ptr, let data = data {
        let buffer = UnsafeBufferPointer<UInt8>(
            start: ptr.assumingMemoryBound(to: UInt8.self),
            count: realsize)
        data.pointee.append(contentsOf: buffer)
    }
    
    return realsize
}

func fetchWebsite(url: String) -> Data? {
    // Initialize CURL
    guard let curl = curl_easy_init() else {
        print("Failed to initialize curl")
        return nil
    }
    defer { curl_easy_cleanup(curl) }
    
    // Set URL
    url.withCString { urlCString in
        curl_easy_setopt(curl, CURLOPT_URL, urlCString)
    }
    
    // Set up data handling
    var responseData = Data()
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeDataCallback)
    withUnsafeMutablePointer(to: &responseData) { responseDataPtr in
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, responseDataPtr)
    }
    
    // Perform the request
    let result = curl_easy_perform(curl)
    
    guard result == CURLE_OK else {
        print("Request failed: \(result)")
        return nil
    }
    
    return responseData
}

// Use the function
if let data = fetchWebsite(url: "https://www.example.com") {
    if let htmlString = String(data: data, encoding: .utf8) {
        print("Received HTML: \(htmlString.prefix(100))...")
    }
}
```

This example demonstrates:
1. Defining a C callback function in Swift
2. Managing memory safely with Swift's pointer types
3. Calling C library functions
4. Handling C error codes

## Exposing Swift to C

Sometimes you need your Swift code to be callable from C. You can use the `@_cdecl` attribute to expose Swift functions to C:

```swift
@_cdecl("swift_greeting")
func swiftGreeting(name: UnsafePointer<CChar>) -> UnsafeMutablePointer<CChar> {
    let swiftName = String(cString: name)
    let greeting = "Hello, \(swiftName)!"
    
    let cString = strdup(greeting)
    return cString!
}
```

This Swift function can be called from C code like this:

```c
// In C code
extern char* swift_greeting(const char* name);

void some_function() {
    char* greeting = swift_greeting("John");
    printf("%s\n", greeting);
    free(greeting);  // Don't forget to free the memory
}
```

## Common Pitfalls and Best Practices

### Memory Management

When working with C APIs, Swift won't automatically manage memory allocated by C functions. Always:

1. Free memory allocated by C functions
2. Use `defer` blocks to ensure cleanup happens
3. Be careful with pointersâ€”Swift's memory safety features don't fully apply to unsafe code

```swift
// Good practice
let cString = some_c_function_that_allocates()
defer {
    free(cString)
}
// Use cString safely here...
```

### Type Safety Considerations

C is less type-safe than Swift. Be careful with:

1. Implicit conversions between integer types
2. Null pointer checking
3. Buffer overruns

```swift
// Check for null pointers
guard let pointer = some_c_function() else {
    print("Received null pointer")
    return
}

// Check array bounds
let bufferSize = 10
let buffer = UnsafeMutablePointer<CInt>.allocate(capacity: bufferSize)
defer { buffer.deallocate() }

// Only access within bounds
for i in 0..<bufferSize {
    buffer[i] = CInt(i * 2)
}
```

### Thread Safety

C libraries may have different threading models than Swift. Check the documentation for any C library you use to ensure thread safety.

## Summary

Swift's C interoperability features provide a powerful bridge between modern Swift programming and the vast ecosystem of C libraries and APIs. Through this interoperability, you can:

- Access low-level system functionality
- Leverage high-performance C code
- Use established C libraries
- Gradually migrate C codebases to Swift

While working with unsafe pointers and manual memory management requires careful attention, Swift's interoperability with C opens up many possibilities that would otherwise be unavailable in a pure Swift environment.

## Additional Resources

- [Swift Documentation: C and Objective-C Interoperability](https://developer.apple.com/documentation/swift/swift_standard_library/c_and_objective-c_interoperability)
- [Apple's Swift Documentation on Using Imported C Functions](https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/using_imported_c_functions_in_swift)
- [LLVM Project Blog: Interoperability with C](https://llvm.org/devmtg/2015-10/slides/GroffLattner-SILForiOStvOS.pdf)

## Exercises

1. **Basic C Function Calling**: Create a Swift program that uses the C standard library function `qsort()` to sort an array of integers.

2. **C Library Integration**: Choose a simple C library (like SQLite or libpng) and write Swift code to use its basic functionality.

3. **Custom C Bridge**: Write a small C library with a few functions, then create a Swift wrapper that provides a more "Swifty" interface to this library.

4. **Memory Management Challenge**: Write a Swift function that correctly manages memory while working with a C function that returns dynamically allocated memory.

5. **Callback Implementation**: Create a Swift program that passes a Swift closure as a callback to a C function requiring a function pointer.