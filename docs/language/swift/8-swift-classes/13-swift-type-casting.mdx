---
title: Swift Type Casting
description: Learn how to check and interpret the type of a class instance at runtime, cast instances to different class types in a class hierarchy, and use type casting operators in Swift.

---

# Swift Type Casting

In Swift, type casting is a way to check the type of an instance or to treat that instance as a different superclass or subclass type within its class hierarchy. Type casting enables you to check the type of a value, treat a value as a different type, and determine whether a value matches certain type constraints.

## Understanding Type Casting in Swift

Type casting in Swift involves using two operators:
- `is`: Used for type checking
- `as`, `as?`, `as!`: Used for type conversion

Let's explore how these operators work through examples.

## Type Checking with `is` Operator

The `is` operator checks whether an instance is of a certain type. It returns `true` if the instance is of that specific type and `false` otherwise.

```swift
class MediaItem {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

class Movie: MediaItem {
    var director: String
    
    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

class Song: MediaItem {
    var artist: String
    
    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}

// Create an array of MediaItem objects
let library = [
    Movie(name: "Inception", director: "Christopher Nolan"),
    Song(name: "Shake It Off", artist: "Taylor Swift"),
    Movie(name: "Interstellar", director: "Christopher Nolan"),
    Song(name: "Bad Blood", artist: "Taylor Swift")
]

// Count movies and songs
var movieCount = 0
var songCount = 0

for item in library {
    if item is Movie {
        movieCount += 1
    } else if item is Song {
        songCount += 1
    }
}

print("Media library contains \(movieCount) movies and \(songCount) songs")
// Output: Media library contains 2 movies and 2 songs
```

In this example, we used the `is` operator to check if each item in our library is a `Movie` or a `Song`.

## Downcasting with `as?` and `as!` Operators

Downcasting is the process of converting a class instance to one of its subclass types. Since downcasting can potentially fail, Swift provides two downcasting operators:

1. The conditional form `as?` returns an optional value that will be `nil` if the downcast fails
2. The forced form `as!` attempts the downcast and triggers a runtime error if the downcast fails

### Conditional Downcasting (`as?`)

```swift
for item in library {
    if let movie = item as? Movie {
        print("Movie: \(movie.name), directed by \(movie.director)")
    } else if let song = item as? Song {
        print("Song: \(song.name), by \(song.artist)")
    }
}

// Output:
// Movie: Inception, directed by Christopher Nolan
// Song: Shake It Off, by Taylor Swift
// Movie: Interstellar, directed by Christopher Nolan
// Song: Bad Blood, by Taylor Swift
```

In this example, we use conditional downcasting to safely access the properties specific to each subclass.

### Forced Downcasting (`as!`)

```swift
// Only use as! when you're certain about the type
let firstItem = library[0]
let movie = firstItem as! Movie
print("The first item is the movie \(movie.name)")
// Output: The first item is the movie Inception

// This would cause a runtime error if firstItem wasn't a Movie
```

**Note:** Only use forced downcasting when you're absolutely sure that the downcast will succeed. Incorrect use of `as!` can cause your app to crash.

## Upcasting with `as` Operator

You can also use the `as` operator for upcasting (casting to a superclass type), which always succeeds:

```swift
let movie = Movie(name: "The Matrix", director: "The Wachowskis")
let mediaItem = movie as MediaItem
print("Media item name: \(mediaItem.name)")
// Output: Media item name: The Matrix

// Note that mediaItem no longer has access to the 'director' property
```

## Type Casting for Any and AnyObject

Swift provides two special types to work with non-specific types:

- `Any` can represent an instance of any type, including function types
- `AnyObject` can represent an instance of any class type

### Working with Any

```swift
var things: [Any] = []

things.append(0)                              // Int
things.append(0.0)                            // Double
things.append("Hello")                        // String
things.append((3.0, 5.0))                     // Tuple
things.append(Movie(name: "Avatar", director: "James Cameron"))
things.append({ (name: String) -> String in   // Function
    return "Hello, \(name)"
})

for thing in things {
    switch thing {
    case let someInt as Int:
        print("An integer with value \(someInt)")
    case let someDouble as Double:
        print("A double with value \(someDouble)")
    case let someString as String:
        print("A string with value \"\(someString)\"")
    case let (x, y) as (Double, Double):
        print("A tuple with values (\(x), \(y))")
    case let movie as Movie:
        print("A movie called \(movie.name), directed by \(movie.director)")
    case let stringConverter as (String) -> String:
        print("A function that returned \(stringConverter("Michael"))")
    default:
        print("Something else")
    }
}

// Output:
// An integer with value 0
// A double with value 0.0
// A string with value "Hello"
// A tuple with values (3.0, 5.0)
// A movie called Avatar, directed by James Cameron
// A function that returned Hello, Michael
```

## Real-world Application: Building a Media Player

Let's implement a simplified media player that handles different types of media content:

```swift
class MediaContent {
    let title: String
    let fileSize: Int // in MB
    
    init(title: String, fileSize: Int) {
        self.title = title
        self.fileSize = fileSize
    }
    
    func play() {
        print("Playing media content...")
    }
}

class VideoContent: MediaContent {
    let resolution: String
    let duration: Int // in seconds
    
    init(title: String, fileSize: Int, resolution: String, duration: Int) {
        self.resolution = resolution
        self.duration = duration
        super.init(title: title, fileSize: fileSize)
    }
    
    override func play() {
        print("Playing video: \(title) (\(resolution)) - \(duration/60)m \(duration%60)s")
    }
}

class AudioContent: MediaContent {
    let artist: String
    let duration: Int // in seconds
    
    init(title: String, fileSize: Int, artist: String, duration: Int) {
        self.artist = artist
        self.duration = duration
        super.init(title: title, fileSize: fileSize)
    }
    
    override func play() {
        print("Playing audio: \(title) by \(artist) - \(duration/60)m \(duration%60)s")
    }
}

class DocumentContent: MediaContent {
    let pageCount: Int
    
    init(title: String, fileSize: Int, pageCount: Int) {
        self.pageCount = pageCount
        super.init(title: title, fileSize: fileSize)
    }
    
    override func play() {
        print("Opening document: \(title) (\(pageCount) pages)")
    }
}

class MediaPlayer {
    var playlist: [MediaContent] = []
    
    func addToPlaylist(_ item: MediaContent) {
        playlist.append(item)
    }
    
    func playAll() {
        for item in playlist {
            item.play()
            
            // Additional type-specific operations
            if let video = item as? VideoContent {
                print("Video quality: \(video.resolution)")
            } else if let audio = item as? AudioContent {
                print("By artist: \(audio.artist)")
            } else if let document = item as? DocumentContent {
                print("Document has \(document.pageCount) pages")
            }
            
            print("---")
        }
    }
    
    func getTotalStorageSize() -> Int {
        return playlist.reduce(0) { $0 + $1.fileSize }
    }
}

// Create a media player
let myPlayer = MediaPlayer()

// Add various media types
myPlayer.addToPlaylist(VideoContent(title: "Vacation Memories", fileSize: 1200, resolution: "1080p", duration: 354))
myPlayer.addToPlaylist(AudioContent(title: "Bohemian Rhapsody", fileSize: 8, artist: "Queen", duration: 355))
myPlayer.addToPlaylist(DocumentContent(title: "Swift Programming Guide", fileSize: 15, pageCount: 250))

// Play all media
myPlayer.playAll()

// Calculate total storage
print("Total storage used: \(myPlayer.getTotalStorageSize()) MB")

// Output:
// Playing video: Vacation Memories (1080p) - 5m 54s
// Video quality: 1080p
// ---
// Playing audio: Bohemian Rhapsody by Queen - 5m 55s
// By artist: Queen
// ---
// Opening document: Swift Programming Guide (250 pages)
// Document has 250 pages
// ---
// Total storage used: 1223 MB
```

In this example, we've built a complete media player system that handles different types of media content. We're using type casting to:

1. Determine the specific type of each media item 
2. Access type-specific properties and methods
3. Provide custom behavior based on the item type

This pattern is commonly used in applications that need to handle different types of content in a unified way.

## Summary

Type casting in Swift allows you to:

- Check instance types at runtime with the `is` operator
- Convert instances to different types within their inheritance hierarchy using `as?`, `as!`, and `as` operators
- Work with collections of mixed types and handle them appropriately
- Build more flexible and powerful applications by leveraging polymorphism

Type casting is an essential part of Swift's type safety system, giving you the flexibility to work with classes in an inheritance hierarchy while still maintaining type safety.

## Practice Exercises

1. Create a `Shape` class hierarchy with subclasses like `Circle`, `Rectangle`, and `Triangle`. Each should have appropriate properties and a method to calculate area. Then write a function that accepts an array of `Shape` objects and uses type casting to calculate the total area.

2. Extend the media player example to handle a new type of content called `InteractiveContent` (like a quiz or a game) with its own unique properties and behavior.

3. Create an `Employee` class hierarchy with various employee types (Manager, Developer, Designer) and implement a payroll system that calculates salary differently based on employee type.

## Additional Resources

- [Swift Official Documentation on Type Casting](https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html)
- [WWDC Sessions on Swift Type System](https://developer.apple.com/videos/play/wwdc2015/414/)
- [Understanding Polymorphism in Swift](https://www.swiftbysundell.com/articles/polymorphism-in-swift/)