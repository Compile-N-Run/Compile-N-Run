---
title: Swift Override Methods
description: Learn how to override methods from parent classes in Swift to customize behavior in child classes. This guide explains method overriding with practical examples for beginners.

---

# Swift Override Methods

## Introduction

Method overriding is a fundamental concept in object-oriented programming that allows a subclass (child class) to provide a specific implementation of a method that's already defined in its superclass (parent class). In Swift, overriding enables you to customize or extend the behavior of inherited methods, properties, or subscripts.

When you create a class hierarchy and want a subclass to behave differently than its parent for particular methods, overriding gives you that flexibility without having to rewrite the entire class.

## Understanding Method Overriding

In Swift, you can override any method, property, or subscript that the parent class declares as `overridable`. To override a method, you must:

1. Use the `override` keyword before the method declaration
2. Ensure the method has the same name, parameters, and return type as the parent method
3. The parent method must be marked as `open` or `override` itself

Let's see a basic example:

```swift
class Vehicle {
    func makeSound() {
        print("Generic vehicle sound")
    }
}

class Car: Vehicle {
    override func makeSound() {
        print("Vroom, vroom!")
    }
}

let myVehicle = Vehicle()
myVehicle.makeSound() // Output: "Generic vehicle sound"

let myCar = Car()
myCar.makeSound() // Output: "Vroom, vroom!"
```

In this example, the `Car` class overrides the `makeSound()` method from its parent class `Vehicle` to provide its own implementation.

## Accessing Superclass Methods

Sometimes you want to extend the superclass's behavior rather than completely replace it. You can call the superclass's implementation using the `super` keyword:

```swift
class ElectricCar: Car {
    override func makeSound() {
        super.makeSound() // Calls Car's implementation: "Vroom, vroom!"
        print("...but quieter")
    }
}

let tesla = ElectricCar()
tesla.makeSound()
// Output:
// Vroom, vroom!
// ...but quieter
```

This technique is particularly useful when you want to add functionality to the parent's implementation rather than replacing it entirely.

## Preventing Method Overriding

If you want to prevent a method from being overridden by subclasses, you can mark it as `final`:

```swift
class Vehicle {
    final func startEngine() {
        print("Engine started")
    }
    
    func makeSound() {
        print("Generic vehicle sound")
    }
}

class Car: Vehicle {
    // This would cause a compiler error:
    // override func startEngine() { 
    //     print("Car engine started") 
    // }
    
    // This is allowed:
    override func makeSound() {
        print("Vroom, vroom!")
    }
}
```

The `final` keyword ensures that the implementation cannot be changed by any subclass.

## Rules for Method Overriding

Here are some important rules to remember when overriding methods:

1. You must use the `override` keyword when overriding a method
2. Not using `override` when you should is a compile-time error
3. Using `override` for a method that doesn't override anything is also a compile-time error
4. The method signature (name, parameters, return type) must match exactly

```swift
class Parent {
    func doSomething() {
        print("Parent doing something")
    }
    
    func calculate(value: Int) -> Int {
        return value * 2
    }
}

class Child: Parent {
    // Correct override
    override func doSomething() {
        print("Child doing something")
    }
    
    // Correct override with matching signature
    override func calculate(value: Int) -> Int {
        return value * 3
    }
    
    // This would cause a compiler error - no matching method in parent
    // override func someOtherMethod() { }
    
    // This would cause a compiler error - signature doesn't match
    // override func calculate(value: String) -> Int { return 0 }
}
```

## Practical Examples

### Example 1: Drawing Shapes

Let's create a practical example with shapes where different shapes override a common drawing method:

```swift
class Shape {
    var color: String
    
    init(color: String) {
        self.color = color
    }
    
    func draw() {
        print("Drawing a shape with color \(color)")
    }
    
    func calculateArea() -> Double {
        return 0.0
    }
}

class Circle: Shape {
    var radius: Double
    
    init(color: String, radius: Double) {
        self.radius = radius
        super.init(color: color)
    }
    
    override func draw() {
        print("Drawing a circle with radius \(radius) and color \(color)")
    }
    
    override func calculateArea() -> Double {
        return Double.pi * radius * radius
    }
}

class Rectangle: Shape {
    var width: Double
    var height: Double
    
    init(color: String, width: Double, height: Double) {
        self.width = width
        self.height = height
        super.init(color: color)
    }
    
    override func draw() {
        print("Drawing a rectangle with width \(width), height \(height) and color \(color)")
    }
    
    override func calculateArea() -> Double {
        return width * height
    }
}

// Using the shapes
let genericShape = Shape(color: "black")
let circle = Circle(color: "red", radius: 5.0)
let rectangle = Rectangle(color: "blue", width: 4.0, height: 6.0)

genericShape.draw()
circle.draw()
rectangle.draw()

print("Circle area: \(circle.calculateArea())")
print("Rectangle area: \(rectangle.calculateArea())")
```

Output:
```
Drawing a shape with color black
Drawing a circle with radius 5.0 and color red
Drawing a rectangle with width 4.0, height 6.0 and color blue
Circle area: 78.53981633974483
Rectangle area: 24.0
```

### Example 2: Employee Hierarchy

Let's create another practical example with an employee hierarchy, where different types of employees have different salary calculations:

```swift
class Employee {
    var name: String
    var id: String
    var baseSalary: Double
    
    init(name: String, id: String, baseSalary: Double) {
        self.name = name
        self.id = id
        self.baseSalary = baseSalary
    }
    
    func calculateMonthlySalary() -> Double {
        return baseSalary / 12
    }
    
    func displayInfo() {
        print("Employee: \(name) (ID: \(id))")
        print("Monthly Salary: $\(calculateMonthlySalary())")
    }
}

class Manager: Employee {
    var teamSize: Int
    var bonus: Double
    
    init(name: String, id: String, baseSalary: Double, teamSize: Int, bonus: Double) {
        self.teamSize = teamSize
        self.bonus = bonus
        super.init(name: name, id: id, baseSalary: baseSalary)
    }
    
    override func calculateMonthlySalary() -> Double {
        // Managers get base salary plus bonus based on team size
        let baseMonthly = super.calculateMonthlySalary()
        let teamBonus = Double(teamSize) * bonus / 12
        return baseMonthly + teamBonus
    }
    
    override func displayInfo() {
        print("Manager: \(name) (ID: \(id))")
        print("Team Size: \(teamSize)")
        print("Monthly Salary: $\(calculateMonthlySalary())")
    }
}

class Developer: Employee {
    var programmingLanguages: [String]
    var experienceYears: Int
    
    init(name: String, id: String, baseSalary: Double, programmingLanguages: [String], experienceYears: Int) {
        self.programmingLanguages = programmingLanguages
        self.experienceYears = experienceYears
        super.init(name: name, id: id, baseSalary: baseSalary)
    }
    
    override func calculateMonthlySalary() -> Double {
        // Developers get base salary plus bonus based on experience
        let baseMonthly = super.calculateMonthlySalary()
        let experienceBonus = Double(experienceYears) * 100 / 12 // $100 per year of experience
        return baseMonthly + experienceBonus
    }
    
    override func displayInfo() {
        print("Developer: \(name) (ID: \(id))")
        print("Languages: \(programmingLanguages.joined(separator: ", "))")
        print("Experience: \(experienceYears) years")
        print("Monthly Salary: $\(calculateMonthlySalary())")
    }
}

// Using the employee classes
let employee = Employee(name: "John Smith", id: "EMP001", baseSalary: 50000)
let manager = Manager(name: "Sarah Johnson", id: "MGR001", baseSalary: 80000, teamSize: 5, bonus: 10000)
let developer = Developer(name: "Mike Chen", id: "DEV001", baseSalary: 65000, 
                         programmingLanguages: ["Swift", "Objective-C", "Python"], 
                         experienceYears: 4)

employee.displayInfo()
print("------------------------")
manager.displayInfo()
print("------------------------")
developer.displayInfo()
```

Output:
```
Employee: John Smith (ID: EMP001)
Monthly Salary: $4166.666666666667
------------------------
Manager: Sarah Johnson (ID: MGR001)
Team Size: 5
Monthly Salary: $7500.0
------------------------
Developer: Mike Chen (ID: DEV001)
Languages: Swift, Objective-C, Python
Experience: 4 years
Monthly Salary: $5750.0
```

## When to Use Method Overriding

Method overriding is especially useful in the following situations:

1. **Specialization**: When a subclass needs to specialize behavior of a parent class
2. **Polymorphism**: When you want different objects to respond differently to the same method call
3. **Framework Integration**: When extending classes from frameworks that expect certain methods to be overridden
4. **Extension**: When you want to add functionality to an existing implementation

## Summary

Method overriding is a powerful feature in Swift's object-oriented programming toolkit that allows subclasses to provide their own implementation of methods inherited from parent classes. Key points to remember:

- Use the `override` keyword when overriding a method
- The method signature (name, parameters, and return type) must match exactly
- Use `super` to call the parent implementation when needed
- Mark methods as `final` to prevent overriding
- Method overriding is essential for polymorphism and customizing behavior in class hierarchies

By mastering method overriding, you can create flexible, modular, and extensible class hierarchies that allow for specialized behavior without code duplication.

## Additional Resources

- [Swift Documentation on Methods](https://docs.swift.org/swift-book/LanguageGuide/Methods.html)
- [Swift Documentation on Inheritance](https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html)

## Exercises

1. Create a `Device` class with a `turnOn()` method, then create subclasses `Phone`, `Laptop`, and `Tablet` that override this method with device-specific implementations.

2. Design a `BankAccount` class with a `withdraw()` method that prevents negative balances, then create a `PremiumAccount` subclass that overrides this method to allow overdrafts up to a certain limit.

3. Create a `Vehicle` class hierarchy with a `calculateFuelEfficiency()` method, and implement different calculations for `Car`, `Truck`, and `Motorcycle` subclasses.

4. Extend the shapes example with additional shapes like `Triangle` and `Square`, and add a new method `perimeter()` that each shape must override.