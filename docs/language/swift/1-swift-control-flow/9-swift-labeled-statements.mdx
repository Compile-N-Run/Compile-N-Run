---
title: Swift Labeled Statements
description: Learn how to use labeled statements in Swift to control flow across nested loops and statements. This guide covers syntax, practical examples, and best practices for beginners.

---

# Swift Labeled Statements

In Swift programming, labeled statements provide a powerful way to control the flow of execution in nested structures. They allow you to identify specific loops or control flow statements and target them precisely when using `break` or `continue` commands. This feature is particularly useful when working with complex nested loops or statements.

## Introduction to Labeled Statements

When writing complex code with nested loops or conditional blocks, you might need to break out of multiple levels of nesting or continue a specific outer loop. Without labels, `break` and `continue` statements only affect the innermost loop they appear in. Labels solve this problem by giving you more control over which loop or statement to affect.

## Basic Syntax of Labeled Statements

Here's the basic syntax for creating a labeled statement in Swift:

```swift
labelName: for item in collection {
    // loop body
}
```

To use the label with `break` or `continue`:

```swift
break labelName    // Exits the labeled loop or switch statement
continue labelName // Skips to the next iteration of the labeled loop
```

## Using Labels with Nested Loops

### Example 1: Breaking Out of Nested Loops

Without labels, breaking out of nested loops can be tricky:

```swift
// Without labels - Can only break out of the innermost loop
for i in 1...3 {
    for j in 1...3 {
        print("i = \(i), j = \(j)")
        if i == 2 && j == 2 {
            break // This only breaks out of the inner loop
        }
    }
}
```

Output:
```
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 2, j = 1
i = 2, j = 2
i = 3, j = 1
i = 3, j = 2
i = 3, j = 3
```

Now, let's use a labeled statement to break out of both loops:

```swift
outerLoop: for i in 1...3 {
    for j in 1...3 {
        print("i = \(i), j = \(j)")
        if i == 2 && j == 2 {
            break outerLoop // This breaks out of the labeled outer loop
        }
    }
}
```

Output:
```
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 2, j = 1
i = 2, j = 2
```

As you can see, using the labeled statement allowed us to exit both loops completely when our condition was met.

### Example 2: Using Continue with Labeled Loops

Labels are also useful with the `continue` statement:

```swift
outerLoop: for i in 1...3 {
    for j in 1...3 {
        if j == 2 {
            continue outerLoop // Skip the remaining inner loop iterations and continue with the next value of i
        }
        print("i = \(i), j = \(j)")
    }
}
```

Output:
```
i = 1, j = 1
i = 2, j = 1
i = 3, j = 1
```

In this example, whenever `j` equals 2, we skip the rest of the inner loop iterations for the current value of `i` and move to the next iteration of the outer loop.

## Practical Applications

### Example 1: Finding a Value in a 2D Grid

Labeled statements are particularly useful when searching through multi-dimensional data structures:

```swift
let grid = [
    [11, 12, 13, 14],
    [21, 22, 23, 24],
    [31, 32, 33, 34]
]

let searchValue = 23
var found = false
var rowFound = 0
var colFound = 0

searchLoop: for (rowIndex, row) in grid.enumerated() {
    for (colIndex, value) in row.enumerated() {
        if value == searchValue {
            found = true
            rowFound = rowIndex
            colFound = colIndex
            break searchLoop // Exit both loops once found
        }
    }
}

if found {
    print("Found value \(searchValue) at position [row: \(rowFound), column: \(colFound)]")
} else {
    print("Value \(searchValue) not found in the grid")
}
```

Output:
```
Found value 23 at position [row: 1, column: 2]
```

### Example 2: Input Validation Loop

Labeled statements can improve user experience by allowing users to restart an entire form validation process:

```swift
func simulateUserInput() -> String {
    // Simulating user input for the example
    let possibleInputs = ["John", "restart", "quit"]
    return possibleInputs.randomElement() ?? "John"
}

formInput: while true {
    print("Enter your name (or 'restart' to begin again, 'quit' to exit):")
    let name = simulateUserInput()
    print("User entered: \(name)")
    
    if name == "quit" {
        print("Exiting form...")
        break
    }
    
    if name == "restart" {
        print("Restarting form from the beginning...")
        continue formInput
    }
    
    // Process more form fields...
    while true {
        print("Enter your age (or 'restart' to begin again):")
        let ageInput = simulateUserInput()
        print("User entered: \(ageInput)")
        
        if ageInput == "restart" {
            print("Restarting form from the beginning...")
            continue formInput // Go back to the beginning of the outer loop
        }
        
        if ageInput == "quit" {
            print("Exiting form...")
            break formInput // Exit both loops
        }
        
        // If we get here, we have a valid age
        print("Form completed for \(name)!")
        break formInput
    }
}
```

This example demonstrates how labeled statements can help manage complex user interaction flows.

## Best Practices for Using Labeled Statements

1. **Use Descriptive Label Names**: Choose clear, descriptive names like `outerLoop` or `searchGrid` rather than generic names like `loop1`.

2. **Use Sparingly**: While labeled statements are powerful, they can make code harder to follow if overused. Consider refactoring complex nested loops into separate functions when possible.

3. **Consistent Indentation**: Maintain proper indentation to make the relationship between labels and their statements visually clear.

4. **Comment Your Intent**: When using labeled statements, a brief comment explaining why you're breaking or continuing a specific labeled loop can help readers understand your code.

## Common Scenarios for Labeled Statements

- Nested loop iteration
- Multi-level search operations
- Complex data processing pipelines
- Interactive user input handling
- Game development (state machines, nested event handlers)

## Summary

Labeled statements in Swift give you precise control over complex nested loops and conditional statements. They allow you to break or continue specific outer loops from within inner loops, which can lead to cleaner and more efficient code in certain scenarios.

Key points to remember:
- Use the syntax `labelName: for...` to create a labeled statement
- Target the label with `break labelName` or `continue labelName`
- Labels work with any loop type (for, while, repeat-while)
- Use labeled statements judiciously to maintain code readability

## Exercises

1. Create a nested loop structure that prints a triangular pattern of stars, using a labeled statement to control the pattern.

2. Write a function that searches for a specific element in a 3D array (an array of arrays of arrays) using labeled statements.

3. Implement a simple game loop with different states, using labeled statements to control transitions between these states.

## Additional Resources

- [Swift Documentation on Control Flow](https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html)
- [Understanding Break and Continue in Swift](https://www.hackingwithswift.com/example-code/language/how-to-use-break-and-continue-in-loops)
- [Advanced Control Flow in Swift](https://www.swiftbysundell.com/articles/picking-the-right-control-flow-tool-in-swift/)

By mastering labeled statements, you'll have another powerful tool in your Swift programming toolkit that can help you write more efficient and elegant solutions to complex problems.