---
title: Swift Control Transfer
description: Learn how Swift control transfer statements let you change the flow of execution in your code, including break, continue, fallthrough, and labeled statements with practical examples.

---

# Swift Control Transfer

Control transfer statements alter the order in which your code executes by transferring control from one piece of code to another. Swift provides several control transfer mechanisms that help you manage the flow of your program's execution more effectively. In this article, we'll explore these mechanisms and how they can make your code more efficient and readable.

## Introduction to Control Transfer Statements

Control transfer statements change the order of execution by transferring control from one part of your code to another. Swift offers four main control transfer statements:

- `break`
- `continue`
- `fallthrough`
- `return`

In addition, Swift provides labeled statements that give you more control over which loop or conditional statement you want to exit or continue. Let's explore each of these.

## The Break Statement

The `break` statement immediately ends execution of an entire control flow statement. It's commonly used in loops and switch statements to exit when a certain condition is met.

### Break in Loops

When you want to exit a loop prematurely based on a condition:

```swift
for number in 1...10 {
    if number == 5 {
        print("Found 5! Breaking out of the loop.")
        break
    }
    print("Current number: \(number)")
}
print("Loop finished")
```

Output:
```
Current number: 1
Current number: 2
Current number: 3
Current number: 4
Found 5! Breaking out of the loop.
Loop finished
```

As you can see, once the number 5 is encountered, the `break` statement terminates the loop, and execution continues with the code after the loop.

### Break in Switch Statements

In Swift, unlike many other languages, `switch` cases don't fall through by default, so the `break` statement is often optional. However, it's useful when you want to exit a switch early:

```swift
let character: Character = "a"

switch character {
case "a", "e", "i", "o", "u":
    print("\(character) is a vowel")
    if character == "a" {
        print("It's the first letter of the alphabet!")
        break
    }
    print("And it's important for pronunciation.")
default:
    print("\(character) is not a vowel")
}
```

Output:
```
a is a vowel
It's the first letter of the alphabet!
```

Notice that the "And it's important for pronunciation" message is not printed because we broke out of the switch case early.

## The Continue Statement

The `continue` statement tells a loop to stop what it's doing and start again at the beginning of the next iteration. Unlike `break`, it doesn't terminate the loop entirely.

```swift
for number in 1...10 {
    if number % 2 == 0 {
        continue  // Skip even numbers
    }
    print("Current number: \(number)")
}
```

Output:
```
Current number: 1
Current number: 3
Current number: 5
Current number: 7
Current number: 9
```

The `continue` statement causes the loop to skip the rest of its body for the current iteration when it encounters an even number, moving directly to the next iteration.

## The Fallthrough Statement

Swift's `switch` statements don't fall through cases by default. To explicitly enable this behavior, use the `fallthrough` statement.

```swift
let score = 85

switch score {
case 90...100:
    print("Excellent job!")
case 80...89:
    print("Good work!")
    fallthrough
case 70...79:
    print("Keep it up!")
default:
    print("Let's work harder next time.")
}
```

Output:
```
Good work!
Keep it up!
```

Even though `score` only matches the `80...89` case, the `fallthrough` statement causes execution to continue into the next case as well.

## Labeled Statements

When working with nested loops or conditional statements, you might need to break or continue a specific outer loop. Swift allows you to label your statements and specify which one to affect.

```swift
outerLoop: for i in 1...3 {
    innerLoop: for j in 1...3 {
        if i == 2 && j == 2 {
            print("Breaking out of outer loop when i=\(i), j=\(j)")
            break outerLoop
        }
        print("i = \(i), j = \(j)")
    }
}
```

Output:
```
i = 1, j = 1
i = 1, j = 2
i = 1, j = 3
i = 2, j = 1
Breaking out of outer loop when i=2, j=2
```

In this example, we use `break outerLoop` to exit both loops when `i` is 2 and `j` is 2.

Similarly, you can use labeled statements with `continue`:

```swift
outerLoop: for i in 1...3 {
    innerLoop: for j in 1...3 {
        if j == 2 {
            print("Continuing outer loop when i=\(i), j=\(j)")
            continue outerLoop
        }
        print("i = \(i), j = \(j)")
    }
}
```

Output:
```
i = 1, j = 1
Continuing outer loop when i=1, j=2
i = 2, j = 1
Continuing outer loop when i=2, j=2
i = 3, j = 1
Continuing outer loop when i=3, j=2
```

This example skips the rest of the inner loop iterations and continues with the next iteration of the outer loop whenever `j` equals 2.

## Real-World Applications

### Game Development

Control transfer statements are crucial in game development, especially when implementing game logic:

```swift
func playGame() {
    var lives = 3
    var score = 0
    var isGameOver = false
    
    gameLoop: while !isGameOver {
        for level in 1...5 {
            print("Playing level \(level)")
            
            let didCompleteLevelSuccessfully = Bool.random()
            if didCompleteLevelSuccessfully {
                score += 100 * level
                print("Level complete! Score: \(score)")
            } else {
                lives -= 1
                print("Lost a life! Remaining lives: \(lives)")
                
                if lives == 0 {
                    print("Game over! Final score: \(score)")
                    isGameOver = true
                    break gameLoop
                }
                
                // Skip to the next attempt on the same level
                continue
            }
        }
        
        print("All levels completed! Moving to the next difficulty.")
        // Reset for next difficulty
    }
}

playGame()
```

This example simulates a simple game with multiple levels and lives. It uses `break` to end the game and `continue` to retry levels.

### Data Processing

When processing data, control transfer statements help filter and transform information efficiently:

```swift
func processTransactions(transactions: [(id: Int, amount: Double, status: String)]) {
    var totalProcessed = 0.0
    var skippedCount = 0
    
    for transaction in transactions {
        // Skip pending transactions
        if transaction.status == "pending" {
            skippedCount += 1
            continue
        }
        
        // Break if we find any negative transactions (potential fraud)
        if transaction.amount < 0 {
            print("Suspicious activity detected! Transaction ID: \(transaction.id)")
            break
        }
        
        // Process the valid transaction
        totalProcessed += transaction.amount
        print("Processed transaction \(transaction.id): $\(transaction.amount)")
    }
    
    print("Summary: Processed $\(totalProcessed) total. Skipped \(skippedCount) pending transactions.")
}

let transactions = [
    (id: 1001, amount: 120.50, status: "completed"),
    (id: 1002, amount: 75.25, status: "pending"),
    (id: 1003, amount: 224.00, status: "completed"),
    (id: 1004, amount: -50.00, status: "completed"),  // Suspicious!
    (id: 1005, amount: 99.99, status: "completed")
]

processTransactions(transactions: transactions)
```

Output:
```
Processed transaction 1001: $120.5
Processed transaction 1003: $224.0
Suspicious activity detected! Transaction ID: 1004
Summary: Processed $344.5 total. Skipped 1 pending transactions.
```

This example demonstrates using `continue` to skip pending transactions and `break` to stop processing when suspicious activity is detected.

## Summary

Control transfer statements in Swift give you powerful tools to control the flow of your program:

- **break**: Exits a loop or switch statement completely
- **continue**: Skips the current iteration of a loop and proceeds to the next iteration
- **fallthrough**: Allows execution to continue to the next case in a switch statement
- **Labeled statements**: Let you target specific loops or conditional blocks when using break and continue

By effectively using these control transfer mechanisms, you can write more efficient and readable code that handles complex conditions and processing requirements.

## Exercises

1. Write a program that prints only the prime numbers between 1 and 50 using control transfer statements.
2. Create a nested loop structure with labels that prints a multiplication table but skips multiples of 7.
3. Implement a "word guessing" game that gives the player 5 attempts to guess a word, using control transfer statements to manage the game flow.
4. Write a function that processes an array of optional values, skipping nil values and stopping when it finds a specific value.

## Additional Resources

- [Swift Documentation: Control Flow](https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html)
- [Swift Programming Language: Control Transfer Statements](https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID135)
- [Apple Developer: Swift Control Flow](https://developer.apple.com/documentation/swift/swift_standard_library/control_flow)

Understanding control transfer is essential for writing Swift code that handles complex conditions efficiently, making it a crucial skill for any Swift developer.