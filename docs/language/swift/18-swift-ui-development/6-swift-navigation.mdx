---
title: Swift Navigation
description: Learn how to implement navigation in SwiftUI applications, including navigation views, navigation links, programmatic navigation, and tabbed interfaces.

---

# Swift Navigation

## Introduction

Navigation is a fundamental aspect of any mobile application, allowing users to move between different screens or views. SwiftUI provides a powerful and declarative way to implement navigation in your iOS applications. In this guide, we'll explore different navigation techniques in SwiftUI, from basic navigation views to more complex navigation patterns.

By the end of this tutorial, you'll understand how to:
- Set up basic navigation with `NavigationView` and `NavigationLink`
- Implement programmatic navigation
- Create tab-based navigation
- Pass data between views during navigation
- Customize navigation appearance

## Basic Navigation with NavigationView

### The NavigationView Container

In SwiftUI, navigation starts with the `NavigationView` container. It provides a navigation bar at the top and manages a stack of views.

```swift
import SwiftUI

struct ContentView: View {
    var body: some View {
        NavigationView {
            Text("Hello, SwiftUI!")
                .navigationTitle("Home")
        }
    }
}
```

This creates a view with a navigation bar displaying "Home" as the title.

### Navigation Titles and Styling

You can customize the navigation title and its appearance:

```swift
NavigationView {
    Text("Welcome to my app")
        .navigationTitle("Home")
        .navigationBarTitleDisplayMode(.large) // .large, .inline, or .automatic
}
```

For a smaller, inline title:

```swift
Text("Welcome to my app")
    .navigationTitle("Home")
    .navigationBarTitleDisplayMode(.inline)
```

## NavigationLink for Moving Between Views

To navigate from one view to another, we use `NavigationLink`. It creates a tappable element that pushes a new view onto the navigation stack when triggered.

```swift
struct ContentView: View {
    var body: some View {
        NavigationView {
            List {
                NavigationLink(destination: DetailView(item: "First Item")) {
                    Text("Go to First Item")
                }
                
                NavigationLink(destination: DetailView(item: "Second Item")) {
                    Text("Go to Second Item")
                }
            }
            .navigationTitle("Items")
        }
    }
}

struct DetailView: View {
    let item: String
    
    var body: some View {
        Text("Details for: \(item)")
            .navigationTitle(item)
    }
}
```

In this example, tapping on either list item navigates to the `DetailView`, passing the corresponding item.

## Creating a Dynamic List with Navigation

A common pattern is to navigate from a list of items to a detail view for the selected item:

```swift
struct ContentView: View {
    let fruits = ["Apple", "Banana", "Cherry", "Date", "Elderberry"]
    
    var body: some View {
        NavigationView {
            List(fruits, id: \.self) { fruit in
                NavigationLink(destination: FruitDetailView(fruit: fruit)) {
                    Text(fruit)
                }
            }
            .navigationTitle("Fruits")
        }
    }
}

struct FruitDetailView: View {
    let fruit: String
    
    var body: some View {
        VStack(spacing: 20) {
            Image(fruit.lowercased())
                .resizable()
                .scaledToFit()
                .frame(height: 200)
                .cornerRadius(12)
            
            Text("About \(fruit)")
                .font(.headline)
            
            Text("This is a delicious \(fruit.lowercased()).")
                .padding()
            
            Spacer()
        }
        .padding()
        .navigationTitle(fruit)
    }
}
```

## Programmatic Navigation

Sometimes, you need to trigger navigation programmatically rather than through a direct user interaction:

```swift
struct LoginView: View {
    @State private var username = ""
    @State private var password = ""
    @State private var isAuthenticated = false
    
    var body: some View {
        NavigationView {
            VStack {
                TextField("Username", text: $username)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .padding()
                
                SecureField("Password", text: $password)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .padding()
                
                Button("Login") {
                    // Validate credentials
                    if username == "admin" && password == "password" {
                        isAuthenticated = true
                    }
                }
                .padding()
                
                NavigationLink(
                    destination: HomeView(username: username),
                    isActive: $isAuthenticated,
                    label: { EmptyView() }
                )
            }
            .navigationTitle("Login")
        }
    }
}

struct HomeView: View {
    let username: String
    
    var body: some View {
        Text("Welcome, \(username)!")
            .navigationTitle("Home")
    }
}
```

In this example, the `NavigationLink` is hidden (using `EmptyView()`) and activated programmatically when `isAuthenticated` becomes `true`.

## Tab-Based Navigation

For apps with multiple main sections, tab-based navigation is often used:

```swift
struct MainTabView: View {
    var body: some View {
        TabView {
            HomeTabView()
                .tabItem {
                    Label("Home", systemImage: "house")
                }
            
            SearchTabView()
                .tabItem {
                    Label("Search", systemImage: "magnifyingglass")
                }
            
            ProfileTabView()
                .tabItem {
                    Label("Profile", systemImage: "person")
                }
        }
    }
}

struct HomeTabView: View {
    var body: some View {
        NavigationView {
            Text("Home Content")
                .navigationTitle("Home")
        }
    }
}

struct SearchTabView: View {
    var body: some View {
        NavigationView {
            Text("Search Content")
                .navigationTitle("Search")
        }
    }
}

struct ProfileTabView: View {
    var body: some View {
        NavigationView {
            Text("Profile Content")
                .navigationTitle("Profile")
        }
    }
}
```

Notice how each tab contains its own `NavigationView`. This allows independent navigation hierarchies in each tab.

## Navigation with Toolbar Items

You can add buttons to the navigation bar using the `.toolbar` modifier:

```swift
struct ContentView: View {
    @State private var showingAddView = false
    
    var body: some View {
        NavigationView {
            List {
                Text("Item 1")
                Text("Item 2")
                Text("Item 3")
            }
            .navigationTitle("Items")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showingAddView = true
                    }) {
                        Image(systemName: "plus")
                    }
                }
            }
            .sheet(isPresented: $showingAddView) {
                AddItemView()
            }
        }
    }
}

struct AddItemView: View {
    @Environment(\.dismiss) var dismiss
    
    var body: some View {
        NavigationView {
            Form {
                Section {
                    Text("Add new item details here")
                }
            }
            .navigationTitle("Add Item")
            .toolbar {
                Button("Save") {
                    // Save logic here
                    dismiss()
                }
            }
        }
    }
}
```

## Deep Linking and Navigation State

For more complex applications, you might need to handle deep linking or save navigation state. SwiftUI's `NavigationLink` can be initialized with a tag and selection binding:

```swift
struct ContentView: View {
    let destinations = ["Home", "Profile", "Settings"]
    @State private var selectedDestination: String? = nil
    
    var body: some View {
        NavigationView {
            List {
                ForEach(destinations, id: \.self) { destination in
                    NavigationLink(
                        destination: DetailView(text: destination),
                        tag: destination,
                        selection: $selectedDestination
                    ) {
                        Text(destination)
                    }
                }
            }
            .navigationTitle("Navigation Demo")
            .onAppear {
                // Example of programmatic deep linking
                // Could come from a URL, notification, etc.
                DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                    selectedDestination = "Settings"
                }
            }
        }
    }
}
```

## Real-World Example: Recipe App Navigation

Let's create a more complete example of a recipe app with multiple navigation patterns:

```swift
struct Recipe: Identifiable {
    let id = UUID()
    let name: String
    let category: String
    let ingredients: [String]
    let instructions: String
}

struct RecipeListView: View {
    @State private var recipes = [
        Recipe(name: "Pasta Carbonara", category: "Italian", 
               ingredients: ["Spaghetti", "Eggs", "Pancetta", "Parmesan"], 
               instructions: "Cook pasta. Mix eggs and cheese. Combine all."),
        Recipe(name: "Caesar Salad", category: "American", 
               ingredients: ["Romaine Lettuce", "Croutons", "Parmesan", "Caesar Dressing"], 
               instructions: "Tear lettuce. Add other ingredients. Toss with dressing."),
        Recipe(name: "Beef Tacos", category: "Mexican", 
               ingredients: ["Beef", "Taco Shells", "Cheese", "Salsa"], 
               instructions: "Cook beef. Fill shells. Add toppings.")
    ]
    
    @State private var selectedCategory: String? = nil
    
    var categories: [String] {
        Array(Set(recipes.map { $0.category })).sorted()
    }
    
    var body: some View {
        NavigationView {
            List {
                Section(header: Text("Categories")) {
                    ForEach(categories, id: \.self) { category in
                        NavigationLink(
                            destination: CategoryRecipesView(category: category, recipes: recipes.filter { $0.category == category }),
                            tag: category,
                            selection: $selectedCategory
                        ) {
                            HStack {
                                Text(category)
                                Spacer()
                                Text("\(recipes.filter { $0.category == category }.count)")
                                    .foregroundColor(.secondary)
                            }
                        }
                    }
                }
                
                Section(header: Text("All Recipes")) {
                    ForEach(recipes) { recipe in
                        NavigationLink(destination: RecipeDetailView(recipe: recipe)) {
                            Text(recipe.name)
                        }
                    }
                }
            }
            .navigationTitle("Recipes")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        // Add new recipe action
                    }) {
                        Image(systemName: "plus")
                    }
                }
            }
        }
    }
}

struct CategoryRecipesView: View {
    let category: String
    let recipes: [Recipe]
    
    var body: some View {
        List(recipes) { recipe in
            NavigationLink(destination: RecipeDetailView(recipe: recipe)) {
                Text(recipe.name)
            }
        }
        .navigationTitle(category)
    }
}

struct RecipeDetailView: View {
    let recipe: Recipe
    @State private var showingInstructions = false
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 20) {
                Text(recipe.name)
                    .font(.largeTitle)
                    .fontWeight(.bold)
                
                Text("Category: \(recipe.category)")
                    .font(.subheadline)
                    .foregroundColor(.secondary)
                
                Divider()
                
                Text("Ingredients")
                    .font(.headline)
                
                ForEach(recipe.ingredients, id: \.self) { ingredient in
                    Text("• \(ingredient)")
                }
                
                Button("Show Cooking Instructions") {
                    showingInstructions = true
                }
                .padding()
                .background(Color.blue)
                .foregroundColor(.white)
                .cornerRadius(10)
            }
            .padding()
            .sheet(isPresented: $showingInstructions) {
                NavigationView {
                    VStack(alignment: .leading) {
                        Text(recipe.instructions)
                            .padding()
                        
                        Spacer()
                    }
                    .navigationTitle("How to Cook")
                    .toolbar {
                        Button("Done") {
                            showingInstructions = false
                        }
                    }
                }
            }
        }
        .navigationTitle("Recipe Details")
        .navigationBarTitleDisplayMode(.inline)
    }
}
```

This example demonstrates:
- Tab-based navigation for categorizing recipes
- List-to-detail navigation for viewing recipe details
- Sheet-based modal navigation for cooking instructions
- Toolbar items for potential actions

## Summary

In this guide, we've explored the fundamentals of navigation in SwiftUI:

1. **Basic Navigation**:
   - Using `NavigationView` as a container
   - Setting navigation titles and appearance

2. **NavigationLink**:
   - Creating links to navigate between views
   - Passing data to destination views

3. **Programmatic Navigation**:
   - Triggering navigation based on conditions rather than direct user interaction

4. **Tab-Based Navigation**:
   - Implementing multiple top-level sections with `TabView`
   - Combining tabs with navigation stacks

5. **Advanced Techniques**:
   - Adding toolbar items
   - Handling navigation state
   - Creating sheets and modal presentations

Navigation is a crucial aspect of iOS app development, and SwiftUI's declarative approach makes it more intuitive than ever. As you build more complex applications, you'll likely combine these techniques to create rich, interactive experiences for your users.

## Exercises

1. Create a simple note-taking app with a list of notes and the ability to view and edit each note.
2. Implement a shopping app with categories, product listings, and product details using nested navigation.
3. Build a settings screen with various options organized in sections, using navigation to drill down into specific settings.
4. Create a profile view with tabs for "About," "Posts," and "Photos," where each tab has its own navigation stack.
5. Implement a wizard-style form that guides users through multiple steps using programmatic navigation.

## Additional Resources

- [Apple's SwiftUI Documentation](https://developer.apple.com/documentation/swiftui)
- [WWDC Videos on SwiftUI Navigation](https://developer.apple.com/videos/all-videos/?q=swiftui%20navigation)
- [Stanford's CS193p Course on iOS Development with SwiftUI](https://cs193p.sites.stanford.edu)
- [SwiftUI Navigation Guide by Hacking with Swift](https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-navigationlink-to-navigate-to-a-new-view)

Happy coding and exploring the world of SwiftUI navigation!