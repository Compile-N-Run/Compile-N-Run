---
title: Swift Gestures
description: Learn how to implement and customize gestures in SwiftUI to make your iOS applications interactive and responsive.

---

# Swift Gestures

## Introduction

Gestures are a fundamental part of iOS user experience. They allow users to interact with applications through touch-based actions like tapping, swiping, dragging, and pinching. SwiftUI provides a powerful gestures API that makes it easy to add these interactive elements to your app.

In this tutorial, you'll learn how to implement various types of gestures in SwiftUI, customize their behavior, and combine multiple gestures to create rich user experiences. Whether you're building a simple utility app or a complex game, understanding gestures will help you create more intuitive and engaging interfaces.

## Basic Gesture Concepts

In SwiftUI, gestures are modifiers that you can attach to views. When a user performs the specified gesture on that view, your app responds accordingly. The fundamental structure follows this pattern:

```swift
YourView()
    .gesture(YourGestureType())
```

Let's start by exploring the basic gesture types available in SwiftUI.

## Tap Gesture

The tap gesture is the most common interaction in iOS apps. It's equivalent to a click on desktop platforms.

### Basic Implementation

Here's how to add a simple tap gesture:

```swift
struct TapGestureExample: View {
    @State private var backgroundColor = Color.blue
    
    var body: some View {
        Rectangle()
            .frame(width: 200, height: 200)
            .foregroundColor(backgroundColor)
            .gesture(
                TapGesture()
                    .onEnded { _ in
                        // Change color when tapped
                        backgroundColor = backgroundColor == Color.blue ? Color.red : Color.blue
                    }
            )
    }
}
```

In this example, tapping the rectangle toggles its color between blue and red.

### Configuring Tap Count

You can configure a tap gesture to detect a specific number of taps:

```swift
TapGesture(count: 2)  // Double tap
    .onEnded { _ in
        // Action for double tap
        print("Double tapped!")
    }
```

## Long Press Gesture

A long press gesture is triggered when the user touches and holds a view for a specified duration.

```swift
struct LongPressGestureExample: View {
    @State private var isPressed = false
    
    var body: some View {
        Circle()
            .fill(isPressed ? Color.green : Color.blue)
            .frame(width: 200, height: 200)
            .gesture(
                LongPressGesture(minimumDuration: 1.0) // 1 second
                    .onEnded { _ in
                        isPressed.toggle()
                    }
            )
            .overlay(
                Text(isPressed ? "Released" : "Press and hold")
                    .foregroundColor(.white)
            )
    }
}
```

This example changes a circle from blue to green when the user holds their finger on it for at least one second.

## Drag Gesture

The drag gesture allows users to move views around the screen.

```swift
struct DragGestureExample: View {
    @State private var position = CGSize.zero
    
    var body: some View {
        Circle()
            .fill(Color.purple)
            .frame(width: 100, height: 100)
            .offset(x: position.width, y: position.height)
            .gesture(
                DragGesture()
                    .onChanged { value in
                        position = value.translation
                    }
                    .onEnded { value in
                        // Optional: Add animations or reset behavior
                    }
            )
    }
}
```

This example allows the user to drag a purple circle around the screen. The `.onChanged` callback updates the position as the user drags.

### Adding Spring Animation

Let's enhance the drag gesture by adding a spring animation that returns the circle to the center:

```swift
struct AnimatedDragGestureExample: View {
    @State private var position = CGSize.zero
    
    var body: some View {
        Circle()
            .fill(Color.purple)
            .frame(width: 100, height: 100)
            .offset(x: position.width, y: position.height)
            .gesture(
                DragGesture()
                    .onChanged { value in
                        position = value.translation
                    }
                    .onEnded { _ in
                        withAnimation(.spring()) {
                            position = .zero
                        }
                    }
            )
    }
}
```

## Rotation Gesture

The rotation gesture lets users rotate views with a twisting motion of two fingers.

```swift
struct RotationGestureExample: View {
    @State private var angle: Angle = .degrees(0)
    
    var body: some View {
        Rectangle()
            .fill(Color.orange)
            .frame(width: 200, height: 200)
            .rotationEffect(angle)
            .gesture(
                RotationGesture()
                    .onChanged { value in
                        angle = value
                    }
            )
    }
}
```

## Magnification Gesture

The magnification gesture (commonly known as pinch-to-zoom) detects when users pinch to scale a view.

```swift
struct MagnificationGestureExample: View {
    @State private var scale: CGFloat = 1.0
    
    var body: some View {
        Image(systemName: "star.fill")
            .font(.system(size: 100))
            .foregroundColor(.yellow)
            .scaleEffect(scale)
            .gesture(
                MagnificationGesture()
                    .onChanged { value in
                        scale = value
                    }
                    .onEnded { _ in
                        withAnimation {
                            scale = 1.0
                        }
                    }
            )
    }
}
```

This example allows users to pinch to resize a star icon, which then animates back to its original size when released.

## Combining Gestures

SwiftUI allows you to combine multiple gestures using three main operators:

1. `simultaneously`: Both gestures can be recognized at the same time
2. `sequentially`: The second gesture is only recognized after the first completes
3. `exclusively`: Only one gesture can be recognized

Here's an example that combines drag and tap gestures:

```swift
struct CombinedGesturesExample: View {
    @State private var position = CGSize.zero
    @State private var color = Color.blue
    
    var body: some View {
        Circle()
            .fill(color)
            .frame(width: 150, height: 150)
            .offset(x: position.width, y: position.height)
            .gesture(
                DragGesture()
                    .onChanged { value in
                        position = value.translation
                    }
                    .onEnded { _ in
                        withAnimation(.spring()) {
                            position = .zero
                        }
                    }
                    .simultaneously(with:
                        TapGesture(count: 2)
                            .onEnded {
                                color = color == .blue ? .red : .blue
                            }
                    )
            )
    }
}
```

In this example, you can both drag the circle and double-tap to change its color at the same time.

## Using Gesture State

For more complex gesture handling, you can use the `.updating` modifier to temporarily store values during a gesture:

```swift
struct GestureStateExample: View {
    @State private var position = CGSize.zero
    @GestureState private var isDragging = false
    
    var body: some View {
        Circle()
            .fill(isDragging ? Color.green : Color.blue)
            .frame(width: 100, height: 100)
            .offset(x: position.width, y: position.height)
            .gesture(
                DragGesture()
                    .updating($isDragging) { _, state, _ in
                        state = true
                    }
                    .onChanged { value in
                        position = value.translation
                    }
                    .onEnded { _ in
                        withAnimation(.spring()) {
                            position = .zero
                        }
                    }
            )
    }
}
```

The `@GestureState` property wrapper automatically resets to its initial value when the gesture ends.

## Real World Example: Card Swiping Interface

Let's create a more complex example that mimics a card swiping interface (like dating apps):

```swift
struct CardView: View {
    @State private var offset = CGSize.zero
    @State private var color = Color.white
    let card: String
    
    var body: some View {
        ZStack {
            Rectangle()
                .fill(color)
                .frame(width: 320, height: 420)
                .cornerRadius(16)
                .shadow(radius: 10)
            
            Text(card)
                .font(.largeTitle)
                .bold()
        }
        .offset(x: offset.width, y: offset.height)
        .rotationEffect(.degrees(Double(offset.width / 20)))
        .gesture(
            DragGesture()
                .onChanged { gesture in
                    offset = gesture.translation
                    
                    // Change color based on drag direction
                    if offset.width > 0 {
                        color = .green.opacity(min(abs(offset.width) / 100, 1.0))
                    } else if offset.width < 0 {
                        color = .red.opacity(min(abs(offset.width) / 100, 1.0))
                    }
                }
                .onEnded { gesture in
                    // Swipe card away or return to center
                    if abs(offset.width) > 150 {
                        withAnimation {
                            offset.width = offset.width > 0 ? 1000 : -1000
                        }
                    } else {
                        withAnimation(.spring()) {
                            offset = .zero
                            color = .white
                        }
                    }
                }
        )
    }
}

struct CardSwipeExample: View {
    let cards = ["🐶", "🐱", "🐰", "🦊", "🐼"]
    
    var body: some View {
        VStack {
            ZStack {
                ForEach(cards.indices, id: \.self) { index in
                    CardView(card: cards[index])
                        .padding()
                }
            }
            
            Text("Swipe left to reject, right to accept")
                .padding()
        }
    }
}
```

This example creates a stack of cards that users can swipe left or right. The cards change color as they're dragged and fly off the screen if swiped far enough.

## Summary

In this tutorial, you've learned:

- How to implement basic gestures like tap, long press, drag, rotation, and magnification
- Ways to customize gesture behavior with modifiers like `.onChanged` and `.onEnded`
- Techniques for combining multiple gestures
- How to use `@GestureState` for temporary state during gestures
- A real-world application with a card swiping interface

Gestures are a powerful way to make your SwiftUI apps feel natural and interactive. By mastering these techniques, you can create interfaces that are both intuitive and delightful to use.

## Additional Resources

- [Apple's SwiftUI Gestures Documentation](https://developer.apple.com/documentation/swiftui/gestures)
- [WWDC Session: Add SwiftUI to Your App](https://developer.apple.com/videos/play/wwdc2019/231/)
- [Human Interface Guidelines: Gestures](https://developer.apple.com/design/human-interface-guidelines/gestures)

## Exercises

1. Create a photo viewer that supports pinch-to-zoom and double-tap to reset zoom.
2. Implement a custom slider that users can drag to adjust a value.
3. Build a drawing app that tracks finger movements using drag gestures.
4. Create a deck of cards that can be spread out and rearranged with drag gestures.
5. Implement a rotation lock that only allows objects to be rotated to specific angles (e.g., 0°, 90°, 180°, 270°).