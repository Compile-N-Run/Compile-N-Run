---
title: Swift Data Types
description: Learn about the fundamental data types in Swift, their usage, and how to work with variables and constants of different types.

---

# Swift Data Types

## Introduction

Data types are one of the most fundamental concepts in any programming language, and Swift is no exception. Data types define what kind of data a variable or constant can hold, how much memory it will use, and what operations can be performed on it.

In this tutorial, we'll explore Swift's primary data types, understand how type safety works in Swift, and learn how to use these types effectively in your iOS and macOS applications.

## Swift's Type System

Swift is a **type-safe** language, which means it helps you be clear about the types of values your code can work with. If part of your code requires a `String`, type safety prevents you from passing an `Int` by mistake. This helps you catch and fix errors as early as possible in your development process.

Let's dive into Swift's basic data types.

## Fundamental Data Types in Swift

### Integers

Integers are whole numbers with no fractional component. Swift provides signed and unsigned integers in 8, 16, 32, and 64 bit forms.

```swift
// Declaring integers
let integerNumber: Int = 42
let unsignedInteger: UInt = 42

// Swift will infer the type automatically
let inferredInteger = 42  // This is automatically an Int

// Maximum and minimum values
print("Maximum value for Int: \(Int.max)")
print("Minimum value for Int: \(Int.min)")
```

Output:
```
Maximum value for Int: 9223372036854775807
Minimum value for Int: -9223372036854775808
```

For most cases, you can simply use `Int` even when the values are only positive, unless you specifically need an unsigned integer.

### Floating-Point Numbers

Floating-point numbers are numbers with a fractional component. Swift provides two signed floating-point number types:

- `Double`: 64-bit floating-point number (15 decimal digits precision)
- `Float`: 32-bit floating-point number (6 decimal digits precision)

```swift
// Declaring floating-point numbers
let double: Double = 3.14159265359
let float: Float = 3.14

// Swift will infer a Double for decimal literals
let inferredDouble = 3.14  // This is automatically a Double

print("Double value: \(double)")
print("Float value: \(float)")
```

Output:
```
Double value: 3.14159265359
Float value: 3.14
```

:::tip
In Swift, when you declare a decimal number without specifying its type, Swift will infer it as a `Double` rather than a `Float`.
:::

### Booleans

Booleans represent true or false values and are commonly used for conditional logic.

```swift
// Declaring booleans
let isSwiftAwesome: Bool = true
let isBoringLanguage = false  // Type inference works here too

// Using booleans in conditionals
if isSwiftAwesome {
    print("I love Swift!")
}

if !isBoringLanguage {
    print("Swift is exciting!")
}
```

Output:
```
I love Swift!
Swift is exciting!
```

### Characters

A `Character` represents a single character, like a letter, number, punctuation mark, or even emoji.

```swift
// Declaring characters
let dollarSign: Character = "$"
let heart: Character = "❤️"
let chesspiece: Character = "♞"

print(dollarSign)
print(heart)
print(chesspiece)
```

Output:
```
$
❤️
♞
```

### Strings

A `String` represents a sequence of characters, like text.

```swift
// Declaring strings
let greeting: String = "Hello, Swift!"
let name = "John"  // Type inference works here

// String concatenation
let message = greeting + " My name is " + name + "."
print(message)

// String interpolation (embedding values within strings)
let age = 25
let introduction = "I am \(name) and I am \(age) years old."
print(introduction)

// Multiline strings
let multilineString = """
This is a multiline string.
It spans multiple lines.
Very useful for longer text.
"""
print(multilineString)
```

Output:
```
Hello, Swift! My name is John.
I am John and I am 25 years old.
This is a multiline string.
It spans multiple lines.
Very useful for longer text.
```

## Type Aliases

Type aliases define an alternative name for an existing type. You create type aliases with the `typealias` keyword.

```swift
// Defining a type alias
typealias AudioSample = UInt16

// Using the type alias
var maxAmplitude: AudioSample = 32767
print("The maximum amplitude is \(maxAmplitude).")
```

Output:
```
The maximum amplitude is 32767.
```

## Type Safety and Type Inference

Swift is type-safe, which means it checks types at compile time to prevent errors. It also uses type inference to determine the type of a variable or constant automatically.

```swift
// Type safety
let name = "John"
// name = 42  // Error: Cannot assign value of type 'Int' to type 'String'

// Type inference
let meaningOfLife = 42  // Swift infers this as Int
let pi = 3.14159  // Swift infers this as Double
let greeting = "Hello"  // Swift infers this as String

// Type annotations
let explicitInteger: Int = 42
let explicitDouble: Double = 3.14159
let explicitString: String = "Hello"
```

## Type Conversions

Sometimes you need to convert one type to another. Swift provides initializers for type conversion.

```swift
// Converting between numeric types
let integerPi = Int(pi)  // 3 (truncates the decimal part)
print("Integer value of pi: \(integerPi)")

let doubleFromInteger = Double(meaningOfLife)  // 42.0
print("Double value from integer: \(doubleFromInteger)")

// Converting numbers to strings
let meaningOfLifeString = String(meaningOfLife)  // "42"
print("String value of meaningOfLife: \(meaningOfLifeString)")

// Converting strings to numbers
let numberString = "123"
if let number = Int(numberString) {
    print("\(numberString) converted to integer: \(number)")
} else {
    print("Could not convert \(numberString) to integer")
}

let invalidNumberString = "123abc"
if let number = Int(invalidNumberString) {
    print("\(invalidNumberString) converted to integer: \(number)")
} else {
    print("Could not convert \(invalidNumberString) to integer")
}
```

Output:
```
Integer value of pi: 3
Double value from integer: 42.0
String value of meaningOfLife: 42
123 converted to integer: 123
Could not convert 123abc to integer
```

## Collection Types

Swift provides three primary collection types: arrays, sets, and dictionaries.

### Arrays

An array stores values of the same type in an ordered list.

```swift
// Declaring arrays
var numbers: [Int] = [1, 2, 3, 4, 5]
var fruits = ["Apple", "Banana", "Orange"]  // Type inference works here

// Accessing elements
print("First number: \(numbers[0])")
print("Second fruit: \(fruits[1])")

// Modifying arrays
numbers.append(6)
fruits += ["Mango"]

print("Updated numbers: \(numbers)")
print("Updated fruits: \(fruits)")

// Creating empty arrays
var emptyArray1: [String] = []
var emptyArray2 = [Int]()

// Checking if an array is empty
if emptyArray1.isEmpty {
    print("emptyArray1 is empty")
}
```

Output:
```
First number: 1
Second fruit: Banana
Updated numbers: [1, 2, 3, 4, 5, 6]
Updated fruits: ["Apple", "Banana", "Orange", "Mango"]
emptyArray1 is empty
```

### Sets

A set stores distinct values of the same type in an unordered collection.

```swift
// Declaring sets
var colors: Set<String> = ["Red", "Green", "Blue"]
var numbers: Set = [1, 2, 3, 4, 5]  // Type inference works here

// Adding and removing elements
colors.insert("Yellow")
colors.remove("Green")

print("Colors: \(colors)")

// Checking if a set contains an element
if colors.contains("Red") {
    print("The set contains Red")
}

// Set operations
let evenNumbers: Set = [2, 4, 6, 8]
let oddNumbers: Set = [1, 3, 5, 7, 9]
let primeNumbers: Set = [2, 3, 5, 7]

// Union
let allNumbers = evenNumbers.union(oddNumbers)
print("All numbers: \(allNumbers)")

// Intersection
let evenPrimes = evenNumbers.intersection(primeNumbers)
print("Even prime numbers: \(evenPrimes)")

// Difference
let nonPrimeEvens = evenNumbers.subtracting(primeNumbers)
print("Non-prime even numbers: \(nonPrimeEvens)")
```

Output:
```
Colors: ["Yellow", "Red", "Blue"]
The set contains Red
All numbers: [2, 4, 6, 8, 1, 3, 5, 7, 9]
Even prime numbers: [2]
Non-prime even numbers: [4, 6, 8]
```

### Dictionaries

A dictionary stores associations between keys and values of the same type.

```swift
// Declaring dictionaries
var countryCodes: [String: String] = ["US": "United States", "CA": "Canada", "FR": "France"]
var ages = ["John": 25, "Alice": 30, "Bob": 27]  // Type inference works here

// Accessing values
if let countryName = countryCodes["US"] {
    print("US stands for \(countryName)")
}

// Adding and modifying values
countryCodes["UK"] = "United Kingdom"
ages["Alice"] = 31

print("Updated country codes: \(countryCodes)")
print("Updated ages: \(ages)")

// Removing key-value pairs
countryCodes.removeValue(forKey: "FR")
print("Country codes after removal: \(countryCodes)")

// Creating empty dictionaries
var emptyDict1: [String: Int] = [:]
var emptyDict2 = [String: Double]()
```

Output:
```
US stands for United States
Updated country codes: ["FR": "France", "US": "United States", "CA": "Canada", "UK": "United Kingdom"]
Updated ages: ["Alice": 31, "John": 25, "Bob": 27]
Country codes after removal: ["US": "United States", "CA": "Canada", "UK": "United Kingdom"]
```

## Optionals

Optionals are a powerful feature in Swift that handle the absence of a value. An optional can either contain a value or be `nil`.

```swift
// Declaring optionals
var possibleNumber: Int? = 42
var noValue: String? = nil

// Unwrapping optionals with if-let
if let actualNumber = possibleNumber {
    print("The number is \(actualNumber)")
} else {
    print("No number provided")
}

// Force unwrapping (use with caution!)
let forcedNumber = possibleNumber!  // This will crash if possibleNumber is nil
print("Forced number: \(forcedNumber)")

// Implicitly unwrapped optionals
var assumedString: String! = "An implicitly unwrapped optional string"
let implicitString: String = assumedString  // No need for unwrapping
print("Implicit string: \(implicitString)")
```

Output:
```
The number is 42
Forced number: 42
Implicit string: An implicitly unwrapped optional string
```

## Real-World Examples

Let's look at some real-world examples of how these data types might be used in a Swift application.

### Example 1: User Profile

```swift
// A struct representing a user profile
struct UserProfile {
    let id: Int
    let username: String
    let name: String
    let age: Int
    let email: String?  // Optional because not all users might provide an email
    let isActive: Bool
    let joinDate: String
    let favoriteColors: [String]
}

// Creating a user profile
let user = UserProfile(
    id: 12345,
    username: "swiftcoder",
    name: "John Doe",
    age: 28,
    email: "john@example.com",
    isActive: true,
    joinDate: "2023-01-15",
    favoriteColors: ["Blue", "Green", "Purple"]
)

// Using the user information
print("User Profile:")
print("ID: \(user.id)")
print("Username: \(user.username)")
print("Name: \(user.name)")
print("Age: \(user.age)")

if let email = user.email {
    print("Email: \(email)")
} else {
    print("No email provided")
}

print("Active user: \(user.isActive ? "Yes" : "No")")
print("Join date: \(user.joinDate)")
print("Favorite colors: \(user.favoriteColors.joined(separator: ", "))")
```

Output:
```
User Profile:
ID: 12345
Username: swiftcoder
Name: John Doe
Age: 28
Email: john@example.com
Active user: Yes
Join date: 2023-01-15
Favorite colors: Blue, Green, Purple
```

### Example 2: Shopping Cart

```swift
// A struct representing a product
struct Product {
    let id: Int
    let name: String
    let price: Double
    let category: String
    let isInStock: Bool
}

// A shopping cart using a dictionary
var cart: [Int: Int] = [:]  // Product ID to quantity

// Product catalog using an array
let catalog: [Product] = [
    Product(id: 1, name: "iPhone", price: 999.99, category: "Electronics", isInStock: true),
    Product(id: 2, name: "Headphones", price: 199.99, category: "Electronics", isInStock: true),
    Product(id: 3, name: "Coffee Mug", price: 14.99, category: "Kitchen", isInStock: false),
    Product(id: 4, name: "T-shirt", price: 24.99, category: "Clothing", isInStock: true)
]

// Function to add a product to the cart
func addToCart(productId: Int, quantity: Int) {
    if let existingQuantity = cart[productId] {
        cart[productId] = existingQuantity + quantity
    } else {
        cart[productId] = quantity
    }
}

// Adding products to cart
addToCart(productId: 1, quantity: 1)
addToCart(productId: 2, quantity: 2)
addToCart(productId: 2, quantity: 1)  // Add one more headphone

// Function to calculate the total price
func calculateTotal() -> Double {
    var total: Double = 0
    
    for (productId, quantity) in cart {
        if let product = catalog.first(where: { $0.id == productId }) {
            if product.isInStock {
                total += product.price * Double(quantity)
            } else {
                print("\(product.name) is out of stock and won't be included in the total")
            }
        }
    }
    
    return total
}

// Display the cart and total
print("Shopping Cart:")
for (productId, quantity) in cart {
    if let product = catalog.first(where: { $0.id == productId }) {
        print("\(product.name) x \(quantity): $\(product.price * Double(quantity))")
    }
}

let total = calculateTotal()
print("Total: $\(total)")
```

Output:
```
Shopping Cart:
iPhone x 1: $999.99
Headphones x 3: $599.97
Total: $1599.96
```

## Summary

In this tutorial, we've explored Swift's fundamental data types:

1. **Integers** (`Int`, `UInt`) for whole numbers
2. **Floating-point numbers** (`Double`, `Float`) for decimal numbers
3. **Booleans** (`Bool`) for true/false values
4. **Characters** (`Character`) for single characters
5. **Strings** (`String`) for text
6. **Collection Types**:
   - Arrays for ordered collections
   - Sets for unordered collections of unique values
   - Dictionaries for key-value associations
7. **Optionals** for values that might be absent

Understanding these data types is crucial for writing effective Swift code. Swift's type system helps catch errors early and makes your code more reliable and maintainable.

## Additional Resources

- [Swift Documentation - The Basics](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html)
- [Swift Documentation - Collection Types](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)
- [Swift Documentation - Strings and Characters](https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html)

## Exercises

1. Create a struct called `Movie` with properties for title, director, release year, and rating.
2. Create an array of at least three movies and print their details.
3. Create a dictionary that maps genre names to arrays of movies.
4. Write a function that finds all movies by a specific director.
5. Create a function that calculates the average rating of all movies in your collection.

Happy coding with Swift!