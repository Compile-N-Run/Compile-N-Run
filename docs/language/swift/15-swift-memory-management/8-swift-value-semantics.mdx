---
title: Swift Value Semantics
description: Learn about value semantics in Swift, how they work, when to use them, and how they impact memory management in your applications.

---

# Swift Value Semantics

Swift's approach to memory management is one of its defining features, and understanding value semantics is fundamental to writing efficient and predictable Swift code. In this article, we'll explore what value semantics are, how they work in Swift, and why they matter for your applications.

## What Are Value Semantics?

Value semantics describe how data behaves when it's assigned to a new variable or passed as a function parameter. With value semantics, when you assign a value to a new variable or pass it to a function, you're working with an independent copy of that data, not a reference to the original.

In Swift, the following types use value semantics:
- Structs (including standard types like `Int`, `String`, `Array`, `Dictionary`)
- Enums
- Tuples

## Value Types vs. Reference Types

Before diving deeper into value semantics, let's compare them with reference semantics:

| Value Semantics | Reference Semantics |
|-----------------|---------------------|
| Copy on assignment | Share on assignment |
| Independent instances | Shared instances |
| Used by structs, enums | Used by classes |
| Predictable behavior | Potential for side effects |

## Basic Value Semantics in Action

Let's see a simple example of value semantics with an `Int`:

```swift
var number1 = 42
var number2 = number1  // Creates a copy

number2 += 10

print("number1: \(number1)")  // number1: 42
print("number2: \(number2)")  // number2: 52
```

Since `Int` is a value type, `number2` receives a copy of `number1`'s value, not a reference. Changing `number2` has no effect on `number1`.

## Custom Value Types and Value Semantics

Let's create a custom struct to demonstrate value semantics:

```swift
struct Point {
    var x: Double
    var y: Double
    
    func description() -> String {
        return "(\(x), \(y))"
    }
}

var point1 = Point(x: 10, y: 20)
var point2 = point1  // Creates a copy

point2.x = 15

print("point1: \(point1.description())")  // point1: (10.0, 20.0)
print("point2: \(point2.description())")  // point2: (15.0, 20.0)
```

When we assign `point1` to `point2`, Swift creates a new copy of the struct. Modifying `point2` doesn't affect `point1`.

## Value Semantics with Collections

Swift's standard collection types (`Array`, `Dictionary`, `Set`) also have value semantics:

```swift
var array1 = [1, 2, 3]
var array2 = array1  // Creates a copy

array2.append(4)
array2[0] = 100

print("array1: \(array1)")  // array1: [1, 2, 3]
print("array2: \(array2)")  // array2: [100, 2, 3, 4]
```

## Copy-on-Write Optimization

While value types create copies when assigned, Swift uses a performance optimization called **copy-on-write** for some types like `Array` and `Dictionary`. This means:

1. The actual copying is deferred until you modify the value.
2. If you never modify the copy, no actual copying occurs.

This provides the safety of value semantics without unnecessary performance costs:

```swift
var largeArray1 = Array(repeating: "Swift", count: 10000)
var largeArray2 = largeArray1  // No actual copying happens yet
// Both variables share the same storage internally

// Only when modifying largeArray2 does Swift create a unique copy
largeArray2[0] = "Swift is awesome"
// Now largeArray1 and largeArray2 have separate storage
```

## Value Semantics and Memory Management

Value semantics simplify memory management:

1. **Automatic Memory Management**: Each value type instance has a clear owner.
2. **Predictable Lifetimes**: A value exists as long as the variable it's assigned to exists.
3. **No Retain Cycles**: Value types can't create strong reference cycles that lead to memory leaks.

## Implementing Value Semantics in Custom Types

Here's how to ensure value semantics in a custom type that contains reference types:

```swift
struct Profile {
    var name: String
    private var _image: SharedImage
    
    var image: UIImage {
        get { return _image.image }
        set { 
            // Create a new backing store when modified
            if !isKnownUniquelyReferenced(&_image) {
                _image = SharedImage(image: newValue)
                return
            }
            _image.image = newValue
        }
    }
    
    init(name: String, image: UIImage) {
        self.name = name
        self._image = SharedImage(image: image)
    }
}

// Helper class to manage the reference type
final class SharedImage {
    var image: UIImage
    
    init(image: UIImage) {
        self.image = image
    }
}
```

This implementation uses the `isKnownUniquelyReferenced` function to implement copy-on-write behavior manually.

## When to Use Value Semantics

Value semantics are ideal for:

1. **Data Models**: Representing immutable facts or values in your app
2. **UI States**: Managing UI state without unexpected side effects
3. **Concurrency**: Safely passing data between threads without synchronization concerns
4. **Functional Programming**: Creating pure functions with predictable behavior

## Practical Example: Managing Game State

Let's see how value semantics can help in a real-world application like a game:

```swift
struct GameState {
    var score: Int
    var level: Int
    var playerPosition: Point
    var inventory: [Item]
    var health: Int
    
    // Creates a new state for the next level
    func advancingToNextLevel() -> GameState {
        var newState = self  // Create a copy
        newState.level += 1
        newState.playerPosition = Point(x: 0, y: 0)  // Reset position
        return newState
    }
}

struct Item {
    let id: String
    let name: String
    var count: Int
}

// Game loop
var currentState = GameState(score: 0, level: 1, 
                           playerPosition: Point(x: 0, y: 0),
                           inventory: [], health: 100)

// After player completes a level
let newState = currentState.advancingToNextLevel()

print("Original state - Level: \(currentState.level)")  // Level: 1
print("New state - Level: \(newState.level)")  // Level: 2
```

This approach allows us to create new game states without modifying the original, making it easier to implement features like "undo" or replay a level.

## Memory Efficiency Considerations

While value semantics are powerful, there are situations where you should be careful:

1. **Large Data Structures**: If you have extremely large custom structs that need to be copied frequently, the performance impact might be significant.
2. **Deep Object Hierarchies**: Value semantics can lead to copying entire object trees.

In these cases, you might:
- Implement custom copy-on-write behavior
- Use reference types where appropriate
- Split large value types into smaller components

## Summary

Swift's value semantics provide a powerful tool for creating predictable and safe code. Key takeaways include:

- Value types create copies when assigned or passed to functions
- Value semantics help avoid unexpected side effects
- Swift uses copy-on-write to optimize performance
- Value types simplify memory management
- Value semantics work well for data modeling and state management

Understanding value semantics is essential for writing idiomatic Swift code that is both safe and efficient.

## Additional Resources

- [Swift Documentation on Value and Reference Types](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html)
- [WWDC Session: Building Better Apps with Value Types in Swift](https://developer.apple.com/videos/play/wwdc2015/414/)
- [The Swift Programming Language: Memory Safety](https://docs.swift.org/swift-book/LanguageGuide/MemorySafety.html)

## Exercises

1. Create a `Temperature` struct with Celsius and Fahrenheit conversions that maintains value semantics.
2. Implement a simple `Stack<Element>` as a struct with push and pop operations.
3. Design a drawing app's state management system using value semantics to enable undo/redo functionality.
4. Compare the performance of a large struct with and without manual copy-on-write implementation.