---
title: Swift Naming Conventions
description: Learn the standard Swift naming conventions to write clean, consistent, and readable code that follows Apple's official guidelines.

---

# Swift Naming Conventions

When writing Swift code, following consistent naming conventions makes your code more readable, maintainable, and aligned with the Swift community standards. These conventions aren't just about aestheticsâ€”they improve code understanding and collaboration between developers.

## Introduction to Swift Naming Conventions

Swift has established naming conventions that reflect Apple's emphasis on clarity and expressiveness. The guiding principle behind Swift naming is that code should read like natural English sentences where possible, making the intent clear to anyone reading it.

As a beginner, adopting these conventions early will help you write more professional code and make it easier to work with others on Swift projects.

## Basic Naming Rules

### Case Conventions

Swift uses several different casing styles depending on what you're naming:

1. **camelCase**: Used for variable names, function names, and parameter names
2. **PascalCase**: Used for type names (classes, structs, enums, protocols)
3. **snake_case**: Generally avoided in Swift (common in other languages)

```swift
// PascalCase for types
class UserProfile { }
struct NetworkResponse { }
enum ConnectionState { }
protocol DataProvider { }

// camelCase for variables and functions
let userName = "John"
var userAge = 25
func calculateTotalPrice() { }
```

### Clarity is Paramount

Swift prioritizes clarity over brevity. Names should be descriptive and unambiguous:

```swift
// Avoid
let w = 640    // What does 'w' represent?
let h = 480    // What does 'h' represent?

// Better
let screenWidth = 640
let screenHeight = 480
```

## Naming Variables and Constants

### Be Descriptive But Concise

Choose names that clearly describe what the variable or constant represents:

```swift
// Too vague
let data = ["John", "Smith", 35]

// Better
let userInfo = ["firstName": "John", "lastName": "Smith", "age": 35]

// Even better with proper types
struct User {
    let firstName: String
    let lastName: String
    let age: Int
}
let user = User(firstName: "John", lastName: "Smith", age: 35)
```

### Boolean Values

Boolean variables and properties should read like assertions:

```swift
// Preferred
let isVisible = true
let hasPermission = false
let canEdit = user.accessLevel >= 4

// Not preferred
let visible = true      // Less clear
let permission = false  // Doesn't read as a condition
```

## Naming Functions and Methods

### Use Verb Phrases for Actions

Functions that perform actions should start with a verb:

```swift
// Good: verb + noun
func fetchUserData() { }
func calculateTotalPrice() { }
func saveUserPreferences() { }

// Not recommended: unclear what the function does
func userData() { }
func totalPrice() { }
```

### Include Parameter Labels for Clarity

Swift allows you to specify external parameter names to make function calls more readable:

```swift
// Without clear parameter labels
func convert(celsius: Double) -> Double {
    return celsius * 9/5 + 32
}
// Usage: convert(celsius: 30)

// With better parameter labels
func convert(from celsius: Double) -> Double {
    return celsius * 9/5 + 32
}
// Usage: convert(from: 30)
```

### Use Prepositions for Parameter Labels

Appropriate prepositions make function calls read more naturally:

```swift
func insert(_ element: Element, at index: Int)
func remove(at index: Int)
func getDistance(from startPoint: Point, to endPoint: Point)
```

## Type Naming Conventions

### Use Nouns for Types

Types (classes, structs, enums) should be named using nouns:

```swift
// Good
class User { }
struct PaymentDetails { }
enum ShippingMethod { }

// Not recommended
class ManageUsers { }    // Sounds like an action, not a type
struct ProcessPayment { } // Sounds like a function
```

### Protocol Naming

Protocols that describe what something is should end with a noun:

```swift
protocol Collection { }
protocol ViewController { }
```

Protocols that describe a capability should end with "able", "ible", or "ing":

```swift
protocol Equatable { }
protocol Hashable { }
protocol Codable { }
protocol Drawing { }
```

## Enum Case Naming

### Use Lowercase camelCase for Enum Cases

Enum cases use camelCase, just like variables and properties:

```swift
enum Direction {
    case up
    case down
    case left
    case right
}

enum HttpStatus {
    case ok
    case notFound
    case internalServerError
}
```

### Associated Values and Parameters

When using associated values with enums, follow the same parameter naming conventions as functions:

```swift
enum NetworkResponse {
    case success(data: Data)
    case failure(error: Error, statusCode: Int)
}

// Usage
let response = NetworkResponse.failure(error: someError, statusCode: 404)
```

## Abbreviations and Acronyms

### Handle Acronyms Consistently

Acronyms and initialisms should be handled consistently in names:

```swift
// Preferred: Treat acronyms like words when they're part of a name
class URLSession { }  // Not "URlSession"
class JSONDecoder { } // Not "jsonDecoder"

// For variables and function names, start with lowercase
let urlString = "https://example.com"
let jsonData = getData()
```

## Real-world Examples

### Example 1: User Authentication System

Here's how you might name components in a user authentication system:

```swift
// Types (PascalCase)
struct User {
    let id: String
    let username: String
    let emailAddress: String
    var isVerified: Bool
    var lastLoginDate: Date?
}

class AuthenticationManager {
    // Properties (camelCase)
    private let securityProvider: SecurityProvider
    private var currentUser: User?
    var isUserLoggedIn: Bool {
        return currentUser != nil
    }
    
    // Methods (camelCase with descriptive parameter names)
    func authenticateUser(with credentials: Credentials) -> AuthResult {
        // Implementation
    }
    
    func signOut(completionHandler: ((Bool) -> Void)? = nil) {
        // Implementation
    }
    
    func resetPassword(for email: String, completion: @escaping (Result<Void, AuthError>) -> Void) {
        // Implementation
    }
}

// Enum with associated values
enum AuthResult {
    case success(user: User)
    case failure(reason: AuthError)
}

// Protocol ending with "Provider" to indicate its purpose
protocol SecurityProvider {
    func encryptData(_ data: Data) -> Data
    func verifyPassword(_ password: String, against hash: String) -> Bool
}
```

### Example 2: Shopping Cart Functionality

```swift
// Product model
struct Product {
    let id: String
    let name: String
    let price: Decimal
    let description: String
    let imageURL: URL?
}

// Shopping cart management
class ShoppingCart {
    // Properties
    private(set) var items: [CartItem] = []
    
    var totalPrice: Decimal {
        return items.reduce(0) { $0 + ($1.product.price * Decimal($1.quantity)) }
    }
    
    var itemCount: Int {
        return items.reduce(0) { $0 + $1.quantity }
    }
    
    // Methods with descriptive names and parameter labels
    func addProduct(_ product: Product, quantity: Int = 1) {
        // Implementation
    }
    
    func removeItem(at index: Int) {
        // Implementation
    }
    
    func updateQuantity(for productId: String, to newQuantity: Int) -> Bool {
        // Implementation
        return true
    }
    
    func clearCart() {
        items = []
    }
}

// Supporting types
struct CartItem {
    let product: Product
    var quantity: Int
}

enum CheckoutError {
    case emptyCart
    case insufficientFunds(amountShort: Decimal)
    case productNoLongerAvailable(productId: String)
}
```

## Common Mistakes to Avoid

1. **Using Abbreviations Excessively**:
   ```swift
   // Avoid
   let mgr = UserManager()
   let num = calculateTtl()
   
   // Better
   let manager = UserManager()
   let total = calculateTotal()
   ```

2. **Inconsistent Naming Styles**:
   ```swift
   // Avoid mixing styles
   let UserName = "John"      // PascalCase for a variable
   class userProfile { }      // camelCase for a class
   
   // Correct
   let userName = "John"      // camelCase for a variable
   class UserProfile { }      // PascalCase for a class
   ```

3. **Too Generic Names**:
   ```swift
   // Too generic
   let list = ["Apple", "Banana", "Orange"]
   
   // Better
   let fruitNames = ["Apple", "Banana", "Orange"]
   ```

## Swift Style Guide Resources

Apple's official Swift style is documented in various places:

1. The [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/) from Swift.org
2. The code style used in the Swift standard library
3. Conventions used in sample code from Apple

## Summary

Following Swift naming conventions helps create code that's easier to read, understand, and maintain. Remember these key principles:

- Use camelCase for variables, properties, functions, and enum cases
- Use PascalCase for types (classes, structs, enums, protocols)
- Be descriptive but concise in naming
- Make function calls read like natural sentences
- Be consistent with acronyms and abbreviations
- Choose clarity over brevity

By following these conventions from the start, you'll develop good habits that will serve you well throughout your Swift programming journey.

## Additional Resources

1. [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/) - Official Swift naming guidelines
2. [Swift Style Guide by Ray Wenderlich](https://github.com/raywenderlich/swift-style-guide) - Popular style guide used by many developers
3. [SwiftLint](https://github.com/realm/SwiftLint) - A tool to enforce Swift style conventions

## Exercises

1. Refactor the following code to follow Swift naming conventions:
   ```swift
   class user_data {
       var First_name: String
       var last_Name: String
       var AGE: Int
       
       func PRINT_DETAILS() {
           print("\(First_name) \(last_Name), \(AGE)")
       }
   }
   ```

2. Examine some open source Swift projects on GitHub and identify how they follow (or don't follow) these naming conventions.

3. Create a small dictionary app with properly named classes, structs, and functions following Swift naming conventions.