---
title: Swift Code Style
description: A comprehensive guide to Swift code style conventions, best practices, and formatting standards to write clean, consistent, and maintainable Swift code.

---

# Swift Code Style

## Introduction

Code style is more than just aesthetics â€” it's about creating readable, maintainable, and consistent code that can be easily understood by you and other developers. In Swift programming, following established style conventions not only makes your code look professional but also helps prevent bugs and makes collaboration smoother.

This guide covers the fundamental Swift code style conventions that will help you write clean, consistent Swift code that follows industry best practices.

## Why Code Style Matters

Before diving into specific guidelines, let's understand why code style is important:

1. **Readability**: Well-formatted code is easier to read and understand
2. **Maintainability**: Consistent style makes the codebase easier to maintain
3. **Collaboration**: Team members can understand each other's code more quickly
4. **Professionalism**: Good style reflects professional development practices
5. **Error reduction**: Clear formatting can help prevent logical errors

## Swift Official Style Guide

Swift doesn't have an official style guide from Apple, but the Swift community has developed several widely-adopted conventions. The [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/) provide excellent direction for naming and API design.

## Naming Conventions

### Variables and Constants

In Swift, use camelCase for variable and constant names:

```swift
// Good
let maxLoginAttempts = 3
var currentLoginAttempt = 0

// Avoid
let MaxLoginAttempts = 3
var current_login_attempt = 0
```

### Functions and Methods

Functions and methods also use camelCase:

```swift
// Good
func calculateTotalPrice(items: [Item]) -> Double {
    // Implementation
}

// Avoid
func Calculate_total_price(items: [Item]) -> Double {
    // Implementation
}
```

### Types (Classes, Structs, Enums, Protocols)

Use PascalCase (initial uppercase) for type names:

```swift
// Good
struct User {
    // Properties and methods
}

class NetworkManager {
    // Properties and methods
}

enum PaymentMethod {
    case creditCard
    case paypal
    case applePay
}

protocol DataSource {
    // Protocol requirements
}

// Avoid
struct user {
    // Properties and methods
}

class networkManager {
    // Properties and methods
}
```

### Enum Cases

Use camelCase for enum cases:

```swift
enum Planet {
    // Good
    case mercury
    case venus
    case earth
    
    // Avoid
    case Mercury
    case Venus
    case Earth
}
```

## Spacing and Formatting

### Indentation

Use 4 spaces for indentation, not tabs:

```swift
func exampleFunction() {
    if condition {
        // 4 spaces indented
        performAction()
    }
}
```

### Line Length

A common convention is to limit lines to 80-120 characters. This improves readability, especially when viewing code side-by-side or on smaller screens:

```swift
// Good: Break long lines into multiple lines
let longText = """
    This is a multiline string that demonstrates
    how to handle long text content in Swift without
    having lines that run too long.
    """

// Good: Break long function calls into multiple lines
let result = someFunction(
    withFirstParameter: firstValue,
    andSecondParameter: secondValue,
    andThirdParameter: thirdValue
)

// Avoid: Long unbroken lines that require horizontal scrolling
let result = someFunction(withFirstParameter: firstValue, andSecondParameter: secondValue, andThirdParameter: thirdValue, andFourthParameter: fourthValue)
```

### Braces

Opening braces should be placed on the same line as the declaration they belong to:

```swift
// Good
if user.isAuthenticated {
    // Handle authenticated user
}

// Avoid
if user.isAuthenticated
{
    // Handle authenticated user
}
```

### Whitespace

Use whitespace to improve readability around operators:

```swift
// Good
let sum = a + b
let name = "Hello, " + userName

// Avoid
let sum=a+b
let name="Hello, "+userName
```

Avoid trailing whitespace at the end of lines.

## Comments

### Single-Line Comments

Use `//` followed by a space for single-line comments:

```swift
// This is a good single-line comment
```

### Multi-Line Comments

Use `/* ... */` for multi-line comments, with `*` aligned on subsequent lines:

```swift
/* This is a multi-line comment.
 * Each line is prefixed with a properly aligned asterisk.
 * This makes the comment block more readable.
 */
```

### Documentation Comments

Use `///` for documentation comments that describe properties, methods, and types:

```swift
/// Calculates the total price of the given items
/// - Parameter items: An array of items to calculate price for
/// - Returns: The total price as a Double
func calculateTotalPrice(items: [Item]) -> Double {
    // Implementation
}
```

## Swift-Specific Conventions

### Type Inference

Take advantage of Swift's type inference when it makes code clearer:

```swift
// Good: Type is clearly inferred
let message = "Hello"
let count = 42
let prices = [10.99, 5.99, 3.99]

// When specifying type makes code clearer, use explicit types
let emptyArray: [String] = []
let jsonDecoder: JSONDecoder = JSONDecoder()
```

### Optionals

Use safe unwrapping techniques with optionals:

```swift
// Good: Optional binding
if let username = username {
    print("Hello, \(username)")
}

// Good: Guard statements for early returns
guard let username = username else {
    return
}
print("Hello, \(username)")

// Avoid: Force unwrapping (unless absolutely certain)
print("Hello, \(username!)")  // Might crash if nil
```

### Final Classes

Consider marking classes as `final` when inheritance is not needed:

```swift
// Prevents inheritance, can improve performance
final class UserManager {
    // Implementation
}
```

## Practical Example: Refactoring Code for Better Style

Let's see how we can refactor a poorly styled code into a well-styled one:

### Before Refactoring:

```swift
struct user_data {
    var First_name:String
    var Last_name:String
    var Age:Int?
    
    func getFullName()->String{
        return First_name+" "+Last_name
    }
    
    func CanVote()->Bool{
        if(Age != nil){if(Age! >= 18){return true}
        }
    return false
    }
}

func Process_User(DATA:user_data){
    let name=DATA.getFullName()
    let voting_status = DATA.CanVote() ? "can vote" : "cannot vote"
    print(name+" "+voting_status);
}
```

### After Refactoring:

```swift
struct UserData {
    var firstName: String
    var lastName: String
    var age: Int?
    
    /// Returns the user's full name as a single string
    func getFullName() -> String {
        return "\(firstName) \(lastName)"
    }
    
    /// Determines if the user is eligible to vote based on age
    /// - Returns: True if the user is 18 or older
    func canVote() -> Bool {
        guard let age = age else {
            return false
        }
        return age >= 18
    }
}

/// Processes user information and prints a summary
/// - Parameter userData: The user data to process
func processUser(userData: UserData) {
    let name = userData.getFullName()
    let votingStatus = userData.canVote() ? "can vote" : "cannot vote"
    print("\(name) \(votingStatus)")
}
```

## Real-World Application: Style in a Complete Swift File

Here's a more comprehensive example showing proper Swift style in a real-world scenario with a simple task management app:

```swift
//
//  TaskManager.swift
//  TaskApp
//
//  Created by Example Developer on 2023-01-15
//

import Foundation

/// Represents the priority level of a task
enum TaskPriority {
    case low
    case medium
    case high
    
    /// Returns a human-readable string describing the priority
    var description: String {
        switch self {
        case .low:
            return "Low Priority"
        case .medium:
            return "Medium Priority"
        case .high:
            return "High Priority"
        }
    }
}

/// Represents a single task in the system
struct Task {
    let id: UUID
    var title: String
    var description: String
    var isComplete: Bool
    var priority: TaskPriority
    var dueDate: Date?
    
    /// Creates a new incomplete task with the given details
    /// - Parameters:
    ///   - title: The task title
    ///   - description: A detailed description of the task
    ///   - priority: The priority level of the task
    ///   - dueDate: Optional due date for the task
    init(title: String, description: String, priority: TaskPriority = .medium, dueDate: Date? = nil) {
        self.id = UUID()
        self.title = title
        self.description = description
        self.isComplete = false
        self.priority = priority
        self.dueDate = dueDate
    }
    
    /// Marks the task as complete
    mutating func markAsComplete() {
        isComplete = true
    }
    
    /// Checks if the task is overdue based on its due date
    /// - Returns: True if the task has a due date in the past and is not complete
    func isOverdue() -> Bool {
        guard let dueDate = dueDate else {
            return false
        }
        
        return !isComplete && dueDate < Date()
    }
}

/// Manages a collection of tasks
final class TaskManager {
    private var tasks: [UUID: Task] = [:]
    
    /// Adds a new task to the manager
    /// - Parameter task: The task to add
    /// - Returns: True if the task was added successfully
    func addTask(_ task: Task) -> Bool {
        guard tasks[task.id] == nil else {
            return false
        }
        
        tasks[task.id] = task
        return true
    }
    
    /// Retrieves a task by its ID
    /// - Parameter id: The ID of the task to retrieve
    /// - Returns: The task if found, nil otherwise
    func getTask(byId id: UUID) -> Task? {
        return tasks[id]
    }
    
    /// Updates an existing task
    /// - Parameter task: The updated task
    /// - Returns: True if the task was updated successfully
    func updateTask(_ task: Task) -> Bool {
        guard tasks[task.id] != nil else {
            return false
        }
        
        tasks[task.id] = task
        return true
    }
    
    /// Lists all tasks filtered by completion status
    /// - Parameter isComplete: The completion status to filter by
    /// - Returns: An array of tasks matching the filter
    func listTasks(isComplete: Bool? = nil) -> [Task] {
        let allTasks = Array(tasks.values)
        
        guard let isComplete = isComplete else {
            return allTasks
        }
        
        return allTasks.filter { $0.isComplete == isComplete }
    }
}
```

## Tools for Maintaining Code Style

Several tools can help you maintain consistent code style:

1. **SwiftLint**: A popular tool that enforces Swift style and conventions
2. **SwiftFormat**: Formats your Swift code automatically
3. **Xcode**: Built-in formatting features (Ctrl + I to format selection)

## Summary

Maintaining a consistent code style across your Swift projects makes your code more readable, maintainable, and professional. The key points to remember are:

- Use camelCase for variables, constants, functions, and methods
- Use PascalCase for types like classes, structs, enums, and protocols
- Use proper indentation (4 spaces) and appropriate line length
- Add meaningful comments and documentation
- Handle optionals safely
- Follow the Swift API Design Guidelines

Following these conventions will help you write Swift code that is not only functional but also clean and professional.

## Additional Resources

- [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/)
- [Ray Wenderlich Swift Style Guide](https://github.com/raywenderlich/swift-style-guide)
- [GitHub Swift Style Guide](https://github.com/github/swift-style-guide)
- [SwiftLint Documentation](https://github.com/realm/SwiftLint)

## Exercises

1. Take a small Swift program you've written and refactor it to follow these style guidelines.
2. Install SwiftLint in your project and fix any warnings it generates.
3. Practice documenting a class or struct using proper Swift documentation comments.
4. Review an open-source Swift project and observe how it implements style conventions.

By consistently applying these style guidelines, you'll develop a professional coding style that will serve you well throughout your Swift development career.