---
title: Swift Error Protocols
description: Learn about Swift's error protocols, how to define custom error types, and implement error handling patterns in your Swift applications.

---

# Swift Error Protocols

## Introduction

Error handling is a critical aspect of writing robust software, and Swift provides elegant ways to handle errors through its protocol-based approach. In this guide, we'll explore Swift's error protocols, how they fit into Swift's error handling system, and how you can leverage them to write more reliable code.

Swift's primary error protocol is `Error`, a simple protocol that serves as the foundation for all error types in Swift. Understanding how to work with this protocol and create your own custom error types will help you build applications that gracefully handle exceptional conditions.

## The Error Protocol Basics

### What is the Error Protocol?

The `Error` protocol in Swift is remarkably simple - it's essentially an empty protocol that types conform to in order to be used with Swift's error handling mechanisms:

```swift
public protocol Error {
    // This protocol doesn't require any specific methods or properties!
}
```

Despite its simplicity, this protocol is powerful because it marks types that can be thrown, caught, and propagated through a Swift program using the `throw`, `try`, `catch`, and `throws` keywords.

### Conforming to the Error Protocol

Creating a custom error type is as simple as declaring an enum, struct, or class that conforms to the `Error` protocol:

```swift
enum NetworkError: Error {
    case noConnection
    case serverError(statusCode: Int)
    case timeout
}
```

Now you can throw these errors in your functions:

```swift
func fetchData() throws -> Data {
    // Check network connection
    let isConnected = checkConnection()
    
    if !isConnected {
        throw NetworkError.noConnection
    }
    
    // Simulate a server response with a status code
    let statusCode = performRequest()
    
    if statusCode != 200 {
        throw NetworkError.serverError(statusCode: statusCode)
    }
    
    return Data() // Return the fetched data if successful
}
```

## Creating Structured Error Types

One of the best practices in Swift error handling is to create structured error types that provide meaningful information about what went wrong.

### Using Enumerations for Error Cases

Enumerations are particularly well-suited for modeling errors because they can represent different error cases with associated values:

```swift
enum ValidationError: Error {
    case invalidEmail(String)
    case passwordTooShort(length: Int, minimumLength: Int)
    case usernameAlreadyExists(String)
}

func validateUser(username: String, email: String, password: String) throws {
    // Validate email format
    if !isValidEmail(email) {
        throw ValidationError.invalidEmail(email)
    }
    
    // Check password length
    if password.count < 8 {
        throw ValidationError.passwordTooShort(length: password.count, minimumLength: 8)
    }
    
    // Check if username is already taken
    if isUsernameTaken(username) {
        throw ValidationError.usernameAlreadyExists(username)
    }
    
    // Validation passed successfully
}
```

## Adding Additional Context with LocalizedError

While the basic `Error` protocol is sufficient for simple use cases, Swift provides additional protocols to enhance error handling. One of these is `LocalizedError`, which allows you to provide user-friendly error messages.

```swift
enum PaymentError: Error, LocalizedError {
    case insufficientFunds(needed: Double, available: Double)
    case cardExpired(expiryDate: Date)
    case invalidCVV
    
    var errorDescription: String? {
        switch self {
        case .insufficientFunds(let needed, let available):
            return "Your account doesn't have enough funds. You need $\(needed) but have $\(available)."
        case .cardExpired(let date):
            let formatter = DateFormatter()
            formatter.dateStyle = .medium
            return "Your card expired on \(formatter.string(from: date))."
        case .invalidCVV:
            return "The security code (CVV) you entered is invalid."
        }
    }
    
    var failureReason: String? {
        switch self {
        case .insufficientFunds:
            return "The account balance is too low."
        case .cardExpired:
            return "The card's expiration date has passed."
        case .invalidCVV:
            return "The CVV must be 3 or 4 digits."
        }
    }
    
    var recoverySuggestion: String? {
        switch self {
        case .insufficientFunds:
            return "Please add funds to your account or use a different payment method."
        case .cardExpired:
            return "Please update your card information or use a different card."
        case .invalidCVV:
            return "Please check the back of your card for the 3 or 4 digit security code."
        }
    }
}
```

You can now throw these errors and access localized descriptions:

```swift
func processPayment(amount: Double, cardNumber: String, cvv: String, expiryDate: Date) throws {
    // Check if the card has expired
    let currentDate = Date()
    if expiryDate < currentDate {
        throw PaymentError.cardExpired(expiryDate: expiryDate)
    }
    
    // Check account balance
    let availableFunds = getAccountBalance()
    if availableFunds < amount {
        throw PaymentError.insufficientFunds(needed: amount, available: availableFunds)
    }
    
    // Validate CVV
    if !isValidCVV(cvv) {
        throw PaymentError.invalidCVV
    }
    
    // Process the payment if all checks pass
    performPaymentTransaction(amount, cardNumber)
}

// Example of how to use and display the error message
do {
    try processPayment(amount: 100.0, cardNumber: "1234-5678-9012-3456", cvv: "abc", expiryDate: Date())
} catch let error as PaymentError {
    print(error.errorDescription ?? "Unknown payment error")
    print(error.failureReason ?? "No reason provided")
    print(error.recoverySuggestion ?? "No recovery suggestion available")
} catch {
    print("An unexpected error occurred: \(error)")
}
```

## Error Protocol in Practice: Custom Error Types

Let's explore a more comprehensive example that shows how to use custom error types in a real application. We'll create a file management system that handles various error conditions.

### Defining a Custom File Error Type

```swift
enum FileError: Error {
    case notFound(fileName: String)
    case noPermission(fileName: String)
    case diskFull(freeSpace: Int, required: Int)
    case corruptData(fileName: String)
}
```

### Using Custom Errors in a File Manager

```swift
class SimpleFileManager {
    func readFile(at path: String) throws -> String {
        // Check if file exists
        guard fileExists(at: path) else {
            throw FileError.notFound(fileName: path)
        }
        
        // Check permissions
        guard hasPermission(for: path) else {
            throw FileError.noPermission(fileName: path)
        }
        
        // Attempt to read file
        let fileData = readFileData(at: path)
        
        // Check for corruption
        guard isValidData(fileData) else {
            throw FileError.corruptData(fileName: path)
        }
        
        return decode(fileData)
    }
    
    func writeFile(at path: String, content: String) throws {
        let requiredSpace = estimateFileSize(content)
        let freeSpace = availableDiskSpace()
        
        // Check if there's enough space
        guard freeSpace >= requiredSpace else {
            throw FileError.diskFull(freeSpace: freeSpace, required: requiredSpace)
        }
        
        // Check permissions
        guard hasPermission(for: path) else {
            throw FileError.noPermission(fileName: path)
        }
        
        // Write the file
        writeData(content, to: path)
    }
    
    // Simulated helper methods
    private func fileExists(at path: String) -> Bool { 
        // Implementation would check the file system
        return true 
    }
    
    private func hasPermission(for path: String) -> Bool { 
        // Implementation would check permissions
        return true
    }
    
    private func readFileData(at path: String) -> Data {
        // Implementation would read file data
        return Data()
    }
    
    private func isValidData(_ data: Data) -> Bool {
        // Implementation would validate data
        return true
    }
    
    private func decode(_ data: Data) -> String {
        // Implementation would decode data to string
        return "File contents"
    }
    
    private func estimateFileSize(_ content: String) -> Int {
        // Implementation would estimate file size
        return content.utf8.count
    }
    
    private func availableDiskSpace() -> Int {
        // Implementation would check available disk space
        return 1_000_000
    }
    
    private func writeData(_ content: String, to path: String) {
        // Implementation would write to the file
    }
}
```

### Handling the Custom Errors

```swift
let fileManager = SimpleFileManager()

// Reading a file
do {
    let content = try fileManager.readFile(at: "document.txt")
    print("File content: \(content)")
} catch let error as FileError {
    switch error {
    case .notFound(let fileName):
        print("Error: The file \(fileName) could not be found.")
    case .noPermission(let fileName):
        print("Error: You don't have permission to access \(fileName).")
    case .diskFull:
        print("Error: Cannot perform operation because the disk is full.")
    case .corruptData(let fileName):
        print("Error: The file \(fileName) contains corrupt data.")
    }
} catch {
    print("An unexpected error occurred: \(error)")
}

// Writing a file
do {
    try fileManager.writeFile(at: "output.txt", content: "Hello, Swift Error Handling!")
    print("File successfully written.")
} catch let error as FileError {
    switch error {
    case .diskFull(let free, let required):
        print("Error: Not enough disk space. You need \(required) bytes but only have \(free) bytes available.")
    case .noPermission(let fileName):
        print("Error: You don't have permission to write to \(fileName).")
    default:
        print("Error: \(error)")
    }
} catch {
    print("An unexpected error occurred: \(error)")
}
```

## Advanced Error Protocol Patterns

### Extending Error Types with Additional Properties

You can extend error types with computed properties to provide additional context:

```swift
extension FileError {
    var isRecoverable: Bool {
        switch self {
        case .notFound, .noPermission:
            return true
        case .diskFull, .corruptData:
            return false
        }
    }
    
    var suggestedAction: String {
        switch self {
        case .notFound(let fileName):
            return "Create the file \(fileName) or check its path."
        case .noPermission(let fileName):
            return "Request access to \(fileName) from an administrator."
        case .diskFull:
            return "Free up space by deleting unnecessary files."
        case .corruptData(let fileName):
            return "Try to recover \(fileName) from a backup."
        }
    }
}
```

### Creating a Custom Error Handling Middleware

For complex applications, you might want to create an error handling middleware that centralizes error handling:

```swift
class ErrorHandler {
    func handle(_ error: Error) {
        // Log the error
        logError(error)
        
        // Handle different types of errors
        if let fileError = error as? FileError {
            handleFileError(fileError)
        } else if let networkError = error as? NetworkError {
            handleNetworkError(networkError)
        } else if let validationError = error as? ValidationError {
            handleValidationError(validationError)
        } else {
            print("Unhandled error: \(error)")
        }
    }
    
    private func handleFileError(_ error: FileError) {
        switch error {
        case .notFound(let fileName):
            print("File not found: \(fileName)")
            // Could trigger a UI alert or recovery action
            
        case .noPermission(let fileName):
            print("Permission denied for file: \(fileName)")
            // Could prompt for elevated permissions
            
        case .diskFull(let free, let required):
            print("Disk full. Need \(required) bytes, but only \(free) available.")
            // Could trigger cleanup suggestions
            
        case .corruptData(let fileName):
            print("Corrupt data in file: \(fileName)")
            // Could attempt auto-repair or restoration
        }
        
        if error.isRecoverable {
            print("This error is recoverable. Suggested action: \(error.suggestedAction)")
        } else {
            print("This error is not recoverable. Suggested action: \(error.suggestedAction)")
        }
    }
    
    private func handleNetworkError(_ error: NetworkError) {
        // Network-specific error handling
    }
    
    private func handleValidationError(_ error: ValidationError) {
        // Validation-specific error handling
    }
    
    private func logError(_ error: Error) {
        // Log to file, analytics service, etc.
        print("ERROR LOG: \(Date()) - \(error)")
    }
}
```

### Using the Error Handler

```swift
let errorHandler = ErrorHandler()

do {
    try fileManager.readFile(at: "nonexistent.txt")
} catch {
    errorHandler.handle(error)
}
```

## Combining Multiple Error Types with Result Type

Swift's `Result` type pairs perfectly with error protocols to handle success and failure cases:

```swift
func fetchUserData(id: String) -> Result<User, NetworkError> {
    // Simulate a network request
    guard isNetworkAvailable() else {
        return .failure(.noConnection)
    }
    
    // Simulate server response
    let statusCode = simulateServerResponse()
    
    if statusCode == 200 {
        // Successfully fetched user
        let user = User(id: id, name: "John Doe", email: "john@example.com")
        return .success(user)
    } else if statusCode == 404 {
        return .failure(.serverError(statusCode: 404))
    } else {
        return .failure(.serverError(statusCode: statusCode))
    }
}

// Helper functions for simulation
func isNetworkAvailable() -> Bool {
    return true
}

func simulateServerResponse() -> Int {
    return 200
}

struct User {
    let id: String
    let name: String
    let email: String
}

// Using the Result type
let userResult = fetchUserData(id: "user123")

switch userResult {
case .success(let user):
    print("Fetched user successfully: \(user.name)")
case .failure(let error):
    switch error {
    case .noConnection:
        print("Error: No network connection available")
    case .serverError(let code):
        print("Error: Server returned status code \(code)")
    case .timeout:
        print("Error: Connection timed out")
    }
}
```

## Summary

Swift's error protocols provide a robust foundation for handling errors in your applications:

1. The `Error` protocol is the basic building block for all Swift error types.
2. Custom error types should be structured to provide meaningful information about what went wrong.
3. The `LocalizedError` protocol allows you to provide user-friendly error messages.
4. Error handling can be tailored to provide detailed recovery suggestions and context.
5. `Result` type offers a clean way to handle functions that can either succeed or fail.

By leveraging Swift's error protocols effectively, you can create more resilient applications that gracefully handle exceptional conditions and provide clear feedback to users.

## Exercises

To reinforce your understanding of Swift error protocols, try these exercises:

1. Create a custom error type for a banking application that handles errors like `insufficientFunds`, `accountLocked`, and `dailyLimitExceeded`.

2. Extend your custom error type to conform to `LocalizedError` and provide helpful error messages for each case.

3. Implement a function that transfers money between accounts and throws appropriate errors when conditions aren't met.

4. Create an error-handling middleware that logs errors, displays user-friendly messages, and suggests recovery actions.

5. Refactor a callback-based API to use Swift's `Result` type for cleaner error handling.

## Additional Resources

- [Swift Documentation on Error Handling](https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html)
- [Apple's Swift Programming Language Guide - Error Handling](https://developer.apple.com/documentation/swift/swift_standard_library/error_handling)
- [WWDC Session: Modern Swift Error Handling](https://developer.apple.com/videos/play/wwdc2020/10164/)

By mastering Swift's error protocols, you'll be able to write more resilient code that handles errors gracefully and provides a better user experience.