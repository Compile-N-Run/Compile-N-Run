---
title: Swift Result Type
description: Learn how to use Swift's Result type for elegant error handling in asynchronous operations and functions that can succeed or fail

---

# Swift Result Type

## Introduction

When writing Swift applications, we often work with operations that can either succeed or fail. Traditional error handling with `do-catch` blocks works well for synchronous code, but can become verbose and difficult to manage in complex scenarios, especially with asynchronous operations.

Enter the `Result` type - a powerful addition introduced in Swift 5 that elegantly handles success or failure scenarios using Swift's enum type system. The `Result` type encapsulates either a success value or an error, making your code more expressive and easier to work with.

## What is the Result Type?

The `Result` type is a generic enum with two cases:
- `.success(Success)`: Represents a successful outcome with an associated value
- `.failure(Failure)`: Represents a failure with an associated error

Here's the basic structure of the `Result` type:

```swift
enum Result<Success, Failure: Error> {
    case success(Success)
    case failure(Failure)
}
```

Where:
- `Success` is a generic type representing the data returned on success
- `Failure` is a generic type conforming to `Error` returned on failure

## Basic Usage of Result Type

Let's start with a simple example to see the `Result` type in action:

```swift
// Define a custom error type
enum NetworkError: Error {
    case invalidURL
    case noData
    case decodingError
}

// A function that returns a Result type
func fetchUserName(id: Int) -> Result<String, NetworkError> {
    // Simulate a network request
    if id < 0 {
        // Return failure for invalid IDs
        return .failure(.invalidURL)
    } else {
        // Return success with a username
        return .success("User\(id)")
    }
}

// Using the function
let result = fetchUserName(id: 123)

// Handling the result
switch result {
case .success(let userName):
    print("Successfully fetched user: \(userName)")
case .failure(let error):
    print("Failed to fetch user: \(error)")
}
```

Output:
```
Successfully fetched user: User123
```

## Working with Result Values

The `Result` type provides several useful methods to work with its values:

### 1. Getting Values Using Methods

You can extract values from a `Result` using various methods:

```swift
let successResult = Result<Int, Error>.success(42)
let failureResult = Result<Int, Error>.failure(NetworkError.noData)

// Get the success value or a default value
let successValue = successResult.success ?? 0 // 42
let failureValue = failureResult.success ?? 0 // 0

// Try getting the success value
do {
    let value = try successResult.get() // 42
    print("The value is: \(value)")
} catch {
    print("Error: \(error)")
}

// This would throw an error
do {
    let value = try failureResult.get() // Throws NetworkError.noData
    print("The value is: \(value)")
} catch {
    print("Error occurred: \(error)")
}
```

### 2. Transforming Results

`Result` provides functional programming methods like `map`, `flatMap`, and more:

```swift
// Transform a success value
let doubledResult = successResult.map { $0 * 2 }
// Result.success(84)

// Transform a failure value
let mappedError = failureResult.mapError { _ in NetworkError.decodingError }
// Result.failure(NetworkError.decodingError)

// Conditional mapping with flatMap
let stringResult = successResult.flatMap { value -> Result<String, Error> in
    if value > 0 {
        return .success("Positive: \(value)")
    } else {
        return .failure(NetworkError.invalidURL)
    }
}
// Result.success("Positive: 42")
```

## Practical Examples

Let's explore some real-world applications of the `Result` type:

### Example 1: Network Requests

The `Result` type is perfect for handling network operations:

```swift
// Define a User struct
struct User: Decodable {
    let id: Int
    let name: String
}

// Function to fetch a user from an API
func fetchUser(id: Int, completion: @escaping (Result<User, NetworkError>) -> Void) {
    // In a real app, this would be an actual network request
    // For example purposes, we'll simulate success/failure
    
    // Simulate network delay
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        if id > 0 {
            // Successful response
            let user = User(id: id, name: "User \(id)")
            completion(.success(user))
        } else {
            // Error response
            completion(.failure(.invalidURL))
        }
    }
}

// Usage
fetchUser(id: 42) { result in
    switch result {
    case .success(let user):
        print("Fetched user: \(user.name) with ID: \(user.id)")
    case .failure(let error):
        print("Failed to fetch user: \(error)")
    }
}
```

### Example 2: Chaining Operations with Result

`Result` is great for chaining multiple operations that can fail:

```swift
// Define operations that return Result
func fetchUserData(userId: Int) -> Result<Data, NetworkError> {
    // Simulate fetching user data
    if userId > 0 {
        let data = "User data for ID: \(userId)".data(using: .utf8)!
        return .success(data)
    } else {
        return .failure(.invalidURL)
    }
}

func parseUser(data: Data) -> Result<User, NetworkError> {
    // Simulate parsing data into a User object
    do {
        // In a real app, you'd use JSONDecoder here
        // For example purposes:
        let name = String(data: data, encoding: .utf8) ?? ""
        let user = User(id: 1, name: name)
        return .success(user)
    } catch {
        return .failure(.decodingError)
    }
}

// Chain operations
func getUserInfo(userId: Int) -> Result<User, NetworkError> {
    return fetchUserData(userId: userId).flatMap { userData in
        return parseUser(data: userData)
    }
}

// Usage
let userResult = getUserInfo(userId: 123)

switch userResult {
case .success(let user):
    print("Got user: \(user.name)")
case .failure(let error):
    print("Error: \(error)")
}
```

### Example 3: Converting from a throwing function

Swift provides an initializer that converts from a throwing function:

```swift
func fetchDataFromDatabase(id: String) throws -> [String: Any] {
    if id.isEmpty {
        throw NetworkError.invalidURL
    }
    return ["name": "Alice", "age": 30]
}

// Convert to Result
let databaseResult = Result { try fetchDataFromDatabase(id: "user123") }

// Using the result
switch databaseResult {
case .success(let data):
    print("Data retrieved: \(data)")
case .failure(let error):
    print("Database error: \(error)")
}
```

## Best Practices for Using Result Type

1. **Use Custom Error Types**: Create specific error enums for your domains to make error handling more precise.

2. **Return Results for Fallible Operations**: When writing functions that can fail, consider returning a `Result` rather than using a throwing function.

3. **Combine with Async/Await**: In Swift 5.5+, combine `Result` with async/await for clean asynchronous error handling:

```swift
func fetchUserAsync(id: Int) async -> Result<User, NetworkError> {
    // Simulate network request
    if id > 0 {
        return .success(User(id: id, name: "User \(id)"))
    } else {
        return .failure(.invalidURL)
    }
}

// Usage with async/await
Task {
    let userResult = await fetchUserAsync(id: 42)
    
    switch userResult {
    case .success(let user):
        print("Async fetched user: \(user.name)")
    case .failure(let error):
        print("Async error: \(error)")
    }
}
```

4. **Use Functional Methods**: Take advantage of `map`, `flatMap`, and other functional methods to transform results without unwrapping.

## When to Use Result vs. Throws

Both `Result` type and `throws` serve similar purposes, but they're best used in different scenarios:

| Feature | Result | throws |
|---------|--------|--------|
| Return multiple values | Can return success value or error | Returns a single value or throws |
| Storage | Can be stored in properties | Cannot store "throwness" |
| Async operations | Excellent for callbacks | Better with async/await |
| Syntax complexity | More verbose | More concise |

Use `Result` when:
- Working with asynchronous code with completion handlers
- Need to store the success/failure in a property
- Want to apply functional transformations
- Building APIs that may be used from Objective-C

Use `throws` when:
- Working with synchronous code
- Using async/await pattern
- Preferring more concise syntax
- Chaining multiple operations that can fail

## Summary

Swift's `Result` type provides an elegant way to handle operations that can succeed or fail. It encapsulates either a success value or an error, making your code more expressive and easier to work with, especially in asynchronous contexts.

Key benefits of the `Result` type include:
- Type safety for both success and failure cases
- Clear separation of success and failure paths
- Ability to store and pass around success/failure states
- Functional programming capabilities with methods like `map` and `flatMap`
- Seamless integration with Swift's error handling system

As you build more complex applications, the `Result` type will become an indispensable tool in your Swift programming toolkit, especially when dealing with network requests, parsing operations, and other fallible tasks.

## Additional Resources

- [Swift Documentation on Result Type](https://developer.apple.com/documentation/swift/result)
- [Swift Evolution Proposal (SE-0235)](https://github.com/apple/swift-evolution/blob/master/proposals/0235-add-result.md)

## Exercises

1. Create a function that reads a file and returns a `Result<String, FileError>` where `FileError` is a custom error type.

2. Implement a cache system that returns a `Result<CachedItem, CacheError>` when retrieving items.

3. Write a function that chains multiple network requests using `Result` and its functional methods.

4. Convert an existing asynchronous API that uses completion handlers to use the `Result` type.