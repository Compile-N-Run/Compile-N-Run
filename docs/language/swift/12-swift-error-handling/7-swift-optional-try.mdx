---
title: Swift Optional Try
description: Learn how to handle errors more gracefully using Swift's optional try statements. This guide covers try?, try!, and when to use each approach in your Swift applications.

---

# Swift Optional Try

Error handling is a crucial part of writing robust Swift applications. While the standard `do-catch` approach gives you full control over error handling, Swift also provides simplified approaches with **optional try** statements. These alternatives - `try?` and `try!` - allow you to handle errors in more compact and convenient ways, especially useful when complete error handling isn't necessary.

## Understanding Optional Try

In Swift, there are three ways to handle errors when calling throwing functions:

1. Standard `try` with `do-catch` blocks
2. Optional try with `try?`
3. Forced try with `try!`

Let's explore the optional variants and understand when to use each approach.

## The try? Operator

The `try?` operator attempts to execute a throwing function, but instead of propagating the error, it converts the result into an optional.

- If the function succeeds, you get the return value wrapped in an optional
- If the function throws an error, you get `nil`

### Basic Syntax

```swift
let result = try? throwingFunction()
```

### Detailed Example

Let's create a simple example with a function that might throw an error:

```swift
enum DataError: Error {
    case invalidFormat
    case corrupted
    case notFound
}

func fetchData(forId id: Int) throws -> String {
    // Simulate different outcomes based on ID
    switch id {
    case 1:
        return "Success: Data for ID 1"
    case 2:
        throw DataError.notFound
    case 3:
        throw DataError.corrupted
    default:
        throw DataError.invalidFormat
    }
}

// Using try? to handle errors
let data1 = try? fetchData(forId: 1)
let data2 = try? fetchData(forId: 2)
let data3 = try? fetchData(forId: 3)

print("Data 1: \(data1 ?? "No data")")  // Output: Data 1: Success: Data for ID 1
print("Data 2: \(data2 ?? "No data")")  // Output: Data 2: No data
print("Data 3: \(data3 ?? "No data")")  // Output: Data 3: No data
```

As you can see, `try?` converts the successful call to an optional containing the value, and converts errors to `nil`. This is particularly useful when you don't care about the specific error, just whether the operation succeeded or failed.

### Using try? with Optional Binding

You can combine `try?` with optional binding for clean, concise code:

```swift
if let data = try? fetchData(forId: 1) {
    print("Successfully retrieved: \(data)")
} else {
    print("Failed to retrieve data")
}

// Output: Successfully retrieved: Success: Data for ID 1
```

## The try! Operator

The `try!` operator is a forceful approach that attempts to execute a throwing function but with no error handling. Use it only when you're absolutely certain the function won't throw an error.

- If the function succeeds, you get the return value directly (not wrapped in an optional)
- If the function throws an error, your application crashes with a runtime error

### Basic Syntax

```swift
let result = try! throwingFunction()
```

### Detailed Example

```swift
// Only use try! when you're 100% sure it won't throw
let definitelyWillSucceed = try! fetchData(forId: 1)
print("The data is: \(definitelyWillSucceed)")  // Output: The data is: Success: Data for ID 1

// This would cause a runtime crash
// let willCrash = try! fetchData(forId: 2)  // Runtime error: Fatal error: 'try!' expression unexpectedly raised an error
```

## When to Use Each Approach

Here's a guide for choosing the right error handling approach:

| Approach | When to Use |
|----------|-------------|
| `try` with `do-catch` | When you need to handle specific error cases differently |
| `try?` | When you just need to know if the operation succeeded or failed |
| `try!` | Only when you're absolutely certain the operation won't fail |

## Real-World Applications

### Example 1: Loading and Processing a File

```swift
func processTextFile(at path: String) throws -> [String] {
    let content = try String(contentsOfFile: path)
    return content.components(separatedBy: .newlines)
}

// Using try? for file operations where missing files are expected
func countLinesInFile(at path: String) -> Int {
    guard let lines = try? processTextFile(at: path) else {
        print("Could not read file at \(path)")
        return 0
    }
    return lines.count
}

let userGuide = countLinesInFile(at: "/path/to/userguide.txt")
print("User guide has \(userGuide) lines")
```

### Example 2: JSON Parsing

```swift
struct User: Decodable {
    let id: Int
    let name: String
    let email: String
}

func parseUser(from jsonString: String) throws -> User {
    guard let data = jsonString.data(using: .utf8) else {
        throw DataError.invalidFormat
    }
    
    return try JSONDecoder().decode(User.self, from: data)
}

// Valid JSON string
let validJSON = """
{
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com"
}
"""

// Invalid JSON string
let invalidJSON = """
{
    "id": "not a number",
    "name": "John Doe",
    "email": "john@example.com"
}
"""

// Using try? for parsing JSON from potentially unverified sources
if let user = try? parseUser(from: validJSON) {
    print("User successfully parsed: \(user.name)")
} else {
    print("Failed to parse user")
}

// Alternative syntax using nil coalescing
let user = (try? parseUser(from: validJSON)) ?? User(id: 0, name: "Unknown", email: "")
print("User name: \(user.name)")
```

### Example 3: Chaining Optional Try Operations

```swift
func fetchUserData(userId: Int) throws -> Data {
    // Simulate fetching user data
    if userId > 0 {
        return Data("User data".utf8)
    } else {
        throw DataError.notFound
    }
}

func parseUserProfile(data: Data) throws -> User {
    // Simulate parsing
    if data.count > 0 {
        return User(id: 1, name: "Jane Smith", email: "jane@example.com")
    } else {
        throw DataError.invalidFormat
    }
}

// Chain multiple operations with try?
func getUserProfile(userId: Int) -> User? {
    guard let userData = try? fetchUserData(userId: userId),
          let user = try? parseUserProfile(data: userData) else {
        return nil
    }
    return user
}

if let profile = getUserProfile(userId: 1) {
    print("Found profile for: \(profile.name)")
} else {
    print("Could not retrieve profile")
}
```

## Summary

Swift's optional try operators provide convenient alternatives to full `do-catch` error handling:

- Use `try?` when you only need to know if an operation succeeded or failed, and don't need error details
- Use `try!` very sparingly, and only when you can guarantee the operation won't throw an error
- Both approaches simplify your code when extensive error handling isn't needed
- For robust applications, consider whether losing error details is acceptable in each situation

Remember that `try?` converts errors to `nil`, which means you lose information about what went wrong. In production code, you'll often want to use `do-catch` for critical operations where error details matter.

## Exercises

1. Create a function that reads a JSON file and parses it using `try?`. Handle the case when the file doesn't exist or contains invalid JSON.
2. Write a program that attempts to resize several images, using `try?` to handle any errors, and report how many images were successfully processed.
3. Implement a function that uses `try?` to attempt multiple strategies for retrieving data, returning the first successful result.

## Additional Resources

- [Swift Documentation on Error Handling](https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html)
- [Swift Evolution Proposal for try?](https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md)
- [WWDC Session on Swift Error Handling](https://developer.apple.com/videos/play/wwdc2020/10648/)

Remember, error handling is about balancing safety with convenience. Choose the approach that best fits your specific use case!