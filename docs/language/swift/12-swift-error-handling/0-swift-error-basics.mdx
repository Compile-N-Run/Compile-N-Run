---
title: Swift Error Basics
description: Learn the fundamentals of Swift error handling - how to define, throw, catch, and handle errors in your Swift applications.

---

# Swift Error Basics

Error handling is a critical skill for any programmer. When you're building real-world applications, things don't always go as planned - files might be missing, network requests could fail, or user input might be invalid. Swift provides a robust error handling system that helps you manage these situations gracefully.

## Introduction to Error Handling in Swift

Swift's error handling model uses throwing, catching, propagating, and manipulating recoverable errors at runtime. Unlike some other languages, Swift doesn't use exceptions but instead treats errors as values that conform to the `Error` protocol.

This approach makes error handling in Swift:
- Type-safe
- Explicit in function signatures
- Manageable through normal control flow

Let's dive into the basics of Swift error handling!

## Defining Errors in Swift

The first step in error handling is defining what can go wrong. In Swift, we define errors by creating enumerations that conform to the `Error` protocol.

```swift
enum NetworkError: Error {
    case invalidURL
    case noConnection
    case serverError(statusCode: Int)
    case unknown
}
```

The example above defines a `NetworkError` type with four possible error cases, including one that carries associated values (the status code for a server error).

## Throwing Errors

Once we've defined our error types, we need a way to signal when errors occur. Swift uses the `throw` keyword to raise an error within a function or method.

Functions that can throw errors must be marked with the `throws` keyword in their declaration:

```swift
func fetchData(from urlString: String) throws -> Data {
    guard let url = URL(string: urlString) else {
        throw NetworkError.invalidURL
    }
    
    // Simulate network conditions
    let networkAvailable = Bool.random()
    if !networkAvailable {
        throw NetworkError.noConnection
    }
    
    // If everything is good, return some data
    return Data()
}
```

## Handling Thrown Errors with do-catch

When calling functions that can throw errors, you need to handle potential errors using `do-catch` statements:

```swift
do {
    let data = try fetchData(from: "https://example.com/api")
    print("Successfully fetched \(data.count) bytes")
} catch NetworkError.invalidURL {
    print("The URL provided was invalid")
} catch NetworkError.noConnection {
    print("Network connection is unavailable")
} catch NetworkError.serverError(let statusCode) {
    print("Server returned error with status code: \(statusCode)")
} catch {
    print("An unknown error occurred: \(error)")
}
```

In this pattern:
- The `do` block contains code that might throw an error
- The `try` keyword precedes any function call that might throw
- Multiple `catch` clauses handle different error cases
- The final `catch` without a specific error type catches any other errors and provides the error as a constant named `error`

## Converting Errors to Optional Values

Sometimes, you might want to handle errors by simply converting them to optional values. Swift provides the `try?` operator for this purpose:

```swift
let data = try? fetchData(from: "https://example.com/api")

// data will be nil if an error was thrown
// Otherwise, it will contain the returned value
if let data = data {
    print("Successfully fetched \(data.count) bytes")
} else {
    print("Failed to fetch data")
}
```

This approach simplifies error handling when you don't need to differentiate between error cases, but just need to know if the operation succeeded or failed.

## Disabling Error Propagation

In rare situations where you're absolutely certain a throwing function won't throw an error in practice, you can use `try!` to disable error propagation:

```swift
// Only use when you are 100% sure this won't throw!
let data = try! fetchData(from: "https://definitelyvalid.com/api")
```

⚠️ **Warning**: Using `try!` will cause a runtime crash if an error is actually thrown. Use this approach very sparingly and only when you have complete certainty that an error cannot occur.

## Practical Example: File Operations

Let's look at a practical example involving file operations, which are common sources of errors in real applications:

```swift
enum FileError: Error {
    case fileNotFound
    case readPermissionDenied
    case invalidFormat
}

func readConfiguration(from filename: String) throws -> [String: Any] {
    // Check if file exists
    guard FileManager.default.fileExists(atPath: filename) else {
        throw FileError.fileNotFound
    }
    
    // Check read permissions (simplified for example)
    let isReadable = true // In reality, check actual permissions
    if !isReadable {
        throw FileError.readPermissionDenied
    }
    
    // Try to parse the file as JSON
    guard let data = FileManager.default.contents(atPath: filename),
          let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
        throw FileError.invalidFormat
    }
    
    return json
}

// Using the function
func loadAppConfiguration() {
    do {
        let config = try readConfiguration(from: "/path/to/config.json")
        print("Loaded configuration with \(config.count) settings")
        
        // Use the configuration...
    } catch FileError.fileNotFound {
        print("Configuration file not found, using defaults")
        // Use default configuration...
    } catch FileError.readPermissionDenied {
        print("Cannot read configuration file due to permission issues")
        // Handle permission error...
    } catch FileError.invalidFormat {
        print("Configuration file is not in the correct format")
        // Handle format error...
    } catch {
        print("Unexpected error: \(error)")
        // Handle unknown error...
    }
}
```

This example demonstrates a complete error handling workflow:
1. Define potential errors with an enum
2. Create a function that throws those errors when appropriate
3. Call the function within a do-catch block to handle different error cases
4. Provide specific handling for each error type

## Error Propagation in Functions

A key aspect of Swift error handling is that errors automatically propagate up the call stack until they're handled. Functions that call throwing functions must either handle the errors or be marked as throwing themselves:

```swift
func setupApplication() throws {
    // This function propagates any errors from readConfiguration
    let config = try readConfiguration(from: "/path/to/config.json")
    try initializeDatabase(with: config)
    try connectToServices(with: config)
}

// Later in the app:
do {
    try setupApplication()
    print("Application initialized successfully")
} catch {
    print("Failed to initialize application: \(error)")
    // Handle startup failure
}
```

In this example, `setupApplication()` doesn't handle errors itself but propagates them to the caller, which then handles them with a do-catch block.

## Summary

Swift's error handling system provides a clean, type-safe way to deal with errors in your code. Let's recap the key concepts:

1. Define errors using enums that conform to the `Error` protocol
2. Mark functions that can throw errors with the `throws` keyword
3. Use the `throw` keyword to raise errors when they occur
4. Handle errors using `do-catch` blocks with the `try` keyword
5. Convert errors to optional values with `try?` when you don't need error details
6. Use `try!` (very sparingly) when you're certain errors won't occur
7. Propagate errors up the call stack when appropriate

Understanding these fundamentals of error handling will help you create more robust and reliable Swift applications that can gracefully recover from unexpected situations.

## Additional Resources and Exercises

### Resources
- [Swift Documentation: Error Handling](https://docs.swift.org/swift-book/LanguageGuide/ErrorHandling.html)
- [Apple Developer: Handling Errors](https://developer.apple.com/documentation/swift/handling_errors)

### Exercises

1. **Error Definition**: Create an enum called `ValidationError` that conforms to `Error` and includes cases for `emptyString`, `tooShort`, `tooLong`, and `invalidCharacters`.

2. **Password Validator**: Write a function that validates a password and throws appropriate errors from your `ValidationError` enum. The password should be at least 8 characters, contain no spaces, and be no longer than 20 characters.

3. **Bank Account**: Create a `BankAccount` class with a balance and a method to withdraw money. The withdraw method should throw appropriate errors when the withdrawal amount is negative or exceeds the current balance.

4. **Error Chaining**: Write a series of functions that call each other and propagate errors up the chain, with the topmost function handling all errors in a do-catch block.

5. **Optional Conversion**: Refactor one of your error-throwing functions to use `try?` and handle the result as an optional value instead of using do-catch.

By practicing these exercises, you'll build confidence in Swift's error handling system and be better prepared to implement error handling in your own applications.