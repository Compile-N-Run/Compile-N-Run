---
title: Swift Assert Precondition
description: Learn how to use assertions and preconditions in Swift to catch programming errors early and ensure your code operates with valid data and state

---

# Swift Assert Precondition

## Introduction

When writing Swift applications, ensuring your code operates on valid data and in the correct state is crucial for creating robust software. Swift provides powerful debugging tools called **assertions** and **preconditions** that help you catch programming errors early in the development process.

These tools act as safeguards in your code by verifying that certain conditions are met before proceeding with execution. If a condition fails, program execution stops immediately, allowing you to identify and fix the issue quickly rather than letting invalid data propagate through your application, potentially causing more complex bugs.

In this tutorial, we'll explore how to use Swift's assertions and preconditions effectively, understand when to use each one, and see how they differ from traditional error handling mechanisms.

## Understanding Assertions and Preconditions

### What Are Assertions?

Assertions are debugging tools that verify conditions during development. They're designed to catch programming errors and incorrect assumptions in your code.

Key characteristics of assertions:
- Only active in debug builds
- Disabled in production (-O or -Ounchecked optimization)
- No performance impact in production code
- Used for internal sanity checks

### What Are Preconditions?

Preconditions are similar to assertions but remain active in production builds by default. They ensure critical requirements are met before executing code.

Key characteristics of preconditions:
- Active in both debug and production builds (unless using -Ounchecked)
- Can impact production performance (though minimally)
- Used when failure would lead to undefined behavior or security issues

## Basic Syntax and Usage

### Assert

The basic syntax for an assertion is:

```swift
assert(condition, message)
```

Where:
- `condition` is a Boolean expression that should be true
- `message` is an optional string shown if the condition fails

Let's see a simple example:

```swift
func divide(_ a: Int, by b: Int) -> Int {
    // Check that we're not dividing by zero
    assert(b != 0, "Division by zero is not allowed")
    return a / b
}

// This works fine
let result = divide(10, by: 2)
print(result) // Output: 5

// This triggers the assertion
// let crashResult = divide(10, by: 0)
// Program will terminate with: "Assertion failed: Division by zero is not allowed"
```

### AssertionFailure

Sometimes you want to trigger an assertion failure directly without checking a condition:

```swift
func processUserRole(_ role: String) {
    switch role {
    case "admin":
        print("Processing admin privileges")
    case "user":
        print("Processing standard user")
    case "guest":
        print("Processing guest restrictions")
    default:
        // This code should never be reached if we handle all roles properly
        assertionFailure("Unexpected user role: \(role)")
    }
}

processUserRole("admin") // Works fine
// processUserRole("hacker") // Triggers assertion failure
```

### Precondition

The syntax for preconditions is similar to assertions:

```swift
precondition(condition, message)
```

Here's an example of using precondition:

```swift
func fetchItem(at index: Int) -> String {
    let items = ["Apple", "Banana", "Orange"]
    
    // Ensure index is within bounds
    precondition(index >= 0 && index < items.count, "Index out of bounds")
    
    return items[index]
}

print(fetchItem(at: 1)) // Output: Banana

// This would crash even in production:
// print(fetchItem(at: 5)) // Fatal error: Index out of bounds
```

### PreconditionFailure

Similar to `assertionFailure`, there's also a `preconditionFailure`:

```swift
func getElementSymbol(atomicNumber: Int) -> String {
    switch atomicNumber {
    case 1: return "H"
    case 2: return "He"
    case 3: return "Li"
    // More cases...
    default:
        if atomicNumber <= 0 {
            preconditionFailure("Atomic number must be positive")
        } else if atomicNumber > 118 {
            preconditionFailure("Unknown element with atomic number \(atomicNumber)")
        } else {
            return "Unknown"
        }
    }
}
```

## When to Use Assert vs. Precondition

Choosing between assertions and preconditions depends on how critical the check is:

| Use Assert When | Use Precondition When |
| --- | --- |
| Verifying internal implementation details | Validating API boundaries/inputs |
| Checking conditions that shouldn't fail if code is correct | Checking conditions necessary for program safety |
| Debugging assumptions | Protecting against undefined behavior |
| Validating development-only checks | Enforcing critical business rules |

## Conditional Compilation

Sometimes you may want to include certain assertions only during development:

```swift
#if DEBUG
assert(expensiveCheckThatShouldOnlyRunDuringDebug())
#endif

// Always runs in debug, only runs in production if it's critical
precondition(criticalCheckForBothDebugAndProduction())
```

## Advanced Usage with Custom Assertions

For cleaner code, you can create your own assertion helpers:

```swift
func assertValidIndex(_ index: Int, for array: [Any], file: StaticString = #file, line: UInt = #line) {
    assert(index >= 0 && index < array.count, 
           "Index \(index) out of bounds for array of length \(array.count)", 
           file: file, 
           line: line)
}

let numbers = [1, 2, 3]
assertValidIndex(1, for: numbers) // No problem
// assertValidIndex(5, for: numbers) // Assertion failure
```

## Real-World Examples

### Example 1: Data Processing Function

```swift
func processUserData(_ data: [String: Any]) -> User {
    // Ensure required fields exist
    precondition(data["id"] != nil, "User data missing ID field")
    precondition(data["name"] != nil, "User data missing name field")
    
    // These should never be nil based on our preconditions
    let id = data["id"] as! Int
    let name = data["name"] as! String
    
    // Age is optional but must be valid if present
    if let age = data["age"] as? Int {
        assert(age >= 0, "User age cannot be negative")
    }
    
    return User(id: id, name: name, age: data["age"] as? Int)
}

// Valid data
let validData: [String: Any] = ["id": 1, "name": "John", "age": 25]
let user = processUserData(validData)
print("Created user: \(user.name)") // Output: Created user: John

// This would trigger a precondition failure:
// let invalidData: [String: Any] = ["id": 2]
// let invalidUser = processUserData(invalidData)
```

### Example 2: Graphics Application

```swift
struct Rectangle {
    var width: Double
    var height: Double
    
    init(width: Double, height: Double) {
        // Validate dimensions
        precondition(width > 0, "Rectangle width must be positive")
        precondition(height > 0, "Rectangle height must be positive")
        
        self.width = width
        self.height = height
    }
    
    func draw(at position: (x: Int, y: Int), on canvas: Canvas) {
        // Verify canvas position is valid
        assert(position.x >= 0 && position.x + Int(width) <= canvas.width,
               "Rectangle would extend beyond canvas width")
        assert(position.y >= 0 && position.y + Int(height) <= canvas.height,
               "Rectangle would extend beyond canvas height")
        
        // Draw implementation
        print("Drawing \(width)x\(height) rectangle at (\(position.x), \(position.y))")
    }
}

struct Canvas {
    let width: Int
    let height: Int
}

let canvas = Canvas(width: 100, height: 100)
let rect = Rectangle(width: 10, height: 20)
rect.draw(at: (x: 5, y: 5), on: canvas) // Output: Drawing 10.0x20.0 rectangle at (5, 5)

// This would trigger an assertion:
// rect.draw(at: (x: 95, y: 5), on: canvas)
```

## Differences from Try-Catch Error Handling

It's important to understand when to use assertions/preconditions versus traditional error handling:

| Assertions/Preconditions | Try-Catch Error Handling |
| --- | --- |
| For programming errors | For expected runtime errors |
| Indicate bugs in code | Handle anticipated failure cases |
| Fail immediately | Allow graceful recovery |
| Non-recoverable | Recoverable |
| Development-focused | User experience-focused |

Example of appropriate error handling vs. assertions:

```swift
// Good use of assertions - internal programming logic
func processPositiveNumber(_ number: Int) {
    precondition(number > 0, "Number must be positive")
    // Process the number...
}

// Good use of error handling - external input from user
func processUserInput(_ input: String) throws -> Int {
    guard let number = Int(input) else {
        throw InputError.notANumber
    }
    guard number > 0 else {
        throw InputError.notPositive
    }
    return number
}

enum InputError: Error {
    case notANumber
    case notPositive
}

// Usage example
do {
    let userInput = "42"
    let number = try processUserInput(userInput)
    processPositiveNumber(number)
} catch InputError.notANumber {
    print("Please enter a valid number")
} catch InputError.notPositive {
    print("Please enter a positive number")
} catch {
    print("Unknown error occurred")
}
```

## Performance Considerations

While assertions are completely removed in release builds, preconditions still get evaluated. However, the performance impact is typically minimal compared to the safety benefits they provide.

If you have a particularly expensive check that you only want in debug builds, consider using `assert()` or conditional compilation with `#if DEBUG`.

## Summary

Assertions and preconditions are powerful tools in Swift that help catch programming errors early:

- **Assertions (`assert`, `assertionFailure`)**: Use during development to verify your internal logic is sound. These are disabled in production builds.
- **Preconditions (`precondition`, `preconditionFailure`)**: Use for validating critical requirements that must be true even in production code.

Using these tools effectively will help you create more robust applications by catching errors early, leading to more reliable software. Remember that assertions and preconditions are meant for programmer errors, not for handling expected failure cases like network issues or invalid user input.

## Exercises

1. Write a function that uses an assertion to verify that an array is not empty before accessing its first element.

2. Create a `Stack` data structure with `push()` and `pop()` methods. Use preconditions to ensure that `pop()` is not called on an empty stack.

3. Write a function that processes a configuration dictionary. Use assertions to verify the presence of required keys during development.

4. Implement a function that uses indexed access on an array but uses preconditions to ensure the index is valid.

5. Create a custom assertion helper that checks if a string matches a specific pattern.

## Additional Resources

- [Swift Documentation on Assertions and Preconditions](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID335)
- [WWDC - Embrace Swift Type System](https://developer.apple.com/videos/play/wwdc2016/416/) (Includes tips on using assertions)
- [Swift Evolution Proposal: SE-0217](https://github.com/apple/swift-evolution/blob/master/proposals/0217-bangbang.md) (Discussions about assertion handling in Swift)
- [Swift by Sundell: Assertions in Swift](https://www.swiftbysundell.com/articles/assertions-in-swift/)