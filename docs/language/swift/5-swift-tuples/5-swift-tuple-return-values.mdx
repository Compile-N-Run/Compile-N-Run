---
title: Swift Tuple Return Values
description: Learn how to use tuples as return values in Swift functions to return multiple values from a single function call.

---

# Swift Tuple Return Values

## Introduction

In Swift, functions typically return a single value of a specific type. But what if you need to return multiple related values from a function? This is where tuple return values shine! A tuple in Swift can group multiple values of different types, making it perfect for returning multiple values from a single function.

Instead of using complex workarounds like output parameters or custom objects, Swift tuples provide an elegant, built-in solution to return multiple values from functions.

## Basic Tuple Return Values

Let's start with a simple example of a function that returns a tuple:

```swift
func getCoordinates() -> (Double, Double) {
    // Return latitude and longitude
    return (37.7749, -122.4194) // San Francisco coordinates
}

// Call the function
let location = getCoordinates()
print("Latitude: \(location.0), Longitude: \(location.1)")
```

**Output:**
```
Latitude: 37.7749, Longitude: -122.4194
```

In this example:
- The function `getCoordinates()` returns a tuple of two `Double` values.
- We access the tuple elements using index notation (`.0` and `.1`).

## Named Tuple Return Values

While returning a tuple with unnamed elements works, it's more readable and maintainable to use named elements:

```swift
func getCoordinates() -> (latitude: Double, longitude: Double) {
    return (latitude: 37.7749, longitude: -122.4194)
}

// Call the function
let location = getCoordinates()
print("Latitude: \(location.latitude), Longitude: \(location.longitude)")

// You can still use index notation if needed
print("Latitude: \(location.0), Longitude: \(location.1)")
```

**Output:**
```
Latitude: 37.7749, Longitude: -122.4194
Latitude: 37.7749, Longitude: -122.4194
```

Named tuple elements make your code more self-documenting and less prone to errors.

## Destructuring Tuple Return Values

Swift allows you to decompose or "destructure" the returned tuple into separate variables:

```swift
func getUserInfo() -> (name: String, age: Int, isPremium: Bool) {
    return (name: "John Doe", age: 30, isPremium: true)
}

// Destructure the returned tuple
let (name, age, status) = getUserInfo()
print("Name: \(name)")
print("Age: \(age)")
print("Premium Status: \(status)")
```

**Output:**
```
Name: John Doe
Age: 30
Premium Status: true
```

This makes your code cleaner by avoiding the dot notation when working with the returned values.

## Ignoring Specific Return Values

Sometimes you might only need some of the values from a returned tuple. Swift allows you to ignore specific values using an underscore (`_`):

```swift
func getMinMaxAvg(for numbers: [Int]) -> (min: Int, max: Int, avg: Double) {
    let min = numbers.min() ?? 0
    let max = numbers.max() ?? 0
    let sum = Double(numbers.reduce(0, +))
    let avg = sum / Double(numbers.count)
    
    return (min: min, max: max, avg: avg)
}

// Only interested in min and max, ignoring avg
let (minimum, maximum, _) = getMinMaxAvg(for: [10, 5, 8, 12, 3])
print("Minimum value: \(minimum)")
print("Maximum value: \(maximum)")

// Only interested in average
let (_, _, average) = getMinMaxAvg(for: [10, 5, 8, 12, 3])
print("Average value: \(average)")
```

**Output:**
```
Minimum value: 3
Maximum value: 12
Average value: 7.6
```

## Optional Tuple Return Values

Functions can also return optional tuples when the return value might not be available:

```swift
func divideWithRemainder(_ dividend: Int, by divisor: Int) -> (quotient: Int, remainder: Int)? {
    guard divisor != 0 else {
        return nil // Cannot divide by zero
    }
    
    return (quotient: dividend / divisor, remainder: dividend % divisor)
}

// Test the function with valid inputs
if let result = divideWithRemainder(10, by: 3) {
    print("Quotient: \(result.quotient), Remainder: \(result.remainder)")
}

// Test the function with invalid input (division by zero)
if let result = divideWithRemainder(10, by: 0) {
    print("Quotient: \(result.quotient), Remainder: \(result.remainder)")
} else {
    print("Cannot perform division")
}
```

**Output:**
```
Quotient: 3, Remainder: 1
Cannot perform division
```

## Practical Applications

### 1. Data Validation

Tuples are great for returning validation results along with error messages:

```swift
func validatePassword(_ password: String) -> (isValid: Bool, message: String) {
    if password.count < 8 {
        return (isValid: false, message: "Password must be at least 8 characters")
    }
    
    if !password.contains(where: { $0.isNumber }) {
        return (isValid: false, message: "Password must contain at least one number")
    }
    
    return (isValid: true, message: "Password is valid")
}

// Validate a weak password
let validationResult = validatePassword("abc123")
if validationResult.isValid {
    print("✅ Success: \(validationResult.message)")
} else {
    print("❌ Error: \(validationResult.message)")
}
```

**Output:**
```
❌ Error: Password must be at least 8 characters
```

### 2. Data Processing with Success/Failure Information

Use tuples to return both processed data and status information:

```swift
func processUserData(_ data: [String: Any]) -> (success: Bool, user: [String: Any], errors: [String]) {
    var processedData = [String: Any]()
    var errors = [String]()
    
    // Extract and validate name
    if let name = data["name"] as? String {
        processedData["name"] = name
    } else {
        errors.append("Missing or invalid name")
    }
    
    // Extract and validate age
    if let age = data["age"] as? Int {
        if age >= 18 {
            processedData["age"] = age
        } else {
            errors.append("User must be at least 18 years old")
        }
    } else {
        errors.append("Missing or invalid age")
    }
    
    return (success: errors.isEmpty, user: processedData, errors: errors)
}

// Test with invalid data
let inputData = ["name": "Alex", "age": 16]
let result = processUserData(inputData)

if result.success {
    print("User data processed successfully: \(result.user)")
} else {
    print("Failed to process user data:")
    for error in result.errors {
        print("- \(error)")
    }
}
```

**Output:**
```
Failed to process user data:
- User must be at least 18 years old
```

### 3. Parsing Operations

Tuples are useful when parsing data that could potentially fail:

```swift
func parseCoordinates(from string: String) -> (success: Bool, latitude: Double?, longitude: Double?) {
    // Expected format: "lat:37.7749,long:-122.4194"
    let components = string.components(separatedBy: ",")
    
    guard components.count == 2 else {
        return (success: false, latitude: nil, longitude: nil)
    }
    
    let latComponents = components[0].components(separatedBy: ":")
    let longComponents = components[1].components(separatedBy: ":")
    
    guard latComponents.count == 2,
          longComponents.count == 2,
          latComponents[0] == "lat",
          longComponents[0] == "long",
          let lat = Double(latComponents[1]),
          let long = Double(longComponents[1]) else {
        return (success: false, latitude: nil, longitude: nil)
    }
    
    return (success: true, latitude: lat, longitude: long)
}

// Test with valid data
let validCoords = "lat:37.7749,long:-122.4194"
let parseResult1 = parseCoordinates(from: validCoords)

if parseResult1.success {
    print("Successfully parsed coordinates: \(parseResult1.latitude!), \(parseResult1.longitude!)")
} else {
    print("Failed to parse coordinates")
}

// Test with invalid data
let invalidCoords = "latitude:37.7749,longitude:-122.4194"
let parseResult2 = parseCoordinates(from: invalidCoords)

if parseResult2.success {
    print("Successfully parsed coordinates: \(parseResult2.latitude!), \(parseResult2.longitude!)")
} else {
    print("Failed to parse coordinates")
}
```

**Output:**
```
Successfully parsed coordinates: 37.7749, -122.4194
Failed to parse coordinates
```

## Summary

Tuple return values in Swift provide an elegant way to return multiple values from functions without creating custom types. Key benefits include:

- Returning multiple values of different types from a single function
- Using named tuple elements to improve code readability
- Destructuring tuples into individual variables for cleaner code
- Ignoring specific values when only some return values are needed
- Handling optional returns when operations might fail

By mastering tuple return values, you can write more concise, readable, and flexible Swift code that effectively communicates multiple pieces of information from functions.

## Exercises

1. Write a function called `minMaxSum` that takes an array of integers and returns a tuple containing the minimum value, maximum value, and sum of all values.

2. Create a function called `parseTimeString` that converts a string like "14:30:45" into a tuple of hours, minutes, and seconds as integers. Return an optional tuple that is `nil` if the string format is invalid.

3. Implement a function called `calculateStatistics` that takes an array of exam scores (integers) and returns a tuple with the average score, highest score, lowest score, and a boolean indicating whether all scores passed (>=60).

## Additional Resources

- [Swift Documentation on Tuples](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID329)
- [Function Types in Swift](https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID174)
- [Optional Types in Swift](https://docs.swift.org/swift-book/LanguageGuide/TheBasics.html#ID330)