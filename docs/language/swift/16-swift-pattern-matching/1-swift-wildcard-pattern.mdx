---
title: Swift Wildcard Pattern
description: Learn how to use the wildcard pattern in Swift pattern matching to ignore specific values during matching operations.

---

# Swift Wildcard Pattern

Pattern matching in Swift provides powerful ways to match and extract values. Among these patterns, the wildcard pattern is perhaps the simplest yet most frequently used one. This guide will walk you through what wildcard patterns are, how they work, and when to use them in your Swift code.

## Introduction to Wildcard Pattern

In Swift, the wildcard pattern is represented by a single underscore (`_`). It matches and ignores any value, essentially saying "I don't care about this value." This is particularly useful when you need to match a pattern but don't need to use some parts of the matched data.

The wildcard pattern can be used in various contexts:
- Switch statements
- For-in loops
- Variable assignments
- Function parameters

## Basic Syntax and Usage

The basic syntax of a wildcard pattern is simply an underscore (`_`).

```swift
let value = (1, 2, 3)
switch value {
    case (_, 2, _): 
        print("The middle value is 2")
    default:
        print("The middle value is not 2")
}
```

In this example, the wildcard pattern (`_`) is used to ignore the first and third components of the tuple, focusing only on the middle value.

## Using Wildcard in Variable Assignments

When you receive a value but don't need to use it, you can assign it to `_`:

```swift
// Without wildcard pattern
let (x, y) = (10, 20)
print("x: \(x), y: \(y)")  // x: 10, y: 20

// With wildcard pattern
let (_, z) = (30, 40)
print("z: \(z)")  // z: 40
// We can't access the first value because we used the wildcard
```

## Wildcard Pattern in For-in Loops

When you need to run a loop a specific number of times but don't need the counter variable:

```swift
// Traditional approach
for index in 0..<3 {
    print("Hello!")  // Will print "Hello!" three times
}

// Using wildcard pattern
for _ in 0..<3 {
    print("Hello again!")  // Will also print "Hello again!" three times
}
```

The second approach makes it clear that we aren't using the loop counter inside the loop body.

## Wildcard in Function Parameters

When defining or calling functions, you can use the wildcard pattern for parameters you don't need:

```swift
// Function with a parameter that won't be used
func greet(_ name: String, _ _: Int) {
    print("Hello, \(name)!")
}

// Calling the function
greet("Alice", 25)  // Prints "Hello, Alice!"
```

The age parameter is marked with a wildcard because we don't use it in the function body.

## Combining Wildcards with Other Patterns

Wildcards can be combined with other patterns for more complex matching:

```swift
let point = (x: 10, y: 0)

switch point {
case (_, 0):
    print("On the x-axis")
case (0, _):
    print("On the y-axis")
case _:
    print("Elsewhere")
}
// Output: "On the x-axis"
```

## Practical Examples

### Example 1: Processing API Responses

When working with APIs, you might receive data structures with more information than you need:

```swift
// Simulated API response
let userResponse = (name: "John", age: 28, id: "usr123", isActive: true)

// Extract only what we need
let (name, _, _, isActive) = userResponse
print("User \(name) is \(isActive ? "active" : "inactive")")
// Output: "User John is active"
```

### Example 2: Error Handling

When catching errors, sometimes you just want to handle a specific type without needing the error instance:

```swift
enum NetworkError: Error {
    case connectionFailed
    case timeout
    case serverError(code: Int)
}

func fetchData() throws {
    throw NetworkError.timeout
}

do {
    try fetchData()
} catch NetworkError.connectionFailed {
    print("Connection failed")
} catch NetworkError.timeout {
    print("Request timed out")
} catch NetworkError.serverError(let code) where code >= 500 {
    print("Server error: \(code)")
} catch _ {
    print("Unknown error occurred")
}
// Output: "Request timed out"
```

### Example 3: Multiple Return Values

When a function returns multiple values but you only need some of them:

```swift
func getUserInfo() -> (name: String, age: Int, email: String) {
    return ("Alex", 32, "alex@example.com")
}

// Extract only name and email
let (name, _, email) = getUserInfo()
print("Contact \(name) at \(email)")
// Output: "Contact Alex at alex@example.com"
```

## Best Practices

1. **Readability**: Use wildcards to make your code more readable by clearly indicating which values are intentionally ignored.

2. **Avoid Unused Variable Warnings**: Using wildcards helps prevent compiler warnings about unused variables.

3. **When to Avoid**: Don't use wildcards if you might need the value later in your codeâ€”it's better to have a named variable.

4. **Documentation**: When using wildcards in public APIs, document why certain parameters are ignored.

## Summary

The wildcard pattern (`_`) in Swift is a simple yet powerful tool that allows you to:

- Ignore specific values in pattern matching
- Skip variable assignments for values you don't need
- Create more readable code by clearly indicating which values are intentionally unused
- Avoid compiler warnings about unused variables

Mastering the wildcard pattern will help you write cleaner, more intentional Swift code that clearly communicates which values matter and which don't.

## Exercises

1. Create a function that takes three parameters but only uses the first and last one.

2. Write a switch statement that matches tuples of type `(Int, String, Bool)` and uses wildcards to only check the Boolean value.

3. Convert this code to use wildcards where appropriate:
   ```swift
   for index in 0..<10 {
       print("Processing...")
   }
   
   let (first, second, third) = (1, 2, 3)
   print("The value is: \(first)")
   ```

## Additional Resources

- [Official Swift Documentation on Patterns](https://docs.swift.org/swift-book/ReferenceManual/Patterns.html)
- [Swift Pattern Matching in Depth](https://www.swiftbysundell.com/basics/pattern-matching/)
- [Swift Enumeration and Pattern Matching](https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html)

By mastering the wildcard pattern along with other pattern matching techniques, you'll be able to write more expressive and concise Swift code.