---
title: Swift Type-casting Pattern
description: Learn all about Swift type-casting patterns in pattern matching - understanding how to match values based on their type with practical examples and real-world applications

---

# Swift Type-casting Pattern

## Introduction

Pattern matching in Swift provides powerful ways to examine and extract values. Among the various pattern matching techniques, the **type-casting pattern** is particularly useful when working with polymorphism and type hierarchies. 

The type-casting pattern allows you to match values based on their actual type at runtime, enabling you to safely work with values whose exact type might not be known until the program runs. This is especially valuable in a language like Swift that combines object-oriented and protocol-oriented programming approaches.

In this tutorial, we'll explore how the type-casting pattern works in Swift, when to use it, and how it can make your code more elegant and safer.

## Basic Concept of Type-casting Pattern

The type-casting pattern uses two operators:
- `is` pattern: Checks if a value is of a particular type
- `as` pattern: Attempts to downcast a value to a specific type

This pattern is commonly used in `switch` statements and `if case`, `guard case` constructs to handle different types in a type hierarchy.

## Using the `is` Pattern

The `is` pattern checks whether a value is of a particular type without casting it. It's a safer way to verify types before attempting any operations that depend on the type.

### Syntax

```swift
case is Type:
    // code to run if the value matches the specified type
```

### Example with `is` Pattern

Let's consider a simple example with a `Media` class hierarchy:

```swift
// Base class
class Media {
    var title: String
    
    init(title: String) {
        self.title = title
    }
}

// Subclasses
class Movie: Media {
    var director: String
    var duration: Int // minutes
    
    init(title: String, director: String, duration: Int) {
        self.director = director
        self.duration = duration
        super.init(title: title)
    }
}

class Song: Media {
    var artist: String
    var duration: Int // seconds
    
    init(title: String, artist: String, duration: Int) {
        self.artist = artist
        self.duration = duration
        super.init(title: title)
    }
}

// Creating a collection of media items
let mediaLibrary: [Media] = [
    Movie(title: "The Matrix", director: "Wachowskis", duration: 136),
    Song(title: "Bohemian Rhapsody", artist: "Queen", duration: 354),
    Movie(title: "Inception", director: "Christopher Nolan", duration: 148),
    Song(title: "Hey Jude", artist: "The Beatles", duration: 431)
]

// Using pattern matching to count items by type
var movieCount = 0
var songCount = 0

for item in mediaLibrary {
    switch item {
    case is Movie:
        movieCount += 1
    case is Song:
        songCount += 1
    default:
        break
    }
}

print("Library contains \(movieCount) movies and \(songCount) songs")
// Output: Library contains 2 movies and 2 songs
```

In this example, we use the `is` pattern to check which type each `Media` object actually is. This lets us count the number of movies and songs without accessing any specific properties of those subclasses.

## Using the `as` Pattern

The `as` pattern (also called the "type-casting pattern") not only checks the type but also casts the value to that type, allowing you to access its specific properties and methods. It uses the `as` keyword followed by a type and an optional binding.

### Syntax

```swift
case let variableName as Type:
    // code that can use variableName as the specified Type
```

### Example with `as` Pattern

Let's enhance our media library example to display specific details about each media item:

```swift
// Using 'as' pattern to access subclass-specific properties
for item in mediaLibrary {
    switch item {
    case let movie as Movie:
        print("Movie: \(movie.title), directed by \(movie.director), \(movie.duration) minutes")
    case let song as Song:
        let minutes = song.duration / 60
        let seconds = song.duration % 60
        print("Song: \(song.title) by \(song.artist), \(minutes):\(seconds.formatted(.number.precision(.integerLength(2))))")
    default:
        print("Unknown media type: \(item.title)")
    }
}

// Output:
// Movie: The Matrix, directed by Wachowskis, 136 minutes
// Song: Bohemian Rhapsody by Queen, 5:54
// Movie: Inception, directed by Christopher Nolan, 148 minutes
// Song: Hey Jude by The Beatles, 7:11
```

In this example, the `as` pattern both checks the type and downcasts the value to that type. This enables us to access the specific properties of `Movie` and `Song` classes, which aren't available on the base `Media` class.

## Using Type-casting Patterns in `if` and `guard` Statements

You can also use type-casting patterns in `if` and `guard` statements with the `case` keyword.

```swift
func processMedia(_ item: Media) {
    // Using if case
    if case let movie as Movie = item {
        print("Processing movie: \(movie.title)")
        // Movie-specific processing...
        return
    }
    
    // Using guard case
    guard case let song as Song = item else {
        print("Unknown media type")
        return
    }
    
    print("Processing song: \(song.title) by \(song.artist)")
    // Song-specific processing...
}

// Try it with different media types
processMedia(mediaLibrary[0])  // Movie
processMedia(mediaLibrary[1])  // Song
```

## Combining Type-casting with Other Patterns

Type-casting patterns can be combined with other patterns for more complex matching:

```swift
for item in mediaLibrary {
    switch item {
    case let movie as Movie where movie.duration > 140:
        print("Long movie: \(movie.title) (\(movie.duration) minutes)")
    case let movie as Movie:
        print("Regular movie: \(movie.title) (\(movie.duration) minutes)")
    case let song as Song where song.duration > 360:  // Longer than 6 minutes
        print("Long song: \(song.title) (\(song.duration / 60) minutes)")
    case let song as Song:
        print("Regular song: \(song.title) (\(song.duration / 60) minutes)")
    default:
        print("Unknown media: \(item.title)")
    }
}

// Output:
// Regular movie: The Matrix (136 minutes)
// Regular song: Bohemian Rhapsody (5 minutes)
// Long movie: Inception (148 minutes)
// Long song: Hey Jude (7 minutes)
```

## Real-world Application: Custom Error Handling

Type-casting patterns are particularly useful when handling errors in Swift. Let's see a practical example:

```swift
enum NetworkError: Error {
    case serverError(code: Int, message: String)
    case connectionError(reason: String)
    case authenticationError(message: String)
}

enum DatabaseError: Error {
    case queryFailed(query: String, message: String)
    case connectionFailed(message: String)
    case dataCorruption(details: String)
}

// Function that might throw different types of errors
func fetchUserData(userId: String) throws -> [String: Any] {
    // Simulate a failure
    if userId.isEmpty {
        throw NetworkError.serverError(code: 404, message: "User not found")
    }
    if userId == "offline" {
        throw NetworkError.connectionError(reason: "No internet connection")
    }
    if userId == "corrupt" {
        throw DatabaseError.dataCorruption(details: "User data table corrupted")
    }
    
    return ["name": "John Doe", "email": "john@example.com"]
}

// Using fetchUserData with different scenarios
func tryFetchData(for userId: String) {
    do {
        let userData = try fetchUserData(userId: userId)
        print("Successfully fetched user data: \(userData)")
    } catch {
        switch error {
        case let networkError as NetworkError:
            switch networkError {
            case .serverError(let code, let message):
                print("Server error \(code): \(message)")
            case .connectionError(let reason):
                print("Connection failed: \(reason)")
            case .authenticationError(let message):
                print("Auth failed: \(message)")
            }
        
        case let dbError as DatabaseError:
            switch dbError {
            case .queryFailed(let query, let message):
                print("Query failed for '\(query)': \(message)")
            case .connectionFailed(let message):
                print("DB connection error: \(message)")
            case .dataCorruption(let details):
                print("Data corruption: \(details)")
            }
            
        default:
            print("Unknown error: \(error)")
        }
    }
}

// Testing with different scenarios
tryFetchData(for: "user123")    // Success case
tryFetchData(for: "")           // Server error
tryFetchData(for: "offline")    // Connection error
tryFetchData(for: "corrupt")    // Database error
```

This example demonstrates how type-casting patterns help you handle different error types appropriately, improving the error-handling logic in your applications.

## Type-casting Pattern with Protocols

Type-casting patterns work equally well with protocols. This is especially useful in Swift which emphasizes protocol-oriented programming:

```swift
protocol Playable {
    var duration: Int { get }
    func play()
}

// Make our classes conform to Playable
extension Movie: Playable {
    func play() {
        print("Playing movie: \(title)")
    }
}

extension Song: Playable {
    func play() {
        print("Playing song: \(title) by \(artist)")
    }
}

// New type that also conforms to Playable
class Podcast: Media, Playable {
    var host: String
    var duration: Int // seconds
    
    init(title: String, host: String, duration: Int) {
        self.host = host
        self.duration = duration
        super.init(title: title)
    }
    
    func play() {
        print("Playing podcast: \(title) with \(host)")
    }
}

// Mixed collection
let playableItems: [Any] = [
    Movie(title: "The Matrix", director: "Wachowskis", duration: 136),
    Song(title: "Bohemian Rhapsody", artist: "Queen", duration: 354),
    Podcast(title: "Swift Talk", host: "Chris & Florian", duration: 1800)
]

// Using type-casting pattern to find and play Playable items
for item in playableItems {
    switch item {
    case let playable as Playable:
        let minutes = playable.duration / 60
        print("Found playable item (\(minutes) mins):")
        playable.play()
    default:
        print("Item is not playable")
    }
}

// Output:
// Found playable item (2 mins):
// Playing movie: The Matrix
// Found playable item (5 mins):
// Playing song: Bohemian Rhapsody by Queen
// Found playable item (30 mins):
// Playing podcast: Swift Talk with Chris & Florian
```

This example demonstrates how to use type-casting to check if objects conform to protocols, which is a common pattern in Swift programming.

## Summary

The Swift type-casting pattern is a powerful feature that allows you to match and work with values based on their runtime type. This pattern is crucial for handling polymorphism and type hierarchies in Swift applications.

Key points to remember:

1. The `is` pattern checks if a value is of a particular type without casting it
2. The `as` pattern checks the type and casts the value, allowing access to type-specific properties
3. Type-casting patterns can be used in `switch`, `if case`, and `guard case` statements
4. They can be combined with other patterns like `where` clauses for more specific matching
5. Type-casting works with both classes and protocols, making it a versatile tool for Swift programming

Type-casting patterns enable you to write cleaner, more maintainable code that can handle different types safely and elegantly, without resorting to complex conditional structures.

## Exercises

1. Create a `Vehicle` class hierarchy with at least three different types of vehicles. Use type-casting patterns to process an array of vehicles and display type-specific information for each.

2. Design a `Shape` protocol with various conforming types. Create a function that takes an array of `Any` objects and uses type-casting to calculate the total area of all shapes in the array.

3. Implement a custom JSON parser that uses type-casting patterns to handle different value types (strings, numbers, arrays, dictionaries).

4. Extend the media library example to include a `Playlist` class that can contain any `Playable` items. Implement a function to calculate the total playing time using type-casting.

## Additional Resources

- [Swift Documentation on Patterns](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/patterns/)
- [Pattern Matching in Swift](https://www.swiftbysundell.com/articles/pattern-matching-in-swift/)
- [Swift Protocols and Protocol Extensions](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols/)
- [Swift Error Handling](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/errorhandling/)