---
title: Swift Async Functions
description: Learn about Swift's async functions and how they simplify asynchronous programming by writing more readable, sequential code while maintaining concurrency benefits.

---

# Swift Async Functions

## Introduction

Asynchronous programming is a crucial skill in modern app development, allowing applications to perform multiple operations simultaneously without blocking the main thread. Swift's async functions, introduced in Swift 5.5, provide an elegant way to write asynchronous code that looks and feels synchronous, making it much easier to understand and maintain.

In this tutorial, we'll explore Swift's async functions - a cornerstone of Swift's modern concurrency model. You'll learn how to define, call, and work with async functions, making your code more efficient while keeping it readable.

## Understanding Asynchronous Programming

Before diving into Swift's async functions, let's understand why asynchronous programming is necessary:

- **Responsiveness**: Keep your app's user interface responsive while performing time-consuming tasks
- **Efficiency**: Make better use of system resources by not blocking threads
- **Network Operations**: Handle network requests without freezing your application
- **Performance**: Execute multiple operations simultaneously for better performance

Traditional approaches to asynchronous programming in Swift involved callbacks, completion handlers, or reactive programming libraries. While these approaches work, they often lead to complex, nested code that's difficult to follow - a problem known as "callback hell" or "pyramid of doom."

## What Are Async Functions?

Async functions in Swift let you write asynchronous code that:

1. Looks like synchronous code (top to bottom)
2. Can "pause" execution at certain points without blocking the thread
3. Resumes execution when asynchronous work completes

An async function is marked with the `async` keyword and can use the `await` keyword to pause execution while waiting for other asynchronous operations to complete.

## Defining an Async Function

Here's how to define a basic async function in Swift:

```swift
func fetchUserData() async -> User {
    // Asynchronous code here
    let user = User(name: "John", id: 123)
    return user
}
```

Key components:
- The `async` keyword indicates this function performs asynchronous work
- The function returns a `User` object, but not necessarily immediately
- The caller of this function will need to use `await` when calling it

## Calling Async Functions with Await

To call an async function, you use the `await` keyword, which signals potential suspension points in your code:

```swift
func loadUserProfile() async {
    // Execution might pause here while waiting for user data
    let user = await fetchUserData()
    print("Loaded user: \(user.name)")
}
```

The `await` keyword does two important things:
1. It marks a potential suspension point where your function might pause execution
2. It unwraps the eventual value from the async function when it completes

## Async/Await vs. Completion Handlers

Let's compare the traditional completion handler approach with the new async/await syntax:

### With Completion Handlers:

```swift
func fetchUserData(completion: @escaping (User?, Error?) -> Void) {
    // Simulate network delay
    DispatchQueue.global().asyncAfter(deadline: .now() + 1) {
        let user = User(name: "John", id: 123)
        completion(user, nil)
    }
}

// Calling the function
fetchUserData { user, error in
    if let user = user {
        print("Loaded user: \(user.name)")
        
        // If we need another async operation, we nest it
        self.fetchUserPosts(for: user) { posts, error in
            if let posts = posts {
                print("User has \(posts.count) posts")
                
                // Further nesting for related operations
                self.fetchComments(for: posts.first!) { comments, error in
                    // More nested code...
                }
            }
        }
    } else if let error = error {
        print("Error: \(error)")
    }
}
```

### With Async/Await:

```swift
func fetchUserData() async throws -> User {
    // Simulate network delay
    try await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
    return User(name: "John", id: 123)
}

func fetchUserPosts(for user: User) async throws -> [Post] {
    try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
    return [Post(id: 1, title: "Hello World")]
}

func fetchComments(for post: Post) async throws -> [Comment] {
    try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
    return [Comment(id: 1, text: "Great post!")]
}

// Calling the functions
async {
    do {
        let user = try await fetchUserData()
        print("Loaded user: \(user.name)")
        
        let posts = try await fetchUserPosts(for: user)
        print("User has \(posts.count) posts")
        
        if let firstPost = posts.first {
            let comments = try await fetchComments(for: firstPost)
            print("First post has \(comments.count) comments")
        }
    } catch {
        print("Error: \(error)")
    }
}
```

Notice how the async/await version:
- Reads from top to bottom like synchronous code
- Avoids deep nesting
- Clearly shows the sequence of operations
- Has cleaner error handling with standard try-catch mechanisms

## Error Handling with Async Functions

Async functions integrate smoothly with Swift's error handling system:

```swift
func fetchWeatherData() async throws -> WeatherData {
    let url = URL(string: "https://api.weather.example/current")!
    
    // This line can throw an error
    let (data, response) = try await URLSession.shared.data(from: url)
    
    guard let httpResponse = response as? HTTPURLResponse,
          httpResponse.statusCode == 200 else {
        throw WeatherError.invalidResponse
    }
    
    // This can also throw an error
    return try JSONDecoder().decode(WeatherData.self, from: data)
}

// Calling with error handling
func updateWeatherUI() async {
    do {
        let weatherData = try await fetchWeatherData()
        updateUI(with: weatherData)
    } catch WeatherError.invalidResponse {
        showErrorMessage("The weather service returned an invalid response")
    } catch is DecodingError {
        showErrorMessage("Couldn't parse weather data")
    } catch {
        showErrorMessage("An error occurred: \(error.localizedDescription)")
    }
}
```

## Practical Example: Building a Weather App

Let's look at a more complete example of using async functions in a weather app:

```swift
// Models
struct WeatherData: Decodable {
    let temperature: Double
    let condition: String
}

enum WeatherError: Error {
    case invalidURL
    case invalidResponse
    case networkError(Error)
}

class WeatherService {
    // Async function to fetch current weather
    func getCurrentWeather(for city: String) async throws -> WeatherData {
        // Format and validate the URL
        guard let encodedCity = city.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),
              let url = URL(string: "https://api.weather.example/current?city=\(encodedCity)") else {
            throw WeatherError.invalidURL
        }
        
        do {
            // Await the network request
            let (data, response) = try await URLSession.shared.data(from: url)
            
            // Validate response
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                throw WeatherError.invalidResponse
            }
            
            // Parse the JSON data
            let weatherData = try JSONDecoder().decode(WeatherData.self, from: data)
            return weatherData
        } catch let error where error is URLError {
            throw WeatherError.networkError(error)
        }
    }
    
    // Get weather for multiple cities concurrently
    func getWeatherForCities(_ cities: [String]) async throws -> [String: WeatherData] {
        var results = [String: WeatherData]()
        
        // Process cities in parallel using TaskGroup
        try await withThrowingTaskGroup(of: (String, WeatherData).self) { group in
            for city in cities {
                group.addTask {
                    let weather = try await self.getCurrentWeather(for: city)
                    return (city, weather)
                }
            }
            
            // Collect results as they complete
            for try await (city, weather) in group {
                results[city] = weather
            }
        }
        
        return results
    }
}

// Using the weather service in a view controller
class WeatherViewController: UIViewController {
    let weatherService = WeatherService()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Start loading the weather
        Task {
            await loadWeather()
        }
    }
    
    func loadWeather() async {
        showLoadingIndicator()
        
        do {
            // Get weather for current location
            let weather = try await weatherService.getCurrentWeather(for: "New York")
            updateUI(with: weather)
            
            // Get forecast for next days (another async operation)
            let forecast = try await loadForecast(for: "New York")
            updateForecastUI(with: forecast)
            
        } catch WeatherError.invalidURL {
            showError("Invalid city name")
        } catch WeatherError.invalidResponse {
            showError("Couldn't reach weather service")
        } catch WeatherError.networkError(let error) {
            showError("Network error: \(error.localizedDescription)")
        } catch {
            showError("An unexpected error occurred")
        }
        
        hideLoadingIndicator()
    }
    
    func loadForecast(for city: String) async throws -> [WeatherData] {
        // Simulation - would be another API call
        try await Task.sleep(nanoseconds: 1_000_000_000)
        return [
            WeatherData(temperature: 72.0, condition: "Sunny"),
            WeatherData(temperature: 75.0, condition: "Partly Cloudy"),
            WeatherData(temperature: 68.0, condition: "Rainy")
        ]
    }
    
    // UI methods
    func showLoadingIndicator() { /* ... */ }
    func hideLoadingIndicator() { /* ... */ }
    func updateUI(with weather: WeatherData) { /* ... */ }
    func updateForecastUI(with forecast: [WeatherData]) { /* ... */ }
    func showError(_ message: String) { /* ... */ }
}
```

This example demonstrates:
- Creating reusable async functions in a service class
- Handling errors properly with Swift's try-catch mechanism
- Sequencing multiple async operations
- Using async functions within a view controller lifecycle

## Advanced: Async Sequences

Swift's concurrency model also includes async sequences, which allow you to process a series of asynchronous values over time:

```swift
// A simple async sequence example - reading lines from a file
func processLogFile() async throws {
    let fileHandle = try FileHandle(forReadingFrom: URL(fileURLWithPath: "/path/to/log.txt"))
    defer { fileHandle.closeFile() }
    
    // Iterate over lines asynchronously
    for try await line in fileHandle.bytes.lines {
        // Process each line as it becomes available
        if line.contains("ERROR") {
            print("Found error: \(line)")
        }
    }
}
```

This allows you to process data as it arrives, rather than waiting for everything to be available.

## Best Practices for Async Functions

1. **Mark UI updates on the main thread**: When updating UI after async operations, use `MainActor`
   ```swift
   @MainActor
   func updateUIWithResults(_ results: [String]) {
       tableView.reloadData()
   }
   ```

2. **Use Task for ad-hoc async work**:
   ```swift
   func viewDidAppear(_ animated: Bool) {
       super.viewDidAppear(animated)
       
       Task {
           let data = try? await loadData()
           await updateUI(with: data)
       }
   }
   ```

3. **Cancel tasks when no longer needed**:
   ```swift
   var dataTask: Task<Void, Never>?
   
   func startLoading() {
       // Cancel previous task if it exists
       dataTask?.cancel()
       
       dataTask = Task {
           // Check for cancellation
           if Task.isCancelled { return }
           let data = try? await fetchData()
           // Process data...
       }
   }
   
   func cancelLoading() {
       dataTask?.cancel()
   }
   ```

4. **Group related async functions in protocol-driven services**:
   ```swift
   protocol WeatherServiceProtocol {
       func getCurrentWeather(for city: String) async throws -> WeatherData
       func getForecast(for city: String) async throws -> [WeatherData]
   }
   ```

5. **Avoid force-unwrapping in async code**: Use safe unwrapping since async code often involves external systems that can fail.

## Summary

Swift's async functions represent a major improvement in how we write asynchronous code:

- The `async` keyword marks functions that perform asynchronous operations
- The `await` keyword marks potential suspension points within async functions
- Async functions can throw errors, which can be caught using standard Swift error handling
- Compared to completion handlers, async/await code is more readable, maintainable, and less error-prone
- Async functions work well with other Swift concurrency features like structured concurrency and actors

By using async functions, you can write code that's both concurrent and easy to follow, improving both performance and maintainability.

## Additional Resources

- [Swift.org: Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html) - Official documentation
- [WWDC21: Meet async/await in Swift](https://developer.apple.com/videos/play/wwdc2021/10132/) - Apple's introduction video
- [Swift by Sundell: Async/await](https://www.swiftbysundell.com/articles/exploring-swift-5-5-async-await/) - Detailed tutorial
- [Swift Evolution: SE-0296](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md) - The original Swift Evolution proposal

## Exercises

1. Convert a function that uses completion handlers to async/await syntax
2. Create a weather app that fetches weather data for multiple cities concurrently
3. Implement error handling for network requests using async functions
4. Use an async sequence to process streaming data
5. Create a function that performs multiple asynchronous operations in sequence, and handle all potential errors

By mastering async functions in Swift, you'll write more maintainable concurrent code and create responsive applications that efficiently utilize system resources.