---
title: Swift Protocol Composition
description: Learn how to combine multiple protocols into a single requirement in Swift, allowing for more flexible and powerful type constraints.

---

# Swift Protocol Composition

## Introduction

Protocol composition is a powerful feature in Swift that allows you to combine multiple protocols into a single requirement. Instead of creating complex inheritance hierarchies or struggling with the limitation that a class can only inherit from a single superclass, protocol composition enables you to specify that a type must conform to multiple protocols simultaneously.

This feature is particularly useful when you want to express complex requirements concisely, making your code more readable and maintainable. In this tutorial, we'll explore how protocol composition works in Swift and how you can leverage it in your own code.

## Understanding Protocol Composition

### Basic Syntax

The syntax for protocol composition uses the ampersand (`&`) symbol to combine protocols:

```swift
protocol1 & protocol2 & protocol3
```

This creates a composite requirement that a type must conform to all the specified protocols.

### Simple Example

Let's start with a simple example to illustrate protocol composition. Imagine we have two protocols:

```swift
protocol Printable {
    func printDescription()
}

protocol Identifiable {
    var id: String { get }
}
```

Now, we can create a function that accepts a parameter that conforms to both protocols:

```swift
func process(item: Printable & Identifiable) {
    print("Processing item with ID: \(item.id)")
    item.printDescription()
}
```

The `item` parameter must be a type that conforms to both `Printable` and `Identifiable`. This means the type needs to implement both the `printDescription()` method and the `id` property.

Let's create a type that conforms to these protocols:

```swift
struct User: Printable, Identifiable {
    var name: String
    var id: String
    
    func printDescription() {
        print("User: \(name)")
    }
}

// Creating a user instance
let user = User(name: "John Doe", id: "12345")

// Using our process function
process(item: user)

// Output:
// Processing item with ID: 12345
// User: John Doe
```

## Advanced Protocol Composition

### Combining Multiple Protocols

You can combine as many protocols as needed to express your requirements:

```swift
protocol Drawable {
    func draw()
}

protocol Animatable {
    func animate()
}

protocol Resizable {
    func resize(to size: CGSize)
}

func renderUI(element: Drawable & Animatable & Resizable) {
    element.draw()
    element.animate()
    element.resize(to: CGSize(width: 100, height: 100))
}
```

### Using Protocol Composition with Classes

You can also combine a class type with protocols. This is useful when you want a type that inherits from a specific class and also conforms to one or more protocols:

```swift
class UIComponent {
    func setup() {
        print("Setting up component")
    }
}

protocol Theme {
    var backgroundColor: String { get }
}

// Function requiring a UIComponent subclass that also conforms to Theme
func styleComponent(component: UIComponent & Theme) {
    component.setup()
    print("Applying background color: \(component.backgroundColor)")
}

// A class that satisfies the requirement
class ThemedButton: UIComponent, Theme {
    var backgroundColor: String = "blue"
    
    func tap() {
        print("Button tapped!")
    }
}

let button = ThemedButton()
styleComponent(component: button)

// Output:
// Setting up component
// Applying background color: blue
```

### Using Protocol Composition with Type Aliases

Creating a type alias for protocol compositions can improve readability:

```swift
typealias ConfigurableView = Drawable & Animatable & Resizable

func setupView(view: ConfigurableView) {
    // Work with the view
    view.draw()
    view.animate()
    view.resize(to: CGSize(width: 200, height: 200))
}
```

## Practical Real-World Examples

### Building a UI Component System

Protocol composition is particularly useful in UI development to create flexible component systems:

```swift
protocol Stackable {
    func addToStack(_ stack: UIStackView)
}

protocol Highlightable {
    func highlight()
    func unhighlight()
}

protocol Interactive {
    var isEnabled: Bool { get set }
    func handleTap()
}

// A function that works with UI elements that can be stacked, highlighted, and interacted with
func configureInteractiveElement(element: Stackable & Highlightable & Interactive, in stack: UIStackView) {
    element.addToStack(stack)
    if element.isEnabled {
        element.highlight()
    }
}

// A custom button implementation
class CustomButton: UIButton, Stackable, Highlightable, Interactive {
    var isEnabled: Bool = true
    
    func addToStack(_ stack: UIStackView) {
        stack.addArrangedSubview(self)
    }
    
    func highlight() {
        backgroundColor = .blue
        setTitleColor(.white, for: .normal)
    }
    
    func unhighlight() {
        backgroundColor = .lightGray
        setTitleColor(.black, for: .normal)
    }
    
    func handleTap() {
        print("Button was tapped!")
    }
}
```

### Data Processing Pipeline

Protocol composition can define requirements for elements in a data processing pipeline:

```swift
protocol DataSource {
    func fetchData() -> [String: Any]
}

protocol DataProcessor {
    func process(data: [String: Any]) -> [String: Any]
}

protocol DataValidator {
    func validate(data: [String: Any]) -> Bool
}

// Function that requires an object which can source, process, and validate data
func runDataPipeline(with handler: DataSource & DataProcessor & DataValidator) {
    let rawData = handler.fetchData()
    let processedData = handler.process(data: rawData)
    
    if handler.validate(data: processedData) {
        print("Data pipeline completed successfully!")
        print("Processed data: \(processedData)")
    } else {
        print("Data validation failed!")
    }
}

// An implementation that handles JSON data
class JSONDataHandler: DataSource, DataProcessor, DataValidator {
    func fetchData() -> [String: Any] {
        // Simulate fetching data from a remote source
        return ["name": "Product", "price": 29.99, "quantity": 10]
    }
    
    func process(data: [String: Any]) -> [String: Any] {
        // Process the data (e.g., calculate total value)
        var processedData = data
        if let price = data["price"] as? Double, let quantity = data["quantity"] as? Int {
            processedData["totalValue"] = price * Double(quantity)
        }
        return processedData
    }
    
    func validate(data: [String: Any]) -> Bool {
        // Validate that the processed data has all required fields
        return data["name"] != nil && data["totalValue"] != nil
    }
}

// Using the data pipeline
let jsonHandler = JSONDataHandler()
runDataPipeline(with: jsonHandler)

// Output:
// Data pipeline completed successfully!
// Processed data: ["name": "Product", "price": 29.99, "quantity": 10, "totalValue": 299.9]
```

## Limitations and Considerations

While protocol composition is powerful, there are some limitations to be aware of:

1. **Performance**: Composing many protocols might impact compile-time performance, though runtime performance is generally not affected.

2. **No Protocol Inheritance**: Protocol composition is not the same as protocol inheritance. It's about combining requirements, not creating inheritance hierarchies.

3. **No Default Implementations**: Protocol composition doesn't allow you to combine default implementations from protocol extensions in special ways.

4. **Name Collisions**: Be cautious about protocols with methods or properties that have the same name but different requirements.

## Summary

Protocol composition is a flexible and powerful feature in Swift that allows you to combine multiple protocol requirements into a single requirement. By using the `&` syntax, you can create more expressive and precise type constraints without complex inheritance hierarchies.

Key benefits of protocol composition include:

- Ability to specify multiple protocol requirements concisely
- More flexible than single inheritance
- Creates clearer, more specific type constraints
- Enables better code organization through protocol-oriented design

Remember that protocol composition is about specifying that a type must conform to all the combined protocols. It's an essential tool for writing protocol-oriented Swift code that's both flexible and maintainable.

## Additional Resources and Exercises

### Resources

- [Swift Documentation on Protocol Composition](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html#ID282)
- [WWDC Session: Protocol-Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/)

### Exercises

1. **Basic Protocol Composition**:
   Create three simple protocols (`Nameable`, `Ageable`, and `Identifiable`) and a struct that conforms to all three. Then, write a function that accepts a parameter of the composite type.

2. **UI Challenge**:
   Design a set of protocols for UI elements (e.g., `Clickable`, `Draggable`, `Resizable`) and create views that implement various combinations of these protocols.

3. **Protocol Composition with Class Requirement**:
   Create a scenario where you need an object to inherit from a specific class and also conform to two protocols. Use protocol composition to express this requirement.

4. **Type Alias for Composition**:
   Create a complex protocol composition with 4+ protocols, then use a type alias to make it more manageable.

5. **Advanced Protocol Composition**:
   Design a small library or framework that heavily leverages protocol composition to create a flexible API.