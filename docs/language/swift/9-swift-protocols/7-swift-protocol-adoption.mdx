---
title: Swift Protocol Adoption
description: Learn how to adopt and implement protocols in Swift, including single and multiple protocol adoption, and understand how they improve code reusability and flexibility.

---

# Swift Protocol Adoption

In Swift programming, protocols define a blueprint of methods, properties, and requirements that classes, structures, or enumerations can adopt. Protocol adoption is the process of implementing these requirements in your types. This concept is fundamental to Swift's approach to composition and polymorphism.

## Introduction to Protocol Adoption

Protocol adoption (also known as conformance) enables your custom types to implement specific behaviors defined by protocols. When a type adopts a protocol, it agrees to provide implementations for all the requirements defined in that protocol.

Think of protocols as contracts: when your type signs the contract (adopts the protocol), it promises to fulfill all the obligations (requirements) specified in that contract.

## Basic Protocol Adoption

### Syntax for Protocol Adoption

Here's the basic syntax for adopting a protocol in Swift:

```swift
struct MyType: SomeProtocol {
    // Implementation of protocol requirements here
}
```

For classes that inherit from a superclass and also adopt protocols:

```swift
class MyClass: SuperClass, Protocol1, Protocol2 {
    // Implementation goes here
}
```

### Example: Simple Protocol Adoption

Let's create a simple `Describable` protocol and adopt it in different types:

```swift
protocol Describable {
    var description: String { get }
    func identify()
}

// Struct adopting the protocol
struct Person: Describable {
    let name: String
    let age: Int
    
    var description: String {
        return "Person named \(name), \(age) years old"
    }
    
    func identify() {
        print("I am \(name), a person.")
    }
}

// Class adopting the protocol
class Product: Describable {
    let name: String
    let price: Double
    
    init(name: String, price: Double) {
        self.name = name
        self.price = price
    }
    
    var description: String {
        return "\(name): $\(price)"
    }
    
    func identify() {
        print("This is \(name), a product.")
    }
}

// Using the protocol
let person = Person(name: "Alice", age: 30)
let product = Product(name: "Laptop", price: 1299.99)

print(person.description)  // Output: Person named Alice, 30 years old
person.identify()          // Output: I am Alice, a person.

print(product.description) // Output: Laptop: $1299.99
product.identify()         // Output: This is Laptop, a product.
```

## Multiple Protocol Adoption

Swift allows types to adopt multiple protocols, which is a powerful way to compose behavior.

### Example: Adopting Multiple Protocols

```swift
protocol Identifiable {
    var id: String { get }
}

protocol Sharable {
    func share()
}

class Document: Identifiable, Sharable, Describable {
    var id: String
    var title: String
    var content: String
    
    init(id: String, title: String, content: String) {
        self.id = id
        self.title = title
        self.content = content
    }
    
    var description: String {
        return "Document: \(title)"
    }
    
    func identify() {
        print("Document ID: \(id)")
    }
    
    func share() {
        print("Sharing document: \(title)")
    }
}

let doc = Document(id: "doc-123", title: "Annual Report", content: "Company performance...")
doc.identify()  // Output: Document ID: doc-123
doc.share()     // Output: Sharing document: Annual Report
```

## Protocol Adoption with Default Implementations

Swift protocols can provide default implementations through protocol extensions, allowing you to adopt a protocol without implementing all of its requirements if the defaults are suitable.

```swift
protocol Greeting {
    func sayHello()
    func sayGoodbye()
}

extension Greeting {
    func sayHello() {
        print("Hello!")
    }
    
    func sayGoodbye() {
        print("Goodbye!")
    }
}

struct EnglishSpeaker: Greeting {
    // Uses default implementation for both methods
}

struct FrenchSpeaker: Greeting {
    // Overrides one method, uses default for the other
    func sayHello() {
        print("Bonjour!")
    }
}

let english = EnglishSpeaker()
english.sayHello()    // Output: Hello!
english.sayGoodbye()  // Output: Goodbye!

let french = FrenchSpeaker()
french.sayHello()     // Output: Bonjour!
french.sayGoodbye()   // Output: Goodbye!
```

## Conditional Protocol Adoption

Sometimes, you may want a type to adopt a protocol only under certain conditions. Swift enables this through conditional conformance.

```swift
// A protocol for types that can be represented as an array
protocol ArrayRepresentable {
    func asArray() -> [Any]
}

// Make arrays of any type conform to ArrayRepresentable
extension Array: ArrayRepresentable {
    func asArray() -> [Any] {
        return self
    }
}

// Conditional conformance: Only arrays of Equatable elements
// can conform to the Equatable protocol
extension Array: Equatable where Element: Equatable {
    // Swift automatically generates implementation
}

// This works because Int is Equatable
let array1 = [1, 2, 3]
let array2 = [1, 2, 3]
print(array1 == array2)  // Output: true

// This becomes available because arrays conform to ArrayRepresentable
let representation = array1.asArray()
print(type(of: representation))  // Output: Array<Any>
```

## Protocol Adoption for Type Constraints

Protocol adoption is often used to constrain generic types, ensuring they have specific capabilities.

```swift
func printDescriptions<T: Describable>(items: [T]) {
    for item in items {
        print(item.description)
        item.identify()
    }
}

let people = [
    Person(name: "Alice", age: 30),
    Person(name: "Bob", age: 25)
]

let products = [
    Product(name: "Laptop", price: 1299.99),
    Product(name: "Phone", price: 799.99)
]

printDescriptions(items: people)
// Output:
// Person named Alice, 30 years old
// I am Alice, a person.
// Person named Bob, 25 years old
// I am Bob, a person.

printDescriptions(items: products)
// Output:
// Laptop: $1299.99
// This is Laptop, a product.
// Phone: $799.99
// This is Phone, a product.
```

## Real-World Applications

### Example: Building a Document Management System

Let's see how protocol adoption helps in designing a flexible document management system:

```swift
// Core protocols
protocol Storable {
    var filename: String { get }
    func save() -> Bool
    func load() -> Bool
}

protocol Printable {
    func preparePrint() -> Bool
    func print() -> Bool
}

protocol Exportable {
    var supportedFormats: [String] { get }
    func export(to format: String) -> Data?
}

// Document types
class TextDocument: Storable, Printable {
    var content: String
    var filename: String
    
    init(filename: String, content: String = "") {
        self.filename = filename
        self.content = content
    }
    
    func save() -> Bool {
        print("Saving text document to \(filename)...")
        return true
    }
    
    func load() -> Bool {
        print("Loading text document from \(filename)...")
        // Simulation of loading
        self.content = "Loaded content"
        return true
    }
    
    func preparePrint() -> Bool {
        print("Preparing text document for printing...")
        return true
    }
    
    func print() -> Bool {
        print("Printing text document: \(content)")
        return true
    }
}

class SpreadsheetDocument: Storable, Printable, Exportable {
    var data: [[String]]
    var filename: String
    
    init(filename: String, data: [[String]] = []) {
        self.filename = filename
        self.data = data
    }
    
    func save() -> Bool {
        print("Saving spreadsheet to \(filename)...")
        return true
    }
    
    func load() -> Bool {
        print("Loading spreadsheet from \(filename)...")
        // Simulation of loading
        self.data = [["A1", "B1"], ["A2", "B2"]]
        return true
    }
    
    func preparePrint() -> Bool {
        print("Preparing spreadsheet for printing...")
        return true
    }
    
    func print() -> Bool {
        print("Printing spreadsheet with \(data.count) rows")
        return true
    }
    
    var supportedFormats: [String] {
        return ["csv", "xlsx", "pdf"]
    }
    
    func export(to format: String) -> Data? {
        if supportedFormats.contains(format) {
            print("Exporting spreadsheet to \(format) format")
            return Data() // Simulated data
        }
        return nil
    }
}

// Document management system
class DocumentManager {
    func saveDocument(_ document: Storable) {
        if document.save() {
            print("Document saved successfully")
        } else {
            print("Failed to save document")
        }
    }
    
    func printDocument(_ document: Printable) {
        if document.preparePrint() && document.print() {
            print("Document printed successfully")
        } else {
            print("Failed to print document")
        }
    }
    
    func exportDocument(_ document: Exportable, format: String) {
        if let _ = document.export(to: format) {
            print("Document exported successfully to \(format)")
        } else {
            print("Failed to export document to \(format)")
        }
    }
}

// Usage
let textDoc = TextDocument(filename: "notes.txt", content: "Important meeting notes")
let spreadsheet = SpreadsheetDocument(filename: "budget.xlsx")

let manager = DocumentManager()

manager.saveDocument(textDoc)
// Output:
// Saving text document to notes.txt...
// Document saved successfully

manager.printDocument(spreadsheet)
// Output:
// Preparing spreadsheet for printing...
// Printing spreadsheet with 0 rows
// Document printed successfully

manager.exportDocument(spreadsheet, format: "pdf")
// Output:
// Exporting spreadsheet to pdf format
// Document exported successfully to pdf
```

This example demonstrates how protocol adoption enables:

1. Different document types to share common behaviors
2. The document manager to work with any document type that conforms to specific protocols
3. Each document type to implement behaviors in the way that makes sense for its specific needs

## Summary

Protocol adoption is a cornerstone of Swift programming that provides:

- **Composition over inheritance**: Adopt multiple protocols to compose behavior rather than inheriting from a deep class hierarchy
- **Type safety**: Ensure that types provide required functionality
- **Flexibility**: Allow different types to implement the same interface in different ways
- **Code reusability**: Define behavior once in a protocol and reuse it across multiple types

By mastering protocol adoption, you can write more modular, flexible, and maintainable Swift code.

## Additional Resources and Exercises

### Resources
- [Swift Documentation on Protocols](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)
- [Apple's Protocol-Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/)

### Exercises

1. **Basic Protocol Adoption**: Create a `Vehicle` protocol with requirements for `startEngine()`, `stopEngine()`, and a `description` property. Then implement this protocol for `Car` and `Motorcycle` classes.

2. **Multiple Protocol Adoption**: Design a `MediaItem` protocol hierarchy with `Playable`, `Downloadable`, and `Shareable` protocols. Create types like `Song`, `Podcast`, and `Video` that adopt different combinations of these protocols.

3. **Protocol Extensions Challenge**: Create a `Collection` protocol extension that adds helpful methods like `printAll()` or `countWhere(condition:)` and test it with different collection types.

4. **Protocol Composition**: Design a system for a digital library using protocols. Create protocols for different aspects like `Borrowable`, `Reviewable`, `Searchable`, and implement them for various media types.

Remember that protocols and their adoption are powerful tools in Swift. Practice using them in different scenarios to gain a deep understanding of their capabilities!