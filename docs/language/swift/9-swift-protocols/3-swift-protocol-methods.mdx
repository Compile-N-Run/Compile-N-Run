---
title: "Swift Protocol Methods"
description: "Learn how to add methods to Swift protocols, implement required functionality in conforming types, and leverage default implementations for cleaner, more maintainable code."

---

# Swift Protocol Methods

Protocols in Swift don't just define properties â€“ they can also define methods that conforming types must implement. Understanding how to work with protocol methods is essential for building flexible, reusable code in Swift.

## Introduction to Protocol Methods

Protocol methods are function declarations within a protocol that describe behavior that conforming types must implement. When you define a method in a protocol, you're creating a contract that says "any type conforming to this protocol must implement this method with this exact signature."

Let's start with a basic example:

```swift
protocol Vehicle {
    func start()
    func stop()
    func makeNoise() -> String
}
```

In this protocol, we've defined three methods:
- `start()`: A method with no parameters and no return value
- `stop()`: Similar to start, no parameters or return value
- `makeNoise()`: A method that returns a String, with no parameters

## Implementing Protocol Methods

When a type adopts a protocol, it must implement all the methods declared in that protocol. Here's how we might implement our `Vehicle` protocol:

```swift
struct Car: Vehicle {
    func start() {
        print("Engine starting")
    }
    
    func stop() {
        print("Engine shutting down")
    }
    
    func makeNoise() -> String {
        return "Vroom vroom!"
    }
}

let myCar = Car()
myCar.start() // Output: Engine starting
print(myCar.makeNoise()) // Output: Vroom vroom!
myCar.stop() // Output: Engine shutting down
```

Another type could implement the same protocol differently:

```swift
struct Bicycle: Vehicle {
    func start() {
        print("Begin pedaling")
    }
    
    func stop() {
        print("Stop pedaling")
    }
    
    func makeNoise() -> String {
        return "Ring ring!"
    }
}

let myBike = Bicycle()
myBike.start() // Output: Begin pedaling
print(myBike.makeNoise()) // Output: Ring ring!
myBike.stop() // Output: Stop pedaling
```

## Methods with Parameters and Return Types

Protocol methods can include parameters and return types, just like regular methods:

```swift
protocol Calculator {
    func add(_ a: Int, _ b: Int) -> Int
    func subtract(_ a: Int, _ b: Int) -> Int
    func evaluate(_ expression: String) throws -> Double
}

struct BasicCalculator: Calculator {
    func add(_ a: Int, _ b: Int) -> Int {
        return a + b
    }
    
    func subtract(_ a: Int, _ b: Int) -> Int {
        return a - b
    }
    
    func evaluate(_ expression: String) throws -> Double {
        // Simple implementation for educational purposes
        if expression == "1+1" {
            return 2.0
        } else {
            throw NSError(domain: "CalculatorError", code: 1, userInfo: nil)
        }
    }
}

let calc = BasicCalculator()
print(calc.add(5, 3)) // Output: 8
print(calc.subtract(10, 4)) // Output: 6

do {
    let result = try calc.evaluate("1+1")
    print("Result is: \(result)") // Output: Result is: 2.0
} catch {
    print("Evaluation failed")
}
```

## Mutating Methods in Protocols

When you need to modify the instance of a value type (struct or enum) from within a method, you must mark that method as `mutating` in the protocol:

```swift
protocol Togglable {
    mutating func toggle()
}

struct LightSwitch: Togglable {
    var isOn: Bool = false
    
    mutating func toggle() {
        isOn = !isOn
    }
}

var light = LightSwitch()
print("Light is on: \(light.isOn)") // Output: Light is on: false
light.toggle()
print("Light is on: \(light.isOn)") // Output: Light is on: true
```

Note that:
1. The protocol must declare the method as `mutating`
2. Classes don't need the `mutating` keyword when implementing, as they're reference types
3. Structs and enums must include the `mutating` keyword in their implementation

## Static and Class Methods in Protocols

Protocols can also define static or class methods that must be implemented by conforming types:

```swift
protocol Creatable {
    static func create() -> Self
    static var defaultName: String { get }
}

struct User: Creatable {
    var name: String
    
    static func create() -> User {
        return User(name: defaultName)
    }
    
    static var defaultName: String {
        return "Anonymous"
    }
}

let defaultUser = User.create()
print(defaultUser.name) // Output: Anonymous
print(User.defaultName) // Output: Anonymous
```

## Protocol Method Requirements and Type Safety

The method signatures in a protocol create a type-safe boundary. The implementation must match exactly:

```swift
protocol Processor {
    func process(data: String) -> Bool
}

struct TextProcessor: Processor {
    // This will compile because the signature matches exactly
    func process(data: String) -> Bool {
        return data.count > 0
    }
    
    // This would not compile if uncommented because it doesn't match the protocol
    // func process(info: String) -> Bool {
    //    return info.count > 0
    // }
}
```

## Default Implementations with Protocol Extensions

One of the most powerful features of Swift protocols is the ability to provide default implementations using protocol extensions:

```swift
protocol Describable {
    func describe() -> String
}

// Default implementation
extension Describable {
    func describe() -> String {
        return "A describable item"
    }
    
    func describeWithPrefix(prefix: String) -> String {
        return "\(prefix): \(describe())"
    }
}

struct Product: Describable {
    var name: String
    
    func describe() -> String {
        return "Product: \(name)"
    }
}

struct Service: Describable {
    // Using the default implementation
}

let laptop = Product(name: "MacBook Pro")
print(laptop.describe()) // Output: Product: MacBook Pro
print(laptop.describeWithPrefix(prefix: "Item")) // Output: Item: Product: MacBook Pro

let genericService = Service()
print(genericService.describe()) // Output: A describable item
```

Notice how:
1. `Product` provides its own implementation of `describe()`
2. `Service` uses the default implementation
3. Both types get access to `describeWithPrefix(prefix:)` without having to implement it

## Real-World Example: Data Source Protocol

Here's a real-world example showing how protocol methods can define a data source for a table-like UI component:

```swift
protocol DataSource {
    var numberOfItems: Int { get }
    func item(at index: Int) -> Any
    func title(for index: Int) -> String
    func select(at index: Int)
}

// Default implementation for optional-like behavior
extension DataSource {
    func title(for index: Int) -> String {
        return "Item \(index)"
    }
    
    func select(at index: Int) {
        print("Item at index \(index) selected")
    }
}

class ContactsDataSource: DataSource {
    private var contacts = ["Alice", "Bob", "Charlie", "David"]
    
    var numberOfItems: Int {
        return contacts.count
    }
    
    func item(at index: Int) -> Any {
        guard index < contacts.count else { return "Unknown" }
        return contacts[index]
    }
    
    func title(for index: Int) -> String {
        guard index < contacts.count else { return "Unknown" }
        return "Contact: \(contacts[index])"
    }
}

// Usage
let dataSource = ContactsDataSource()
print("Number of items: \(dataSource.numberOfItems)") // Output: Number of items: 4
print(dataSource.item(at: 1)) // Output: Bob
print(dataSource.title(for: 2)) // Output: Contact: Charlie
dataSource.select(at: 0) // Output: Item at index 0 selected
```

This pattern is similar to how iOS's `UITableViewDataSource` and similar protocols work, allowing for flexible UI components that can display different types of data.

## Protocol Methods vs. Protocol Properties

Protocol methods differ from protocol properties in a few key ways:

```swift
protocol DeviceInfo {
    // Property requirements
    var name: String { get }
    var batteryLevel: Int { get }
    
    // Method requirements
    func turnOn()
    func getDetails() -> String
}

struct Phone: DeviceInfo {
    var name: String
    var batteryLevel: Int
    private var isOn = false
    
    func turnOn() {
        // Method can contain complex logic and side effects
        print("Turning on \(name)...")
        // isOn = true
    }
    
    func getDetails() -> String {
        // Methods can compute and return values
        return "Phone: \(name), Battery: \(batteryLevel)%"
    }
}

let iPhone = Phone(name: "iPhone 14", batteryLevel: 85)
iPhone.turnOn() // Output: Turning on iPhone 14...
print(iPhone.getDetails()) // Output: Phone: iPhone 14, Battery: 85%
```

Methods in protocols are better suited for:
1. Operations that perform actions
2. Computations with parameters
3. Operations that might have side effects
4. Complex logic that shouldn't be part of a property's getter/setter

## Summary

Protocol methods are a powerful feature in Swift that allow you to define behavior requirements for conforming types. By using protocol methods, you can:

- Create flexible interfaces that can be implemented by many different types
- Establish clear contracts for type behavior
- Add default implementations to reduce code duplication
- Build extensible, modular systems

As you continue working with Swift, you'll find that protocols and protocol methods form the foundation of many design patterns and architectural approaches, making them essential tools in your Swift programming toolkit.

## Additional Resources and Exercises

### Resources
- [Swift Documentation: Protocols](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)
- [Swift by Sundell: Protocol-Oriented Programming](https://www.swiftbysundell.com/basics/protocols/)

### Exercises

1. **Basic Protocol Implementation**: Create a `Shape` protocol with methods for `area()` and `perimeter()`. Then implement it for `Circle`, `Rectangle`, and `Triangle` structs.

2. **Protocol with Mutating Methods**: Design a `Counter` protocol with `increment()`, `decrement()`, and `reset()` methods. Implement it for a `SimpleCounter` struct.

3. **Protocol Extensions**: Extend the `Sequence` protocol in Swift with a custom method called `summarize()` that prints the first 3 elements (if available) followed by "..." and then the last element.

4. **Advanced Challenge**: Create a `CacheManager` protocol with methods for storing, retrieving, and purging cached items. Implement it using different storage strategies (memory, UserDefaults, etc.).