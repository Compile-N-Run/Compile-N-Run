---
title: Swift Protocol Requirements
description: Learn how to define and implement protocol requirements in Swift, including properties, methods, and initializers.

---

# Swift Protocol Requirements

## Introduction

Protocols in Swift define a blueprint of methods, properties, and other requirements that suit a particular task or functionality. When you adopt a protocol, you're promising to implement those requirements. In this guide, we'll explore how to define protocol requirements, implement them in conforming types, and leverage them in your Swift applications.

## What are Protocol Requirements?

Protocol requirements are the specific methods, properties, initializers, or other functionalities that a type must implement to conform to a protocol. These requirements act as a contract that conforming types agree to fulfill.

Requirements can include:
- Property requirements
- Method requirements
- Initializer requirements
- Subscript requirements
- Associated types

Let's explore each of these in detail.

## Property Requirements

Protocols can require conforming types to provide specific properties, either instance properties or type properties. You can specify whether a property is read-only or read-write.

### Syntax for Property Requirements

```swift
protocol SomeProtocol {
    // Read-only property
    var readOnlyProperty: Int { get }
    
    // Read-write property
    var readWriteProperty: String { get set }
    
    // Type property
    static var typeProperty: Bool { get }
}
```

### Example: Implementing Property Requirements

```swift
protocol Vehicle {
    var numberOfWheels: Int { get }
    var description: String { get }
    static var defaultColor: String { get set }
}

class Car: Vehicle {
    // Stored property to satisfy requirement
    let numberOfWheels: Int = 4
    
    // Computed property to satisfy requirement
    var description: String {
        return "A car with \(numberOfWheels) wheels"
    }
    
    // Type property requirement
    static var defaultColor: String = "Black"
}

let myCar = Car()
print(myCar.numberOfWheels)     // Output: 4
print(myCar.description)        // Output: A car with 4 wheels
print(Car.defaultColor)         // Output: Black
```

## Method Requirements

Protocols can define instance methods and type methods that conforming types must implement.

### Syntax for Method Requirements

```swift
protocol SomeProtocol {
    // Instance method
    func someMethod() -> String
    
    // Type method
    static func someTypeMethod()
    
    // Mutating method (allows value types to modify self)
    mutating func modifySelf()
}
```

### Example: Implementing Method Requirements

```swift
protocol Togglable {
    // Mutating allows value types to change their properties
    mutating func toggle()
}

enum Switch: Togglable {
    case on, off
    
    mutating func toggle() {
        switch self {
        case .on:
            self = .off
        case .off:
            self = .on
        }
    }
}

var lightSwitch = Switch.off
print(lightSwitch)      // Output: off
lightSwitch.toggle()
print(lightSwitch)      // Output: on
```

## Initializer Requirements

Protocols can require specific initializers to be implemented by conforming types.

### Syntax for Initializer Requirements

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

### Example: Implementing Initializer Requirements

```swift
protocol Identifiable {
    var id: String { get }
    init(id: String)
}

class User: Identifiable {
    var id: String
    
    // Required marks this initializer as needed for protocol conformance
    required init(id: String) {
        self.id = id
    }
}

let newUser = User(id: "user123")
print(newUser.id)       // Output: user123
```

## Protocol Requirements for Class Inheritance

When a class conforms to a protocol, you can mark protocol initializer requirements with the `required` modifier. This ensures that subclasses also implement the initializer.

```swift
class Animal: Identifiable {
    var id: String
    
    required init(id: String) {
        self.id = id
    }
}

class Dog: Animal {
    var breed: String
    
    init(id: String, breed: String) {
        self.breed = breed
        super.init(id: id)
    }
    
    // Still need to implement the required initializer
    required init(id: String) {
        self.breed = "Unknown"
        super.init(id: id)
    }
}
```

## Optional Protocol Requirements

You can define optional requirements in protocols using the `@objc` attribute and marking requirements as `optional`. The conforming type doesn't need to implement these requirements.

```swift
@objc protocol MediaPlayer {
    // Required
    var isPlaying: Bool { get }
    
    // Optional
    @objc optional func play()
    @objc optional func pause()
}

// Must inherit from NSObject to use @objc protocols
class AudioPlayer: NSObject, MediaPlayer {
    var isPlaying: Bool = false
    
    // We implement play() but not pause()
    func play() {
        isPlaying = true
        print("Playing audio")
    }
}

let player = AudioPlayer()
player.play()           // Output: Playing audio
print(player.isPlaying) // Output: true
```

## Protocol Composition

Sometimes you need a type to conform to multiple protocols. Swift allows you to combine protocols using protocol composition.

```swift
protocol Named {
    var name: String { get }
}

protocol Aged {
    var age: Int { get }
}

struct Person: Named, Aged {
    var name: String
    var age: Int
}

func greet(person: Named & Aged) {
    print("Hello, \(person.name)! You are \(person.age) years old.")
}

let john = Person(name: "John", age: 35)
greet(person: john)     // Output: Hello, John! You are 35 years old.
```

## Protocol Extensions

Protocol extensions allow you to provide default implementations for protocol requirements.

```swift
protocol Describable {
    var description: String { get }
}

// Default implementation
extension Describable {
    var description: String {
        return "A describable item"
    }
}

struct SimpleItem: Describable {
    // Uses default implementation
}

struct CustomItem: Describable {
    // Custom implementation
    var description: String {
        return "A custom item with special description"
    }
}

let simple = SimpleItem()
let custom = CustomItem()

print(simple.description)  // Output: A describable item
print(custom.description)  // Output: A custom item with special description
```

## Real-World Application: Data Source Protocol

A common use case for protocols is to define data sources for UI components. Let's implement a simplified version of a table view data source:

```swift
// Protocol definition
protocol TableViewDataSource {
    var numberOfItems: Int { get }
    func item(at index: Int) -> String
    func didSelectItem(at index: Int)
}

// Data provider conforming to the protocol
class ContactsDataSource: TableViewDataSource {
    private let contacts = ["Alice", "Bob", "Charlie", "David"]
    
    var numberOfItems: Int {
        return contacts.count
    }
    
    func item(at index: Int) -> String {
        return contacts[index]
    }
    
    func didSelectItem(at index: Int) {
        print("Selected contact: \(contacts[index])")
    }
}

// TableView simulation that uses the data source
class TableView {
    var dataSource: TableViewDataSource
    
    init(dataSource: TableViewDataSource) {
        self.dataSource = dataSource
    }
    
    func render() {
        print("Rendering \(dataSource.numberOfItems) items:")
        for i in 0..<dataSource.numberOfItems {
            print("- \(dataSource.item(at: i))")
        }
    }
    
    func userDidSelect(index: Int) {
        dataSource.didSelectItem(at: index)
    }
}

// Usage
let contactsDataSource = ContactsDataSource()
let tableView = TableView(dataSource: contactsDataSource)

tableView.render()
// Output:
// Rendering 4 items:
// - Alice
// - Bob
// - Charlie
// - David

tableView.userDidSelect(index: 1)
// Output: Selected contact: Bob
```

This pattern is widely used in iOS development with protocols like `UITableViewDataSource` and `UICollectionViewDataSource`.

## Summary

Protocol requirements form the foundation of Swift's protocol-oriented programming paradigm. They allow you to:

1. Define contracts that other types must fulfill
2. Specify properties, methods, and initializers that conforming types must implement
3. Create flexible, reusable code that works with any type conforming to your protocols
4. Build modular systems with clear separation of concerns

By mastering protocol requirements, you gain a powerful tool for designing well-structured Swift applications with high cohesion and low coupling.

## Additional Exercises

1. Create a `Playable` protocol with requirements for `play()`, `pause()`, and `stop()` methods, along with a `currentPosition` property. Then implement it for different media types like audio and video.

2. Define a `Storable` protocol that requires conforming types to provide methods for saving to and loading from disk. Implement this protocol for a custom data type.

3. Design a protocol hierarchy for a simple game with characters that can `attack()`, `defend()`, and have properties like `health` and `power`. Create different character types that conform to these protocols.

## Further Reading

- [Swift Documentation: Protocols](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)
- [Protocol-Oriented Programming in Swift](https://developer.apple.com/videos/play/wwdc2015/408/)
- [Swift by Sundell: Protocols](https://www.swiftbysundell.com/basics/protocols/)