---
title: "Kotlin TypeCasting"
description: "Learn how type casting works in Kotlin, including safe and unsafe casts, smart casts, and type checking with practical examples."

---

# Kotlin TypeCasting

When working with different data types in Kotlin, you'll often need to convert values from one type to another. This process is called **type casting**. Kotlin provides several safe and efficient ways to perform type casting, which we'll explore in this tutorial.

## Introduction to Type Casting

Type casting allows you to treat a variable of one type as another type. In Kotlin, type casting is more robust and safer compared to Java, helping you avoid common runtime errors such as `ClassCastException`.

Kotlin supports:
- **Smart casts**: Automatic casts performed by the compiler
- **Safe casts**: Using the `as?` operator
- **Unsafe casts**: Using the `as` operator
- **Type checking**: Using the `is` and `!is` operators

## Type Checking with `is` and `!is`

Before casting, you often need to check whether an object is of a specific type. Kotlin provides the `is` and `!is` operators for this purpose.

```kotlin
fun checkType(obj: Any) {
    if (obj is String) {
        println("The object is a String")
    } else if (obj is Int) {
        println("The object is an Integer")
    } else {
        println("The object is of type ${obj.javaClass.simpleName}")
    }
}

fun main() {
    checkType("Hello")  // Output: The object is a String
    checkType(42)       // Output: The object is an Integer
    checkType(3.14)     // Output: The object is of type Double
}
```

The `!is` operator checks if an object is NOT of a specific type:

```kotlin
fun isNotString(obj: Any): Boolean {
    return obj !is String
}

fun main() {
    println(isNotString("Hello"))  // Output: false
    println(isNotString(42))       // Output: true
}
```

## Smart Casts

One of Kotlin's most powerful features is smart casting. After you check a type with `is`, the compiler automatically casts the object to that type within the scope where the check is true.

```kotlin
fun processValue(value: Any) {
    // First, we check if the value is a String
    if (value is String) {
        // Inside this block, 'value' is automatically cast to String
        // No explicit casting is needed
        println("String value with length ${value.length}")
        println("Uppercase: ${value.uppercase()}")
    } 
    // Here 'value' is back to type Any
}

fun main() {
    processValue("Kotlin")
    /* Output:
    String value with length 6
    Uppercase: KOTLIN
    */
}
```

Smart casts work with `&&`, `||`, and `!` operators:

```kotlin
fun smartCastWithOperators(obj: Any) {
    // Smart cast works with logical operators
    if (obj is String && obj.length > 0) {
        println("Non-empty string: $obj")
    }
}

fun main() {
    smartCastWithOperators("Hello")  // Output: Non-empty string: Hello
    smartCastWithOperators("")       // No output
}
```

## Unsafe Cast with `as` Operator

You can explicitly cast an object using the `as` operator. However, this is considered "unsafe" because it will throw a `ClassCastException` if the cast is not possible.

```kotlin
fun unsafeCast(value: Any) {
    try {
        val str = value as String  // Unsafe cast
        println("Successfully cast to String: $str")
    } catch (e: ClassCastException) {
        println("Cannot cast ${value.javaClass.simpleName} to String")
    }
}

fun main() {
    unsafeCast("Hello")  // Output: Successfully cast to String: Hello
    unsafeCast(42)       // Output: Cannot cast Integer to String
}
```

## Safe Cast with `as?` Operator

To avoid exceptions, Kotlin provides the `as?` operator for safe casting. It returns `null` if the cast is not possible instead of throwing an exception.

```kotlin
fun safeCast(value: Any) {
    val str = value as? String  // Safe cast
    if (str != null) {
        println("Successfully cast to String: $str")
    } else {
        println("Could not cast ${value.javaClass.simpleName} to String")
    }
}

fun main() {
    safeCast("Hello")  // Output: Successfully cast to String: Hello
    safeCast(42)       // Output: Could not cast Integer to String
}
```

## Combining Safe Cast with Elvis Operator

A common pattern is to combine safe casting with the Elvis operator (`?:`) to provide default values or alternative actions:

```kotlin
fun processString(value: Any) {
    // Try to cast to String, or use a default if casting fails
    val str = (value as? String) ?: "Default string"
    println("Processing string: $str")
}

fun main() {
    processString("Hello")  // Output: Processing string: Hello
    processString(42)       // Output: Processing string: Default string
}
```

## Practical Example: Handling Different UI Elements

Let's see a practical example where type casting is useful, like in a UI system where you need to handle different types of elements:

```kotlin
// Base UI element class
open class UIElement(val id: String)

// Specific UI elements
class Button(id: String, val label: String) : UIElement(id)
class TextField(id: String, val text: String, val maxLength: Int) : UIElement(id)
class Checkbox(id: String, val isChecked: Boolean) : UIElement(id)

// Function to process UI elements
fun processElement(element: UIElement) {
    println("Processing element with ID: ${element.id}")
    
    when (element) {
        is Button -> {
            // Smart cast to Button
            println("Button with label: ${element.label}")
            println("Simulating button click")
        }
        is TextField -> {
            // Smart cast to TextField
            println("Text field with content: ${element.text}")
            println("Max length: ${element.maxLength}")
        }
        is Checkbox -> {
            // Smart cast to Checkbox
            val status = if (element.isChecked) "checked" else "unchecked" 
            println("Checkbox is $status")
        }
        else -> {
            println("Unknown UI element type")
        }
    }
    println()
}

fun main() {
    val button = Button("btn-submit", "Submit Form")
    val textField = TextField("txt-name", "John Doe", 50)
    val checkbox = Checkbox("chk-terms", true)
    
    val elements = listOf(button, textField, checkbox)
    
    for (element in elements) {
        processElement(element)
    }
}
```

Output:
```
Processing element with ID: btn-submit
Button with label: Submit Form
Simulating button click

Processing element with ID: txt-name
Text field with content: John Doe
Max length: 50

Processing element with ID: chk-terms
Checkbox is checked
```

## Converting Between Primitive Types

For primitive types, Kotlin provides specific conversion functions:

```kotlin
fun primitiveConversions() {
    val intValue = 42
    
    // Integer to other types
    val longValue: Long = intValue.toLong()
    val doubleValue: Double = intValue.toDouble()
    val floatValue: Float = intValue.toFloat()
    val shortValue: Short = intValue.toShort()
    val byteValue: Byte = intValue.toByte()
    val stringValue: String = intValue.toString()
    
    println("Integer: $intValue")
    println("Long: $longValue")
    println("Double: $doubleValue")
    println("Float: $floatValue")
    println("Short: $shortValue")
    println("Byte: $byteValue")
    println("String: $stringValue")
    
    // String to Number
    val numericString = "123.45"
    val parsedDouble = numericString.toDouble()
    val parsedInt = parsedDouble.toInt() // Truncates the decimal part
    
    println("String to Double: $parsedDouble")
    println("Double to Int (truncated): $parsedInt")
}

fun main() {
    primitiveConversions()
}
```

Output:
```
Integer: 42
Long: 42
Double: 42.0
Float: 42.0
Short: 42
Byte: 42
String: 42
String to Double: 123.45
Double to Int (truncated): 123
```

## Summary

Kotlin's type casting system provides several mechanisms for safely converting between types:

- **Type checking** with `is` and `!is` operators to verify an object's type
- **Smart casts** that automatically cast objects after type checking
- **Unsafe casting** with the `as` operator (which can throw exceptions)
- **Safe casting** with the `as?` operator (which returns null on failure)
- **Primitive conversion functions** like `toInt()`, `toString()`, etc.

By using these features, you can write safer, more expressive code that avoids common runtime errors while still working with different types of data.

## Additional Resources and Exercises

### Resources
- [Kotlin Official Documentation on Type Checks and Casts](https://kotlinlang.org/docs/typecasts.html)
- [Kotlin Koans: Smart Casts](https://play.kotlinlang.org/koans/Introduction/Smart%20casts/Task.kt)

### Exercises

1. Create a function that takes an `Any` parameter and safely extracts a number from it (handle both numeric types and strings containing numbers).

2. Implement a function that takes a list of `Any` objects and returns the sum of all numbers in the list (integers, doubles, etc.), ignoring non-numeric values.

3. Create a simple class hierarchy with a base class and several subclasses. Then write a function that takes the base class type and performs different actions based on the actual runtime type of the object.

4. Write a function that safely converts a string to an integer, returning a default value if the conversion fails.

Remember, effective type casting is about ensuring type safety while still maintaining the flexibility to work with different types when needed.