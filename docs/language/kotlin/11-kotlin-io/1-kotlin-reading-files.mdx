---
title: "Kotlin Reading Files"
description: "Learn how to read files in Kotlin using different techniques, from basic file reading to more advanced operations with buffered readers and streams"

---

# Kotlin Reading Files

In modern applications, reading data from files is a common operation. Whether you're parsing configuration files, processing user-uploaded content, or analyzing datasets, Kotlin provides several convenient ways to read files. This guide will walk you through various file reading techniques in Kotlin, from simple one-liners to more complex streaming operations.

## Introduction to File Reading in Kotlin

File reading operations in Kotlin are built on top of Java's I/O libraries but offer more concise syntax and additional helper functions. The Kotlin standard library provides extensions that make reading files more straightforward and less error-prone than traditional Java approaches.

Before we dive into the examples, it's important to understand that file operations can throw exceptions, especially when files don't exist or can't be accessed. In this guide, we'll show proper error handling techniques alongside the reading operations.

## Basic File Reading Operations

### Reading an Entire File as a String

The simplest way to read a file in Kotlin is to use the `readText()` extension function:

```kotlin
import java.io.File

fun main() {
    try {
        val content = File("sample.txt").readText()
        println("File content:")
        println(content)
    } catch (e: Exception) {
        println("Error reading file: ${e.message}")
    }
}
```

**Output (Assuming sample.txt contains "Hello, Kotlin!"):**
```
File content:
Hello, Kotlin!
```

This approach is excellent for small files but not recommended for large files as it loads the entire content into memory at once.

### Reading a File Line by Line

To read a file line by line, you can use the `readLines()` function:

```kotlin
import java.io.File

fun main() {
    try {
        val lines = File("sample.txt").readLines()
        println("File contains ${lines.size} lines:")
        lines.forEachIndexed { index, line ->
            println("${index + 1}: $line")
        }
    } catch (e: Exception) {
        println("Error reading file: ${e.message}")
    }
}
```

**Output (Assuming sample.txt contains multiple lines):**
```
File contains 3 lines:
1: Hello, Kotlin!
2: This is a sample file.
3: We're learning how to read files.
```

### Reading a File as Bytes

Sometimes you need to read binary files. Kotlin provides the `readBytes()` function:

```kotlin
import java.io.File

fun main() {
    try {
        val bytes = File("image.png").readBytes()
        println("Read ${bytes.size} bytes from the file")
        // Process the bytes as needed
    } catch (e: Exception) {
        println("Error reading file: ${e.message}")
    }
}
```

## Advanced File Reading Techniques

### Using BufferedReader for Efficient Reading

For larger files, using a `BufferedReader` is more memory-efficient:

```kotlin
import java.io.BufferedReader
import java.io.File
import java.io.FileReader

fun main() {
    val file = File("large_file.txt")
    
    BufferedReader(FileReader(file)).use { reader ->
        var line: String?
        var lineCount = 0
        
        while (reader.readLine().also { line = it } != null) {
            lineCount++
            // Process each line
            println("Line $lineCount: ${line?.substring(0, minOf(line?.length ?: 0, 20))}...")
        }
        
        println("Processed $lineCount lines")
    }
}
```

The `use` function ensures that the reader is properly closed after reading, even if an exception occurs.

### Using Kotlin's Sequence API for Stream Processing

Kotlin's Sequence API allows for efficient processing of large files without loading everything into memory:

```kotlin
import java.io.File

fun main() {
    File("large_file.txt").useLines { lines ->
        // Find lines containing "Kotlin"
        val kotlinLines = lines.filter { it.contains("Kotlin") }
            .toList()
        
        println("Found ${kotlinLines.size} lines containing 'Kotlin'")
        kotlinLines.take(3).forEach { println(it) }
    }
}
```

The `useLines` function opens the file, processes the lines as a sequence, and automatically closes the file afterward.

## Reading Specific File Types

### Reading CSV Files

CSV files are common for data processing. Here's how to read a simple CSV file:

```kotlin
import java.io.File

fun main() {
    File("data.csv").useLines { lines ->
        // Skip header line
        val data = lines.drop(1).map { line ->
            val fields = line.split(",")
            fields // Or transform into a data class
        }.toList()
        
        println("Read ${data.size} data rows")
        data.take(3).forEach { println(it) }
    }
}
```

### Reading JSON Files

To read JSON files, you'll typically use a library like Gson or Kotlinx Serialization:

```kotlin
import kotlinx.serialization.json.Json
import kotlinx.serialization.Serializable
import java.io.File

@Serializable
data class Person(val name: String, val age: Int, val email: String)

fun main() {
    // You need to add kotlinx.serialization dependency to your project
    val jsonString = File("people.json").readText()
    
    try {
        val people = Json.decodeFromString<List<Person>>(jsonString)
        println("Loaded ${people.size} people:")
        people.forEach { person ->
            println("${person.name} (${person.age}) - ${person.email}")
        }
    } catch (e: Exception) {
        println("Error parsing JSON: ${e.message}")
    }
}
```

## Reading Files from Resources

In JVM applications, especially with frameworks like Spring Boot, you often need to read files from the classpath resources:

```kotlin
fun main() {
    val resourceName = "config.properties"
    val inputStream = Thread.currentThread().contextClassLoader.getResourceAsStream(resourceName)
    
    if (inputStream != null) {
        val content = inputStream.bufferedReader().use { it.readText() }
        println("Resource content:")
        println(content)
    } else {
        println("Resource not found: $resourceName")
    }
}
```

## Real-World Example: Log File Analyzer

Here's a practical example that analyzes a log file to extract and summarize error messages:

```kotlin
import java.io.File
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

fun main() {
    val logFile = File("application.log")
    
    if (!logFile.exists()) {
        println("Log file not found")
        return
    }
    
    val errorPattern = Regex("(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) \\[ERROR\\] (.+)")
    val dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
    
    val errors = mutableListOf<Pair<LocalDateTime, String>>()
    
    logFile.useLines { lines ->
        lines.forEach { line ->
            val matchResult = errorPattern.find(line)
            if (matchResult != null) {
                val (dateStr, message) = matchResult.destructured
                val dateTime = LocalDateTime.parse(dateStr, dateFormatter)
                errors.add(dateTime to message)
            }
        }
    }
    
    println("Found ${errors.size} error messages in the log file")
    
    if (errors.isNotEmpty()) {
        println("\nMost recent errors:")
        errors.sortedByDescending { it.first }
            .take(5)
            .forEach { (dateTime, message) ->
                println("${dateTime.format(dateFormatter)}: $message")
            }
        
        // Count errors by hour
        val errorsByHour = errors.groupBy { it.first.hour }
            .mapValues { it.value.size }
            .toSortedMap()
        
        println("\nErrors by hour:")
        errorsByHour.forEach { (hour, count) ->
            println("$hour:00 - ${String.format("%02d", (hour + 1) % 24)}:00: $count errors")
        }
    }
}
```

This example:
1. Parses a log file looking for error messages
2. Extracts the timestamp and message from each error
3. Displays the most recent errors
4. Shows a distribution of errors by hour

## Summary

Kotlin provides numerous ways to read files, from simple one-liners to more complex streaming operations. The choice of method depends on your specific requirements:

- Use `readText()` or `readLines()` for small files
- Use `BufferedReader` or `useLines()` for large files
- Choose appropriate specialized methods for specific file formats (CSV, JSON, etc.)

Remember to always handle exceptions and properly close resources when working with files. Kotlin's extension functions like `use` and `useLines` make this easier by automatically managing resource cleanup.

## Exercises

1. Create a program that counts the frequency of each word in a text file.
2. Write a function that reads a CSV file and converts it to a list of custom objects.
3. Implement a log file analyzer that finds patterns in timestamps (e.g., periods of high activity).
4. Create a program that merges multiple text files into a single file.
5. Write a function that reads a large file in chunks of specified size and processes each chunk separately.

## Additional Resources

- [Kotlin Documentation on I/O](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/)
- [Java NIO for Advanced File Operations](https://docs.oracle.com/javase/tutorial/essential/io/fileio.html)
- [Kotlinx Serialization](https://github.com/Kotlin/kotlinx.serialization) for working with structured data formats
- [Apache Commons IO](https://commons.apache.org/proper/commons-io/) for additional file utilities

With these tools and techniques, you'll be well-equipped to handle file reading operations in your Kotlin applications!