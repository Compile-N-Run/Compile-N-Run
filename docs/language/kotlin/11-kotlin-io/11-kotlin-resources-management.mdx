---
title: Kotlin Resources Management
description: Learn how to efficiently manage resources like files and streams in Kotlin to prevent memory leaks and ensure proper cleanup

---

# Kotlin Resources Management

## Introduction

When working with external resources in any programming language, such as files, network connections, or database connections, it's crucial to properly manage these resources. Improper resource management can lead to resource leaks, which may cause your application to consume excessive memory or even crash.

In this tutorial, we'll explore how Kotlin handles resource management, particularly for I/O operations. We'll cover Kotlin's elegant solutions for ensuring resources are properly closed after use, preventing memory leaks, and maintaining application stability.

## Why Resource Management Matters

Before diving into Kotlin's approaches, let's understand why proper resource management is essential:

1. **Memory Efficiency**: Unclosed resources can lead to memory leaks.
2. **System Resource Limits**: Operating systems limit the number of open files and connections.
3. **Data Integrity**: Improperly closed resources might lead to incomplete or corrupted data.

## Basic Resource Management in Kotlin

### The Traditional Approach with `try-finally`

In many programming languages, resources are managed using a try-finally block:

```kotlin
fun readFirstLine(path: String): String {
    val reader = BufferedReader(FileReader(path))
    try {
        return reader.readLine()
    } finally {
        reader.close()
    }
}
```

While this works, it's verbose and error-prone. What happens if an exception occurs during `close()`? It would overshadow the original exception that might have occurred in the `try` block.

## The Kotlin Way: `use` Function

Kotlin provides a concise and safe way to manage resources through the `use` extension function, which is available for all `Closeable` resources.

### Basic Usage of `use`

```kotlin
fun readFirstLine(path: String): String {
    BufferedReader(FileReader(path)).use { reader ->
        return reader.readLine()
    }
}
```

The `use` function automatically closes the resource after the block completes, even if an exception occurs. This is equivalent to the try-with-resources construct in Java but with a more elegant syntax.

### How `use` Works

Under the hood, the `use` function:
1. Executes the provided lambda with the resource as a parameter
2. Ensures the resource's `close()` method is called when the lambda completes
3. Properly handles exceptions so that exceptions in the `close()` method don't overshadow original exceptions

### Example: Reading a File with `use`

```kotlin
fun readFile(path: String): List<String> {
    val lines = mutableListOf<String>()
    
    File(path).bufferedReader().use { reader ->
        reader.forEachLine { line ->
            lines.add(line)
        }
    }
    
    return lines
}
```

**Input**: A text file named "example.txt" containing:
```
Hello
Kotlin
Resources
```

**Output**:
```
[Hello, Kotlin, Resources]
```

## Multiple Resources with `use`

When working with multiple resources, you can nest `use` blocks:

```kotlin
fun copyFile(source: String, destination: String) {
    File(source).inputStream().use { input ->
        File(destination).outputStream().use { output ->
            input.copyTo(output)
        }
    }
}
```

### Using Kotlin's Destructuring for Cleaner Syntax

For even cleaner code when dealing with multiple resources, you can use Kotlin's destructuring declarations along with an extension function:

```kotlin
inline fun <T : Closeable, U : Closeable, R> useBoth(first: T, second: U, block: (T, U) -> R): R {
    first.use { firstItem ->
        second.use { secondItem ->
            return block(firstItem, secondItem)
        }
    }
}

fun copyFileImproved(source: String, destination: String) {
    val input = File(source).inputStream()
    val output = File(destination).outputStream()
    
    useBoth(input, output) { inp, out ->
        inp.copyTo(out)
    }
}
```

## Resource Management for Custom Types

You can make your own classes compatible with the `use` function by implementing the `Closeable` or `AutoCloseable` interface.

```kotlin
class DatabaseConnection(private val connectionString: String) : Closeable {
    init {
        println("Opening connection to $connectionString")
        // Connection opening logic
    }
    
    fun executeQuery(query: String): List<String> {
        println("Executing: $query")
        return listOf("Result 1", "Result 2")
    }
    
    override fun close() {
        println("Closing database connection")
        // Resource cleanup logic
    }
}

fun main() {
    DatabaseConnection("jdbc:mysql://localhost/test").use { connection ->
        val results = connection.executeQuery("SELECT * FROM users")
        println("Query results: $results")
    }
}
```

**Output**:
```
Opening connection to jdbc:mysql://localhost/test
Executing: SELECT * FROM users
Query results: [Result 1, Result 2]
Closing database connection
```

## Real-World Example: Processing Large Files

Let's look at a practical example where proper resource management is crucial - processing a large file line by line without loading it entirely into memory:

```kotlin
fun countWordsInFile(filePath: String): Map<String, Int> {
    val wordCounts = mutableMapOf<String, Int>()
    
    File(filePath).bufferedReader().use { reader ->
        reader.forEachLine { line ->
            line.split(Regex("\\s+")).forEach { word ->
                val cleanWord = word.trim().lowercase()
                if (cleanWord.isNotEmpty()) {
                    wordCounts[cleanWord] = wordCounts.getOrDefault(cleanWord, 0) + 1
                }
            }
        }
    }
    
    return wordCounts
}
```

For a large log file, this function would efficiently count word occurrences without excessive memory usage because:
1. It processes the file line by line rather than loading it entirely
2. The `use` function ensures the file handle is properly released
3. Only the word count map is stored in memory

## Beyond Files: Other Closeable Resources

The `use` function works with any resource that implements `Closeable`, including:

### Network Connections

```kotlin
fun fetchUrl(urlString: String): String {
    val url = URL(urlString)
    return url.openConnection().getInputStream().use { inputStream ->
        inputStream.bufferedReader().readText()
    }
}
```

### Database Connections

```kotlin
fun executeQuery(query: String): List<Map<String, Any>> {
    val results = mutableListOf<Map<String, Any>>()
    
    connection.use { conn ->
        conn.createStatement().use { statement ->
            statement.executeQuery(query).use { resultSet ->
                while (resultSet.next()) {
                    val row = mutableMapOf<String, Any>()
                    for (i in 1..resultSet.metaData.columnCount) {
                        val columnName = resultSet.metaData.getColumnName(i)
                        row[columnName] = resultSet.getObject(i)
                    }
                    results.add(row)
                }
            }
        }
    }
    
    return results
}
```

## Advanced Patterns

### Deferred Resource Cleanup

Sometimes you need to create a resource and return it for use elsewhere. In these cases, the caller should handle closing:

```kotlin
fun createReader(path: String): BufferedReader {
    return File(path).bufferedReader()
}

fun processFile(path: String) {
    createReader(path).use { reader ->
        // Process the file
    }
}
```

### Creating Your Own Use-like Extensions

You can create your own extension functions similar to `use` for types that have different cleanup methods:

```kotlin
inline fun <T : Lock, R> T.withLock(block: () -> R): R {
    lock()
    try {
        return block()
    } finally {
        unlock()
    }
}

fun processSharedResource(lock: ReentrantLock) {
    lock.withLock {
        // Access shared resource safely
    }
}
```

## Summary

Kotlin provides elegant solutions for resource management:

1. The `use` extension function automatically closes resources, even when exceptions occur
2. It works with any class implementing `Closeable` or `AutoCloseable`
3. Resources are closed in the reverse order they were opened when nesting `use` blocks
4. Custom types can be made compatible by implementing the `Closeable` interface

By following these patterns, you can write safer, more concise code that properly manages external resources like files, network connections, and database connections.

## Exercises

1. Write a function that reads a CSV file and converts it to a list of objects using the `use` function.
2. Create a custom `Closeable` class representing a logging system and use it with the `use` function.
3. Implement a function that merges multiple text files into one using proper resource management.
4. Write an extension function similar to `use` but for resources that need to be "reset" instead of closed.
5. Refactor the following code to use proper resource management:
   ```kotlin
   fun readAndWriteFile(input: String, output: String) {
       val reader = BufferedReader(FileReader(input))
       val writer = BufferedWriter(FileWriter(output))
       
       var line = reader.readLine()
       while (line != null) {
           writer.write(line)
           writer.newLine()
           line = reader.readLine()
       }
       
       reader.close()
       writer.close()
   }
   ```

## Additional Resources

- [Kotlin Documentation on Closeable](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/-closeable/)
- [Java AutoCloseable Interface](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html)
- [Effective Resource Management in Kotlin](https://www.baeldung.com/kotlin-closeable-resource)
- [Kotlin Standard Library use function source code](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/io/Closeable.kt)