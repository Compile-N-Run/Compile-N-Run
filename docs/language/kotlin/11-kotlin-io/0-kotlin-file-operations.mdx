---
title: Kotlin File Operations
description: Learn how to perform basic and advanced file operations in Kotlin including reading, writing, and manipulating files and directories.

---

# Kotlin File Operations

File operations are a fundamental part of many applications, from simple data storage to complex document management systems. Kotlin provides a rich set of APIs to work with files and directories, making it easy to perform common tasks like reading, writing, and managing file systems.

## Introduction to Kotlin File Operations

In Kotlin, file operations are primarily handled through the `java.io` and `kotlin.io` packages. Kotlin builds upon Java's file handling capabilities while providing more concise and expressive APIs. This makes working with files more intuitive and less error-prone.

Before diving into specific operations, it's important to understand that Kotlin treats files as objects, representing them using the `File` class from the Java standard library. The Kotlin standard library extends this class with additional functionality through extension functions.

## Basic File Concepts

### The File Class

The `File` class is the primary entry point for file operations in Kotlin:

```kotlin
import java.io.File

// Create a File object
val file = File("example.txt")
```

A `File` object can represent either an existing file or directory, or a new one that you plan to create.

## Reading Files in Kotlin

Kotlin offers multiple approaches for reading files, from simple one-liners to more complex streaming operations.

### Reading a File as a String

To read an entire file as a single string:

```kotlin
val content = File("example.txt").readText()
println(content)
```

**Output (assuming example.txt contains "Hello, Kotlin!"):**
```
Hello, Kotlin!
```

### Reading a File Line by Line

For larger files, it's often better to process files line by line:

```kotlin
File("example.txt").forEachLine { line ->
    println("Line: $line")
}
```

**Output:**
```
Line: Hello, Kotlin!
Line: File operations are fun!
```

### Reading as a List of Lines

If you need to process lines as a collection:

```kotlin
val lines = File("example.txt").readLines()
println("The file has ${lines.size} lines")
lines.forEach { println(it) }
```

### Using Buffered Reader

For more control over the reading process:

```kotlin
File("example.txt").bufferedReader().use { reader ->
    var line: String?
    while (reader.readLine().also { line = it } != null) {
        println(line)
    }
}
```

The `use` function ensures the reader is properly closed after usage, even if an exception occurs.

## Writing Files in Kotlin

Kotlin simplifies file writing operations with several convenient methods.

### Writing a String to a File

To write a simple string to a file:

```kotlin
File("output.txt").writeText("Hello, File Operations!")
```

This will create the file if it doesn't exist, or overwrite it if it does.

### Appending to a File

To add content to the end of a file without erasing existing content:

```kotlin
File("log.txt").appendText("\nNew log entry: " + java.time.LocalDateTime.now())
```

### Writing Lines to a File

To write multiple lines at once:

```kotlin
val lines = listOf("First line", "Second line", "Third line")
File("lines.txt").writeLines(lines)
```

### Using Buffered Writer

For more control over the writing process:

```kotlin
File("detailed.txt").bufferedWriter().use { writer ->
    writer.write("Line 1\n")
    writer.write("Line 2\n")
    writer.write("Line 3\n")
}
```

## File Management Operations

Beyond reading and writing, Kotlin provides numerous operations for managing files and directories.

### Checking if a File Exists

```kotlin
val file = File("example.txt")
if (file.exists()) {
    println("The file exists!")
} else {
    println("The file does not exist!")
}
```

### Creating Files and Directories

```kotlin
// Create a new file
val newFile = File("new_file.txt")
val created = newFile.createNewFile()
println("File created: $created")

// Create a directory
val directory = File("new_directory")
val dirCreated = directory.mkdir()
println("Directory created: $dirCreated")

// Create multiple nested directories
val nestedDirs = File("parent/child/grandchild")
val nestedCreated = nestedDirs.mkdirs()
println("Nested directories created: $nestedCreated")
```

### Deleting Files

```kotlin
val fileToDelete = File("temporary.txt")
if (fileToDelete.exists()) {
    val deleted = fileToDelete.delete()
    println("File deleted: $deleted")
}
```

### Renaming or Moving Files

```kotlin
val source = File("old_name.txt")
val destination = File("new_name.txt")

// Rename/move the file
val success = source.renameTo(destination)
println("File renamed: $success")
```

### Listing Directory Contents

```kotlin
val directory = File("src")
if (directory.isDirectory) {
    val contents = directory.listFiles()
    println("Directory contains ${contents?.size ?: 0} items:")
    contents?.forEach { println(it.name) }
}
```

## Working with File Paths

Kotlin provides utilities for working with file paths, making it easier to navigate the file system.

### Getting Absolute and Canonical Paths

```kotlin
val file = File("example.txt")
println("Absolute path: ${file.absolutePath}")
println("Canonical path: ${file.canonicalPath}")
```

### Working with Path Components

```kotlin
val file = File("/home/user/documents/report.pdf")
println("Name: ${file.name}")               // report.pdf
println("Parent: ${file.parent}")           // /home/user/documents
println("Extension: ${file.extension}")     // pdf
println("Name without extension: ${file.nameWithoutExtension}") // report
```

## Real-World Examples

Let's look at some practical applications of file operations in Kotlin.

### Example 1: Simple Log Parser

This example reads a log file, filters specific entries, and exports them to a new file:

```kotlin
fun parseLogFile(inputPath: String, outputPath: String, searchTerm: String) {
    val input = File(inputPath)
    val output = File(outputPath)
    
    if (!input.exists()) {
        println("Input file does not exist!")
        return
    }
    
    val matchingLines = input.readLines().filter { it.contains(searchTerm) }
    
    output.writeText("Found ${matchingLines.size} entries containing '$searchTerm':\n\n")
    output.appendText(matchingLines.joinToString("\n"))
    
    println("Log parsing complete. Results saved to ${output.absolutePath}")
}

// Usage
parseLogFile("application.log", "errors.txt", "ERROR")
```

### Example 2: Directory Size Calculator

This example calculates the total size of files in a directory:

```kotlin
fun calculateDirectorySize(directoryPath: String): Long {
    val directory = File(directoryPath)
    
    if (!directory.exists() || !directory.isDirectory) {
        println("Invalid directory path!")
        return 0
    }
    
    var totalSize = 0L
    
    directory.walkTopDown().filter { it.isFile }.forEach { file ->
        totalSize += file.length()
    }
    
    return totalSize
}

// Usage
val dirPath = "src/main/resources"
val size = calculateDirectorySize(dirPath)
println("Total size of $dirPath: ${size / 1024} KB")
```

### Example 3: CSV File Processor

This example reads a CSV file, processes each row, and writes the results to a new file:

```kotlin
fun processCsvFile(inputPath: String, outputPath: String) {
    val input = File(inputPath)
    val output = File(outputPath)
    
    val processedLines = mutableListOf<String>()
    
    // Add header to output file
    processedLines.add("ID,Name,Score,Grade")
    
    // Process each line (skip header)
    input.readLines().drop(1).forEach { line ->
        val columns = line.split(",")
        if (columns.size >= 3) {
            val id = columns[0]
            val name = columns[1]
            val score = columns[2].toDoubleOrNull() ?: 0.0
            
            // Calculate grade based on score
            val grade = when {
                score >= 90 -> "A"
                score >= 80 -> "B"
                score >= 70 -> "C"
                score >= 60 -> "D"
                else -> "F"
            }
            
            processedLines.add("$id,$name,$score,$grade")
        }
    }
    
    // Write results to output file
    output.writeLines(processedLines)
    println("CSV processing complete. Results saved to ${output.absolutePath}")
}

// Usage
processCsvFile("students.csv", "grades.csv")
```

## Best Practices for File Operations

When working with files in Kotlin, keep these best practices in mind:

1. **Always close resources**: Use the `use` function for resources like readers and writers to ensure they're properly closed.
2. **Handle exceptions**: File operations can fail for various reasons. Always handle potential exceptions.
3. **Check file existence**: Before attempting to read or modify a file, check if it exists.
4. **Use buffered operations**: For large files, use buffered readers and writers for better performance.
5. **Consider thread safety**: If multiple threads access the same file, implement proper synchronization.

## Summary

Kotlin provides a comprehensive set of tools for file operations, making it easy to read, write, and manage files in your applications. By using Kotlin's extension functions on the Java File class, you can write more concise and expressive code.

In this guide, we covered:
- Reading files using various methods
- Writing and appending to files
- Managing file system operations like creating, deleting, and renaming files
- Working with file paths and properties
- Real-world examples of file operations in action

File operations are a fundamental skill for any developer, and Kotlin's approach makes these operations straightforward and less error-prone.

## Additional Resources and Exercises

### Resources
- [Kotlin Official Documentation on I/O](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/)
- [Java File API Documentation](https://docs.oracle.com/javase/8/docs/api/java/io/File.html)
- [Kotlin Input/Output on GitHub](https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib/jvm/src/kotlin/io)

### Exercises

1. **File Copy Utility**: Create a function that copies a file from one location to another, showing progress as a percentage.
2. **Text File Analyzer**: Write a program that analyzes a text file and returns statistics like word count, character count, and frequency of each word.
3. **Directory Backup Tool**: Create a utility that backs up a directory by copying all its contents to another location, preserving the directory structure.
4. **File Watcher**: Implement a simple file watcher that monitors a specific file or directory for changes and logs when modifications occur.
5. **Binary File Handler**: Write functions to read and write binary data (like integers, doubles) to a file using DataInputStream and DataOutputStream.

Try these exercises to strengthen your understanding of file operations in Kotlin!