---
title: "Kotlin LiveData"
description: "Learn how to use LiveData in Kotlin Android development to build lifecycle-aware, responsive UI components that automatically update when underlying data changes."

---

# Kotlin LiveData

## Introduction

LiveData is one of the core components of Android Jetpack's Architecture Components. It's an observable data holder class that is lifecycle-aware, which means it respects the lifecycle of other app components, such as activities, fragments, or services. This awareness ensures LiveData only updates app component observers that are in an active lifecycle state, helping you avoid memory leaks and crashes.

In this tutorial, we'll explore how to use LiveData in Kotlin Android applications, its benefits, and practical implementations that will help you build more robust, maintainable apps.

## What is LiveData?

LiveData is an observable data holder that:

- Is **lifecycle-aware**: It only notifies observers that are in an active lifecycle state
- Automatically cleans up when the lifecycle is destroyed
- Ensures your UI matches your data state
- Handles configuration changes properly
- Shares resources efficiently (you can have a single source of truth)

## Getting Started with LiveData

### Setting Up Dependencies

First, make sure to include the necessary dependencies in your app's `build.gradle` file:

```gradle
dependencies {
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.6.1"
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.1"
}
```

### Creating a LiveData Object

The simplest way to create a LiveData object is to use the `MutableLiveData` class:

```kotlin
// Inside a ViewModel
private val _counter = MutableLiveData<Int>(0)
val counter: LiveData<Int> = _counter
```

Here we're following an important pattern:
1. `_counter` is a mutable version that the ViewModel can modify
2. `counter` is an immutable LiveData that we expose to observers

### Observing LiveData

To observe LiveData changes, you use the `observe()` method, providing a `LifecycleOwner` (like an Activity or Fragment) and an observer:

```kotlin
// In an Activity or Fragment
viewModel.counter.observe(this) { newValue ->
    // Update UI with the new value
    counterTextView.text = "Count: $newValue"
}
```

### Modifying LiveData Values

To update the value in a `MutableLiveData` object, you use the `setValue()` method (or `postValue()` for background threads):

```kotlin
// Inside the ViewModel
fun incrementCounter() {
    _counter.value = (_counter.value ?: 0) + 1
}
```

## Practical Example: A Counter App

Let's create a simple counter application that demonstrates LiveData in action.

### Step 1: Create the ViewModel

```kotlin
class CounterViewModel : ViewModel() {
    // Mutable LiveData, private to the ViewModel
    private val _count = MutableLiveData<Int>(0)
    
    // Public immutable LiveData exposed to observers
    val count: LiveData<Int> = _count
    
    fun increment() {
        _count.value = (_count.value ?: 0) + 1
    }
    
    fun decrement() {
        _count.value = (_count.value ?: 0) - 1
    }
    
    fun reset() {
        _count.value = 0
    }
}
```

### Step 2: Set up the UI (activity_main.xml)

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/countTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="0"
        android:textSize="40sp"
        app:layout_constraintBottom_toTopOf="@+id/buttonLayout"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toTopOf="parent" />

    <LinearLayout
        android:id="@+id/buttonLayout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintTop_toBottomOf="@+id/countTextView">

        <Button
            android:id="@+id/decrementButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="-"
            android:layout_margin="8dp" />

        <Button
            android:id="@+id/resetButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Reset"
            android:layout_margin="8dp" />

        <Button
            android:id="@+id/incrementButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="+"
            android:layout_margin="8dp" />
    </LinearLayout>

</androidx.constraintlayout.widget.ConstraintLayout>
```

### Step 3: Implement the Activity

```kotlin
class MainActivity : AppCompatActivity() {
    
    private lateinit var viewModel: CounterViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Initialize ViewModel
        viewModel = ViewModelProvider(this)[CounterViewModel::class.java]
        
        // Setup UI elements
        val countTextView = findViewById<TextView>(R.id.countTextView)
        val incrementButton = findViewById<Button>(R.id.incrementButton)
        val decrementButton = findViewById<Button>(R.id.decrementButton)
        val resetButton = findViewById<Button>(R.id.resetButton)
        
        // Observe the LiveData
        viewModel.count.observe(this) { newCount ->
            countTextView.text = newCount.toString()
        }
        
        // Set up button click listeners
        incrementButton.setOnClickListener { viewModel.increment() }
        decrementButton.setOnClickListener { viewModel.decrement() }
        resetButton.setOnClickListener { viewModel.reset() }
    }
}
```

## Advanced LiveData Techniques

### Transformations

LiveData provides transformation methods that help you manipulate or convert LiveData values:

#### Map Transformation

`Transformations.map()` applies a function on the source LiveData and returns a new LiveData:

```kotlin
val doubledCount: LiveData<Int> = Transformations.map(count) { it * 2 }
```

#### SwitchMap Transformation

`Transformations.switchMap()` is useful when you need to react to changes in one LiveData by switching to another:

```kotlin
val userId: MutableLiveData<String> = MutableLiveData()

val user: LiveData<User> = Transformations.switchMap(userId) { id ->
    repository.getUserById(id) // This returns a LiveData<User>
}
```

### MediatorLiveData

`MediatorLiveData` allows you to merge multiple LiveData sources:

```kotlin
val firstName = MutableLiveData<String>()
val lastName = MutableLiveData<String>()

val fullName = MediatorLiveData<String>().apply {
    addSource(firstName) { firstName ->
        value = "$firstName ${lastName.value ?: ""}"
    }
    addSource(lastName) { lastName ->
        value = "${firstName.value ?: ""} $lastName"
    }
}
```

## Real-World Example: A Weather App

Let's see how LiveData can be used in a more practical application like a weather app.

### Step 1: Create Data Classes

```kotlin
data class WeatherData(
    val temperature: Float,
    val condition: String,
    val humidity: Int,
    val windSpeed: Float
)
```

### Step 2: Create a Repository

```kotlin
class WeatherRepository {
    // Simulates a network call
    suspend fun fetchWeatherData(cityId: String): WeatherData {
        delay(1000) // Simulate network delay
        return WeatherData(
            temperature = (Math.random() * 30 + 5).toFloat(),
            condition = listOf("Sunny", "Cloudy", "Rainy", "Windy").random(),
            humidity = (Math.random() * 100).toInt(),
            windSpeed = (Math.random() * 20).toFloat()
        )
    }
}
```

### Step 3: Create the ViewModel

```kotlin
class WeatherViewModel : ViewModel() {
    private val repository = WeatherRepository()
    
    private val _weatherData = MutableLiveData<WeatherData>()
    val weatherData: LiveData<WeatherData> = _weatherData
    
    private val _loading = MutableLiveData<Boolean>()
    val loading: LiveData<Boolean> = _loading
    
    private val _error = MutableLiveData<String?>()
    val error: LiveData<String?> = _error
    
    fun loadWeather(cityId: String) {
        viewModelScope.launch {
            try {
                _loading.value = true
                _error.value = null
                _weatherData.value = repository.fetchWeatherData(cityId)
            } catch (e: Exception) {
                _error.value = "Failed to load weather: ${e.localizedMessage}"
            } finally {
                _loading.value = false
            }
        }
    }
}
```

### Step 4: Implement the UI

```kotlin
class WeatherActivity : AppCompatActivity() {
    
    private lateinit var viewModel: WeatherViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_weather)
        
        viewModel = ViewModelProvider(this)[WeatherViewModel::class.java]
        
        val temperatureTextView = findViewById<TextView>(R.id.temperatureTextView)
        val conditionTextView = findViewById<TextView>(R.id.conditionTextView)
        val humidityTextView = findViewById<TextView>(R.id.humidityTextView)
        val windSpeedTextView = findViewById<TextView>(R.id.windSpeedTextView)
        val refreshButton = findViewById<Button>(R.id.refreshButton)
        val progressBar = findViewById<ProgressBar>(R.id.progressBar)
        val errorTextView = findViewById<TextView>(R.id.errorTextView)
        
        // Observe weather data
        viewModel.weatherData.observe(this) { weatherData ->
            temperatureTextView.text = "${weatherData.temperature}°C"
            conditionTextView.text = weatherData.condition
            humidityTextView.text = "Humidity: ${weatherData.humidity}%"
            windSpeedTextView.text = "Wind: ${weatherData.windSpeed} km/h"
        }
        
        // Observe loading state
        viewModel.loading.observe(this) { isLoading ->
            progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
        }
        
        // Observe error state
        viewModel.error.observe(this) { errorMessage ->
            if (errorMessage != null) {
                errorTextView.text = errorMessage
                errorTextView.visibility = View.VISIBLE
            } else {
                errorTextView.visibility = View.GONE
            }
        }
        
        // Set up refresh button
        refreshButton.setOnClickListener {
            viewModel.loadWeather("default_city_id")
        }
        
        // Load initial data
        viewModel.loadWeather("default_city_id")
    }
}
```

## LiveData with Room Database

LiveData works seamlessly with Room, allowing you to observe database changes:

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM user_table")
    fun getAllUsers(): LiveData<List<User>>
    
    @Query("SELECT * FROM user_table WHERE id = :userId")
    fun getUserById(userId: Int): LiveData<User>
    
    @Insert
    suspend fun insert(user: User)
}
```

When you use this DAO:

```kotlin
class UserRepository(private val userDao: UserDao) {
    // Returns LiveData so the UI can observe it
    val allUsers: LiveData<List<User>> = userDao.getAllUsers()
    
    fun getUserById(userId: Int): LiveData<User> {
        return userDao.getUserById(userId)
    }
    
    suspend fun insert(user: User) {
        userDao.insert(user)
    }
}
```

## Common LiveData Patterns and Best Practices

### 1. Single source of truth

Keep a single source of truth by exposing LiveData from your ViewModel and not manipulating it elsewhere:

```kotlin
class MyViewModel : ViewModel() {
    private val _data = MutableLiveData<MyData>()
    val data: LiveData<MyData> = _data  // Only expose immutable LiveData
}
```

### 2. LiveData with coroutines

Use coroutines with LiveData for asynchronous operations:

```kotlin
private val _result = MutableLiveData<Result>()
val result: LiveData<Result> = _result

fun loadData() {
    viewModelScope.launch {
        try {
            val data = withContext(Dispatchers.IO) {
                repository.fetchData()
            }
            _result.value = Result.Success(data)
        } catch (e: Exception) {
            _result.value = Result.Error(e)
        }
    }
}
```

### 3. Combine multiple LiveData

Use `MediatorLiveData` to combine information from multiple LiveData sources:

```kotlin
val posts = repository.getPosts()
val comments = repository.getComments()

val postsWithComments = MediatorLiveData<Pair<List<Post>, List<Comment>>>().apply {
    var postsValue: List<Post>? = null
    var commentsValue: List<Comment>? = null
    
    fun update() {
        if (postsValue != null && commentsValue != null) {
            this.value = Pair(postsValue!!, commentsValue!!)
        }
    }
    
    addSource(posts) { 
        postsValue = it
        update()
    }
    
    addSource(comments) {
        commentsValue = it
        update()
    }
}
```

## Summary

LiveData is a powerful component for building responsive, lifecycle-aware Android applications. We've covered:

- The basics of creating and observing LiveData objects
- How to transform and combine LiveData
- LiveData's lifecycle awareness and benefits
- Integration with other architecture components like ViewModel and Room
- Real-world examples showing practical implementations

By using LiveData, you can build applications that:
- React to data changes automatically
- Handle configuration changes gracefully
- Avoid memory leaks
- Follow clean architecture principles

## Additional Resources

- [Official Android LiveData Documentation](https://developer.android.com/topic/libraries/architecture/livedata)
- [Guide to app architecture](https://developer.android.com/jetpack/guide)
- [ViewModel Overview](https://developer.android.com/topic/libraries/architecture/viewmodel)
- [Room with LiveData](https://developer.android.com/training/data-storage/room/accessing-data)

## Exercises

1. Create a simple todo list app using LiveData and ViewModel to manage the list of tasks
2. Modify the counter app to save the count in SharedPreferences and restore it when the app restarts
3. Implement a search feature in a list using LiveData transformations
4. Build a currency converter that updates conversion rates from a remote API using LiveData
5. Create a music player app that uses MediatorLiveData to combine song metadata with playback progress

With these exercises, you'll gain practical experience with LiveData and improve your Android architecture skills.