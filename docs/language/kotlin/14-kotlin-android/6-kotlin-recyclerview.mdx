---
title: "Kotlin RecyclerView"
description: "Learn how to implement RecyclerView in Kotlin Android applications to efficiently display and manage large data sets with smooth scrolling performance"

---

# Kotlin RecyclerView

## Introduction

RecyclerView is one of the most important UI components in Android development. It's designed to display large sets of data efficiently by recycling view elements that are no longer visible on screen. This recycling mechanism significantly improves performance compared to traditional list views, especially when working with long lists.

In this tutorial, we'll learn how to implement RecyclerView in a Kotlin Android application, covering everything from basic setup to advanced customization. You'll understand why RecyclerView is preferred over older list components and how to leverage its powerful features in your applications.

## Why Use RecyclerView?

Before diving into implementation details, let's understand why RecyclerView is essential:

1. **View Recycling**: As the name suggests, RecyclerView reuses (recycles) views that are scrolled off-screen instead of creating new ones, reducing memory usage and improving performance.

2. **Flexibility**: RecyclerView allows for horizontal, vertical, grid, and staggered grid layouts without requiring separate components.

3. **Animation Support**: It provides built-in animations for item changes, additions, and removals.

4. **Decoupled Architecture**: RecyclerView separates the responsibilities of layout and data binding into different components, making it more flexible and easier to maintain.

## Prerequisites

Before we begin, ensure you have:

- Android Studio installed
- Basic knowledge of Kotlin syntax
- A basic Android project created

## Setup

First, add the RecyclerView dependency to your module's `build.gradle` file:

```groovy
dependencies {
    implementation "androidx.recyclerview:recyclerview:1.2.1"
}
```

Next, add the RecyclerView to your layout XML:

```xml
<androidx.recyclerview.widget.RecyclerView
    android:id="@+id/recyclerView"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:scrollbars="vertical" />
```

## Core Components of RecyclerView

RecyclerView's architecture consists of several components working together:

1. **RecyclerView**: The ViewGroup that contains the list of items
2. **Adapter**: Provides views for items and binds data to them
3. **LayoutManager**: Arranges items within the RecyclerView
4. **ViewHolder**: Holds and describes item views to be recycled

Let's implement each of these components step by step.

## Creating a Model Class

First, let's create a data class that represents each item in our list:

```kotlin
data class User(
    val id: Int,
    val name: String,
    val email: String,
    val avatarUrl: String
)
```

## Implementing the ViewHolder

The ViewHolder references the views that will display data for each item:

```kotlin
class UserViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
    val nameTextView: TextView = itemView.findViewById(R.id.textViewName)
    val emailTextView: TextView = itemView.findViewById(R.id.textViewEmail)
    val avatarImageView: ImageView = itemView.findViewById(R.id.imageViewAvatar)
}
```

## Creating the Item Layout

Now, let's create a layout file for each item in our list. Create a new XML layout file called `user_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.cardview.widget.CardView 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="8dp"
    app:cardCornerRadius="8dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp">

        <ImageView
            android:id="@+id/imageViewAvatar"
            android:layout_width="60dp"
            android:layout_height="60dp"
            android:contentDescription="User Avatar" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginStart="16dp"
            android:orientation="vertical">

            <TextView
                android:id="@+id/textViewName"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:textSize="18sp"
                android:textStyle="bold" />

            <TextView
                android:id="@+id/textViewEmail"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="4dp"
                android:textSize="14sp" />
        </LinearLayout>
    </LinearLayout>
</androidx.cardview.widget.CardView>
```

## Implementing the Adapter

The adapter connects your data to the RecyclerView:

```kotlin
class UserAdapter(private val users: List<User>) : RecyclerView.Adapter<UserViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        // Inflate the layout and create a ViewHolder
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.user_item, parent, false)
        return UserViewHolder(view)
    }

    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        // Bind data to the ViewHolder
        val user = users[position]
        holder.nameTextView.text = user.name
        holder.emailTextView.text = user.email
        
        // If you want to load images, you might use a library like Glide:
        // Glide.with(holder.itemView.context)
        //     .load(user.avatarUrl)
        //     .into(holder.avatarImageView)
    }

    override fun getItemCount(): Int = users.size
}
```

## Setting Up the RecyclerView

Now, let's connect everything in your Activity or Fragment:

```kotlin
class MainActivity : AppCompatActivity() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: UserAdapter
    private val userList = mutableListOf<User>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Initialize RecyclerView
        recyclerView = findViewById(R.id.recyclerView)
        
        // Set Layout Manager
        recyclerView.layoutManager = LinearLayoutManager(this)
        
        // Prepare data
        prepareUserData()
        
        // Initialize and set adapter
        adapter = UserAdapter(userList)
        recyclerView.adapter = adapter
    }

    private fun prepareUserData() {
        // Add sample data
        userList.add(User(1, "John Doe", "john@example.com", "https://randomuser.me/api/portraits/men/1.jpg"))
        userList.add(User(2, "Jane Smith", "jane@example.com", "https://randomuser.me/api/portraits/women/1.jpg"))
        userList.add(User(3, "Bob Johnson", "bob@example.com", "https://randomuser.me/api/portraits/men/2.jpg"))
        userList.add(User(4, "Alice Williams", "alice@example.com", "https://randomuser.me/api/portraits/women/2.jpg"))
        // Add more users as needed
    }
}
```

## Different LayoutManagers

RecyclerView offers several layout managers for different arrangements:

### Linear Layout (vertical or horizontal)

```kotlin
// Vertical layout (default)
recyclerView.layoutManager = LinearLayoutManager(this)

// Horizontal layout
recyclerView.layoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)
```

### Grid Layout

```kotlin
// Display items in a grid with 2 columns
recyclerView.layoutManager = GridLayoutManager(this, 2)
```

### Staggered Grid Layout

```kotlin
// Staggered grid with 2 columns (items can have different heights)
recyclerView.layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)
```

## Handling Item Click Events

To respond to item clicks, implement a click listener in your adapter:

```kotlin
class UserAdapter(
    private val users: List<User>,
    private val onItemClick: (User) -> Unit
) : RecyclerView.Adapter<UserViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.user_item, parent, false)
        return UserViewHolder(view)
    }

    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        val user = users[position]
        holder.nameTextView.text = user.name
        holder.emailTextView.text = user.email
        
        // Set click listener for the entire item
        holder.itemView.setOnClickListener {
            onItemClick(user)
        }
    }

    override fun getItemCount(): Int = users.size
}
```

Then in your Activity:

```kotlin
adapter = UserAdapter(userList) { user ->
    // Handle the click event
    Toast.makeText(this, "Clicked on ${user.name}", Toast.LENGTH_SHORT).show()
    
    // Or navigate to a details screen
    val intent = Intent(this, UserDetailActivity::class.java).apply {
        putExtra("USER_ID", user.id)
    }
    startActivity(intent)
}
```

## Adding Item Decorations

Item decorations allow you to add spacing or dividers between items:

```kotlin
// Add divider between items
val dividerItemDecoration = DividerItemDecoration(
    recyclerView.context,
    (recyclerView.layoutManager as LinearLayoutManager).orientation
)
recyclerView.addItemDecoration(dividerItemDecoration)

// Or add custom spacing
recyclerView.addItemDecoration(
    object : RecyclerView.ItemDecoration() {
        override fun getItemOffsets(
            outRect: Rect,
            view: View,
            parent: RecyclerView,
            state: RecyclerView.State
        ) {
            outRect.top = 16
            outRect.bottom = 16
            outRect.left = 16
            outRect.right = 16
        }
    }
)
```

## Animation Effects

RecyclerView provides built-in animations for changes in the dataset:

```kotlin
// Define a custom item animator
val animator = DefaultItemAnimator()
animator.addDuration = 1000
animator.removeDuration = 1000
animator.changeDuration = 1000
recyclerView.itemAnimator = animator
```

To update the dataset with animations:

```kotlin
// Add a new user
fun addUser(user: User) {
    userList.add(user)
    adapter.notifyItemInserted(userList.size - 1)
}

// Remove a user
fun removeUser(position: Int) {
    userList.removeAt(position)
    adapter.notifyItemRemoved(position)
}

// Update a user
fun updateUser(position: Int, user: User) {
    userList[position] = user
    adapter.notifyItemChanged(position)
}
```

## Implementing DiffUtil for Efficient Updates

DiffUtil is a utility class that calculates the difference between two lists and outputs a list of update operations that converts the first list into the second one. It makes updating RecyclerView more efficient:

```kotlin
class UserDiffCallback(
    private val oldList: List<User>,
    private val newList: List<User>
) : DiffUtil.Callback() {

    override fun getOldListSize(): Int = oldList.size

    override fun getNewListSize(): Int = newList.size

    override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return oldList[oldItemPosition].id == newList[newItemPosition].id
    }

    override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
        return oldList[oldItemPosition] == newList[newItemPosition]
    }
}
```

Update your adapter to use ListAdapter which internally uses DiffUtil:

```kotlin
class UserAdapter : ListAdapter<User, UserViewHolder>(UserDiffCallback) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): UserViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.user_item, parent, false)
        return UserViewHolder(view)
    }

    override fun onBindViewHolder(holder: UserViewHolder, position: Int) {
        val user = getItem(position)
        holder.nameTextView.text = user.name
        holder.emailTextView.text = user.email
    }

    companion object {
        private val UserDiffCallback = object : DiffUtil.ItemCallback<User>() {
            override fun areItemsTheSame(oldItem: User, newItem: User): Boolean {
                return oldItem.id == newItem.id
            }

            override fun areContentsTheSame(oldItem: User, newItem: User): Boolean {
                return oldItem == newItem
            }
        }
    }
}
```

Then, to update the list:

```kotlin
// Initialize adapter
adapter = UserAdapter()
recyclerView.adapter = adapter

// Submit a new list
adapter.submitList(userList)
```

## Real-World Example: Fetching and Displaying User Data

Here's a complete example that fetches user data from a remote API using Retrofit and displays it in a RecyclerView:

```kotlin
// 1. User Model
data class User(
    val id: Int,
    val name: String,
    val email: String,
    val avatarUrl: String
)

// 2. Retrofit API Interface
interface UserApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}

// 3. Create Retrofit Instance
object RetrofitInstance {
    private const val BASE_URL = "https://api.example.com/"
    
    private val retrofit = Retrofit.Builder()
        .baseUrl(BASE_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()
    
    val userApiService: UserApiService = retrofit.create(UserApiService::class.java)
}

// 4. ViewModel to handle data loading
class UserViewModel : ViewModel() {
    private val _users = MutableLiveData<List<User>>()
    val users: LiveData<List<User>> = _users
    
    private val _isLoading = MutableLiveData<Boolean>()
    val isLoading: LiveData<Boolean> = _isLoading
    
    private val _error = MutableLiveData<String?>()
    val error: LiveData<String?> = _error
    
    fun loadUsers() {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            try {
                val fetchedUsers = RetrofitInstance.userApiService.getUsers()
                _users.value = fetchedUsers
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _isLoading.value = false
            }
        }
    }
}

// 5. Activity implementation
class MainActivity : AppCompatActivity() {

    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: UserAdapter
    private lateinit var viewModel: UserViewModel
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Initialize RecyclerView
        recyclerView = findViewById(R.id.recyclerView)
        recyclerView.layoutManager = LinearLayoutManager(this)
        
        // Initialize adapter
        adapter = UserAdapter(emptyList()) { user ->
            Toast.makeText(this, "Clicked: ${user.name}", Toast.LENGTH_SHORT).show()
        }
        recyclerView.adapter = adapter
        
        // Initialize ViewModel
        viewModel = ViewModelProvider(this)[UserViewModel::class.java]
        
        // Observe LiveData
        viewModel.users.observe(this) { users ->
            adapter = UserAdapter(users) { user ->
                Toast.makeText(this, "Clicked: ${user.name}", Toast.LENGTH_SHORT).show()
            }
            recyclerView.adapter = adapter
        }
        
        viewModel.isLoading.observe(this) { isLoading ->
            // Show/hide loading indicator
            findViewById<ProgressBar>(R.id.progressBar).visibility = 
                if (isLoading) View.VISIBLE else View.GONE
        }
        
        viewModel.error.observe(this) { errorMessage ->
            errorMessage?.let {
                Toast.makeText(this, it, Toast.LENGTH_LONG).show()
            }
        }
        
        // Load users
        viewModel.loadUsers()
    }
}
```

## Best Practices for RecyclerView

1. **Use ViewHolder Pattern** (Already enforced by RecyclerView)
2. **Implement DiffUtil** for efficient updates
3. **Optimize View Binding** by avoiding expensive operations in `onBindViewHolder`
4. **Use setHasFixedSize(true)** if your RecyclerView has items of fixed dimensions
5. **Consider Pagination** for very large datasets
6. **Implement Item Animations** thoughtfully without overwhelming users
7. **Handle Empty States** properly
8. **Consider View Types** for heterogeneous lists

## Common Issues and Solutions

### Scrolling Performance Issues

If you notice lag during scrolling:

- Avoid heavy operations in `onBindViewHolder`
- Use image loading libraries like Glide or Coil that cache images
- Implement view recycling properly
- Simplify your item layouts

### Item Updates Not Showing

If your item updates aren't showing:

- Ensure you're calling the correct notification methods (`notifyItemChanged`, etc.)
- Check that you're modifying the correct dataset that's connected to the adapter
- Consider using DiffUtil for complex updates

## Summary

In this tutorial, we've learned how to implement RecyclerView in Kotlin Android applications:

1. We started with basic RecyclerView setup and created necessary components (Adapter, ViewHolder).
2. We explored different LayoutManagers for various display patterns.
3. We implemented item click handling and decorations for better UI.
4. We added animations and efficient update mechanisms with DiffUtil.
5. We built a real-world example that fetches and displays data from a remote API.

RecyclerView is a powerful and flexible component that should be a core part of any Android developer's toolkit. By understanding its architecture and capabilities, you can build efficient, performant list-based interfaces that provide a smooth user experience.

## Additional Resources

- [Android Developer Documentation on RecyclerView](https://developer.android.com/develop/ui/views/layout/recyclerview)
- [Kotlin Documentation](https://kotlinlang.org/docs/home.html)
- [Material Design Guidelines for Lists](https://material.io/components/lists)

## Exercise

Try these exercises to reinforce your understanding:

1. Create a RecyclerView that displays a list of movies with images, titles, and ratings.
2. Implement multiple view types in a single RecyclerView (e.g., header, content, footer).
3. Add swipe-to-delete functionality to your RecyclerView.
4. Implement an endless scrolling RecyclerView that loads more data as the user reaches the end of the list.
5. Create a RecyclerView with grid layout that changes the number of columns based on screen orientation.