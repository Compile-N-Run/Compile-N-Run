---
title: "Kotlin Nullability Annotations"
description: "Learn how to use Kotlin's nullability annotations to improve interoperability with Java code and make your Kotlin code safer when working with external libraries."

---

# Kotlin Nullability Annotations

## Introduction

Kotlin's type system distinguishes between nullable and non-nullable types, providing compile-time null safety. However, when interacting with Java code, Kotlin needs additional information to determine whether a Java type should be treated as nullable or non-nullable. This is where nullability annotations come in.

Nullability annotations allow Kotlin to understand the nullability intentions of Java code, making interoperability safer and more predictable. In this guide, we'll explore how these annotations work and how you can use them effectively in your projects.

## Understanding the Problem

When Kotlin interoperates with Java, it faces a fundamental challenge: Java doesn't have nullability information built into its type system. Let's see what this means:

```kotlin
// Java method (as seen from Kotlin)
fun javaMethod(): String // Is this String nullable or non-nullable?
```

Without additional information, Kotlin treats types coming from Java as **platform types**, denoted as `String!`. Platform types can be treated as both nullable and non-nullable, which is flexible but can lead to runtime `NullPointerException` errors.

## Java Nullability Annotations

To solve this problem, Java has several annotation systems to indicate nullability:

1. JetBrains annotations (`org.jetbrains.annotations`)
2. Android annotations (`androidx.annotation`)
3. JSR-305 annotations (`javax.annotation`)
4. Eclipse annotations (`org.eclipse.jdt.annotation`) 
5. Checker Framework annotations (`org.checkerframework.checker.nullness.qual`)

Let's look at the most commonly used ones:

### JetBrains Annotations

```kotlin
// Java code
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class User {
    @NotNull
    public String getName() {
        return "John";
    }
    
    @Nullable
    public String getMiddleName() {
        return null;
    }
}
```

When used in Kotlin:

```kotlin
val user = User()
val name: String = user.name       // OK, treated as non-nullable
val middle: String? = user.middleName  // OK, treated as nullable
val error: String = user.middleName    // Compilation error: Type mismatch
```

### Android Annotations

Android provides its own set of nullability annotations:

```kotlin
// Java code
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

public class Product {
    @NonNull
    public String getTitle() {
        return "Smartphone";
    }
    
    @Nullable
    public String getDescription() {
        return null;
    }
}
```

### JSR-305 Annotations

JSR-305 annotations are another common standard:

```kotlin
// Java code
import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class Order {
    @Nonnull
    public String getOrderId() {
        return "ORD-12345";
    }
    
    @Nullable
    public String getNote() {
        return null;
    }
}
```

## Using Nullability Annotations in Your Kotlin Project

### Step 1: Add Annotation Dependencies

First, add the required dependencies to your project:

```kotlin
// For JetBrains annotations
implementation("org.jetbrains:annotations:23.0.0")

// For JSR-305 annotations
implementation("com.google.code.findbugs:jsr305:3.0.2")
```

### Step 2: Configure JSR-305 Support (Optional)

If you're using JSR-305 annotations, you might want to configure how Kotlin treats them. Add to your `build.gradle.kts`:

```kotlin
kotlin {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
    }
}
```

### Step 3: Annotate Your Java Code

When writing Java code intended for Kotlin consumption, add nullability annotations:

```kotlin
// Java code
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class Customer {
    private final String id;
    private String email;
    
    public Customer(@NotNull String id) {
        this.id = id;
        this.email = null;
    }
    
    @NotNull
    public String getId() {
        return id;
    }
    
    @Nullable
    public String getEmail() {
        return email;
    }
    
    public void setEmail(@Nullable String email) {
        this.email = email;
    }
}
```

### Step 4: Use the Java Code in Kotlin

Now when you use this Java code in Kotlin, the compiler will enforce nullability:

```kotlin
fun main() {
    val customer = Customer("12345")
    
    // getId() returns @NotNull String
    val id: String = customer.id  // OK
    
    // getEmail() returns @Nullable String
    val email: String? = customer.email  // OK
    
    // This would cause a compilation error
    // val nonNullEmail: String = customer.email  // Error: Type mismatch
    
    // Safe call is needed
    println(customer.email?.length)  // Prints: null
    
    // Set a new email
    customer.email = "customer@example.com"
    println(customer.email?.length)  // Prints: 21
    
    // Can also set to null
    customer.email = null  // OK because parameter is @Nullable
}
```

## Real-World Examples

### Example 1: Working with Third-Party Libraries

When using third-party Java libraries in Kotlin, nullability annotations help ensure type safety:

```kotlin
// Assuming a Java library for HTTP requests
import com.example.http.HttpClient
import com.example.http.Response

fun fetchUserData(userId: String): UserData? {
    val client = HttpClient()
    val response = client.get("https://api.example.com/users/$userId")
    
    // Without annotations, we'd have to be very careful here
    val body = response.body // Is this nullable? We don't know!
    
    // With proper annotations in the Java library:
    // - If body is annotated with @NotNull, this is safe
    // - If body is annotated with @Nullable, the compiler would warn us
    
    return if (response.isSuccessful && body != null) {
        parseUserData(body)
    } else {
        null
    }
}
```

### Example 2: Hybrid Java/Kotlin Codebase

In projects mixing Java and Kotlin code, annotations create a better developer experience:

```kotlin
// Java class with annotations
public class DatabaseRepository {
    @Nullable
    public User findUserById(long id) {
        // implementation...
    }
    
    @NotNull
    public List<User> getAllUsers() {
        // implementation...
    }
}

// Kotlin usage
class UserService(private val repository: DatabaseRepository) {
    fun getUser(id: Long): User? {
        // Kotlin knows this can be null
        return repository.findUserById(id)
    }
    
    fun processAllUsers() {
        val users = repository.allUsers // Non-null List<User>
        for (user in users) {
            // Safe to access user properties without null checks
            println("Processing user: ${user.name}")
        }
    }
}
```

## Advanced: Defining Nullability for Specific Packages

For large projects, you can configure nullability for entire packages in your `build.gradle.kts`:

```kotlin
kotlin {
    kotlinOptions {
        freeCompilerArgs = listOf(
            "-Xjava-package-nullable=com.example.nullable",
            "-Xjava-package-nonnull=com.example.nonnull,org.example.utils"
        )
    }
}
```

This treats all types from `com.example.nullable` as nullable by default and all types from `com.example.nonnull` and `org.example.utils` as non-nullable by default.

## Common Pitfalls and Best Practices

1. **Be consistent with annotation usage**: Use the same annotation system throughout your project.

2. **Watch out for inherited nullability**: When overriding methods, respect the nullability of the superclass method.

3. **Remember that annotations can lie**: A method annotated with `@NotNull` might still return `null` at runtime if the Java code doesn't respect its own annotations.

4. **Consider using `@ChecksForNull` for boolean methods**: For methods like `isEmpty()` that check for null values.

5. **Don't rely on method names for nullability**: Even if a method is called `getNonNullValue()`, always use annotations to be explicit.

## Summary

Kotlin's nullability annotations bridge the gap between Java's lenient null handling and Kotlin's strict null safety. By properly annotating Java code:

- You make Kotlin usage of Java APIs safer
- You reduce the need for defensive null checks
- You communicate intent clearly to both humans and compilers
- You prevent null-related bugs at compile time rather than runtime

When working with Java interoperability, always prefer using explicitly annotated APIs and consider adding nullability annotations to your own Java code that will be consumed by Kotlin.

## Additional Resources

- [Official Kotlin Documentation on Java Interoperability](https://kotlinlang.org/docs/java-interop.html)
- [JetBrains Annotations JavaDoc](https://javadoc.io/doc/org.jetbrains/annotations/latest/index.html)
- [JSR-305 Specifications](https://jcp.org/en/jsr/detail?id=305)
- [Android Nullability Annotations Guide](https://developer.android.com/kotlin/common-patterns#nullability-annotations)

## Exercises

1. Create a Java class with methods returning both nullable and non-nullable values, and use it from Kotlin.
2. Take an existing Java library and determine if it uses nullability annotations. If not, create a wrapper class in Java with proper annotations.
3. Write a Kotlin function that safely handles a Java method that doesn't use nullability annotations.
4. Experiment with different JSR-305 configuration options and observe how they affect type checking.