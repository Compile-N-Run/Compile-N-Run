---
title: Kotlin Native Interoperability
description: Learn how Kotlin Native allows you to interact with native platforms like C, Objective-C, and Swift to build cross-platform applications with shared code.

---

# Kotlin Native Interoperability

## Introduction

Kotlin Native is a technology that compiles Kotlin code to native binaries, allowing Kotlin to run without a virtual machine. One of the most powerful features of Kotlin Native is its **interoperability** capabilities, which allow Kotlin code to seamlessly interact with native code written in languages like C, Objective-C, and Swift.

In this tutorial, we'll explore how Kotlin Native interoperability works, why it's useful, and how you can use it in your projects to leverage existing native libraries and frameworks.

## Why Kotlin Native Interoperability Matters

Before diving into the technical details, let's understand why interoperability is important:

1. **Reuse existing libraries**: Access the vast ecosystem of C, Objective-C, and Swift libraries
2. **Performance**: Directly call native code without overhead
3. **Platform-specific features**: Access platform-specific APIs not available in Kotlin
4. **Cross-platform development**: Write shared business logic in Kotlin while using native UI frameworks

## Getting Started with Kotlin Native

To work with Kotlin Native, you'll need to set up your environment first:

1. Install the Kotlin Native compiler (included in recent Kotlin installations)
2. Set up a build system like Gradle with the Kotlin Multiplatform plugin

Let's create a simple project structure:

```
my-kotlin-native-project/
├── build.gradle.kts
├── gradle.properties
├── settings.gradle.kts
└── src/
    ├── nativeMain/
    │   └── kotlin/
    │       └── Main.kt
    └── nativeInterop/
        └── cinterop/
            └── libc.def
```

## Interoperability with C Libraries

### Step 1: Creating a Definition File

To use a C library in Kotlin Native, you first need to create a `.def` file that describes the library interface. Let's create a simple definition file for the C standard library:

```
// libc.def
headers = stdio.h stdlib.h string.h
```

### Step 2: Configure Gradle

In your `build.gradle.kts` file:

```kotlin
plugins {
    kotlin("multiplatform") version "1.8.0"
}

kotlin {
    linuxX64("native") {  // or macosX64, mingwX64, etc.
        val main by compilations.getting
        val libc by main.cinterops.creating
    }
}
```

### Step 3: Using C Functions in Kotlin

Now you can use C functions directly in your Kotlin code:

```kotlin
import kotlinx.cinterop.*
import platform.posix.*

fun main() {
    // Using printf from C
    printf("Hello from C printf!\n")
    
    // Using malloc and free from C
    val memory = malloc(10 * sizeOf<IntVar>())?.reinterpret<IntVar>()
    if (memory != null) {
        for (i in 0 until 10) {
            memory[i] = i * i
        }
        
        for (i in 0 until 10) {
            println("memory[$i] = ${memory[i]}")
        }
        
        free(memory)
    }
}
```

**Output:**
```
Hello from C printf!
memory[0] = 0
memory[1] = 1
memory[2] = 4
memory[3] = 9
memory[4] = 16
memory[5] = 25
memory[6] = 36
memory[7] = 49
memory[8] = 64
memory[9] = 81
```

## Memory Management in Kotlin Native Interop

When working with C interoperability, you need to be careful about memory management. Kotlin Native has two memory models:

1. **Kotlin objects**: Managed by Kotlin's memory manager
2. **Native memory**: Manually managed (malloc/free)

### Working with Native Pointers

Here's an example of safe pointer handling:

```kotlin
import kotlinx.cinterop.*
import platform.posix.*

fun main() {
    memScoped {
        val buffer = allocArray<ByteVar>(64)
        
        // Copy a string to the buffer
        strcpy(buffer, "Hello, Native World!")
        
        // Read from the buffer
        println("Buffer contains: ${buffer.toKString()}")
        
        // No need to free - memScoped handles it
    }
}
```

The `memScoped` block ensures that any memory allocated within it is automatically freed when the block exits.

## Interoperability with Objective-C (iOS/macOS)

For Apple platforms, Kotlin Native can interoperate with Objective-C frameworks.

### Step 1: Create a Framework Definition File

```
// Foundation.def
language = Objective-C
modules = Foundation
```

### Step 2: Using Objective-C APIs

```kotlin
import platform.Foundation.*
import platform.UIKit.*

fun createNSString(): NSString {
    return NSString.stringWithString("Hello from Objective-C!")
}

fun createUILabel(): UILabel {
    val label = UILabel()
    label.text = "Kotlin ♥ iOS"
    label.textAlignment = NSTextAlignmentCenter
    return label
}
```

## Interoperability with Swift

While you can't directly call Swift code from Kotlin Native, you can expose Kotlin code to Swift.

### Step 1: Set Up a Framework Target

```kotlin
kotlin {
    ios() {
        binaries {
            framework {
                baseName = "SharedCode"
            }
        }
    }
}
```

### Step 2: Create Kotlin Classes for Swift

```kotlin
// SharedCode.kt
@file:JvmName("SharedCode")

class User(val id: Int, val name: String) {
    fun greet(): String {
        return "Hello, $name!"
    }
}

// This function will be accessible from Swift
fun createUser(id: Int, name: String): User {
    return User(id, name)
}
```

### Step 3: Use from Swift

```swift
import SharedCode

let user = SharedCodeKt.createUser(id: 1, name: "Alex")
print(user.greet())  // Prints: Hello, Alex!
```

## Real-World Example: Using SQLite in Kotlin Native

Let's build a practical example using the SQLite library:

### Step 1: Create SQLite Definition File

```
// sqlite.def
headers = sqlite3.h
headerFilter = sqlite3*.h
compilerOpts.linux = -I/usr/include
linkerOpts.osx = -L/usr/lib -lsqlite3
linkerOpts.linux = -L/usr/lib -lsqlite3
```

### Step 2: Create a Kotlin Wrapper

```kotlin
import kotlinx.cinterop.*
import sqlite3.*

class SQLiteDatabase(private val db: CPointer<sqlite3>) {
    
    companion object {
        fun open(path: String): SQLiteDatabase? {
            val dbPtr = memScoped {
                val dbPtrPtr = alloc<CPointerVar<sqlite3>>()
                val result = sqlite3_open(path, dbPtrPtr.ptr)
                if (result != SQLITE_OK) {
                    println("Failed to open database: ${sqlite3_errmsg(dbPtrPtr.value)?.toKString()}")
                    return null
                }
                dbPtrPtr.value
            }
            
            return if (dbPtr != null) SQLiteDatabase(dbPtr) else null
        }
    }
    
    fun execute(sql: String): Boolean {
        var result = false
        memScoped {
            val errorPtr = alloc<CPointerVar<ByteVar>>()
            val rc = sqlite3_exec(db, sql, null, null, errorPtr.ptr)
            
            if (rc != SQLITE_OK) {
                println("SQL error: ${errorPtr.value?.toKString()}")
                sqlite3_free(errorPtr.value)
            } else {
                result = true
            }
        }
        return result
    }
    
    fun query(sql: String): List<Map<String, String>> {
        val results = mutableListOf<Map<String, String>>()
        
        memScoped {
            val stmtPtr = alloc<CPointerVar<sqlite3_stmt>>()
            
            if (sqlite3_prepare_v2(db, sql, -1, stmtPtr.ptr, null) == SQLITE_OK) {
                val stmt = stmtPtr.value
                
                try {
                    while (sqlite3_step(stmt) == SQLITE_ROW) {
                        val row = mutableMapOf<String, String>()
                        val columnCount = sqlite3_column_count(stmt)
                        
                        for (i in 0 until columnCount) {
                            val columnName = sqlite3_column_name(stmt, i)?.toKString() ?: "Column$i"
                            val value = sqlite3_column_text(stmt, i)?.toKString() ?: ""
                            row[columnName] = value
                        }
                        
                        results.add(row)
                    }
                } finally {
                    sqlite3_finalize(stmt)
                }
            }
        }
        
        return results
    }
    
    fun close() {
        sqlite3_close(db)
    }
}
```

### Step 3: Using Our SQLite Wrapper

```kotlin
fun main() {
    val db = SQLiteDatabase.open(":memory:") ?: return
    
    // Create a table
    db.execute("""
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            name TEXT,
            email TEXT
        )
    """)
    
    // Insert data
    db.execute("INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')")
    db.execute("INSERT INTO users (name, email) VALUES ('Bob', 'bob@example.com')")
    
    // Query data
    val users = db.query("SELECT * FROM users")
    
    println("Users in database:")
    users.forEach { user ->
        println("ID: ${user["id"]}, Name: ${user["name"]}, Email: ${user["email"]}")
    }
    
    // Clean up
    db.close()
}
```

**Output:**
```
Users in database:
ID: 1, Name: Alice, Email: alice@example.com
ID: 2, Name: Bob, Email: bob@example.com
```

## Common Challenges and Solutions

### 1. Memory Management Issues

**Challenge**: Native resources not being freed properly.

**Solution**: Use `memScoped` and `AutofreeScope` for automatic resource management:

```kotlin
memScoped {
    val buffer = allocArrayOf("Hello", "World")
    // Use buffer...
} // buffer is automatically freed here
```

### 2. Type Conversion

**Challenge**: Converting between Kotlin and C types.

**Solution**: Use conversion functions provided by `kotlinx.cinterop`:

```kotlin
// Convert C string to Kotlin String
val cString: CPointer<ByteVar> = /* from C */
val kotlinString = cString.toKString()

// Convert Kotlin String to C string
val kotlinString = "Hello"
memScoped {
    val cString = kotlinString.cstr.ptr
    // Use cString...
}
```

### 3. Callback Functions

**Challenge**: Passing Kotlin functions to C as callbacks.

**Solution**: Use `StableRef` and function pointers:

```kotlin
// Define a callback type
typealias CallbackFunction = (Int) -> Unit

fun registerCallback(callback: CallbackFunction) {
    // Create a stable reference to the callback that won't be moved by GC
    val callbackRef = StableRef.create(callback)
    
    // Create a C function pointer
    val cCallback = staticCFunction { value: Int ->
        val callbackRef = /* retrieve stored reference */
        callbackRef.get()(value)
    }
    
    // Register with C library
    c_register_callback(cCallback)
}
```

## Summary

Kotlin Native interoperability is a powerful feature that enables Kotlin code to interact seamlessly with native libraries and frameworks. Key points to remember:

1. Use `.def` files to define interfaces with C libraries
2. Handle memory management carefully, preferring `memScoped` blocks
3. Leverage platform-specific features through interoperability
4. Create wrappers around native APIs for a more Kotlin-friendly interface

With Kotlin Native interoperability, you can enjoy the best of both worlds: Kotlin's modern language features and the vast ecosystem of native libraries available across platforms.

## Further Resources

- [Kotlin Native Documentation](https://kotlinlang.org/docs/native-overview.html)
- [C Interop Documentation](https://kotlinlang.org/docs/native-c-interop.html)
- [Multiplatform Programming](https://kotlinlang.org/docs/multiplatform.html)

## Exercises

1. Create a Kotlin Native wrapper for a simple C library of your choice
2. Build a small application that uses platform-specific APIs through interop
3. Implement a SQLite database helper with more features like prepared statements and transactions
4. Create a shared module that can be used from both Kotlin and Swift