---
title: "Kotlin Native Development"
description: "Learn how to build native applications for multiple platforms using Kotlin Native, a key component of Kotlin Multiplatform that enables compilation to native binaries."

---

# Kotlin Native Development

## Introduction

Kotlin Native is a technology that compiles Kotlin code to native binaries, allowing you to run Kotlin applications on platforms where virtual machines are not available or not desirable. It's an essential part of the Kotlin Multiplatform ecosystem that enables developers to share code between different platforms while still leveraging platform-specific capabilities.

With Kotlin Native, you can:
- Create standalone executable applications that run without a virtual machine
- Build libraries that can be used from other programming languages
- Target multiple platforms including iOS, macOS, Windows, Linux, and embedded systems
- Share business logic between mobile, web, and desktop applications

This guide will walk you through the basics of Kotlin Native development, from setting up your environment to creating and running your first native application.

## Setting Up Your Environment

Before you start with Kotlin Native development, you need to set up your development environment:

1. **Install IntelliJ IDEA or Android Studio** (if you haven't already)
2. **Install the Kotlin plugin** (usually included by default in recent versions)

### Creating a Kotlin Native Project

You can create a new Kotlin Native project using Gradle:

```kotlin
plugins {
    kotlin("multiplatform") version "1.9.0"
}

kotlin {
    // Target platforms
    linuxX64 {
        binaries {
            executable()
        }
    }
    
    macosX64 {
        binaries {
            executable()
        }
    }
    
    mingwX64 {
        binaries {
            executable()
        }
    }
}
```

This configuration sets up a project that can compile to Linux, macOS, and Windows executables.

## Hello World in Kotlin Native

Let's start with a simple "Hello World" program:

Create a file `src/nativeMain/kotlin/Main.kt`:

```kotlin
fun main() {
    println("Hello, Kotlin Native!")
}
```

### Building and Running the Application

To build the application, run the appropriate Gradle task:

```bash
# For macOS
./gradlew runDebugExecutableMacosX64

# For Linux
./gradlew runDebugExecutableLinuxX64

# For Windows
./gradlew runDebugExecutableMingwX64
```

**Output:**
```
Hello, Kotlin Native!
```

## Understanding Kotlin Native Memory Management

One of the key differences between Kotlin Native and Kotlin/JVM is the memory management system. Kotlin Native uses a combination of automatic reference counting and object freezing to ensure memory safety.

### Memory Model

Kotlin Native uses a strict memory model to prevent sharing mutable state between threads:

1. **Object Freezing**: When objects are shared between threads, they become "frozen" (immutable)
2. **Strict Ownership**: Each object is owned by a single thread or shared in a controlled way

Here's an example demonstrating object freezing:

```kotlin
import kotlin.native.concurrent.*

fun main() {
    val mutableList = mutableListOf(1, 2, 3)
    println("Before freezing: $mutableList")
    
    // Freezing the list
    mutableList.freeze()
    
    println("Is frozen: ${mutableList.isFrozen}")
    
    try {
        // This will throw an exception
        mutableList.add(4)
    } catch (e: Exception) {
        println("Cannot modify frozen list: ${e.message}")
    }
}
```

**Output:**
```
Before freezing: [1, 2, 3]
Is frozen: true
Cannot modify frozen list: Modification of frozen collection is prohibited
```

## Interoperability with Native Languages

Kotlin Native provides excellent interoperability with native code, allowing you to call C libraries and be called from C code.

### Calling C Libraries from Kotlin

You can create C interop definitions to access C libraries. Let's see how to call a simple C function:

First, create a C header file `simple.h`:

```c
#ifndef SIMPLE_H
#define SIMPLE_H

int add(int a, int b);

#endif
```

Then implement it in `simple.c`:

```c
#include "simple.h"

int add(int a, int b) {
    return a + b;
}
```

Create a cinterop definition file `simple.def`:

```
headers = simple.h
```

Configure your build.gradle.kts:

```kotlin
kotlin {
    linuxX64 {
        compilations.getByName("main") {
            cinterops {
                val simple by creating
            }
        }
    }
    // Similar configuration for other platforms
}
```

Now you can use the C function in Kotlin:

```kotlin
import simple.*

fun main() {
    val result = add(40, 2)
    println("Result from C function: $result")
}
```

**Output:**
```
Result from C function: 42
```

## Platform-Specific Code

Sometimes you need to write platform-specific code. Kotlin Native provides `expect`/`actual` declarations for this purpose:

```kotlin
// Common code
expect fun getPlatformName(): String

// Platform-specific implementations
// In src/linuxX64Main/kotlin/Platform.kt
actual fun getPlatformName(): String = "Linux"

// In src/macosX64Main/kotlin/Platform.kt
actual fun getPlatformName(): String = "macOS"

// In src/mingwX64Main/kotlin/Platform.kt
actual fun getPlatformName(): String = "Windows"

// Usage in common code
fun main() {
    println("Hello from ${getPlatformName()}!")
}
```

## Real-World Example: Cross-Platform Calculator

Let's create a simple calculator library that can be used on multiple platforms:

```kotlin
// In src/commonMain/kotlin/Calculator.kt
class Calculator {
    fun add(a: Int, b: Int): Int = a + b
    fun subtract(a: Int, b: Int): Int = a - b
    fun multiply(a: Int, b: Int): Int = a * b
    fun divide(a: Int, b: Int): Int {
        require(b != 0) { "Cannot divide by zero" }
        return a / b
    }
    
    // Platform-specific calculation
    expect fun calculateTax(amount: Double): Double
}

// In src/linuxX64Main/kotlin/Calculator.kt
actual fun Calculator.calculateTax(amount: Double): Double {
    // German tax rate of 19%
    return amount * 0.19
}

// In src/macosX64Main/kotlin/Calculator.kt
actual fun Calculator.calculateTax(amount: Double): Double {
    // California tax rate of 7.25%
    return amount * 0.0725
}

// Main program
fun main() {
    val calculator = Calculator()
    val a = 10
    val b = 5
    
    println("$a + $b = ${calculator.add(a, b)}")
    println("$a - $b = ${calculator.subtract(a, b)}")
    println("$a * $b = ${calculator.multiply(a, b)}")
    println("$a / $b = ${calculator.divide(a, b)}")
    
    val amount = 100.0
    println("Tax on $amount = ${calculator.calculateTax(amount)}")
}
```

Depending on the platform, you'll get different outputs for the tax calculation.

## Working with Concurrency

Kotlin Native has a different concurrency model than Kotlin/JVM. Here's how to use workers for background processing:

```kotlin
import kotlin.native.concurrent.*

fun main() {
    val worker = Worker.start()
    
    val future = worker.execute(TransferMode.SAFE, { "Hello" }) { input ->
        // This code runs in a separate thread
        "$input from worker thread"
    }
    
    println("Waiting for worker result...")
    val result = future.result
    println("Got result: $result")
    
    worker.requestTermination().result
}
```

**Output:**
```
Waiting for worker result...
Got result: Hello from worker thread
```

## Optimizing Kotlin Native Performance

Kotlin Native applications can be optimized for performance with these techniques:

1. **Use release builds**: They include full optimization
2. **Avoid excessive memory allocations**
3. **Use appropriate collection types**: Consider using Array instead of List when performance is critical
4. **Leverage compiler optimizations**:

```kotlin
kotlin {
    linuxX64 {
        binaries {
            executable {
                optimized = true
            }
        }
    }
}
```

## Summary

In this guide, we've covered the essentials of Kotlin Native development:

1. Setting up a Kotlin Native project
2. Creating and running a simple application
3. Understanding Kotlin Native's memory management
4. Interoperability with C/C++ code
5. Writing platform-specific implementations
6. Building a real-world cross-platform application
7. Working with concurrency in Kotlin Native
8. Optimizing performance

Kotlin Native is a powerful technology that enables you to write Kotlin code that can compile to native binaries for various platforms. This capability, combined with the Kotlin Multiplatform approach, allows you to share business logic across platforms while still leveraging platform-specific APIs and features.

## Additional Resources

- [Official Kotlin Native Documentation](https://kotlinlang.org/docs/native-overview.html)
- [Kotlin Native GitHub Repository](https://github.com/JetBrains/kotlin/tree/master/kotlin-native)
- [KMM (Kotlin Multiplatform Mobile) Documentation](https://kotlinlang.org/docs/kmm-overview.html)
- [Kotlin Native Samples](https://github.com/JetBrains/kotlin-native/tree/master/samples)

## Exercises

1. Create a simple command-line calculator app that works on multiple platforms
2. Write a library that processes JSON data and can be used from both Kotlin and Swift
3. Implement a platform-specific file reader that works on Windows, Linux, and macOS
4. Create a program that interoperates with a C library (like SQLite or libcurl)
5. Build a shared library that can be used from Android and iOS applications