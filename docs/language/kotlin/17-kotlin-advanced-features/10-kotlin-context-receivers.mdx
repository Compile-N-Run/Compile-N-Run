---
title: "Kotlin Context Receivers"
description: "Learn about Kotlin's Context Receivers feature, an advanced way to handle contextual programming with improved readability and type safety"

---

# Kotlin Context Receivers

## Introduction

Kotlin is known for its expressive and concise syntax that helps developers write clean and maintainable code. Among its advanced features, **Context Receivers** represent a powerful extension to Kotlin's capabilities for contextual programming.

Context Receivers were introduced as an experimental feature in Kotlin 1.6.20 and provide a way to specify multiple receiver types for a function or property. This feature expands on Kotlin's existing receiver concepts (like extension functions and with() expressions) to create more flexible and readable code.

In this guide, we'll explore what Context Receivers are, how they work, and how they can improve your Kotlin codebase through practical examples.

## Prerequisites

To follow along with this guide, you should:
- Have a basic understanding of Kotlin
- Be familiar with Kotlin extension functions and receivers
- Have Kotlin 1.6.20 or later installed

## Understanding Context Receivers

### What Are Receivers in Kotlin?

Before diving into Context Receivers, let's quickly review what receivers are in Kotlin:

1. **Extension Functions**: Allow you to "add" functions to existing types without modifying them.
2. **Scope Functions**: Functions like `with`, `let`, `run`, etc., that create temporary scopes with an object as the receiver.

In both cases, the "receiver" is the object on which methods are called without explicit qualification inside the scope.

### What Are Context Receivers?

Context Receivers extend this concept to allow multiple receivers for a single function or property. This enables a function to:
- Access members from multiple contexts
- Express requirements more clearly
- Make code more modular and reusable

## Enabling Context Receivers

Context Receivers are still an experimental feature, so you need to enable them explicitly:

```kotlin
// In your gradle.build.kts file
kotlin {
    sourceSets.all {
        languageSettings.enableLanguageFeature("ContextReceivers")
    }
}
```

Or by adding a compiler argument:

```kotlin
// In your gradle.build.kts file
tasks.withType<KotlinCompile>().configureEach {
    kotlinOptions.freeCompilerArgs += "-Xcontext-receivers"
}
```

## Basic Syntax of Context Receivers

The syntax for context receivers uses the `context(Type1, Type2, ...)` prefix:

```kotlin
context(Logger, Database)
fun saveUser(user: User) {
    log("Saving user: ${user.name}") // Method from Logger context
    insert(user)                     // Method from Database context
}
```

In this example, `saveUser` has access to methods from both the `Logger` and `Database` contexts without needing explicit qualifiers.

## Simple Context Receivers Example

Let's start with a basic example:

```kotlin
// Define some context classes
class NetworkManager {
    fun makeRequest(url: String): String = "Response from $url"
}

class Logger {
    fun log(message: String) = println("LOG: $message")
}

// Function with multiple context receivers
context(NetworkManager, Logger)
fun fetchDataAndLog(endpoint: String): String {
    log("Making request to $endpoint")        // Using Logger's method
    val response = makeRequest(endpoint)      // Using NetworkManager's method
    log("Received response: $response")
    return response
}

// Using the function
fun main() {
    val network = NetworkManager()
    val logger = Logger()
    
    with(network) {
        with(logger) {
            val data = fetchDataAndLog("api/users")
            println("Result: $data")
        }
    }
}
```

**Output:**
```
LOG: Making request to api/users
LOG: Received response: Response from api/users
Result: Response from api/users
```

## Real-World Example: Building a UI with Context Receivers

Let's look at a more practical example of using context receivers to build a UI component system:

```kotlin
// Different context types for our UI framework
class StyleContext {
    fun applyStyle(element: String, style: String) {
        println("Applying style '$style' to $element")
    }
    
    val primaryColor = "#0066CC"
    val secondaryColor = "#EEEEEE"
}

class LayoutContext {
    fun addToContainer(element: String) {
        println("Adding $element to container")
    }
    
    fun withPadding(amount: Int, block: () -> Unit) {
        println("Adding padding: $amount")
        block()
        println("Padding scope ended")
    }
}

class EventContext {
    fun onClick(element: String, action: () -> Unit) {
        println("Registering click handler for $element")
    }
}

// UI component using all contexts
context(StyleContext, LayoutContext, EventContext)
fun buildButton(text: String) {
    val button = "Button with text: $text"
    applyStyle(button, "background-color: $primaryColor; color: white")
    withPadding(8) {
        addToContainer(button)
    }
    onClick(button) {
        println("Button '$text' was clicked")
    }
}

// Using our UI framework
fun createUI() {
    val styleContext = StyleContext()
    val layoutContext = LayoutContext()
    val eventContext = EventContext()
    
    with(styleContext) {
        with(layoutContext) {
            with(eventContext) {
                buildButton("Submit")
                buildButton("Cancel")
            }
        }
    }
}

fun main() {
    createUI()
}
```

**Output:**
```
Applying style 'background-color: #0066CC; color: white' to Button with text: Submit
Adding padding: 8
Adding Button with text: Submit to container
Padding scope ended
Registering click handler for Button with text: Submit
Applying style 'background-color: #0066CC; color: white' to Button with text: Cancel
Adding padding: 8
Adding Button with text: Cancel to container
Padding scope ended
Registering click handler for Button with text: Cancel
```

This example shows how context receivers can make domain-specific languages (DSLs) more modular and readable.

## Advanced Usage: Context Receivers with Extensions

Context receivers work wonderfully with extension functions:

```kotlin
class StringBuilder {
    private var content = ""
    fun append(str: String) { content += str }
    fun build(): String = content
}

class HtmlContext {
    fun h1(text: String) = "<h1>$text</h1>"
    fun p(text: String) = "<p>$text</p>"
}

class StyleContext {
    fun color(text: String, color: String) = "<span style=\"color: $color\">$text</span>"
}

// Extension function with context receivers
context(HtmlContext, StyleContext)
fun StringBuilder.addStyledHeader(text: String, headerColor: String) {
    append(color(h1(text), headerColor))
}

context(HtmlContext)
fun StringBuilder.addParagraph(text: String) {
    append(p(text))
}

fun buildHtml(): String {
    val htmlContext = HtmlContext()
    val styleContext = StyleContext()
    val builder = StringBuilder()
    
    with(htmlContext) {
        with(styleContext) {
            builder.addStyledHeader("Welcome to Kotlin", "blue")
        }
        builder.addParagraph("Context receivers are powerful!")
    }
    
    return builder.build()
}

fun main() {
    val html = buildHtml()
    println(html)
}
```

**Output:**
```
<span style="color: blue"><h1>Welcome to Kotlin</h1></span><p>Context receivers are powerful!</p>
```

## Comparing With Other Approaches

To appreciate Context Receivers better, let's compare with alternative approaches:

### Without Context Receivers

```kotlin
class Logger {
    fun log(message: String) = println("LOG: $message")
}

class Database {
    fun insert(data: String) = println("DB: Inserted $data")
}

// Without context receivers (using explicit parameters)
fun saveUser(user: String, logger: Logger, database: Database) {
    logger.log("Saving user: $user")
    database.insert(user)
}

fun main() {
    val logger = Logger()
    val database = Database()
    saveUser("John", logger, database)
}
```

### With Context Receivers

```kotlin
context(Logger, Database)
fun saveUser(user: String) {
    log("Saving user: $user")  // From Logger context
    insert(user)               // From Database context
}

fun main() {
    val logger = Logger()
    val database = Database()
    
    with(logger) {
        with(database) {
            saveUser("John")
        }
    }
}
```

The context receivers approach often leads to more readable code, especially when there are multiple contexts involved.

## Best Practices and Considerations

1. **Use Sparingly**: While powerful, context receivers can make code flow harder to follow if overused.
2. **Clear Naming**: Choose context class names that clearly indicate their purpose.
3. **Organize Related Functionality**: Group related methods in context classes for better organization.
4. **Document Dependencies**: Clearly document what each context is used for in your function.
5. **Consider Compilation Impact**: Context receivers may have an impact on compilation time and generated code size.

## Limitations and Future Development

As an experimental feature, context receivers have some current limitations:

1. **Experimental Status**: The API may change in future Kotlin versions.
2. **IDE Support**: IDE support for context receivers is still evolving.
3. **Learning Curve**: The feature introduces additional complexity that may be challenging for beginners.

## When to Use Context Receivers

Context receivers are particularly useful when:

- Building DSLs (Domain Specific Languages)
- Working with multiple cross-cutting concerns (logging, security, transactions)
- Creating frameworks where components need access to multiple capabilities
- Implementing dependency injection patterns without heavy frameworks

## Summary

Kotlin Context Receivers provide a powerful mechanism for expressing multiple receiver contexts within a function or property. This feature enhances Kotlin's already strong capabilities for creating expressive and concise code.

Key benefits include:
- Cleaner code with fewer explicit parameters
- Improved readability by reducing nesting
- Enhanced type safety compared to implicit approaches
- Better organization of contextual capabilities

While still experimental, context receivers represent an exciting direction for Kotlin's development and can already be useful in many practical scenarios.

## Additional Resources

- [Kotlin Context Receivers KIP](https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md) - The official Kotlin Improvement Proposal
- [Kotlin 1.6.20 Release Notes](https://kotlinlang.org/docs/whatsnew1620.html#context-receivers-for-kotlin-jvm) - Official documentation on the feature release
- [Kotlin Language Documentation](https://kotlinlang.org/docs/home.html) - For deeper learning about Kotlin features

## Exercises

1. Create a simple logging system with context receivers that allows different formatting based on log levels.
2. Implement a mini database access layer using context receivers for transaction management.
3. Build a small UI framework similar to the example above but add more components and contexts.
4. Refactor an existing codebase that uses explicit parameters to use context receivers instead.
5. Create a testing utility that uses context receivers to provide mocks and verification capabilities.

By mastering Context Receivers, you'll add a powerful tool to your Kotlin programming toolkit that can help create more maintainable and expressive code.