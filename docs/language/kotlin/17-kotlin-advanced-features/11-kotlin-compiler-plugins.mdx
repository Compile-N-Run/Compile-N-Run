---
title: Kotlin Compiler Plugins
description: Learn how Kotlin compiler plugins extend the language functionality and how to use them effectively in your projects

---

# Kotlin Compiler Plugins

## Introduction

Kotlin compiler plugins are powerful tools that extend the Kotlin language by modifying how the compiler processes your code. Unlike regular libraries that provide functionality at runtime, compiler plugins work during the compilation phase, enabling language features that would otherwise be impossible or difficult to implement.

These plugins integrate with the Kotlin compiler to transform or generate code, add custom checks, or implement language extensions without modifying the compiler itself. This makes them an essential part of Kotlin's extensibility story, allowing the language to evolve and adapt to different use cases.

In this tutorial, we'll explore the most important Kotlin compiler plugins, how they work, and how you can use them in your projects.

## Understanding Compiler Plugins

### What Are Compiler Plugins?

Compiler plugins are extensions that hook into the compilation process to:

1. **Transform code**: Modify the code before it's compiled
2. **Generate new code**: Add additional code that wasn't in the original source
3. **Perform additional checks**: Add custom validation during compilation
4. **Enable language features**: Support syntax or behavior not part of the core language

### How Plugins Differ from Libraries

Before diving deeper, let's understand how compiler plugins differ from regular libraries:

| Compiler Plugins | Regular Libraries |
| --- | --- |
| Work during compilation | Work at runtime |
| Can generate or modify code | Can only use existing code |
| Integrated with the compiler | Imported and used by your code |
| Usually require build tool configuration | Simply added as dependencies |

## Popular Kotlin Compiler Plugins

Let's explore some of the most widely used Kotlin compiler plugins:

### 1. kotlin-allopen

By default, Kotlin classes are final (non-inheritable). The `kotlin-allopen` plugin makes classes open (inheritable) based on annotations, which is particularly useful when working with frameworks that rely on inheritance, like Spring.

#### Configuration in Gradle

```kotlin
plugins {
    kotlin("jvm") version "1.9.0"
    kotlin("plugin.spring") version "1.9.0" // includes allopen with Spring annotations
}

// Or manually:
plugins {
    kotlin("jvm") version "1.9.0"
    kotlin("plugin.allopen") version "1.9.0"
}

allOpen {
    annotation("com.example.Openable")
}
```

#### Example Usage

```kotlin
// Without allopen, this class would be final and can't be extended
@Service // Spring annotation - recognized by allopen when using plugin.spring
class UserService {
    fun getUsers(): List<User> {
        // implementation
        return listOf()
    }
}

// Custom annotation approach
@Target(AnnotationTarget.CLASS)
annotation class Openable

@Openable // This will make the class open thanks to allopen configuration
class ConfigService {
    fun getConfig(): Config {
        // implementation
        return Config()
    }
}
```

### 2. kotlin-noarg

This plugin generates no-argument constructors for classes with specific annotations. This is useful for frameworks like JPA that require no-arg constructors for entity classes.

#### Configuration in Gradle

```kotlin
plugins {
    kotlin("jvm") version "1.9.0"
    kotlin("plugin.jpa") version "1.9.0" // includes noarg with JPA annotations
}

// Or manually:
plugins {
    kotlin("jvm") version "1.9.0"
    kotlin("plugin.noarg") version "1.9.0"
}

noArg {
    annotation("com.example.NoArg")
}
```

#### Example Usage

```kotlin
// JPA entities need no-arg constructors, which this plugin provides
@Entity
class User(
    @Id val id: Long,
    val name: String,
    val email: String
)

// Custom annotation approach
@Target(AnnotationTarget.CLASS)
annotation class NoArg

@NoArg
class Product(val id: String, val name: String, val price: Double)
```

Behind the scenes, the plugin generates a no-argument constructor that isn't visible in your source code.

### 3. kotlin-serialization

This official Kotlin plugin enables the `kotlinx.serialization` library to work by generating serialization code during compilation.

#### Configuration in Gradle

```kotlin
plugins {
    kotlin("jvm") version "1.9.0"
    kotlin("plugin.serialization") version "1.9.0"
}

dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.1")
}
```

#### Example Usage

```kotlin
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json

@Serializable
data class Person(val name: String, val age: Int)

fun main() {
    val person = Person("John Doe", 30)
    
    // Serialization to JSON
    val jsonString = Json.encodeToString(person)
    println("Serialized: $jsonString")
    
    // Deserialization from JSON
    val deserializedPerson = Json.decodeFromString<Person>(jsonString)
    println("Deserialized: $deserializedPerson")
}
```

Output:
```
Serialized: {"name":"John Doe","age":30}
Deserialized: Person(name=John Doe, age=30)
```

### 4. kotlin-parcelize

Android developers will appreciate this plugin, which automatically generates Parcelable implementation code for Kotlin data classes.

#### Configuration in Gradle

```kotlin
plugins {
    id("com.android.application")
    kotlin("android") version "1.9.0"
    id("kotlin-parcelize")
}
```

#### Example Usage

```kotlin
import android.os.Parcelable
import kotlinx.parcelize.Parcelize

@Parcelize
data class User(
    val id: Int,
    val name: String,
    val email: String
) : Parcelable

// Now you can pass this class between Android components:
fun startDetailActivity(user: User) {
    val intent = Intent(this, DetailActivity::class.java)
    intent.putExtra("USER", user)
    startActivity(intent)
}

// And retrieve it in the other Activity:
fun retrieveUser() {
    val user = intent.getParcelableExtra<User>("USER")
    // Use the user object
}
```

### 5. Compose Compiler Plugin

This plugin powers Jetpack Compose, enabling the reactive UI framework for Android.

#### Configuration in Gradle

```kotlin
plugins {
    id("com.android.application")
    kotlin("android") version "1.9.0"
}

dependencies {
    implementation("androidx.compose.ui:ui:1.4.3")
    // Other compose dependencies
}

android {
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.1"
    }
}
```

#### Example Usage

```kotlin
import androidx.compose.material.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue

@Composable
fun GreetingScreen() {
    var name by remember { mutableStateOf("World") }
    
    Text("Hello, $name!")
}
```

The Compose compiler plugin transforms this code to efficiently track state changes and update only the necessary UI components.

## Creating Custom Compiler Plugins

Creating custom compiler plugins is an advanced topic and requires understanding of the Kotlin compiler internals. While beyond the scope of this tutorial, the high-level steps involved are:

1. Set up a Gradle project for your compiler plugin
2. Implement the `ComponentRegistrar` interface to register your plugin with the compiler
3. Use the Kotlin compiler API to detect code patterns and perform transformations
4. Package and publish your plugin

If you're interested in developing your own compiler plugins, the [Kotlin Symbol Processing API (KSP)](https://kotlinlang.org/docs/ksp-overview.html) provides a more accessible approach for many common use cases.

## Best Practices for Using Compiler Plugins

When using compiler plugins, keep these best practices in mind:

1. **Use sparingly**: Each plugin adds complexity to your build process and can slow down compilation
2. **Document usage**: Make sure all team members understand which plugins are being used and why
3. **Version consistency**: Keep plugin versions aligned with your Kotlin version to avoid compatibility issues
4. **Watch for behavior changes**: Code with plugins may behave differently than you'd expect from standard Kotlin
5. **Test thoroughly**: Verify that the generated code works as expected in all scenarios

## Real-World Example: Building a Spring Boot Application

Let's see how compiler plugins work together in a Spring Boot application:

```kotlin
plugins {
    kotlin("jvm") version "1.9.0"
    kotlin("plugin.spring") version "1.9.0"
    kotlin("plugin.jpa") version "1.9.0"
    kotlin("plugin.serialization") version "1.9.0"
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.1")
    // Other dependencies
}
```

The application code:

```kotlin
import kotlinx.serialization.Serializable
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import org.springframework.stereotype.Service
import org.springframework.web.bind.annotation.*
import javax.persistence.Entity
import javax.persistence.Id

@SpringBootApplication
class Application

fun main(args: Array<String>) {
    runApplication<Application>(*args)
}

@Entity
@Serializable
data class Product(
    @Id val id: Long,
    val name: String,
    val price: Double
)

@Repository
interface ProductRepository : JpaRepository<Product, Long>

@Service
class ProductService(private val repository: ProductRepository) {
    fun getAllProducts() = repository.findAll()
    fun getProduct(id: Long) = repository.findById(id)
    fun saveProduct(product: Product) = repository.save(product)
}

@RestController
@RequestMapping("/products")
class ProductController(private val service: ProductService) {
    @GetMapping
    fun getAllProducts() = service.getAllProducts()
    
    @GetMapping("/{id}")
    fun getProduct(@PathVariable id: Long) = service.getProduct(id)
    
    @PostMapping
    fun createProduct(@RequestBody product: Product) = service.saveProduct(product)
}
```

In this example:
- `plugin.spring` makes Spring-annotated classes open
- `plugin.jpa` generates no-arg constructors for JPA entities
- `plugin.serialization` enables `@Serializable` to work for JSON conversion

## Summary

Kotlin compiler plugins are powerful tools that extend the language capabilities beyond what's possible with regular libraries. They work by modifying or generating code during compilation, enabling integration with frameworks and platforms that have specific requirements.

The most common compiler plugins include:
- **kotlin-allopen**: Makes classes inheritable based on annotations
- **kotlin-noarg**: Generates no-argument constructors for annotated classes
- **kotlin-serialization**: Enables compile-time serialization code generation
- **kotlin-parcelize**: Automates Parcelable implementation for Android
- **Compose compiler**: Powers the reactive UI framework for Android

By understanding how these plugins work and when to use them, you can leverage Kotlin's full potential while keeping your code concise and expressive.

## Additional Resources

- [Official Kotlin Compiler Plugins Documentation](https://kotlinlang.org/docs/reference/compiler-plugins.html)
- [Kotlin Symbol Processing API](https://kotlinlang.org/docs/ksp-overview.html)
- [KotlinX Serialization Guide](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/serialization-guide.md)
- [Spring Boot with Kotlin Guide](https://spring.io/guides/tutorials/spring-boot-kotlin/)

## Exercises

1. Configure a Gradle project with the `kotlin-allopen` plugin and create a class with a custom annotation that makes it open.
2. Create a JPA entity class using the `kotlin-noarg` plugin and verify that it works with a JPA repository.
3. Use the `kotlinx.serialization` plugin to create a data class that can be serialized to both JSON and XML formats.
4. If you're an Android developer, try using the `kotlin-parcelize` plugin to simplify passing data between Activities.
5. Explore the documentation for a compiler plugin not covered in this tutorial and experiment with using it in a small project.