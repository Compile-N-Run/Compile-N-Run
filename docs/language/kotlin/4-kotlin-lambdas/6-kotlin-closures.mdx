---
title: Kotlin Closures
description: Learn about closures in Kotlin - how functions can capture and remember variables from their outer scope, creating powerful and flexible programming patterns.

---

# Kotlin Closures

## Introduction

In Kotlin, a closure is a function that can access and manipulate variables defined outside of its scope. This powerful concept allows functions, particularly lambdas, to "remember" and use variables from the context in which they were created, even after that context is no longer directly accessible.

Closures are a fundamental part of functional programming in Kotlin and provide a way to make your code more concise and expressive by preserving state between function calls.

## Understanding Closures

### What is a Closure?

A closure consists of:
- A function (often a lambda)
- The environment in which it was created
- Access to variables from that environment, even when executed elsewhere

Think of a closure as a function that "closes over" or captures the variables from its surrounding scope.

### Basic Example of a Closure

```kotlin
fun createCounter(): () -> Int {
    var count = 0  // This variable is declared outside the lambda
    
    // The lambda "closes over" the count variable
    val counter = { count++ }  // Increment and return count
    
    return counter  // Return the lambda function
}

fun main() {
    val myCounter = createCounter()
    
    println(myCounter())  // Output: 0
    println(myCounter())  // Output: 1
    println(myCounter())  // Output: 2
    
    // Create a new counter
    val anotherCounter = createCounter()
    println(anotherCounter())  // Output: 0 (independent of myCounter)
}
```

In this example, `count` is defined in the `createCounter` function, but the returned lambda can still access and modify it even after `createCounter` has completed execution. Each call to `createCounter` creates a new independent closure with its own `count` variable.

## How Closures Work in Kotlin

Kotlin implements closures by capturing variables in special structures that persist even after the function where they were declared completes. This allows the variables to remain accessible to the lambda.

### Variable Capture Behavior

Variables can be captured in two ways:

1. **By value** - For immutable values (val), a copy of the value is stored
2. **By reference** - For mutable values (var), a reference to the variable is stored

```kotlin
fun closureDemonstration() {
    var mutableValue = 5
    val immutableValue = 10
    
    val printValues = {
        println("Mutable: $mutableValue, Immutable: $immutableValue")
    }
    
    printValues()  // Output: Mutable: 5, Immutable: 10
    
    mutableValue = 7
    
    printValues()  // Output: Mutable: 7, Immutable: 10
}

fun main() {
    closureDemonstration()
}
```

Notice how the lambda sees the updated value of `mutableValue` but `immutableValue` remains constant.

## Common Closure Patterns

### 1. Event Handlers

Closures are commonly used for event handling where they capture the state at the time of registration:

```kotlin
fun setupButton(buttonText: String) {
    var clickCount = 0
    
    // The onClick lambda captures both buttonText and clickCount
    val button = Button(buttonText)
    button.onClick = {
        clickCount++
        println("'$buttonText' clicked $clickCount times")
    }
    
    // Return button or add it to UI...
}
```

### 2. Creating Factory Functions

Closures allow for elegant factory function patterns:

```kotlin
fun makeGreeter(greeting: String): (String) -> String {
    return { name -> "$greeting, $name!" }
}

fun main() {
    val sayHello = makeGreeter("Hello")
    val sayHowdy = makeGreeter("Howdy")
    
    println(sayHello("Alice"))  // Output: Hello, Alice!
    println(sayHowdy("Bob"))    // Output: Howdy, Bob!
}
```

### 3. Memoization (Caching Results)

Closures can be used to implement memoization - a technique to cache function results:

```kotlin
fun createMemoizedFunction(): (Int) -> Int {
    val cache = mutableMapOf<Int, Int>()
    
    return { n: Int ->
        cache.getOrPut(n) {
            println("Computing for $n")
            // Expensive computation (here just a simple example)
            n * n
        }
    }
}

fun main() {
    val square = createMemoizedFunction()
    
    println(square(4))  // Output: Computing for 4 \n 16
    println(square(4))  // Output: 16 (retrieved from cache)
    println(square(5))  // Output: Computing for 5 \n 25
}
```

## Closure Scope and Variables

### Local Variables in Closures

Kotlin allows lambdas to access local variables, making them part of the closure:

```kotlin
fun processData(data: List<Int>, threshold: Int): List<Int> {
    var count = 0
    
    return data.filter {
        if (it > threshold) {
            count++  // Modifying the captured variable
            true
        } else {
            false
        }
    }.also {
        println("Found $count values above threshold")
    }
}

fun main() {
    val result = processData(listOf(1, 5, 3, 9, 7, 2), 4)
    println(result)  // Output: Found 3 values above threshold \n [5, 9, 7]
}
```

### Final Variables and Closures

In Kotlin, you can capture both `val` (read-only) and `var` (mutable) variables in closures:

```kotlin
fun generateFibonacciSequence(): Sequence<Int> {
    var a = 0
    var b = 1
    
    // This lambda captures and modifies a and b
    return generateSequence {
        val result = a
        val next = a + b
        a = b
        b = next
        result
    }
}

fun main() {
    val fibonacci = generateFibonacciSequence()
    println(fibonacci.take(10).toList())  // Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
}
```

## Practical Examples

### Example 1: Custom Iterator with State

Let's create a custom iterator that remembers its state using closures:

```kotlin
fun createPowerSequence(base: Int): () -> Int {
    var exponent = 0
    
    return {
        val result = base.toDouble().pow(exponent).toInt()
        exponent++
        result
    }
}

fun main() {
    val powersOfTwo = createPowerSequence(2)
    
    repeat(5) {
        println(powersOfTwo())
    }
    // Output:
    // 1  (2^0)
    // 2  (2^1)
    // 4  (2^2)
    // 8  (2^3)
    // 16 (2^4)
    
    val powersOfThree = createPowerSequence(3)
    println(powersOfThree())  // Output: 1 (3^0)
    println(powersOfThree())  // Output: 3 (3^1)
}
```

### Example 2: Data Processing Pipeline

Closures enable building flexible data processing pipelines:

```kotlin
fun createDataProcessor(initialData: List<Int>): DataProcessor {
    var data = initialData
    
    val filter: (Int) -> Boolean = { it % 2 == 0 }
    val map: (Int) -> Int = { it * 2 }
    
    return object : DataProcessor {
        override fun applyFilter(): DataProcessor {
            data = data.filter(filter)
            return this
        }
        
        override fun applyTransformation(): DataProcessor {
            data = data.map(map)
            return this
        }
        
        override fun getResult(): List<Int> = data
    }
}

interface DataProcessor {
    fun applyFilter(): DataProcessor
    fun applyTransformation(): DataProcessor
    fun getResult(): List<Int>
}

fun main() {
    val processor = createDataProcessor(listOf(1, 2, 3, 4, 5, 6))
    
    // Process the data
    val result = processor
        .applyFilter()       // Keep even numbers: [2, 4, 6]
        .applyTransformation() // Multiply by 2: [4, 8, 12]
        .getResult()
        
    println(result)  // Output: [4, 8, 12]
}
```

### Example 3: Partial Function Application

Closures allow for partial application of functions (fixing some arguments):

```kotlin
fun createMultiplier(factor: Int): (Int) -> Int {
    return { number -> factor * number }
}

fun main() {
    val double = createMultiplier(2)
    val triple = createMultiplier(3)
    
    println(double(10))  // Output: 20
    println(triple(10))  // Output: 30
    
    // Use with collections
    val numbers = listOf(1, 2, 3, 4, 5)
    println(numbers.map(double))  // Output: [2, 4, 6, 8, 10]
    println(numbers.map(triple))  // Output: [3, 6, 9, 12, 15]
}
```

## Potential Issues with Closures

### Memory Leaks

Closures can inadvertently cause memory leaks if they capture references to large objects:

```kotlin
fun riskyFunction() {
    val largeData = LargeDataClass()  // Imagine this holds a lot of memory
    
    someObject.setCallback {
        // This lambda captures largeData, preventing it from being garbage collected
        // until someObject releases the callback
        println(largeData.someProperty)
    }
}
```

### Mutability Concerns

Captured mutable variables can lead to unexpected behavior:

```kotlin
fun createFunctions(): List<() -> Int> {
    val functions = mutableListOf<() -> Int>()
    
    // Problem: All functions will use the final value of i
    var i = 0
    while (i < 3) {
        functions.add { i }  // Captures reference to i, not its value
        i++
    }
    
    return functions
}

fun createFunctionsProperly(): List<() -> Int> {
    val functions = mutableListOf<() -> Int>()
    
    // Solution: Create a new variable in each iteration
    for (i in 0 until 3) {
        val capturedI = i  // New variable for each iteration
        functions.add { capturedI }
        // Or more concisely: functions.add { i }  // In Kotlin, loop variables are scoped to each iteration
    }
    
    return functions
}

fun main() {
    val badFunctions = createFunctions()
    for (f in badFunctions) {
        println(f())  // Output: 3, 3, 3
    }
    
    val goodFunctions = createFunctionsProperly()
    for (f in goodFunctions) {
        println(f())  // Output: 0, 1, 2
    }
}
```

## Summary

Closures in Kotlin are a powerful feature that lets functions capture and remember their surrounding context. They form the backbone of many functional programming patterns and enable more concise and flexible code.

Key points to remember:
- Closures "close over" variables from their enclosing scope
- They can capture both val (immutable) and var (mutable) variables
- Each closure instance maintains its own captured state
- Closures enable powerful patterns like callbacks, factories, and memoization
- Be mindful of potential memory leaks when capturing references in long-lived closures

## Additional Resources

- [Kotlin Official Documentation on Lambdas](https://kotlinlang.org/docs/lambdas.html)
- [Functional Programming with Kotlin](https://www.manning.com/books/functional-programming-in-kotlin)

## Exercises

1. Create a simple counter function that uses a closure to maintain state.
2. Implement a function that returns different greeting functions based on the time of day.
3. Write a memoization function that caches the results of an expensive calculation.
4. Create a function that builds a custom logger which remembers a prefix and severity level.
5. Implement a simple event system with subscription functions that use closures to maintain callbacks.