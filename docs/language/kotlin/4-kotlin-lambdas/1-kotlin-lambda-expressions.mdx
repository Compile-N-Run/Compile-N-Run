---
title: Kotlin Lambda Expressions
description: Learn about lambda expressions in Kotlin - what they are, how to use them, and why they're useful in modern programming

---

# Kotlin Lambda Expressions

## Introduction to Lambda Expressions

Lambda expressions are one of Kotlin's most powerful features, allowing you to write concise code in a functional programming style. Simply put, a lambda is a function that doesn't have a name - it's an anonymous function that can be passed around as an expression.

Lambdas are particularly useful for:
- Passing behavior as arguments to functions
- Creating short, inline function definitions
- Working with collections (filtering, mapping, etc.)
- Building cleaner, more readable code

Let's dive into understanding lambda expressions in Kotlin and how they can improve your code.

## Basic Lambda Syntax

A Kotlin lambda expression has the following structure:

```kotlin
{ parameter(s) -> body }
```

Where:
- The curly braces `{ }` encapsulate the entire lambda expression
- `parameter(s)` are the input parameters (optional if none are needed)
- The arrow `->` separates parameters from the body
- `body` contains the expressions or statements to execute

Let's see some simple examples:

```kotlin
// A lambda that takes no parameters and returns a String
val greet = { "Hello, World!" }
println(greet()) // Output: Hello, World!

// A lambda that takes one parameter and returns its square
val square = { x: Int -> x * x }
println(square(4)) // Output: 16

// A lambda that takes two parameters and returns their sum
val sum = { a: Int, b: Int -> a + b }
println(sum(5, 3)) // Output: 8
```

## Lambda Type Declarations

When assigning lambdas to variables, you can specify their type using function type notation:

```kotlin
// Explicitly declared function type
val greet: () -> String = { "Hello, World!" }
val square: (Int) -> Int = { x -> x * x }
val sum: (Int, Int) -> Int = { a, b -> a + b }
```

Note that when the parameter types can be inferred from the function type declaration, you can omit them in the lambda:

```kotlin
// No need to write { x: Int -> x * x } since the type is declared
val square: (Int) -> Int = { x -> x * x }
```

## Passing Lambdas to Functions

One of the most common uses for lambdas is passing them as arguments to other functions:

```kotlin
fun operateOnNumbers(a: Int, b: Int, operation: (Int, Int) -> Int): Int {
    return operation(a, b)
}

// Using the function with different operations
val result1 = operateOnNumbers(10, 5, { a, b -> a + b })
val result2 = operateOnNumbers(10, 5, { a, b -> a - b })
val result3 = operateOnNumbers(10, 5, { a, b -> a * b })

println(result1) // Output: 15
println(result2) // Output: 5
println(result3) // Output: 50
```

## Trailing Lambda Syntax

Kotlin has a special syntax for passing a lambda as the last parameter to a function. When a function's last parameter is a function, you can place the lambda outside the parentheses:

```kotlin
// Instead of this:
operateOnNumbers(10, 5, { a, b -> a + b })

// You can write:
operateOnNumbers(10, 5) { a, b -> a + b }
```

If the function has only one parameter and it's a lambda, you can omit the parentheses entirely:

```kotlin
fun executeOperation(operation: () -> Unit) {
    operation()
}

// Can be called as:
executeOperation { println("Executing operation") }
```

## The `it` Implicit Parameter

For lambdas with a single parameter, Kotlin provides a shorthand: you can use the implicit parameter name `it` instead of declaring a named parameter:

```kotlin
// Using a named parameter
val squareNamed = { x: Int -> x * x }

// Using the implicit 'it' parameter
val squareImplicit: (Int) -> Int = { it * it }

println(squareNamed(4))    // Output: 16
println(squareImplicit(4)) // Output: 16
```

This makes short lambdas even more concise:

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)

// Using named parameter
val evenNumbers1 = numbers.filter({ n -> n % 2 == 0 })

// Using 'it' and trailing lambda
val evenNumbers2 = numbers.filter { it % 2 == 0 }

println(evenNumbers2) // Output: [2, 4]
```

## Capturing Variables in Lambdas

Lambdas can access and modify variables declared in the outer scope - this is known as "capturing":

```kotlin
var sum = 0
val numbers = listOf(1, 2, 3, 4, 5)

numbers.forEach { 
    sum += it 
}

println("The sum is $sum") // Output: The sum is 15
```

Be careful with capturing variables from outer scopes, especially if lambdas are stored and used later, as you might experience unexpected behavior.

## Returning from Lambdas

By default, the last expression in a lambda becomes its return value. However, you can use explicit `return` statements within lambdas:

```kotlin
val multiply = { a: Int, b: Int ->
    val result = a * b
    result // This is the return value
}

println(multiply(4, 5)) // Output: 20
```

When using `return` in a lambda, it returns from the enclosing function, not just the lambda. To return only from the lambda, use a qualified return:

```kotlin
fun processNumbers() {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    numbers.forEach {
        if (it == 3) return@forEach // Returns just from the lambda
        println("Processing $it")
    }
    
    println("Done processing numbers")
}

// Output:
// Processing 1
// Processing 2
// Processing 4
// Processing 5
// Done processing numbers
```

## Real-World Applications of Lambdas

### Working with Collections

Lambdas shine when working with collections through extension functions like `filter`, `map`, `reduce`, etc.

```kotlin
val people = listOf(
    Person("Alice", 29),
    Person("Bob", 31),
    Person("Carol", 25),
    Person("Dave", 29)
)

// Find people older than 30
val olderPeople = people.filter { it.age > 30 }
println("People older than 30: ${olderPeople.map { it.name }}")
// Output: People older than 30: [Bob]

// Get average age
val averageAge = people.map { it.age }.average()
println("Average age: $averageAge")
// Output: Average age: 28.5

// Group people by age
val byAge = people.groupBy { it.age }
println("People grouped by age: ${byAge.mapValues { it.value.map { person -> person.name } }}")
// Output: People grouped by age: {29=[Alice, Dave], 31=[Bob], 25=[Carol]}
```

### Event Handling

Lambdas are perfect for event-driven programming:

```kotlin
// Android example (conceptual)
button.setOnClickListener { view ->
    // Handle button click
    textView.text = "Button clicked!"
}
```

### Building Custom DSLs

Kotlin lambdas allow for the creation of expressive DSLs (Domain-Specific Languages):

```kotlin
// Example of a simple HTML DSL
fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()
    return html
}

class HTML {
    var body = ""
    
    fun body(init: Body.() -> Unit) {
        val body = Body()
        body.init()
        this.body = body.content
    }
}

class Body {
    var content = ""
    
    fun p(text: String) {
        content += "<p>$text</p>"
    }
}

// Using the DSL
val webpage = html {
    body {
        p("First paragraph")
        p("Second paragraph")
    }
}

println(webpage.body)
// Output: <p>First paragraph</p><p>Second paragraph</p>
```

### Asynchronous Programming

Lambdas are fundamental for asynchronous code and callbacks:

```kotlin
// Conceptual example of asynchronous code
fetchData { response ->
    if (response.isSuccessful) {
        processData(response.data)
    } else {
        showError(response.error)
    }
}
```

## Lambda vs Function References

When you need to pass an existing function as a parameter, you can use function references (`::`) instead of defining a new lambda:

```kotlin
fun isEven(n: Int): Boolean = n % 2 == 0

val numbers = listOf(1, 2, 3, 4, 5)

// Using a lambda
val evenNumbers1 = numbers.filter { isEven(it) }

// Using a function reference (more concise)
val evenNumbers2 = numbers.filter(::isEven)

println(evenNumbers2) // Output: [2, 4]
```

## Performance Considerations

While lambdas are convenient, they do come with some overhead:

- Each lambda expression creates an object instance at runtime
- Capturing variables from the outer scope adds complexity

For performance-critical code, you can use the `inline` modifier on functions that take lambdas as parameters, which instructs the compiler to copy the lambda's body directly to the call site:

```kotlin
inline fun measureTimeMillis(block: () -> Unit): Long {
    val start = System.currentTimeMillis()
    block()
    return System.currentTimeMillis() - start
}

val time = measureTimeMillis {
    // Code to measure
    for (i in 1..1000000) {
        // Do something
    }
}
println("Execution took $time ms")
```

## Summary

Lambda expressions in Kotlin provide a powerful way to write concise, expressive code, enabling functional programming patterns. They allow you to:

- Pass behavior as parameters
- Create anonymous functions on the fly
- Work efficiently with collections
- Build readable, maintainable code
- Create custom DSLs

As you continue learning Kotlin, you'll find that lambdas become an essential tool in your programming toolbox, especially for modern applications using reactive and functional patterns.

## Exercise Ideas

1. Write a function that takes a list of integers and a lambda to transform each integer, then returns the transformed list.
2. Create a simple calculator that performs operations using lambdas.
3. Implement a "compose" function that takes two functions (as lambdas) and returns a new function that is their composition.
4. Build a mini text processing library using lambdas for operations like filtering lines, mapping text transforms, etc.
5. Create a simple event system using lambdas as callbacks.

## Additional Resources

- [Kotlin Official Documentation on Lambdas](https://kotlinlang.org/docs/lambdas.html)
- [Function References in Kotlin](https://kotlinlang.org/docs/reflection.html#function-references)
- Book: "Kotlin in Action" by Dmitry Jemerov and Svetlana Isakova (covers lambdas extensively)
- [Advanced Kotlin: Lambdas and Higher-Order Functions](https://www.baeldung.com/kotlin-lambda-expressions)

Remember, mastering lambdas takes practice, so experiment with them in your projects to become more fluent with functional programming concepts in Kotlin!

data class Person(val name: String, val age: Int)