---
title: Kotlin Data Classes
description: Learn about Kotlin data classes, their purpose, features, and how they simplify the creation of classes focused on holding data.

---

# Kotlin Data Classes

## Introduction

In many applications, we create classes that do nothing but hold data. These classes typically contain fields, constructors, getters, setters, `equals()`, `hashCode()`, and `toString()` methods. Writing all this code can be tedious and error-prone.

Kotlin addresses this common scenario with **data classes** - a special kind of class designed specifically to hold data with minimal boilerplate code. With a single `data` keyword, Kotlin automatically generates all the utility functions that are typically required for data storage classes.

## Basic Syntax

Here's the basic syntax for declaring a data class in Kotlin:

```kotlin
data class ClassName(val property1: Type1, val property2: Type2, ...)
```

That's it! The `data` keyword before the `class` keyword tells the compiler that this is a data class.

## What Makes Data Classes Special?

When you define a data class, the Kotlin compiler automatically generates several functions for you:

1. `equals()` and `hashCode()` - for comparing instances
2. `toString()` - returns a string representation like "ClassName(property1=value1, property2=value2)"
3. `componentN()` functions - enable destructuring declarations
4. `copy()` - creates a copy of an instance, optionally modifying some properties

Let's see how this works in practice:

## Basic Example

Let's create a simple data class to represent a user:

```kotlin
data class User(val id: Int, val name: String, val email: String)

fun main() {
    // Create a user
    val user1 = User(1, "John Doe", "john@example.com")
    
    // Print the user
    println(user1)
    
    // Output: User(id=1, name=John Doe, email=john@example.com)
}
```

Notice that we didn't need to define a `toString()` method, yet we got a nice string representation of our `User` object.

## Equality with Data Classes

Data classes provide a meaningful implementation of `equals()`:

```kotlin
fun main() {
    val user1 = User(1, "John Doe", "john@example.com")
    val user2 = User(1, "John Doe", "john@example.com")
    val user3 = User(2, "Jane Doe", "jane@example.com")
    
    println("user1 == user2: ${user1 == user2}")
    println("user1 == user3: ${user1 == user3}")
    
    // Output:
    // user1 == user2: true
    // user1 == user3: false
}
```

Even though `user1` and `user2` are different instances, they are considered equal because they have the same property values.

## The copy() Function

Data classes provide a convenient `copy()` function that allows you to create a copy of an object while changing some of its properties:

```kotlin
fun main() {
    val user1 = User(1, "John Doe", "john@example.com")
    
    // Create a copy with a different email
    val user2 = user1.copy(email = "john.doe@example.com")
    
    println("Original: $user1")
    println("Copy: $user2")
    
    // Output:
    // Original: User(id=1, name=John Doe, email=john@example.com)
    // Copy: User(id=1, name=John Doe, email=john.doe@example.com)
}
```

## Destructuring Declarations

Kotlin's data classes support destructuring declarations, which allows you to extract components of an object into separate variables:

```kotlin
fun main() {
    val user = User(1, "John Doe", "john@example.com")
    
    // Destructuring
    val (id, name, email) = user
    
    println("ID: $id")
    println("Name: $name")
    println("Email: $email")
    
    // Output:
    // ID: 1
    // Name: John Doe
    // Email: john@example.com
}
```

This works because data classes automatically generate `componentN()` functions for each property in order of declaration.

## Real-World Applications

### Example 1: API Responses

Data classes are perfect for modeling API responses:

```kotlin
data class ApiResponse(
    val success: Boolean,
    val message: String,
    val data: Any?
)

fun fetchUserData(userId: Int): ApiResponse {
    // Simulate API call
    return ApiResponse(
        success = true,
        message = "User retrieved successfully",
        data = User(userId, "John Doe", "john@example.com")
    )
}

fun main() {
    val response = fetchUserData(1)
    
    if (response.success) {
        println("Success: ${response.message}")
        println("Data: ${response.data}")
    } else {
        println("Error: ${response.message}")
    }
    
    // Output:
    // Success: User retrieved successfully
    // Data: User(id=1, name=John Doe, email=john@example.com)
}
```

### Example 2: Database Entity Mapping

Data classes work well for database entity mapping:

```kotlin
data class Product(
    val id: Int,
    val name: String,
    val price: Double,
    val category: String
)

// Simulating a database
class ProductDatabase {
    private val products = mutableListOf<Product>()
    
    fun addProduct(product: Product) {
        products.add(product)
    }
    
    fun findByCategory(category: String): List<Product> {
        return products.filter { it.category == category }
    }
}

fun main() {
    val db = ProductDatabase()
    
    db.addProduct(Product(1, "Laptop", 999.99, "Electronics"))
    db.addProduct(Product(2, "Smartphone", 699.99, "Electronics"))
    db.addProduct(Product(3, "T-Shirt", 19.99, "Clothing"))
    
    val electronics = db.findByCategory("Electronics")
    
    println("Electronics products:")
    electronics.forEach { println("- $it") }
    
    // Output:
    // Electronics products:
    // - Product(id=1, name=Laptop, price=999.99, category=Electronics)
    // - Product(id=2, name=Smartphone, price=699.99, category=Electronics)
}
```

## Limitations of Data Classes

While data classes are powerful, they do have some limitations:

1. They cannot be `abstract`, `open`, `sealed`, or `inner`
2. They must have a primary constructor with at least one parameter
3. All primary constructor parameters must be marked as `val` or `var`

## Data Classes Best Practices

1. **Keep them immutable when possible** - Using `val` for properties makes your data classes immutable and safer to use in multi-threaded environments.

2. **Use them for simple data containers** - If you need complex behavior, consider using regular classes.

3. **Follow naming conventions** - Use meaningful names that reflect the data they contain.

4. **Consider adding validation** - You can add validation in init blocks:

```kotlin
data class User(val id: Int, val name: String, val email: String) {
    init {
        require(name.isNotBlank()) { "Name cannot be blank" }
        require(email.contains('@')) { "Invalid email format" }
    }
}
```

## Summary

Kotlin data classes provide a concise way to create classes that are primarily used to hold data. With just the `data` keyword, you get:

- Automatic generation of `equals()`, `hashCode()`, and `toString()`
- A `copy()` function for creating modified copies
- Support for destructuring declarations
- A clean, readable syntax

These features help you write more maintainable and less error-prone code by eliminating boilerplate code that would otherwise be necessary for data handling classes.

## Exercises

1. Create a data class `Book` with properties for `title`, `author`, and `publicationYear`. Create several instances and experiment with the `equals()` and `copy()` methods.

2. Create a data class `Point2D` with `x` and `y` coordinates. Implement a function that calculates the distance between two points.

3. Create a nested structure using data classes to represent a blog post with comments. Each comment should include the commenter's name and the comment text.

## Additional Resources

- [Official Kotlin Documentation on Data Classes](https://kotlinlang.org/docs/data-classes.html)
- [Kotlin Standard Library Documentation](https://kotlinlang.org/api/latest/jvm/stdlib/)
- [Effective Kotlin: Best Practices](https://kt.academy/article/ek-data-classes)