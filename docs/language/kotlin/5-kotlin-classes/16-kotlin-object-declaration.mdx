---
title: Kotlin Object Declaration
description: Learn how to use object declarations in Kotlin to create singleton objects and implement the Singleton pattern easily and efficiently.

---

# Kotlin Object Declaration

## Introduction

In Kotlin, an **object declaration** is a special feature that allows you to create a singleton in a very convenient way. A singleton is a design pattern that restricts the instantiation of a class to a single instance and provides global access to that instance.

Unlike regular classes, which can be instantiated multiple times, an object can only have one instance that is created at the first access to it (lazy initialization). Object declarations are extremely useful when you need exactly one instance of a class to coordinate actions across your application.

## Basic Object Declaration Syntax

Here's the basic syntax for declaring an object in Kotlin:

```kotlin
object ObjectName {
    // Properties
    // Methods
}
```

When you declare an object, Kotlin automatically creates a single instance of it for you. You can access this instance directly using the object name.

## Simple Object Example

Let's start with a basic example:

```kotlin
object DatabaseConnection {
    val url = "jdbc:mysql://localhost:3306/mydb"
    val username = "admin"
    
    fun connect() {
        println("Connecting to database at $url...")
        // Code to establish connection
    }
    
    fun disconnect() {
        println("Disconnecting from database...")
        // Code to close connection
    }
}

fun main() {
    // Access the object directly by its name
    DatabaseConnection.connect()
    println("Username: ${DatabaseConnection.username}")
    DatabaseConnection.disconnect()
}
```

**Output:**
```
Connecting to database at jdbc:mysql://localhost:3306/mydb...
Username: admin
Disconnecting from database...
```

In this example, `DatabaseConnection` is a singleton object. You can access its properties and methods directly without creating an instance.

## Object Declarations vs. Classes

To understand the difference between object declarations and regular classes, consider this comparison:

```kotlin
// Regular class
class Calculator {
    fun add(a: Int, b: Int): Int = a + b
}

// Object declaration
object MathHelper {
    fun square(n: Int): Int = n * n
}

fun main() {
    // Using a class - need to create an instance
    val calc = Calculator()
    println("2 + 3 = ${calc.add(2, 3)}")
    
    // Another instance of the same class
    val anotherCalc = Calculator()
    
    // Using an object - access directly
    println("5 squared is ${MathHelper.square(5)}")
    
    // This line would cause a compilation error:
    // val anotherHelper = MathHelper()
}
```

**Output:**
```
2 + 3 = 5
5 squared is 25
```

## When to Use Object Declarations

Object declarations are particularly useful in the following scenarios:

1. **Implementing the Singleton pattern** - When you need exactly one instance of a class
2. **Utility classes** - For grouping utility functions that don't require state
3. **Centralized data management** - For managing application-wide data or settings
4. **Factory methods** - To organize methods that create instances of other classes

## Object Declarations with Inheritance

Objects can also implement interfaces or inherit from other classes:

```kotlin
interface JSONConverter {
    fun toJSON(obj: Any): String
}

object DefaultJSONConverter : JSONConverter {
    override fun toJSON(obj: Any): String {
        // Simplified implementation
        return "{\"data\": \"${obj.toString()}\"}"
    }
}

fun main() {
    val json = DefaultJSONConverter.toJSON("Hello World")
    println(json)
}
```

**Output:**
```
{"data": "Hello World"}
```

## Practical Example: Logger Object

Here's a more practical example of an object for logging:

```kotlin
object Logger {
    private var logLevel = "INFO"
    private val logHistory = mutableListOf<String>()
    
    fun setLogLevel(level: String) {
        logLevel = level
        log("Log level changed to $level")
    }
    
    fun log(message: String) {
        val timestamp = java.time.LocalDateTime.now()
        val logEntry = "[$timestamp][$logLevel] $message"
        logHistory.add(logEntry)
        println(logEntry)
    }
    
    fun getLogHistory(): List<String> = logHistory.toList()
}

fun main() {
    Logger.log("Application starting")
    Logger.setLogLevel("DEBUG")
    Logger.log("Loading configuration")
    Logger.log("Application ready")
    
    println("\nLog History:")
    Logger.getLogHistory().forEach { println(it) }
}
```

This example demonstrates how a singleton Logger object can maintain state (log history) and provide consistent functionality throughout an application.

## Object Declaration vs. Companion Object

Don't confuse object declarations with companion objects:

```kotlin
// Regular object declaration (standalone singleton)
object Config {
    val appName = "MyKotlinApp"
}

// Class with companion object
class User(val name: String) {
    // Companion object belongs to the User class
    companion object Factory {
        fun createGuest() = User("Guest")
    }
}

fun main() {
    // Using regular object
    println("App name: ${Config.appName}")
    
    // Using companion object
    val guest = User.createGuest()
    println("User: ${guest.name}")
}
```

**Output:**
```
App name: MyKotlinApp
User: Guest
```

The main difference is that a companion object is tied to a class, while a regular object declaration creates a standalone singleton.

## Anonymous Objects

Kotlin also supports anonymous objects, which are created without explicit declarations:

```kotlin
fun createListener() = object {
    fun onClicked() = println("Clicked!")
    fun onLongPressed() = println("Long pressed!")
}

// Anonymous object implementing an interface
interface ClickListener {
    fun onClick()
}

fun setClickListener() = object : ClickListener {
    override fun onClick() {
        println("Button clicked")
    }
}

fun main() {
    val listener = createListener()
    listener.onClicked()
    
    val clickListener = setClickListener()
    clickListener.onClick()
}
```

**Output:**
```
Clicked!
Button clicked
```

## Real-world Example: Application Settings

Here's how an object can be used to manage application settings:

```kotlin
object AppSettings {
    private val settings = mutableMapOf<String, Any>(
        "theme" to "light",
        "fontSize" to 14,
        "notifications" to true
    )
    
    fun setSetting(key: String, value: Any) {
        settings[key] = value
        println("Setting '$key' updated to '$value'")
    }
    
    fun getSetting(key: String): Any? {
        return settings[key]
    }
    
    fun getAllSettings(): Map<String, Any> {
        return settings.toMap()
    }
}

fun main() {
    // Access the settings
    println("Current theme: ${AppSettings.getSetting("theme")}")
    
    // Update a setting
    AppSettings.setSetting("theme", "dark")
    
    // Print all settings
    println("All settings:")
    AppSettings.getAllSettings().forEach { (key, value) ->
        println("$key = $value")
    }
}
```

**Output:**
```
Current theme: light
Setting 'theme' updated to 'dark'
All settings:
theme = dark
fontSize = 14
notifications = true
```

## Summary

Object declarations in Kotlin provide a concise way to implement the Singleton pattern. They are especially useful for:

- Creating singletons without boilerplate code
- Centralizing utility functions and shared resources
- Organizing code that doesn't need multiple instances
- Implementing interfaces or extending classes with a singleton

Using objects effectively can help you write more organized and maintainable code by ensuring that certain components exist only once in your application.

## Exercises

To practice working with Kotlin object declarations, try these exercises:

1. Create a `NetworkMonitor` object that tracks network status and logs connection changes.
2. Implement a `ResourceManager` object that keeps track of application resources and prevents duplication.
3. Design a simple dependency injection system using objects.
4. Create an object that implements multiple interfaces.
5. Build a configuration system that loads settings from a file using an object.

## Additional Resources

- [Official Kotlin Documentation on Object Expressions and Declarations](https://kotlinlang.org/docs/object-declarations.html)
- [Singleton Pattern in Kotlin](https://kotlinlang.org/docs/object-declarations.html#object-declarations-overview)
- [Effective Kotlin: Best Practices](https://www.manning.com/books/effective-kotlin)