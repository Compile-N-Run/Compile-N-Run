---
title: Kotlin Interface Delegation
description: Learn how to use Kotlin's interface delegation to implement the delegation pattern without boilerplate code, enhancing code reusability and maintainability.

---

# Kotlin Interface Delegation

## Introduction

Interface delegation is a powerful feature in Kotlin that provides an elegant solution to the "favor composition over inheritance" design principle. While inheritance is a fundamental concept in object-oriented programming, it can sometimes lead to tightly coupled code and the fragile base class problem. 

Interface delegation allows a class to implement interfaces by delegating their implementation to specified objects, effectively achieving the benefits of multiple inheritance without its complications. This approach promotes code reuse and maintainability while avoiding the pitfalls of traditional inheritance hierarchies.

In this tutorial, we'll explore how Kotlin's interface delegation works, its benefits, and how to implement it effectively in your code.

## Understanding the Delegation Pattern

Before diving into Kotlin's implementation, let's first understand what the delegation pattern is:

The delegation pattern is a design pattern where an object handles a request by delegating to a second object (the delegate). Instead of inheriting behavior from a parent class, the first object contains an instance of the delegate and forwards specific method calls to it.

Traditionally, implementing this pattern requires a lot of boilerplate code. Let's see a simple example in standard Java-like code:

```kotlin
interface Engine {
    fun start()
    fun stop()
}

class ElectricEngine : Engine {
    override fun start() {
        println("Electric engine starting silently...")
    }
    
    override fun stop() {
        println("Electric engine stopped")
    }
}

class Car {
    private val engine: Engine = ElectricEngine()
    
    // Manually delegating methods
    fun startEngine() {
        engine.start()
    }
    
    fun stopEngine() {
        engine.stop()
    }
}
```

## Kotlin's Interface Delegation Syntax

Kotlin simplifies this pattern significantly with its built-in delegation syntax using the `by` keyword. Here's how it works:

```kotlin
interface Engine {
    fun start()
    fun stop()
}

class ElectricEngine : Engine {
    override fun start() {
        println("Electric engine starting silently...")
    }
    
    override fun stop() {
        println("Electric engine stopped")
    }
}

class Car(private val engine: Engine) : Engine by engine {
    // No need to manually implement start() and stop()
    // They are automatically delegated to the engine instance
    
    fun drive() {
        println("Car is driving")
    }
}
```

When you run:

```kotlin
fun main() {
    val myCar = Car(ElectricEngine())
    myCar.start() // Delegated to ElectricEngine
    myCar.drive() // Car's own method
    myCar.stop()  // Delegated to ElectricEngine
}
```

Output:
```
Electric engine starting silently...
Car is driving
Electric engine stopped
```

This example demonstrates how the `Car` class implements the `Engine` interface by delegating to the `engine` property. The `by` keyword tells the Kotlin compiler to generate all the methods of the `Engine` interface that delegate to the specified object.

## When to Use Interface Delegation

Interface delegation is particularly useful in these scenarios:

1. **Avoiding inheritance issues**: When you want to reuse code without the tight coupling of inheritance
2. **Implementing decorators**: When you want to add functionality to an existing implementation
3. **Composing behavior**: When you need to combine multiple behaviors from different interfaces
4. **Testing**: When you need to easily swap implementations for testing purposes

## Overriding Delegated Methods

One of the powerful aspects of Kotlin's interface delegation is that you can still override specific methods when needed, while delegating others:

```kotlin
class EnhancedCar(private val engine: Engine) : Engine by engine {
    override fun start() {
        println("Performing pre-start check...")
        engine.start()  // Still calling the delegate's implementation
        println("Engine started successfully!")
    }
    
    fun drive() {
        println("Car is driving")
    }
}
```

When you run:

```kotlin
fun main() {
    val myCar = EnhancedCar(ElectricEngine())
    myCar.start()
    myCar.drive()
    myCar.stop()  // This is still fully delegated
}
```

Output:
```
Performing pre-start check...
Electric engine starting silently...
Engine started successfully!
Car is driving
Electric engine stopped
```

In this example, `EnhancedCar` overrides the `start()` method to add additional behavior while still calling the delegated implementation, and completely delegates the `stop()` method.

## Delegating to Multiple Interfaces

Kotlin allows a class to delegate to multiple interfaces, effectively composing behavior:

```kotlin
interface Engine {
    fun start()
    fun stop()
}

interface Entertainment {
    fun playMusic()
    fun stopMusic()
}

class BasicEngine : Engine {
    override fun start() = println("Engine started")
    override fun stop() = println("Engine stopped")
}

class MusicSystem : Entertainment {
    override fun playMusic() = println("Music playing")
    override fun stopMusic() = println("Music stopped")
}

class ModernCar(
    engine: Engine,
    entertainment: Entertainment
) : Engine by engine, Entertainment by entertainment {
    fun drive() = println("Car is driving")
}
```

When you run:

```kotlin
fun main() {
    val modernCar = ModernCar(BasicEngine(), MusicSystem())
    modernCar.start()        // From Engine interface
    modernCar.playMusic()    // From Entertainment interface
    modernCar.drive()        // Car's own method
    modernCar.stopMusic()    // From Entertainment interface
    modernCar.stop()         // From Engine interface
}
```

Output:
```
Engine started
Music playing
Car is driving
Music stopped
Engine stopped
```

This example shows how `ModernCar` effectively implements both interfaces through delegation, giving it the combined functionality without traditional inheritance.

## Real-World Example: Building a Logger System

Let's look at a more practical example that demonstrates how interface delegation can be used in a real-world application. We'll build a flexible logging system that can output to different destinations:

```kotlin
interface Logger {
    fun log(message: String)
    fun error(message: String)
    fun debug(message: String)
}

// Concrete implementations
class ConsoleLogger : Logger {
    override fun log(message: String) = println("[INFO] $message")
    override fun error(message: String) = println("[ERROR] $message")
    override fun debug(message: String) = println("[DEBUG] $message")
}

class FileLogger(private val filename: String) : Logger {
    override fun log(message: String) = appendToFile("[INFO] $message")
    override fun error(message: String) = appendToFile("[ERROR] $message")
    override fun debug(message: String) = appendToFile("[DEBUG] $message")
    
    private fun appendToFile(message: String) {
        // For this example, we're just printing what would be written to a file
        println("Writing to $filename: $message")
    }
}

// Using delegation to create a composite logger
class ApplicationLogger(
    private val consoleLogger: Logger,
    private val fileLogger: Logger
) : Logger {
    // Custom implementation that delegates to both loggers
    override fun log(message: String) {
        consoleLogger.log(message)
        fileLogger.log(message)
    }
    
    override fun error(message: String) {
        consoleLogger.error(message)
        fileLogger.error(message)
    }
    
    // We could delegate this to just one logger if we wanted
    override fun debug(message: String) {
        consoleLogger.debug(message)
        // Not logging debug messages to file
    }
}

// Another approach using interface delegation
class FilteredLogger(private val logger: Logger) : Logger by logger {
    // Only override the methods we want to filter
    override fun debug(message: String) {
        // Only log debug messages if a condition is met
        if (isDebugEnabled) {
            logger.debug(message)
        }
    }
    
    companion object {
        var isDebugEnabled = false
    }
}
```

Using our logging system:

```kotlin
fun main() {
    val consoleLogger = ConsoleLogger()
    val fileLogger = FileLogger("app.log")
    
    // Using the composite logger
    val appLogger = ApplicationLogger(consoleLogger, fileLogger)
    appLogger.log("Application started")
    appLogger.error("Connection failed")
    appLogger.debug("Current state: initializing")
    
    println("\n--- Using filtered logger ---\n")
    
    // Using the filtered logger
    val filteredLogger = FilteredLogger(consoleLogger)
    filteredLogger.log("This is a regular log message")
    filteredLogger.debug("This debug message won't show")
    
    // Enable debug logging
    FilteredLogger.isDebugEnabled = true
    filteredLogger.debug("Now this debug message will show")
}
```

Output:
```
[INFO] Application started
Writing to app.log: [INFO] Application started
[ERROR] Connection failed
Writing to app.log: [ERROR] Connection failed
[DEBUG] Current state: initializing

--- Using filtered logger ---

[INFO] This is a regular log message
[DEBUG] Now this debug message will show
```

This example demonstrates two different approaches to using delegation:

1. The `ApplicationLogger` doesn't use the `by` keyword but manually implements methods that delegate to multiple loggers.
2. The `FilteredLogger` uses the `by` keyword for automatic delegation, only overriding the methods it needs to customize.

## Benefits of Interface Delegation

1. **Code Reusability**: Reuse implementation without inheritance hierarchy
2. **Flexibility**: Easily change behavior by swapping out the delegate object
3. **Testability**: Simplifies mocking and testing by allowing easy substitution of components
4. **Reduced Boilerplate**: Kotlin handles all the forwarding code for you
5. **Composition over Inheritance**: Follows the design principle of favoring composition
6. **Multiple Interface Implementation**: Effectively achieves functionality similar to multiple inheritance

## Common Pitfalls and Considerations

1. **Memory overhead**: Each delegation creates an additional object reference
2. **Method resolution complexity**: When multiple interfaces have methods with the same signature
3. **Debugging challenges**: Call stacks might be more complex with delegated methods
4. **Visibility of delegation**: The delegate instance is typically private, making it harder to access directly

## Summary

Kotlin's interface delegation provides a powerful mechanism to implement the delegation pattern with minimal boilerplate code. By using the `by` keyword, you can delegate the implementation of an interface to a specific object, allowing for flexible composition of behavior.

Key takeaways:

- Use interface delegation to favor composition over inheritance
- The `by` keyword automatically implements all methods of an interface by forwarding calls to the specified delegate
- You can override specific methods while delegating others
- A class can delegate to multiple interfaces
- Delegation is particularly useful for creating decorators, adapters, and composable components

Interface delegation is one of Kotlin's features that significantly improves code organization, reusability, and maintainability when used appropriately.

## Exercises

1. Create a `ReadOnlyList` class that delegates to a normal list but overrides any methods that would modify the list to throw an exception
2. Implement a caching system using delegation where a `CachedDataSource` delegates to a `RemoteDataSource` but caches results
3. Design a notification system with multiple notification channels (email, SMS, push) using interface delegation
4. Create a performance monitoring decorator that measures and logs the execution time of interface methods using delegation

## Additional Resources

- [Kotlin Official Documentation on Delegation](https://kotlinlang.org/docs/delegation.html)
- [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns) - The original book by the Gang of Four that describes the Delegation Pattern
- [Effective Java](https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/) - Item 18: "Favor composition over inheritance"