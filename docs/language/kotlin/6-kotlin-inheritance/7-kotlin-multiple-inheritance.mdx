---
title: "Kotlin Multiple Inheritance"
description: "Learn how Kotlin handles multiple inheritance through interfaces, abstract classes, and delegation. Understand the diamond problem and how Kotlin solves it elegantly."

---

# Kotlin Multiple Inheritance

## Introduction

Multiple inheritance refers to a feature in object-oriented programming where a class can inherit from more than one parent class. While this concept sounds useful, it can lead to various complications, most notably the "diamond problem" where ambiguity arises when two parent classes implement the same method.

Unlike languages like C++ that support direct multiple inheritance, Kotlin takes a more controlled approach. In this tutorial, we'll explore how Kotlin handles multiple inheritance through interfaces, abstract classes, and its elegant delegation pattern.

## Understanding Multiple Inheritance Constraints in Kotlin

Kotlin, like Java, doesn't support multiple inheritance for classes directly. A class can only extend one superclass. However, Kotlin provides powerful alternatives that effectively achieve the benefits of multiple inheritance while avoiding its pitfalls.

```kotlin
// This is NOT allowed in Kotlin:
// class Child : ParentOne(), ParentTwo() // Error!

// This is allowed - one parent class and multiple interfaces
class Child : ParentClass(), InterfaceOne, InterfaceTwo
```

## Multiple Inheritance Through Interfaces

Interfaces in Kotlin can contain both abstract methods and method implementations (called default implementations), making them a powerful tool for sharing behavior across classes.

### Basic Interface Implementation

```kotlin
interface Flyable {
    fun fly()
    
    // Default implementation
    fun describeFlight() {
        println("This object can fly")
    }
}

interface Swimmable {
    fun swim()
    
    // Default implementation
    fun describeSwimming() {
        println("This object can swim")
    }
}

// Duck implements both interfaces
class Duck : Flyable, Swimmable {
    override fun fly() {
        println("The duck is flying")
    }
    
    override fun swim() {
        println("The duck is swimming")
    }
}

fun main() {
    val duck = Duck()
    duck.fly()        // Output: The duck is flying
    duck.swim()       // Output: The duck is swimming
    duck.describeFlight()    // Output: This object can fly
    duck.describeSwimming()  // Output: This object can swim
}
```

### The Diamond Problem and Its Solution

The diamond problem occurs when a class inherits from two interfaces that have methods with the same signature. Kotlin requires you to provide an explicit override to resolve this ambiguity.

```kotlin
interface A {
    fun doSomething() {
        println("A's implementation")
    }
}

interface B {
    fun doSomething() {
        println("B's implementation")
    }
}

class C : A, B {
    // Must override to resolve the conflict
    override fun doSomething() {
        // Can call specific parent implementations if needed
        super<A>.doSomething()
        super<B>.doSomething()
        println("C's implementation")
    }
}

fun main() {
    val c = C()
    c.doSomething()
    // Output:
    // A's implementation
    // B's implementation
    // C's implementation
}
```

## Delegation: The Kotlin Way of Multiple Inheritance

Kotlin introduces the delegation pattern as a first-class feature with the `by` keyword. This approach allows you to implement an interface by delegating all of its members to a specified object.

### Basic Delegation

```kotlin
interface Engine {
    fun start()
    fun stop()
}

class ElectricEngine : Engine {
    override fun start() = println("Electric engine starting silently")
    override fun stop() = println("Electric engine stopped")
}

class GasEngine : Engine {
    override fun start() = println("Gas engine starting with a roar")
    override fun stop() = println("Gas engine stopped")
}

// Car delegates Engine implementation to the provided instance
class HybridCar(
    private val electricEngine: Engine,
    private val gasEngine: Engine
) : Engine by electricEngine {
    // We can choose which methods to override and which to delegate
    fun switchToGasMode() {
        println("Switching to gas mode")
        gasEngine.start()
    }
}

fun main() {
    val electric = ElectricEngine()
    val gas = GasEngine()
    val hybridCar = HybridCar(electric, gas)
    
    hybridCar.start()  // Delegated to electric engine
    // Output: Electric engine starting silently
    
    hybridCar.switchToGasMode()
    // Output: 
    // Switching to gas mode
    // Gas engine starting with a roar
    
    hybridCar.stop()  // Still delegated to electric engine
    // Output: Electric engine stopped
}
```

### Advanced Delegation: Combining Multiple Interfaces

Kotlin allows delegating multiple interfaces to different implementations, effectively achieving multiple inheritance.

```kotlin
interface Worker {
    fun work()
}

interface Sleeper {
    fun sleep()
}

class DefaultWorker : Worker {
    override fun work() = println("Working hard...")
}

class DefaultSleeper : Sleeper {
    override fun sleep() = println("Sleeping peacefully...")
}

// Person delegates different behaviors to different objects
class Person(
    worker: Worker,
    sleeper: Sleeper
) : Worker by worker, Sleeper by sleeper {
    // Can add additional methods or override if needed
    fun live() {
        work()
        sleep()
        println("Living a balanced life!")
    }
}

fun main() {
    val person = Person(DefaultWorker(), DefaultSleeper())
    person.live()
    // Output:
    // Working hard...
    // Sleeping peacefully...
    // Living a balanced life!
}
```

## Real-World Application: Building a Media Player

Let's see how we can use Kotlin's approach to multiple inheritance to build a flexible media player system.

```kotlin
// Core functionality interfaces
interface AudioPlayable {
    fun playAudio()
    fun stopAudio()
}

interface VideoPlayable {
    fun playVideo()
    fun stopVideo()
}

interface StreamCapable {
    fun streamContent(url: String)
}

// Implementations
class BasicAudioPlayer : AudioPlayable {
    override fun playAudio() = println("Playing audio...")
    override fun stopAudio() = println("Audio stopped")
}

class HDVideoPlayer : VideoPlayable {
    override fun playVideo() = println("Playing HD video...")
    override fun stopVideo() = println("Video stopped")
}

class StreamPlayer : StreamCapable {
    override fun streamContent(url: String) = println("Streaming from $url")
}

// Creating specialized media players through delegation
class AdvancedMediaPlayer(
    audioPlayer: AudioPlayable,
    videoPlayer: VideoPlayable,
    streamPlayer: StreamCapable
) : AudioPlayable by audioPlayer,
    VideoPlayable by videoPlayer,
    StreamCapable by streamPlayer {
    
    fun playMedia(mediaType: String, url: String? = null) {
        when (mediaType) {
            "audio" -> playAudio()
            "video" -> playVideo()
            "stream" -> url?.let { streamContent(it) } ?: println("URL required for streaming")
            else -> println("Unsupported media type")
        }
    }
}

fun main() {
    val mediaPlayer = AdvancedMediaPlayer(
        BasicAudioPlayer(),
        HDVideoPlayer(),
        StreamPlayer()
    )
    
    mediaPlayer.playMedia("audio")
    // Output: Playing audio...
    
    mediaPlayer.playMedia("video")
    // Output: Playing HD video...
    
    mediaPlayer.playMedia("stream", "https://example.com/stream")
    // Output: Streaming from https://example.com/stream
}
```

This example demonstrates how you can create a complex system by composing multiple interfaces and delegating their implementations, achieving the benefits of multiple inheritance without its drawbacks.

## When to Use Each Approach

1. **Interfaces with default methods**: Use when you want to share behavior across unrelated classes
2. **Abstract classes**: Use when you have a clear "is-a" relationship and want to share state
3. **Delegation**: Use when you want to compose behavior from multiple sources without inheritance

## Summary

Kotlin provides a robust solution to multiple inheritance through:

1. **Interfaces with default implementations** that allow sharing behavior across classes
2. **Explicit overrides** for resolving conflicts from multiple inherited methods
3. **The delegation pattern with the `by` keyword** for composing behavior from multiple sources

These mechanisms enable you to achieve the benefits of multiple inheritance while avoiding its traditional problems, like the diamond problem. By using these features effectively, you can create flexible, maintainable code that adheres to good object-oriented design principles.

## Exercises

1. Create an interface hierarchy for different types of vehicles (land, water, air) and implement a class that can function in multiple environments
2. Implement a notification system with different notification methods (email, SMS, push) using delegation
3. Solve the diamond problem by creating two interfaces with conflicting methods and a class that correctly implements both

## Additional Resources

- [Kotlin Official Documentation on Interfaces](https://kotlinlang.org/docs/interfaces.html)
- [Kotlin Delegation Pattern Documentation](https://kotlinlang.org/docs/delegation.html)
- Book: "Kotlin in Action" by Dmitry Jemerov and Svetlana Isakova (Chapter on Interfaces and Delegation)