---
title: Kotlin Abstract Classes
description: Learn about abstract classes in Kotlin, how they work, when to use them, and how they differ from interfaces in the context of inheritance.

---

# Kotlin Abstract Classes

## Introduction

Abstract classes are a fundamental concept in object-oriented programming and serve as an important tool in Kotlin's inheritance system. An abstract class is a class that cannot be instantiated directly and is designed to be subclassed by other classes. It acts as a template or blueprint that defines common behaviors and attributes that its subclasses should inherit.

In Kotlin, abstract classes bridge the gap between regular classes and interfaces, providing a way to define both concrete implementations and abstract members that subclasses must implement. Understanding abstract classes is crucial for designing robust and flexible object hierarchies in your Kotlin applications.

## What is an Abstract Class?

An abstract class in Kotlin is defined using the `abstract` keyword. Here are the key characteristics of abstract classes:

1. Cannot be instantiated directly (you cannot create objects of an abstract class)
2. May contain both abstract and non-abstract members
3. Abstract members must be implemented by subclasses
4. Can have constructors, including primary and secondary constructors
5. Can maintain state (have properties with backing fields)

## Creating Abstract Classes

Let's see how to define an abstract class in Kotlin:

```kotlin
abstract class Shape {
    // Non-abstract property
    var color: String = "Undefined"
    
    // Non-abstract method (has implementation)
    fun setColor(color: String) {
        this.color = color
    }
    
    // Abstract property (no implementation)
    abstract val area: Double
    
    // Abstract method (no implementation)
    abstract fun draw()
    
    // Abstract method with parameters
    abstract fun resize(factor: Double)
}
```

In this example, `Shape` is an abstract class with:
- A concrete property `color`
- A concrete method `setColor()`
- An abstract property `area`
- Abstract methods `draw()` and `resize()`

## Implementing Abstract Classes

To use an abstract class, you need to create a concrete class that extends it and implements all its abstract members:

```kotlin
class Circle(private val radius: Double) : Shape() {
    override val area: Double
        get() = Math.PI * radius * radius
    
    override fun draw() {
        println("Drawing a Circle with radius $radius and color $color")
    }
    
    override fun resize(factor: Double) {
        println("Resizing Circle by factor $factor")
    }
}

class Rectangle(private val width: Double, private val height: Double) : Shape() {
    override val area: Double
        get() = width * height
    
    override fun draw() {
        println("Drawing a Rectangle with width $width, height $height, and color $color")
    }
    
    override fun resize(factor: Double) {
        println("Resizing Rectangle by factor $factor")
    }
}
```

Now let's see how we use these classes:

```kotlin
fun main() {
    // Creating instances of concrete subclasses
    val circle = Circle(5.0)
    val rectangle = Rectangle(4.0, 6.0)
    
    // Setting properties and calling methods
    circle.setColor("Red")
    rectangle.setColor("Blue")
    
    circle.draw()
    println("Circle area: ${circle.area}")
    
    rectangle.draw()
    println("Rectangle area: ${rectangle.area}")
    
    circle.resize(2.0)
    rectangle.resize(0.5)
}
```

Output:
```
Drawing a Circle with radius 5.0 and color Red
Circle area: 78.53981633974483
Drawing a Rectangle with width 4.0, height 6.0, and color Blue
Rectangle area: 24.0
Resizing Circle by factor 2.0
Resizing Rectangle by factor 0.5
```

## Abstract Classes with Constructors

Abstract classes in Kotlin can have constructors, just like regular classes:

```kotlin
abstract class Vehicle(val brand: String, val model: String) {
    var year: Int = 2023
    
    abstract fun accelerate()
    abstract fun brake()
    
    fun displayInfo() {
        println("$year $brand $model")
    }
}

class Car(brand: String, model: String, val engineType: String) : Vehicle(brand, model) {
    override fun accelerate() {
        println("The $brand $model is accelerating")
    }
    
    override fun brake() {
        println("The $brand $model is braking")
    }
}

fun main() {
    val myCar = Car("Toyota", "Corolla", "Hybrid")
    myCar.year = 2022
    myCar.displayInfo()
    myCar.accelerate()
    myCar.brake()
}
```

Output:
```
2022 Toyota Corolla
The Toyota Corolla is accelerating
The Toyota Corolla is braking
```

## Abstract Classes vs. Interfaces

While abstract classes and interfaces might seem similar, they have key differences:

| Feature | Abstract Class | Interface |
|---------|---------------|-----------|
| State | Can have state (properties with backing fields) | Properties must be abstract or have custom getters/setters |
| Constructor | Can have constructors | Cannot have constructors |
| Implementation | Can provide default implementations | Can provide default implementations (since Kotlin 1.0) |
| Multiple Inheritance | A class can extend only one abstract class | A class can implement multiple interfaces |
| Visibility modifiers | Can use various visibility modifiers | Members are public by default |
| Purpose | Primarily for sharing code among related classes | Primarily for defining capabilities |

## When to Use Abstract Classes

Consider using abstract classes when:

1. You want to share code among several closely related classes
2. Classes that extend your abstract class need access to common fields and methods
3. You need to declare non-public members (like protected methods)
4. You want to provide a common implementation that subclasses can either use or override

## Real-World Example: Game Development

Let's look at a practical example of abstract classes in a simple game development scenario:

```kotlin
abstract class GameObject(
    var x: Double,
    var y: Double
) {
    abstract val width: Double
    abstract val height: Double
    
    var isVisible: Boolean = true
    
    abstract fun update(deltaTime: Double)
    abstract fun render()
    
    fun move(dx: Double, dy: Double) {
        x += dx
        y += dy
    }
    
    fun isCollidingWith(other: GameObject): Boolean {
        return x < other.x + other.width &&
               x + width > other.x &&
               y < other.y + other.height &&
               y + height > other.y
    }
}

class Player(x: Double, y: Double) : GameObject(x, y) {
    override val width: Double = 50.0
    override val height: Double = 50.0
    
    var speed: Double = 100.0
    var health: Int = 100
    
    override fun update(deltaTime: Double) {
        // Update player logic here
        println("Updating player position and state")
    }
    
    override fun render() {
        println("Rendering player at ($x, $y)")
    }
    
    fun attack() {
        println("Player attacks!")
    }
}

class Enemy(x: Double, y: Double, private val type: String) : GameObject(x, y) {
    override val width: Double = 40.0
    override val height: Double = 40.0
    
    var damage: Int = 10
    
    override fun update(deltaTime: Double) {
        // Update enemy AI here
        println("Updating enemy of type $type")
    }
    
    override fun render() {
        println("Rendering enemy of type $type at ($x, $y)")
    }
}

fun main() {
    val gameObjects = arrayListOf<GameObject>()
    
    // Add player and enemies
    val player = Player(100.0, 100.0)
    gameObjects.add(player)
    gameObjects.add(Enemy(200.0, 150.0, "Zombie"))
    gameObjects.add(Enemy(300.0, 100.0, "Skeleton"))
    
    // Game loop
    val deltaTime = 0.016 // ~60 FPS
    
    // Update all game objects
    for (obj in gameObjects) {
        obj.update(deltaTime)
    }
    
    // Render all visible objects
    for (obj in gameObjects) {
        if (obj.isVisible) {
            obj.render()
        }
    }
    
    // Check collisions
    for (i in 0 until gameObjects.size) {
        for (j in i+1 until gameObjects.size) {
            if (gameObjects[i].isCollidingWith(gameObjects[j])) {
                println("Collision detected between objects at indices $i and $j")
            }
        }
    }
    
    // Player-specific action
    player.attack()
}
```

Output:
```
Updating player position and state
Updating enemy of type Zombie
Updating enemy of type Skeleton
Rendering player at (100.0, 100.0)
Rendering enemy of type Zombie at (200.0, 150.0)
Rendering enemy of type Skeleton at (300.0, 100.0)
Player attacks!
```

In this example, `GameObject` is an abstract class that provides common functionality for all game objects, while `Player` and `Enemy` are concrete implementations with their specific behaviors.

## Summary

Abstract classes in Kotlin provide a powerful way to:

- Define common behaviors and properties for related classes
- Enforce implementation of required methods in subclasses
- Share code among related classes
- Create a clear inheritance hierarchy

Key points to remember:
- Abstract classes cannot be instantiated
- They can have both abstract and concrete members
- Subclasses must implement all abstract members
- Abstract classes can have constructors and maintain state
- A class can extend only one abstract class

By using abstract classes effectively, you can create more maintainable, modular, and robust code that follows good object-oriented design principles.

## Exercises

1. Create an abstract `Database` class with methods like `connect()`, `disconnect()`, `executeQuery()`, and implement concrete subclasses for MySQL and MongoDB.

2. Design an abstract `Animal` class with properties like `name`, `age`, and methods like `makeSound()`. Create various animal subclasses.

3. Implement an abstract `Notification` class with a method to send notifications, then create concrete implementations for Email, SMS, and Push notifications.

## Additional Resources

- [Kotlin Official Documentation on Classes and Inheritance](https://kotlinlang.org/docs/classes.html)
- [Abstract Classes vs. Interfaces in Kotlin](https://kotlinlang.org/docs/interfaces.html)
- [Object-Oriented Programming Principles in Kotlin](https://kotlinlang.org/docs/object-declarations.html)

Now you have a solid understanding of abstract classes in Kotlin and how they fit into Kotlin's inheritance system!