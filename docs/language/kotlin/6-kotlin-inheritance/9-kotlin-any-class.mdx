---
title: "Kotlin Any Class"
description: "Learn about Kotlin's Any class, the root of the class hierarchy, and how it provides essential functionality for all objects"

---

# Kotlin Any Class

## Introduction

In Kotlin, the `Any` class is a fundamental part of the language's type system. Similar to Java's `Object` class, `Any` serves as the root superclass of all non-nullable classes in Kotlin. Whether you explicitly declare it or not, every class you create ultimately inherits from the `Any` class.

Understanding `Any` is crucial because it defines the basic behavior that all objects in Kotlin share. It provides essential methods that are available to every object and establishes the foundation for Kotlin's object-oriented programming model.

## The Role of Any in Kotlin's Type Hierarchy

In Kotlin's type system:

- Every class that doesn't declare a superclass explicitly inherits from `Any`
- `Any` is not the same as `Object` in Java, though they serve similar purposes
- Unlike Java's `Object`, Kotlin's `Any` doesn't have methods like `wait()`, `notify()`, and `notifyAll()`

Let's look at a simple example:

```kotlin
// Even without explicitly extending Any, this class inherits from Any
class Person(val name: String, val age: Int)

// This is equivalent to:
class Person(val name: String, val age: Int) : Any()
```

## Methods Provided by the Any Class

The `Any` class provides three essential methods that are available to all objects:

1. `equals()`: For comparing objects for equality
2. `hashCode()`: For generating a hash code for objects
3. `toString()`: For creating a string representation of objects

Let's explore each of these methods in detail:

### equals() Method

The `equals()` method determines whether two objects are considered equal. By default, it checks for reference equality (if two variables refer to the exact same object in memory).

```kotlin
fun main() {
    val person1 = Person("Alice", 30)
    val person2 = Person("Alice", 30)
    val person3 = person1
    
    println(person1.equals(person2)) // false (different objects)
    println(person1.equals(person3)) // true (same object reference)
    println(person1 == person2)      // false (== calls equals() in Kotlin)
}

class Person(val name: String, val age: Int)
```

Output:
```
false
true
false
```

To implement meaningful equality based on object content, you need to override the `equals()` method:

```kotlin
class Person(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Person) return false
        
        return name == other.name && age == other.age
    }
}

fun main() {
    val person1 = Person("Alice", 30)
    val person2 = Person("Alice", 30)
    
    println(person1 == person2) // true (custom equals implementation)
}
```

Output:
```
true
```

### hashCode() Method

The `hashCode()` method returns an integer that represents the object's hash code value. This value is used in hash-based collections like `HashMap` and `HashSet`.

According to the contract between `equals()` and `hashCode()`:
- If two objects are equal (according to `equals()`), they must have the same hash code
- If two objects have the same hash code, they might or might not be equal

```kotlin
class Person(val name: String, val age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Person) return false
        
        return name == other.name && age == other.age
    }
    
    override fun hashCode(): Int {
        var result = name.hashCode()
        result = 31 * result + age
        return result
    }
}

fun main() {
    val personSet = hashSetOf(Person("Alice", 30))
    println(personSet.contains(Person("Alice", 30))) // true
}
```

Output:
```
true
```

### toString() Method

The `toString()` method returns a string representation of the object. By default, it returns the class name followed by the hash code in hexadecimal format.

```kotlin
fun main() {
    val person = Person("Alice", 30)
    println(person.toString()) // Something like "Person@3d075dc0"
}

class Person(val name: String, val age: Int)
```

Output:
```
Person@3d075dc0
```

For more readable output, you should override the `toString()` method:

```kotlin
class Person(val name: String, val age: Int) {
    override fun toString(): String {
        return "Person(name=$name, age=$age)"
    }
}

fun main() {
    val person = Person("Alice", 30)
    println(person) // Kotlin automatically calls toString() when printing objects
}
```

Output:
```
Person(name=Alice, age=30)
```

## Using Any as a Parameter Type

The `Any` type can be used as a parameter type when a function needs to accept objects of any type:

```kotlin
fun printObject(obj: Any) {
    println("Object: $obj")
    println("Object type: ${obj::class.simpleName}")
}

fun main() {
    printObject("Hello")
    printObject(42)
    printObject(Person("Bob", 25))
    printObject(listOf(1, 2, 3))
}

class Person(val name: String, val age: Int) {
    override fun toString(): String {
        return "Person(name=$name, age=$age)"
    }
}
```

Output:
```
Object: Hello
Object type: String
Object: 42
Object type: Int
Object: Person(name=Bob, age=25)
Object type: Person
Object: [1, 2, 3]
Object type: ArrayList
```

## Any vs. Any?

In Kotlin's type system:

- `Any` represents a non-nullable type (cannot be null)
- `Any?` represents a nullable type (can be null)

```kotlin
fun acceptAny(obj: Any) {
    // obj cannot be null here
    println(obj)
}

fun acceptNullableAny(obj: Any?) {
    // obj can be null here
    if (obj != null) {
        println(obj)
    } else {
        println("Object is null")
    }
}

fun main() {
    acceptAny("Hello")
    // acceptAny(null) // This would cause a compilation error
    
    acceptNullableAny("Hello")
    acceptNullableAny(null)
}
```

Output:
```
Hello
Hello
Object is null
```

## Real-World Applications

### Creating a Generic Container

```kotlin
class Box<T : Any>(var content: T) {
    fun replaceContent(newContent: T) {
        content = newContent
    }
    
    fun describe(): String {
        return "Box containing a ${content::class.simpleName}: $content"
    }
}

fun main() {
    val stringBox = Box("Hello World")
    println(stringBox.describe())
    
    val numberBox = Box(42)
    println(numberBox.describe())
    
    val personBox = Box(Person("Charlie", 35))
    println(personBox.describe())
    
    // Change the content
    personBox.replaceContent(Person("Diana", 28))
    println(personBox.describe())
}

class Person(val name: String, val age: Int) {
    override fun toString(): String {
        return "Person(name=$name, age=$age)"
    }
}
```

Output:
```
Box containing a String: Hello World
Box containing a Int: 42
Box containing a Person: Person(name=Charlie, age=35)
Box containing a Person: Person(name=Diana, age=28)
```

### Creating a Simple Object Registry

```kotlin
class ObjectRegistry {
    private val objects = mutableMapOf<String, Any>()
    
    fun register(key: String, obj: Any) {
        objects[key] = obj
    }
    
    fun get(key: String): Any? {
        return objects[key]
    }
    
    fun <T> getTyped(key: String, clazz: Class<T>): T? {
        val obj = objects[key] ?: return null
        return if (clazz.isInstance(obj)) {
            @Suppress("UNCHECKED_CAST")
            obj as T
        } else {
            null
        }
    }
}

fun main() {
    val registry = ObjectRegistry()
    
    // Register different types of objects
    registry.register("appName", "My Amazing App")
    registry.register("version", 2.1)
    registry.register("isActive", true)
    registry.register("user", Person("Eve", 40))
    
    // Retrieve and use objects
    val appName = registry.getTyped("appName", String::class.java)
    println("Application name: $appName")
    
    val version = registry.getTyped("version", Double::class.java)
    println("Version: $version")
    
    val user = registry.getTyped("user", Person::class.java)
    println("Current user: ${user?.name}, age: ${user?.age}")
}

class Person(val name: String, val age: Int) {
    override fun toString(): String {
        return "Person(name=$name, age=$age)"
    }
}
```

Output:
```
Application name: My Amazing App
Version: 2.1
Current user: Eve, age: 40
```

## Summary

The `Any` class is a fundamental part of Kotlin's type system, serving as the root of the class hierarchy. Key points to remember:

- Every Kotlin class implicitly inherits from `Any` if no other superclass is specified
- `Any` provides three essential methods: `equals()`, `hashCode()`, and `toString()`
- When creating custom classes, consider overriding these methods for proper behavior
- `Any` can be used as a parameter type to accept objects of any type
- `Any` is non-nullable; use `Any?` for nullable references
- Understanding `Any` is crucial for working with Kotlin's type system effectively

By mastering the `Any` class and its methods, you'll better understand Kotlin's object model and be able to write more robust and flexible code.

## Exercises

1. Create a class `Product` with properties `name`, `price`, and `category`, and override all the necessary methods inherited from `Any` to make it work correctly with hash-based collections.

2. Write a function `printDetails` that accepts an `Any` parameter and prints different information based on the actual type of the object (use the `is` operator for type checking).

3. Create a class hierarchy with a base class and several subclasses. Implement the `toString()` method in each class to provide meaningful string representations, and demonstrate polymorphism by storing instances in a list of the base class type.

## Additional Resources

- [Kotlin Documentation on Classes and Inheritance](https://kotlinlang.org/docs/classes.html)
- [Kotlin Equality Operators](https://kotlinlang.org/docs/equality.html)
- [Data Classes in Kotlin](https://kotlinlang.org/docs/data-classes.html) (which automatically implement `equals()`, `hashCode()`, and `toString()`)