---
title: "Kotlin Named Arguments"
description: "Learn how to use named arguments in Kotlin functions to create more readable, flexible, and maintainable code."

---

# Kotlin Named Arguments

When calling functions in Kotlin, you can explicitly name the parameters you're passing values to. This powerful feature enhances code readability, makes your function calls safer, and provides greater flexibility. Let's dive into how named arguments work and why they're valuable in your Kotlin programming toolkit.

## Introduction to Named Arguments

In most programming languages, when you call a function, you pass arguments in the same order as the parameters in the function declaration. Kotlin supports this traditional approach but also offers a more explicit way to pass arguments — by naming them.

Named arguments allow you to specify which parameter you're providing a value for by using the parameter's name, regardless of the order.

## Basic Syntax

Here's how you use named arguments:

```kotlin
fun functionName(param1: Type1, param2: Type2) {
    // Function body
}

// Calling the function with named arguments
functionName(param1 = value1, param2 = value2)
```

## Why Use Named Arguments?

Before we dive deeper, let's understand why named arguments are useful:

1. **Improved readability** - Makes function calls self-documenting, especially with many parameters
2. **Flexibility in argument order** - Parameters can be provided in any order
3. **Clarity at call site** - Reduces confusion about which value corresponds to which parameter
4. **Works well with default parameters** - Allows skipping parameters with defaults selectively

## Named Arguments in Action

Let's look at some examples to understand how named arguments work:

### Example 1: Basic Usage

```kotlin
fun printUserInfo(name: String, age: Int, email: String) {
    println("User: $name, Age: $age, Email: $email")
}

fun main() {
    // Using positional arguments
    printUserInfo("Alice", 29, "alice@example.com")
    
    // Using named arguments
    printUserInfo(
        name = "Bob",
        age = 31,
        email = "bob@example.com"
    )
    
    // Output:
    // User: Alice, Age: 29, Email: alice@example.com
    // User: Bob, Age: 31, Email: bob@example.com
}
```

### Example 2: Changing the Order

One of the key benefits of named arguments is that the order doesn't matter:

```kotlin
fun createProfile(name: String, bio: String, isPremium: Boolean) {
    println("Creating profile for $name")
    println("Bio: $bio")
    println("Premium status: $isPremium")
}

fun main() {
    // Arguments in different order
    createProfile(
        bio = "Kotlin enthusiast and developer",
        isPremium = true,
        name = "Carol"
    )
    
    // Output:
    // Creating profile for Carol
    // Bio: Kotlin enthusiast and developer
    // Premium status: true
}
```

## Named Arguments with Default Values

Named arguments work especially well with default parameter values, allowing you to skip parameters that have default values:

```kotlin
fun configureServer(host: String = "localhost", port: Int = 8080, secure: Boolean = false) {
    println("Configuring server at $host:$port (secure: $secure)")
}

fun main() {
    // Using all default values
    configureServer()
    
    // Overriding just the port
    configureServer(port = 9000)
    
    // Overriding host and secure option
    configureServer(host = "192.168.1.1", secure = true)
    
    // Output:
    // Configuring server at localhost:8080 (secure: false)
    // Configuring server at localhost:9000 (secure: false)
    // Configuring server at 192.168.1.1:8080 (secure: true)
}
```

## Mixing Positional and Named Arguments

You can also mix positional and named arguments in a function call, but there's a rule: all positional arguments must come before any named arguments.

```kotlin
fun sendMessage(recipient: String, message: String, priority: Int = 1, encrypted: Boolean = false) {
    println("To: $recipient")
    println("Message: $message")
    println("Priority: $priority")
    println("Encrypted: $encrypted")
    println()
}

fun main() {
    // First two arguments are positional, last is named
    sendMessage("team@example.com", "Meeting tomorrow", priority = 2)
    
    // First argument is positional, others are named
    sendMessage("boss@example.com", 
            message = "Project completed", 
            encrypted = true, 
            priority = 3)
    
    // Output:
    // To: team@example.com
    // Message: Meeting tomorrow
    // Priority: 2
    // Encrypted: false
    //
    // To: boss@example.com
    // Message: Project completed 
    // Priority: 3
    // Encrypted: true
}
```

## Real-World Applications

### Example: UI Component Configuration

Named arguments are particularly useful when configuring UI components:

```kotlin
fun createButton(
    text: String,
    width: Int = 100,
    height: Int = 40,
    color: String = "blue",
    isEnabled: Boolean = true,
    onClick: () -> Unit
) {
    println("Creating $color button with text: '$text'")
    println("Dimensions: ${width}x$height pixels")
    println("Button is ${if (isEnabled) "enabled" else "disabled"}")
    println("Button was clicked: ${onClick()}")
}

fun main() {
    createButton(
        text = "Submit",
        color = "green",
        onClick = { "Processing submission..." }
    )
    
    createButton(
        text = "Cancel",
        color = "red",
        isEnabled = false,
        width = 120,
        onClick = { "Canceling operation..." }
    )
    
    // Output:
    // Creating green button with text: 'Submit'
    // Dimensions: 100x40 pixels
    // Button is enabled
    // Button was clicked: Processing submission...
    //
    // Creating red button with text: 'Cancel'
    // Dimensions: 120x40 pixels 
    // Button is disabled
    // Button was clicked: Canceling operation...
}
```

### Example: Network Request Configuration

Named arguments can make network request configuration more readable:

```kotlin
fun fetchData(
    url: String,
    method: String = "GET",
    headers: Map<String, String> = mapOf(),
    body: String? = null,
    timeout: Int = 30000,
    cache: Boolean = true
) {
    println("Making $method request to $url")
    if (headers.isNotEmpty()) println("Headers: $headers")
    if (body != null) println("Body: $body")
    println("Timeout: ${timeout}ms, Cache: $cache")
}

fun main() {
    fetchData(
        url = "https://api.example.com/users",
        headers = mapOf("Authorization" to "Bearer token123"),
        cache = false
    )
    
    fetchData(
        url = "https://api.example.com/posts",
        method = "POST",
        body = """{"title": "New Post", "content": "Hello World!"}""",
        timeout = 5000
    )
    
    // Output:
    // Making GET request to https://api.example.com/users
    // Headers: {Authorization=Bearer token123}
    // Timeout: 30000ms, Cache: false
    //
    // Making POST request to https://api.example.com/posts
    // Body: {"title": "New Post", "content": "Hello World!"}
    // Timeout: 5000ms, Cache: true
}
```

## Best Practices for Named Arguments

1. **Use named arguments for functions with many parameters** - Improves readability and reduces errors.

2. **Always use named arguments for boolean flags** - What does `createUser("John", true, false)` mean? Much clearer to write `createUser(name = "John", isPremium = true, sendEmail = false)`.

3. **Consider named arguments when multiple parameters have the same type** - Prevents accidentally swapping arguments.

4. **Named arguments work great in builder patterns** - Makes the code read more like a configuration DSL.

5. **Use named arguments when skipping default parameters** - When you want to use the default value for some parameters but not others.

## Limitations to Be Aware Of

When calling Java methods from Kotlin, you cannot use named arguments because Java bytecode does not always preserve parameter names.

```kotlin
// This works in Kotlin-to-Kotlin calls
kotlinFunction(name = "test", age = 25)

// This doesn't work for Java methods called from Kotlin
javaMethod(name = "test", age = 25) // Compilation error
```

## Summary

Named arguments in Kotlin provide a powerful way to make your function calls more readable, flexible, and less error-prone:

- Explicitly specify which parameter you're passing a value to
- Call parameters in any order
- Skip parameters that have default values
- Make code more self-documenting, especially with multiple parameters
- Work particularly well with default parameters

When combined with Kotlin's other features like default arguments, named arguments help create flexible, user-friendly APIs that are both powerful and easy to use correctly.

## Exercises

1. Refactor the following function call to use named arguments:
   ```kotlin
   sendEmail("user@example.com", "Welcome!", "Welcome to our platform", true, 3)
   ```

2. Create a function to format a person's name with several optional parameters (title, middle name, suffix) and call it in multiple ways using named arguments.

3. Write a function that creates a user account with at least 6 parameters, some with default values, and demonstrate calling it with named arguments.

## Additional Resources

- [Official Kotlin Documentation on Named Arguments](https://kotlinlang.org/docs/functions.html#named-arguments)
- [Kotlin Default Arguments](https://kotlinlang.org/docs/functions.html#default-arguments)
- [Effective Kotlin: Items 28-30 on function design](https://kt.academy/article/ek-function-interfaces)

Named arguments are one of those small language features that greatly improve day-to-day developer experience—use them often to make your Kotlin code more readable and maintainable!