---
title: Kotlin Fold Functions
description: Learn how to use Kotlin fold, foldRight, and related functions to transform collections into single values. Understand the concepts with step-by-step explanations and practical examples.

---

# Kotlin Fold Functions

When working with collections in Kotlin, there are often situations where you need to process all elements and combine them into a single result. This is where **fold functions** come into play. These powerful functional operations allow you to accumulate a value by applying an operation to each element in a collection.

## Introduction to Fold Functions

Fold functions are higher-order functions that traverse a collection, maintaining an accumulated value which is updated for each element according to a provided operation. In Kotlin, the main fold functions are:

- `fold`: Accumulates value starting with an initial value and applying an operation from first to last element
- `foldRight`: Similar to fold but processes elements from last to first
- `reduce`: Like fold, but uses the first element as the initial value
- `reduceRight`: Like foldRight, but uses the last element as the initial value

Let's dive into each of these functions and explore how they work.

## Understanding `fold()`

The `fold()` function takes two parameters:
1. An initial value
2. A lambda function that takes two parameters: the accumulated value and the current element

### Basic Syntax

```kotlin
inline fun <T, R> Iterable<T>.fold(
    initial: R, 
    operation: (acc: R, element: T) -> R
): R
```

### Simple Example

Let's calculate the sum of a list of numbers using `fold()`:

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    val sum = numbers.fold(0) { accumulator, number ->
        accumulator + number
    }
    
    println("Sum: $sum") // Output: Sum: 15
}
```

In this example:
- We start with an initial value of `0`
- For each number in the list, we add it to the accumulator
- The final result is the sum of all numbers

### Step-by-Step Execution

Let's trace the execution of the previous example:

1. Initial accumulator value: 0
2. Process 1: 0 + 1 = 1 (new accumulator)
3. Process 2: 1 + 2 = 3 (new accumulator)
4. Process 3: 3 + 3 = 6 (new accumulator)
5. Process 4: 6 + 4 = 10 (new accumulator)
6. Process 5: 10 + 5 = 15 (final result)

## The `foldRight()` Function

The `foldRight()` function works similarly to `fold()` but processes elements from right to left (last to first).

### Basic Syntax

```kotlin
inline fun <T, R> List<T>.foldRight(
    initial: R, 
    operation: (element: T, acc: R) -> R
): R
```

### Example of `foldRight()`

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    val result = numbers.foldRight("") { number, acc ->
        "$number$acc"
    }
    
    println("Result: $result") // Output: Result: 54321
}
```

Notice that:
1. We start with an empty string as the initial value
2. We process elements from right to left (5, 4, 3, 2, 1)
3. The operation concatenates the current number before the accumulated string

## Practical Differences Between `fold()` and `foldRight()`

For commutative operations like addition, `fold()` and `foldRight()` produce the same result:

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    val sumFromLeft = numbers.fold(0) { acc, num -> acc + num }
    val sumFromRight = numbers.foldRight(0) { num, acc -> num + acc }
    
    println("Sum from left: $sumFromLeft") // Output: Sum from left: 15
    println("Sum from right: $sumFromRight") // Output: Sum from right: 15
}
```

However, for non-commutative operations like division or string concatenation, the order matters:

```kotlin
fun main() {
    val numbers = listOf(8, 4, 2)
    
    // (8 / 4) / 2 = 1
    val divideFromLeft = numbers.fold(null) { acc, num -> 
        if (acc == null) num else acc / num 
    }
    
    // 8 / (4 / 2) = 4
    val divideFromRight = numbers.foldRight(null) { num, acc -> 
        if (acc == null) num else num / acc 
    }
    
    println("Divide from left: $divideFromLeft") // Output: Divide from left: 1
    println("Divide from right: $divideFromRight") // Output: Divide from right: 4
}
```

## The `reduce()` and `reduceRight()` Functions

The `reduce()` and `reduceRight()` functions are similar to their fold counterparts but don't require an initial value. Instead, they use the first (or last) element as the initial value.

### Basic Syntax

```kotlin
inline fun <S, T : S> Iterable<T>.reduce(
    operation: (acc: S, element: T) -> S
): S

inline fun <S, T : S> List<T>.reduceRight(
    operation: (element: T, acc: S) -> S
): S
```

### Example Using `reduce()`

```kotlin
fun main() {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    val product = numbers.reduce { acc, number ->
        acc * number
    }
    
    println("Product: $product") // Output: Product: 120
}
```

In this example:
- The first element (1) is used as the initial accumulator value
- For each subsequent number, we multiply it with the accumulator
- The final result is the product of all numbers

### Important Consideration

If the collection is empty, `reduce()` and `reduceRight()` will throw a `NoSuchElementException`. Always check if your collection is empty when using these functions:

```kotlin
fun main() {
    val numbers = listOf<Int>()
    
    val sum = try {
        numbers.reduce { acc, number -> acc + number }
    } catch (e: NoSuchElementException) {
        0 // Default value when list is empty
    }
    
    println("Sum: $sum") // Output: Sum: 0
}
```

## Real-World Applications

### Example 1: Building a Sentence from Words

```kotlin
fun main() {
    val words = listOf("Kotlin", "fold", "functions", "are", "powerful")
    
    val sentence = words.foldIndexed("") { index, acc, word ->
        when {
            index == 0 -> word
            index == words.lastIndex -> "$acc $word."
            else -> "$acc $word"
        }
    }
    
    println(sentence) // Output: Kotlin fold functions are powerful.
}
```

### Example 2: Calculating Statistics from a Data Set

```kotlin
data class SalesRecord(val product: String, val amount: Double)

fun main() {
    val salesData = listOf(
        SalesRecord("Product A", 150.0),
        SalesRecord("Product B", 75.5),
        SalesRecord("Product A", 200.0),
        SalesRecord("Product C", 120.0),
        SalesRecord("Product B", 50.0)
    )
    
    // Calculate total sales by product
    val salesByProduct = salesData.fold(mutableMapOf<String, Double>()) { acc, record ->
        val currentTotal = acc.getOrDefault(record.product, 0.0)
        acc[record.product] = currentTotal + record.amount
        acc
    }
    
    println("Sales by product:")
    salesByProduct.forEach { (product, total) ->
        println("$product: $$$total")
    }
    
    // Output:
    // Sales by product:
    // Product A: $350.0
    // Product B: $125.5
    // Product C: $120.0
}
```

### Example 3: Building a Tree Structure

```kotlin
class TreeNode(val value: Int, var left: TreeNode? = null, var right: TreeNode? = null)

fun main() {
    val values = listOf(5, 3, 7, 2, 4, 6, 8)
    
    // Build a simple binary search tree using fold
    val root = values.fold<Int, TreeNode?>(null) { tree, value ->
        fun insert(node: TreeNode?, newValue: Int): TreeNode {
            if (node == null) return TreeNode(newValue)
            
            if (newValue < node.value) {
                node.left = insert(node.left, newValue)
            } else if (newValue > node.value) {
                node.right = insert(node.right, newValue)
            }
            
            return node
        }
        
        if (tree == null) TreeNode(value) else insert(tree, value)
    }
    
    // Function to print the tree in-order
    fun printInOrder(node: TreeNode?) {
        if (node == null) return
        printInOrder(node.left)
        print("${node.value} ")
        printInOrder(node.right)
    }
    
    print("Tree in-order traversal: ")
    printInOrder(root)
    // Output: Tree in-order traversal: 2 3 4 5 6 7 8
}
```

## Fold vs. Other Collection Operations

### When to Use Fold Instead of ForEach or Map

- Use `fold` when you need to accumulate a result that depends on all elements
- Use `map` when you need to transform each element independently
- Use `forEach` for side effects without returning a result

### Performance Considerations

Fold operations are generally efficient as they process each element only once. However, for large collections, consider these tips:

- Use an appropriate initial value to avoid unnecessary conversions
- Consider using specialized functions like `sumOf()` for simple aggregations
- For parallel processing on very large collections, consider using `kotlinx.coroutines` parallel processing capabilities

## Summary

Fold functions are powerful tools in Kotlin's functional programming arsenal. They allow you to:

- Process collections and accumulate results with a concise syntax
- Control the direction of processing (`fold` vs `foldRight`)
- Choose whether to provide an initial value (`fold`) or use the first element (`reduce`)
- Perform complex transformations on collections to produce single results

These functions are particularly useful when you need to aggregate data, transform collections into different structures, or perform sequential computations where each step depends on the previous results.

## Exercises

1. Write a function that uses `fold` to calculate the factorial of a number.
2. Use `foldRight` to reverse a list without using the built-in `reversed()` function.
3. Implement a function that uses `fold` to count the occurrences of each character in a string.
4. Create a function that uses `fold` to find the maximum and minimum values in a list simultaneously.
5. Use fold to transform a list of integers into a balanced binary search tree.

## Additional Resources

- [Kotlin Official Documentation: Collection Operations](https://kotlinlang.org/docs/collection-operations.html)
- [Kotlin Standard Library: Fold Functions](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/fold.html)
- [Kotlin by Example: Fold and Reduce](https://play.kotlinlang.org/byExample/05_Collections/03_fold)
- [Introduction to Functional Programming in Kotlin](https://kotlinlang.org/docs/lambdas.html)

Remember that mastering fold functions takes practice, but they can greatly enhance the readability and maintainability of your code when working with collections.