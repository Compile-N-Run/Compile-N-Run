---
title: Kotlin Pure Functions
description: Learn about pure functions in Kotlin, their characteristics, benefits, and how to implement them in your functional programming approach.

---

# Kotlin Pure Functions

## Introduction

In functional programming, a **pure function** is one of the most fundamental concepts. Pure functions are the building blocks that make functional code predictable, testable, and reliable. But what exactly is a pure function in Kotlin, and why should you care about writing them?

In this tutorial, we'll explore pure functions in Kotlin, understand their characteristics, benefits, and how to effectively implement them in your code.

## What is a Pure Function?

A pure function is a function that:

1. **Always returns the same output for the same input** - Deterministic behavior
2. **Produces no side effects** - Doesn't modify any state outside its scope
3. **Doesn't rely on external state** - Only depends on its input parameters

Let's break down each of these characteristics with examples.

## Characteristics of Pure Functions

### 1. Deterministic Output

A pure function will always return the same result when called with the same arguments, regardless of how many times it's called.

```kotlin
// Pure function - always returns the same result for the same input
fun add(a: Int, b: Int): Int {
    return a + b
}

// Usage
fun main() {
    println(add(5, 3)) // Output: 8
    println(add(5, 3)) // Output: 8 (always the same result)
}
```

### 2. No Side Effects

A pure function doesn't modify any state outside its scope or perform any observable side effects such as I/O operations, modifying global variables, or changing parameters.

```kotlin
// Impure function - has side effect (modifies external list)
var totalCalls = 0

// Impure function - modifies global state
fun logCall(message: String): String {
    totalCalls++
    println("Log: $message")
    return message
}

// Pure alternative
fun createLogMessage(message: String, callCount: Int): Pair<String, Int> {
    return Pair("Log: $message", callCount + 1)
}

// Usage
fun main() {
    // Impure approach
    logCall("Hello")  // Side effect: modifies totalCalls and prints
    println("Total calls: $totalCalls")  // Output: 1
    
    // Pure approach
    var currentCallCount = 0
    val (logMessage, newCallCount) = createLogMessage("Hello", currentCallCount)
    currentCallCount = newCallCount
    println(logMessage)  // We handle the output explicitly
    println("Total calls: $currentCallCount")  // Output: 1
}
```

### 3. No External Dependencies

A pure function only relies on its input parameters and doesn't access any external state like global variables or system resources.

```kotlin
// Global variable (external state)
val tax = 0.1

// Impure function - depends on external state
fun calculateTotalPrice(price: Double): Double {
    return price * (1 + tax) // Depends on the global 'tax' variable
}

// Pure function - all dependencies are explicit inputs
fun calculateTotalPurePrice(price: Double, taxRate: Double): Double {
    return price * (1 + taxRate)
}

// Usage
fun main() {
    val itemPrice = 100.0
    
    // Impure approach
    println("Total price: ${calculateTotalPrice(itemPrice)}") // Output: 110.0
    
    // Pure approach - explicitly pass all dependencies
    println("Total price: ${calculateTotalPurePrice(itemPrice, 0.1)}") // Output: 110.0
}
```

## Benefits of Pure Functions

### 1. Easier Testing

Pure functions are deterministic and isolated, making them incredibly easy to test:

```kotlin
// A pure function for testing
fun calculateCircleArea(radius: Double): Double {
    return Math.PI * radius * radius
}

// Simple unit test for our pure function
fun testCalculateCircleArea() {
    val result = calculateCircleArea(2.0)
    val expected = Math.PI * 4
    
    if (Math.abs(result - expected) < 0.0001) {
        println("Test passed!")
    } else {
        println("Test failed! Expected: $expected, Actual: $result")
    }
}

fun main() {
    testCalculateCircleArea() // Output: Test passed!
}
```

### 2. Improved Readability and Reasoning

Pure functions are easier to understand because they only depend on their inputs:

```kotlin
// Pure function that's easy to reason about
fun fullName(firstName: String, lastName: String): String {
    return "$firstName $lastName"
}

// Usage
fun main() {
    val name = fullName("John", "Doe")
    println(name) // Output: John Doe
    
    // We can easily substitute the function call with its result
    // This is called "referential transparency"
    println("Hello, ${fullName("John", "Doe")}!") // Output: Hello, John Doe!
}
```

### 3. Concurrency and Parallelism

Pure functions don't share state, making them safe for concurrent execution:

```kotlin
import kotlinx.coroutines.*

fun processData(data: Int): Int {
    // Pure computation - can be safely parallelized
    return data * data
}

fun main() = runBlocking {
    val numbers = listOf(1, 2, 3, 4, 5)
    
    // Process each number concurrently
    val results = numbers.map { number ->
        async {
            processData(number)
        }
    }.awaitAll()
    
    println(results) // Output: [1, 4, 9, 16, 25]
}
```

## Converting Impure to Pure Functions

Let's look at some common patterns for converting impure functions to pure ones:

### 1. Making Dependencies Explicit

```kotlin
// Impure: Depends on system time (external state)
fun generateGreeting(): String {
    val hour = java.time.LocalTime.now().hour
    return if (hour < 12) "Good morning!" else "Good day!"
}

// Pure: Make dependencies explicit
fun generateGreetingPure(hour: Int): String {
    return if (hour < 12) "Good morning!" else "Good day!"
}

fun main() {
    // Impure approach
    println(generateGreeting())
    
    // Pure approach - we explicitly pass the hour
    val currentHour = java.time.LocalTime.now().hour
    println(generateGreetingPure(currentHour))
}
```

### 2. Returning New Objects Instead of Modifying

```kotlin
// Impure: Modifies the input list
fun addItem(items: MutableList<String>, item: String): List<String> {
    items.add(item) // Side effect!
    return items
}

// Pure: Returns a new list
fun addItemPure(items: List<String>, item: String): List<String> {
    return items + item // Creates a new list
}

fun main() {
    val shoppingList = mutableListOf("Milk", "Eggs")
    
    // Impure approach
    addItem(shoppingList, "Bread")
    println(shoppingList) // Output: [Milk, Eggs, Bread]
    
    // Pure approach
    val newList = addItemPure(listOf("Milk", "Eggs"), "Bread")
    println(newList) // Output: [Milk, Eggs, Bread]
}
```

### 3. Isolating Side Effects

```kotlin
// Impure: Mixes logic with I/O
fun processUserInput(): String {
    println("Enter your name:")
    val name = readLine() ?: ""
    return "Hello, ${name.uppercase()}!"
}

// Pure: Separate the transformation logic
fun formatGreeting(name: String): String {
    return "Hello, ${name.uppercase()}!"
}

fun main() {
    // Impure approach
    val greeting = processUserInput()
    println(greeting)
    
    // Pure approach - separate I/O from logic
    println("Enter your name:")
    val name = readLine() ?: ""
    val pureGreeting = formatGreeting(name)
    println(pureGreeting)
}
```

## Real-World Example: E-commerce Discount Calculator

Let's implement a discount calculator for an e-commerce platform:

```kotlin
// Data classes
data class Product(val id: String, val name: String, val price: Double)
data class Discount(val percentage: Double)

// Pure function for calculating discounted price
fun calculateDiscountedPrice(product: Product, discount: Discount): Double {
    return product.price * (1 - discount.percentage / 100)
}

// Pure function for calculating total with tax
fun calculateTotalWithTax(discountedPrice: Double, taxRate: Double): Double {
    return discountedPrice * (1 + taxRate / 100)
}

// Pure function combining both calculations
fun calculateFinalPrice(
    product: Product, 
    discount: Discount,
    taxRate: Double
): Double {
    val discountedPrice = calculateDiscountedPrice(product, discount)
    return calculateTotalWithTax(discountedPrice, taxRate)
}

fun main() {
    val laptop = Product("P1001", "MacBook Air", 999.0)
    val holidayDiscount = Discount(15.0)
    val localTaxRate = 8.5
    
    val discountedPrice = calculateDiscountedPrice(laptop, holidayDiscount)
    val finalPrice = calculateFinalPrice(laptop, holidayDiscount, localTaxRate)
    
    println("Product: ${laptop.name}")
    println("Original Price: $${laptop.price}")
    println("Discounted Price: $${String.format("%.2f", discountedPrice)}")
    println("Final Price (with ${localTaxRate}% tax): $${String.format("%.2f", finalPrice)}")
}
```

Output:
```
Product: MacBook Air
Original Price: $999.0
Discounted Price: $849.15
Final Price (with 8.5% tax): $921.33
```

## When Pure Functions Are Challenging

Although pure functions offer many benefits, there are situations where they're challenging to implement:

1. **I/O Operations**: File reading, network requests, database access
2. **User Interaction**: UI events, input/output
3. **Time-dependent Functions**: Date/time operations, random number generation

In these cases, we typically try to isolate the impure parts from the pure logic.

## Best Practices for Pure Functions in Kotlin

1. **Use immutable data structures** (`List`, `Map`, `Set` instead of their mutable counterparts)
2. **Make all dependencies explicit** as function parameters
3. **Return new objects** instead of modifying existing ones
4. **Keep functions small and focused** on a single task
5. **Isolate side effects** at the boundaries of your application

## Summary

Pure functions are a cornerstone of functional programming in Kotlin, offering numerous benefits:

- Predictable behavior that's easier to reason about
- Improved testability due to deterministic outputs
- Better concurrency safety with no shared state
- Code that's easier to maintain and refactor

By understanding and applying pure functions in your Kotlin code, you'll write more robust, maintainable, and bug-free applications. Remember that in real-world applications, we often can't make everything pure, but we can strive to keep as much of our logic pure as possible, isolating the impure parts.

## Exercises

1. Refactor the following function to make it pure:
   ```kotlin
   var counter = 0
   fun incrementAndGet(): Int {
       counter++
       return counter
   }
   ```

2. Write a pure function that takes a list of numbers and returns a new list with only the even numbers.

3. Create a pure function that takes a string and returns a map with the frequency of each character.

## Additional Resources

- [Kotlin Official Documentation](https://kotlinlang.org/docs/reference/)
- Book: "Functional Programming in Kotlin" by Marco Vermeulen, Rúnar Bjarnason, and Paul Chiusano
- [Arrow](https://arrow-kt.io/) - Functional companion to Kotlin's standard library