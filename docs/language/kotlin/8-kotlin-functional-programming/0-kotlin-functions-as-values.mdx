---
title: Kotlin Functions as Values
description: Learn how Kotlin treats functions as first-class citizens, allowing them to be stored in variables, passed as arguments, and returned from other functions.

---

# Kotlin Functions as Values

## Introduction

One of the core concepts that makes functional programming powerful is the ability to treat functions as first-class citizens. In Kotlin, this means functions can be:

- Stored in variables and data structures
- Passed as arguments to other functions
- Returned from other functions
- Created on the fly without being tied to a name (lambdas)

This approach represents a significant shift from traditional object-oriented programming, where functions (methods) are typically tied to classes. Understanding how to use functions as values unlocks many functional programming patterns and can lead to more concise, maintainable code.

## Functions as Variables

In Kotlin, you can assign functions to variables using function references (`::`), lambda expressions, or anonymous functions.

### Using Function References

```kotlin
fun greet(name: String): String {
    return "Hello, $name!"
}

fun main() {
    // Storing a function reference in a variable
    val greeterFunction = ::greet
    
    // Calling the function through the variable
    val result = greeterFunction("World")
    println(result)  // Output: Hello, World!
}
```

### Using Lambda Expressions

Lambda expressions provide a more concise way to create function values:

```kotlin
fun main() {
    // Creating a function as a lambda and storing it in a variable
    val greeter: (String) -> String = { name -> "Hello, $name!" }
    
    // Calling the function
    val result = greeter("World")
    println(result)  // Output: Hello, World!
    
    // A more concise way with type inference
    val adder = { x: Int, y: Int -> x + y }
    println(adder(5, 3))  // Output: 8
}
```

### Function Type Syntax

When declaring variables that hold functions, Kotlin uses a specific syntax for function types:

```kotlin
// A function that takes a String and returns a String
val f1: (String) -> String

// A function that takes two Ints and returns an Int
val f2: (Int, Int) -> Int

// A function that takes no parameters and returns a Boolean
val f3: () -> Boolean

// A function with named parameters (names are for readability only)
val f4: (firstName: String, lastName: String) -> String
```

## Passing Functions as Arguments

Functions that accept other functions as parameters are called higher-order functions, and they're a cornerstone of functional programming.

```kotlin
// A higher-order function that accepts a function as a parameter
fun processNumber(x: Int, transformer: (Int) -> Int): Int {
    return transformer(x)
}

fun main() {
    // Passing a lambda as an argument
    val result1 = processNumber(5) { it * 2 }
    println(result1)  // Output: 10
    
    // Passing different functions to the same higher-order function
    val square: (Int) -> Int = { it * it }
    val result2 = processNumber(5, square)
    println(result2)  // Output: 25
    
    val addFive: (Int) -> Int = { it + 5 }
    val result3 = processNumber(5, addFive)
    println(result3)  // Output: 10
}
```

## Returning Functions from Functions

Functions can also return other functions, which enables powerful patterns like function factories:

```kotlin
// A function that returns another function
fun createMultiplier(factor: Int): (Int) -> Int {
    return { number -> number * factor }
}

fun main() {
    // Getting a function from another function
    val doubler = createMultiplier(2)
    val tripler = createMultiplier(3)
    
    println(doubler(10))  // Output: 20
    println(tripler(10))  // Output: 30
}
```

## Real-World Applications

### Building a Simple Calculator

```kotlin
fun main() {
    val operations = mapOf(
        "add" to { a: Int, b: Int -> a + b },
        "subtract" to { a: Int, b: Int -> a - b },
        "multiply" to { a: Int, b: Int -> a * b },
        "divide" to { a: Int, b: Int -> if (b != 0) a / b else throw IllegalArgumentException("Cannot divide by zero") }
    )
    
    // Using our calculator
    val a = 10
    val b = 5
    
    operations.forEach { (name, operation) ->
        println("$name: $a and $b = ${operation(a, b)}")
    }
}
```

Output:
```
add: 10 and 5 = 15
subtract: 10 and 5 = 5
multiply: 10 and 5 = 50
divide: 10 and 5 = 2
```

### Data Processing Pipeline

```kotlin
data class Person(val name: String, val age: Int)

fun main() {
    val people = listOf(
        Person("Alice", 29),
        Person("Bob", 31),
        Person("Charlie", 25),
        Person("Diana", 34),
        Person("Eve", 23)
    )
    
    // Creating a processing pipeline with functions
    val filterAdults: (List<Person>) -> List<Person> = { list -> 
        list.filter { it.age >= 18 } 
    }
    
    val sortByAge: (List<Person>) -> List<Person> = { list -> 
        list.sortedBy { it.age } 
    }
    
    val getNames: (List<Person>) -> List<String> = { list -> 
        list.map { it.name } 
    }
    
    // Compose the functions
    val processData: (List<Person>) -> List<String> = { data ->
        getNames(sortByAge(filterAdults(data)))
    }
    
    // Use the processing pipeline
    val result = processData(people)
    println("Processed result: $result")
}
```

Output:
```
Processed result: [Eve, Charlie, Alice, Bob, Diana]
```

### Event Handler System

```kotlin
class EventSystem {
    private val handlers = mutableMapOf<String, MutableList<() -> Unit>>()
    
    // Register a handler for an event
    fun on(eventName: String, handler: () -> Unit) {
        val eventHandlers = handlers.getOrPut(eventName) { mutableListOf() }
        eventHandlers.add(handler)
    }
    
    // Trigger an event
    fun trigger(eventName: String) {
        handlers[eventName]?.forEach { it() }
    }
}

fun main() {
    val events = EventSystem()
    
    // Register event handlers
    events.on("start") { println("Application starting...") }
    events.on("start") { println("Initializing modules...") }
    events.on("stop") { println("Shutting down...") }
    
    // Trigger events
    println("Triggering start event:")
    events.trigger("start")
    
    println("\nTriggering stop event:")
    events.trigger("stop")
}
```

Output:
```
Triggering start event:
Application starting...
Initializing modules...

Triggering stop event:
Shutting down...
```

## Closures in Kotlin

A closure is a function that "captures" variables from its surrounding scope. Kotlin fully supports closures:

```kotlin
fun createCounter(): () -> Int {
    var count = 0
    
    // This function captures the count variable
    return {
        count++
        count
    }
}

fun main() {
    val counter1 = createCounter()
    val counter2 = createCounter()
    
    println(counter1())  // Output: 1
    println(counter1())  // Output: 2
    println(counter1())  // Output: 3
    
    println(counter2())  // Output: 1 (separate counter)
    println(counter2())  // Output: 2
    
    println(counter1())  // Output: 4 (continues from previous state)
}
```

## Summary

Functions as values is a foundational concept in functional programming that Kotlin fully embraces. By treating functions as first-class citizens, you can:

- Store functions in variables and collections
- Pass functions as arguments to other functions
- Return functions from other functions
- Create function expressions on the fly

This approach enables powerful programming patterns like higher-order functions, function composition, and closures, which can lead to more modular, reusable, and concise code.

## Exercises

1. Create a function `compose` that takes two functions `f` and `g` and returns a new function that applies `g` after `f`.
2. Implement a `retry` higher-order function that takes a potentially failing function and retries it a specified number of times before giving up.
3. Build a simple text processing library with functions for different transformations (uppercase, lowercase, trim, etc.) that can be composed together.
4. Implement a memoization function that caches results of expensive function calls.

## Additional Resources

- [Kotlin Official Documentation on Functions](https://kotlinlang.org/docs/functions.html)
- [Higher-Order Functions and Lambdas in Kotlin](https://kotlinlang.org/docs/lambdas.html)
- Book: "Functional Programming in Kotlin" by Marco Vermeulen, RÃºnar Bjarnason, and Paul Chiusano
- Book: "Kotlin in Action" by Dmitry Jemerov and Svetlana Isakova