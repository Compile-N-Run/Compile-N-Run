# C Arrays of Structures

In the world of programming, we often need to manage collections of complex data. When you need to store multiple instances of structured data, C provides a powerful feature: arrays of structures. This allows you to organize related structured data in a sequential manner, combining the benefits of structures and arrays.

## What is an Array of Structures?

An array of structures is exactly what it sounds like: an array where each element is a structure. This concept is incredibly useful when dealing with collections of related structured data, such as:

- A list of students with their names, IDs, and grades
- A catalog of products with their details
- Employee records in a company
- Book information in a library system

## Declaring an Array of Structures

```c
struct Student {
    char name[50];
    int rollNumber;
    float marks;
};

// Declaring an array of 5 Student structures
struct Student students[5];
```

In this example, `students` is an array that can hold 5 student records, each with a name, roll number, and marks.

## Initializing an Array of Structures

There are several ways to initialize an array of structures:

### 1. During Declaration

```c
struct Student {
    char name[50];
    int rollNumber;
    float marks;
};

struct Student students[3] = {
    {"Alice", 101, 92.5},
    {"Bob", 102, 88.0},
    {"Charlie", 103, 76.5}
};
```

### 2. Using Designated Initializers (C99 and later)

```c
struct Student students[3] = {
    [0] = {.name = "Alice", .rollNumber = 101, .marks = 92.5},
    [1] = {.name = "Bob", .rollNumber = 102, .marks = 88.0},
    [2] = {.name = "Charlie", .rollNumber = 103, .marks = 76.5}
};
```

### 3. Individual Element Initialization

```c
struct Student students[3];

// Initializing the first student
strcpy(students[0].name, "Alice");
students[0].rollNumber = 101;
students[0].marks = 92.5;

// ... and so on for other elements
```

## Accessing Elements in an Array of Structures

To access a specific structure in the array, use the array index notation, and then use the dot operator to access individual members of the structure:

```c
// Accessing the name of the first student
printf("First student: %s\n", students[0].name);

// Accessing the marks of the second student
printf("Second student's marks: %.1f\n", students[1].marks);

// Modifying a value
students[2].marks = 78.5;
```

## Processing Arrays of Structures with Loops

Arrays of structures are often processed using loops. This is particularly useful when you need to perform operations on all structures in the array:

```c
// Calculating the average marks
float total = 0;
for (int i = 0; i < 3; i++) {
    total += students[i].marks;
}
float average = total / 3;
printf("Average marks: %.2f\n", average);

// Displaying all student information
for (int i = 0; i < 3; i++) {
    printf("Student %d:\n", i+1);
    printf("  Name: %s\n", students[i].name);
    printf("  Roll Number: %d\n", students[i].rollNumber);
    printf("  Marks: %.1f\n", students[i].marks);
    printf("\n");
}
```

## Arrays of Structures as Function Parameters

You can pass an array of structures to a function just like any other array:

```c
void displayStudents(struct Student students[], int size) {
    for (int i = 0; i < size; i++) {
        printf("Student %d: %s, Roll: %d, Marks: %.1f\n", 
               i+1, students[i].name, students[i].rollNumber, students[i].marks);
    }
}

// Function call
displayStudents(students, 3);
```

## Dynamically Allocating Arrays of Structures

For larger arrays or when the size is determined at runtime, you can use dynamic memory allocation:

```c
int n;
printf("Enter the number of students: ");
scanf("%d", &n);

// Dynamically allocate memory for n Student structures
struct Student *dynamicStudents = (struct Student *)malloc(n * sizeof(struct Student));

if (dynamicStudents == NULL) {
    printf("Memory allocation failed\n");
    return 1;
}

// Now use dynamicStudents as an array
for (int i = 0; i < n; i++) {
    printf("Enter details for student %d:\n", i+1);
    printf("Name: ");
    scanf("%s", dynamicStudents[i].name);
    printf("Roll Number: ");
    scanf("%d", &dynamicStudents[i].rollNumber);
    printf("Marks: ");
    scanf("%f", &dynamicStudents[i].marks);
}

// Don't forget to free the allocated memory when done
free(dynamicStudents);
```

## Practical Example: Managing a Book Inventory

Here's a more complete example that demonstrates using an array of structures to manage a simple book inventory:

```c
#include <stdio.h>
#include <string.h>

struct Book {
    char title[100];
    char author[50];
    int year;
    float price;
};

void printBookDetails(struct Book book) {
    printf("Title: %s\n", book.title);
    printf("Author: %s\n", book.author);
    printf("Year: %d\n", book.year);
    printf("Price: $%.2f\n\n", book.price);
}

int main() {
    struct Book library[3];
    
    // Initialize the first book
    strcpy(library[0].title, "C Programming Language");
    strcpy(library[0].author, "Dennis Ritchie");
    library[0].year = 1978;
    library[0].price = 29.99;
    
    // Initialize the second book
    strcpy(library[1].title, "Algorithms");
    strcpy(library[1].author, "Robert Sedgewick");
    library[1].year = 2011;
    library[1].price = 45.50;
    
    // Initialize the third book
    strcpy(library[2].title, "Clean Code");
    strcpy(library[2].author, "Robert Martin");
    library[2].year = 2008;
    library[2].price = 37.95;
    
    printf("Library Inventory:\n----------------\n");
    for (int i = 0; i < 3; i++) {
        printf("Book %d:\n", i+1);
        printBookDetails(library[i]);
    }
    
    // Find books published after 2000
    printf("Books published after 2000:\n");
    for (int i = 0; i < 3; i++) {
        if (library[i].year > 2000) {
            printBookDetails(library[i]);
        }
    }
    
    return 0;
}
```

## Common Pitfalls and Best Practices

### 1. String Copying

When working with string members, always use functions like `strcpy()` or `strncpy()` rather than direct assignment:

```c
// Incorrect
students[0].name = "Alice"; // This will cause a compilation error

// Correct
strcpy(students[0].name, "Alice");
```

### 2. Memory Management

When using dynamically allocated arrays of structures, always remember to free the memory when it's no longer needed:

```c
struct Student *students = malloc(n * sizeof(struct Student));
// Use the array...
free(students); // Don't forget this!
```

### 3. Size Calculations

Be careful with sizeof operations when dealing with arrays of structures:

```c
// This gives the size of the entire array
size_t sizeOfArray = sizeof(students);

// This gives the size of a single structure
size_t sizeOfOneStruct = sizeof(struct Student);

// Number of elements in the array
int numElements = sizeOfArray / sizeOfOneStruct;
```

## Summary

Arrays of structures in C provide a powerful way to organize collections of complex data. They combine the benefits of structures (organizing related data of different types) with the sequential storage and indexing capabilities of arrays.

Key points to remember:
- Each element in the array is a complete structure
- Access individual structures using array indexing
- Access structure members using the dot operator after the array index
- Arrays of structures can be processed efficiently using loops
- They can be dynamically allocated when the size is determined at runtime

As you build more complex programs, arrays of structures will become an essential tool in your programming toolkit, helping you organize and process related data efficiently.