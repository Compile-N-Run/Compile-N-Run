# C Dynamic Memory Allocation

In C programming, memory allocation refers to the process of reserving memory space for variables, data structures, and objects during program execution. While static memory allocation happens at compile time, dynamic memory allocation occurs at runtime, giving us the flexibility to allocate memory as needed.

## Why Dynamic Memory Allocation?

Static memory allocation has limitations:

- The size of data structures must be known at compile time
- Memory cannot be resized during program execution
- Allocated memory remains reserved for the entire program's lifetime

Dynamic memory allocation overcomes these limitations by allowing:

- Memory allocation at runtime
- Allocation of memory based on user input or program requirements
- Memory reallocation or deallocation as needed

## Memory Allocation Functions

C provides four primary functions for dynamic memory management from the `<stdlib.h>` library:

- `malloc()`: Allocates memory of requested size
- `calloc()`: Allocates memory and initializes it to zero
- `realloc()`: Resizes previously allocated memory
- `free()`: Releases allocated memory

## malloc()

The `malloc()` function allocates a specified number of bytes and returns a pointer to the first byte of the allocated memory.

```c
void* malloc(size_t size);
```

### Example:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocate memory for 5 integers
    int* ptr = (int*)malloc(5 * sizeof(int));
    
    // Check if memory allocation was successful
    if (ptr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    
    // Use the allocated memory
    for (int i = 0; i < 5; i++) {
        ptr[i] = i + 1;
    }
    
    // Print the values
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr[i]);
    }
    
    // Free the allocated memory
    free(ptr);
    
    return 0;
}
```

## calloc()

The `calloc()` function allocates memory for an array of elements, initializes all bytes to zero, and returns a pointer to the allocated memory.

```c
void* calloc(size_t num_elements, size_t element_size);
```

### Example:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocate memory for 5 integers and initialize to zero
    int* ptr = (int*)calloc(5, sizeof(int));
    
    // Check if memory allocation was successful
    if (ptr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    
    // Print the values (should all be 0)
    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr[i]);
    }
    
    // Free the allocated memory
    free(ptr);
    
    return 0;
}
```

## realloc()

The `realloc()` function changes the size of a previously allocated memory block.

```c
void* realloc(void* ptr, size_t new_size);
```

### Example:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    // Allocate memory for 5 integers
    int* ptr = (int*)malloc(5 * sizeof(int));
    
    // Check if memory allocation was successful
    if (ptr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    
    // Initialize the array
    for (int i = 0; i < 5; i++) {
        ptr[i] = i + 1;
    }
    
    // Resize the array to hold 10 integers
    ptr = (int*)realloc(ptr, 10 * sizeof(int));
    
    // Check if reallocation was successful
    if (ptr == NULL) {
        printf("Memory reallocation failed!\n");
        return 1;
    }
    
    // Initialize the new elements
    for (int i = 5; i < 10; i++) {
        ptr[i] = i + 1;
    }
    
    // Print all values
    for (int i = 0; i < 10; i++) {
        printf("%d ", ptr[i]);
    }
    
    // Free the allocated memory
    free(ptr);
    
    return 0;
}
```

## free()

The `free()` function deallocates memory previously allocated by `malloc()`, `calloc()`, or `realloc()`.

```c
void free(void* ptr);
```

## Common Pitfalls in Dynamic Memory Allocation

### 1. Memory Leaks

A memory leak occurs when allocated memory is not freed, causing the program to consume more and more memory over time.

```c
void memoryLeak() {
    int* ptr = (int*)malloc(sizeof(int));
    // No free(ptr) - memory leak!
}
```

### 2. Dangling Pointers

A dangling pointer points to memory that has been freed.

```c
int* createDanglingPointer() {
    int* ptr = (int*)malloc(sizeof(int));
    *ptr = 10;
    free(ptr);
    return ptr; // Dangling pointer - points to freed memory
}
```

### 3. Double Free

Attempting to free memory that has already been freed.

```c
int* ptr = (int*)malloc(sizeof(int));
free(ptr);
free(ptr); // Error: double free
```

### 4. Memory Corruption

Accessing memory beyond allocated boundaries.

```c
int* ptr = (int*)malloc(5 * sizeof(int));
ptr[10] = 100; // Buffer overflow - writing beyond allocated memory
```

## Best Practices

1. **Always check return values**: Always check if memory allocation functions return NULL.
2. **Always free allocated memory**: Use `free()` to deallocate memory when it's no longer needed.
3. **Set pointers to NULL after freeing**: After freeing memory, set the pointer to NULL to avoid dangling pointer errors.
4. **Use tools for memory debugging**: Tools like Valgrind can help detect memory leaks and other memory-related issues.

```c
int* ptr = (int*)malloc(sizeof(int));
free(ptr);
ptr = NULL; // Good practice
```

## Dynamic Memory Allocation for Data Structures

### Example: Dynamic Array

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int size;
    printf("Enter the size of the array: ");
    scanf("%d", &size);
    
    // Dynamically allocate an array
    int* dynamicArray = (int*)malloc(size * sizeof(int));
    
    if (dynamicArray == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }
    
    // Use the dynamic array
    printf("Enter %d elements:\n", size);
    for (int i = 0; i < size; i++) {
        scanf("%d", &dynamicArray[i]);
    }
    
    printf("Elements in the array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", dynamicArray[i]);
    }
    
    // Free the allocated memory
    free(dynamicArray);
    
    return 0;
}
```

## Conclusion

Dynamic memory allocation is a powerful feature in C that provides flexibility in managing memory resources during program execution. However, it requires careful handling to avoid common issues like memory leaks, dangling pointers, and memory corruption. By following best practices and understanding the memory allocation functions, you can effectively use dynamic memory allocation in your C programs.