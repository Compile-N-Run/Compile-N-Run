# C Multidimensional Arrays

:::tip
  Multidimensional arrays are a powerful extension of one-dimensional arrays that allow you to work with data in multiple dimensions, such as tables, matrices, and higher-dimensional data structures.
:::

## Overview

In C, a multidimensional array is essentially an array of arrays. While one-dimensional arrays organize elements in a line, multidimensional arrays arrange them in a grid-like structure with rows and columns (2D), or in even more complex arrangements (3D, 4D, etc.).

## Two-Dimensional Arrays

A two-dimensional array is the most common type of multidimensional array, often used to represent tables, matrices, or grids.

### Declaration and Initialization

```c
// Declaration syntax
data_type array_name[row_size][column_size];

// Examples
int matrix[3][4];  // 3 rows, 4 columns
float grades[30][5];  // 30 students, 5 subjects

// Initialization with values
int matrix[3][3] = {
    {1, 2, 3},  // Row 0
    {4, 5, 6},  // Row 1
    {7, 8, 9}   // Row 2
};

// Alternative form of initialization
int matrix[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
```

### Accessing Elements

Elements in a 2D array are accessed using two indices:

```c
// Syntax
array_name[row_index][column_index]

// Example
int value = matrix[1][2];  // Access element at row 1, column 2
matrix[0][0] = 10;         // Assign value 10 to first element
```

### Traversing a 2D Array

```c
#include <stdio.h>

int main() {
    int matrix[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // Traversing using nested loops
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    return 0;
}
```

## Three-Dimensional Arrays

Three-dimensional arrays can be thought of as a collection of 2D arrays.

### Declaration and Initialization

```c
// Declaration
int cube[2][3][4];  // 2 blocks, each with 3 rows and 4 columns

// Initialization
int cube[2][2][2] = {
    {{1, 2}, {3, 4}},    // First 2D array
    {{5, 6}, {7, 8}}     // Second 2D array
};
```

### Accessing and Traversing

```c
#include <stdio.h>

int main() {
    int cube[2][2][2] = {
        {{1, 2}, {3, 4}},
        {{5, 6}, {7, 8}}
    };
    
    // Accessing element
    int value = cube[1][0][1];  // Value is 6
    
    // Traversing a 3D array
    for (int i = 0; i < 2; i++) {
        printf("Layer %d:\n", i);
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 2; k++) {
                printf("%d ", cube[i][j][k]);
            }
            printf("\n");
        }
        printf("\n");
    }
    
    return 0;
}
```

## Memory Layout

In C, multidimensional arrays are stored in row-major order. This means that elements of the rightmost index change fastest when moving through memory sequentially.

```c
int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
```

Memory layout: `1, 2, 3, 4, 5, 6`

:::tip
  Understanding the memory layout is crucial for optimizing performance when working with large multidimensional arrays, as it affects cache efficiency.
:::

## Passing Multidimensional Arrays to Functions

### Fixed Size Arrays

```c
void processMatrix(int matrix[3][4]) {
    // Function body
}

// Alternative notation
void processMatrix(int (*matrix)[4]) {
    // Function body  
}
```

### Variable Size Arrays (C99 and later)

```c
void processMatrix(int rows, int cols, int matrix[rows][cols]) {
    // Function body
}
```

### Using Pointers for More Flexibility

```c
void processMatrix(int *matrix, int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            // Access element using pointer arithmetic
            int value = *(matrix + i*cols + j);
            // or: matrix[i*cols + j]
        }
    }
}

// Call the function
int matrix[3][4];
processMatrix((int *)matrix, 3, 4);
```

## Common Operations with 2D Arrays

### Matrix Addition

```c
#include <stdio.h>

void addMatrices(int A[][3], int B[][3], int C[][3], int rows, int cols) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
}

int main() {
    int A[2][3] = {{1, 2, 3}, {4, 5, 6}};
    int B[2][3] = {{7, 8, 9}, {10, 11, 12}};
    int C[2][3];
    
    addMatrices(A, B, C, 2, 3);
    
    printf("Result of matrix addition:\n");
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", C[i][j]);
        }
        printf("\n");
    }
    
    return 0;
}
```

### Matrix Multiplication

```c
#include <stdio.h>

void multiplyMatrices(int A[][2], int B[][3], int C[][3], int rowsA, int colsA, int colsB) {
    for (int i = 0; i < rowsA; i++) {
        for (int j = 0; j < colsB; j++) {
            C[i][j] = 0;
            for (int k = 0; k < colsA; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }
}

int main() {
    int A[3][2] = {{1, 2}, {3, 4}, {5, 6}};
    int B[2][3] = {{7, 8, 9}, {10, 11, 12}};
    int C[3][3];
    
    multiplyMatrices(A, B, C, 3, 2, 3);
    
    printf("Result of matrix multiplication:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", C[i][j]);
        }
        printf("\n");
    }
    
    return 0;
}
```

## Best Practices and Common Pitfalls

:::success
  <h4>Best Practices</h4>
  <ul>
    <li>Always initialize arrays to avoid unpredictable behavior with uninitialized values</li>
    <li>Use meaningful names for array dimensions that reflect their purpose</li>
    <li>When possible, traverse arrays in the way they are stored in memory (row-major order) for better performance</li>
    <li>Consider using dynamic memory allocation for large arrays to avoid stack overflow</li>
  </ul>
:::

:::danger
  <h4>Common Pitfalls</h4>
  <ul>
    <li>Array index out of bounds errors are not caught by the compiler</li>
    <li>Forgetting that array indices start at 0, not 1</li>
    <li>Confusion with row and column indices when accessing elements</li>
    <li>Not specifying all dimensions except the first when passing to functions</li>
  </ul>
:::

## Conclusion

Multidimensional arrays are essential data structures in C programming, particularly useful for working with tabular data, matrices, and higher-dimensional data representations. Understanding how to declare, initialize, access, and manipulate these arrays is fundamental for many advanced programming tasks, especially in scientific computing, graphics, and game development.

In the next section, we'll explore strings in C, which are essentially character arrays with special properties and functions.

:::tip
  <strong>Remember:</strong> Multidimensional arrays in C have fixed sizes at compile time. If you need more flexibility, consider using dynamic memory allocation with pointers or exploring higher-level data structures.
:::