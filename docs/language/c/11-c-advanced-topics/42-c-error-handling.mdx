# C Error Handling

Error handling is a critical aspect of robust software development. In C, error handling mechanisms are relatively simple but effective when used correctly. This page covers how to detect, report, and handle errors in C programs.

## Introduction to Error Handling in C

Unlike modern languages with exception handling mechanisms, C relies on return values, global error variables, and user-defined strategies to manage errors. Effective error handling in C requires discipline and consistent coding practices.

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

## Error Detection Methods in C

### Return Values

The most common method for error detection in C is through function return values:

```c
FILE *file = fopen("nonexistent.txt", "r");
if (file == NULL) {
    // Handle error
    printf("Error opening file!\n");
}
```

### Global Error Variable: errno

C provides a standard global variable called `errno` (defined in `<errno.h>`) that is set by system calls and some library functions to indicate what went wrong.

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        printf("Error opening file: %s\n", strerror(errno));
        return 1;
    }
    
    // File operations...
    fclose(file);
    return 0;
}
```

## Error Reporting Functions

### perror()

The `perror()` function prints a description of the last error that occurred:

```c
#include <stdio.h>
#include <errno.h>

int main() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        perror("Error opening file");
        return 1;
    }
    
    // File operations...
    fclose(file);
    return 0;
}
```

### strerror()

The `strerror()` function returns a pointer to the textual representation of the current errno value:

```c
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        printf("Error: %s\n", strerror(errno));
        return 1;
    }
    
    // File operations...
    fclose(file);
    return 0;
}
```

## Common errno Values

Here are some common errno values defined in `<errno.h>`:

| Errno Value | Symbolic Constant | Description |
|-------------|-------------------|-------------|
| 1 | EPERM | Operation not permitted |
| 2 | ENOENT | No such file or directory |
| 13 | EACCES | Permission denied |
| 14 | EFAULT | Bad address |
| 22 | EINVAL | Invalid argument |

## Implementing Custom Error Handling

For larger programs, it's often helpful to create a custom error handling system:

```c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

// Error levels
#define ERROR_FATAL    0
#define ERROR_WARNING  1
#define ERROR_INFO     2

void handle_error(int level, const char *message) {
    switch(level) {
        case ERROR_FATAL:
            fprintf(stderr, "FATAL ERROR: %s\n", message);
            if (errno != 0) {
                fprintf(stderr, "System error: %s\n", strerror(errno));
            }
            exit(EXIT_FAILURE);
            break;
            
        case ERROR_WARNING:
            fprintf(stderr, "WARNING: %s\n", message);
            if (errno != 0) {
                fprintf(stderr, "System error: %s\n", strerror(errno));
            }
            break;
            
        case ERROR_INFO:
            fprintf(stderr, "INFO: %s\n", message);
            break;
            
        default:
            fprintf(stderr, "UNKNOWN ERROR LEVEL: %s\n", message);
    }
}

int main() {
    FILE *file = fopen("config.txt", "r");
    if (file == NULL) {
        handle_error(ERROR_FATAL, "Cannot open configuration file");
    }
    
    // Rest of the program...
    fclose(file);
    return 0;
}
```

## Error Handling in Memory Allocation

Memory allocation is a common source of errors in C programs:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *array = (int *)malloc(10 * sizeof(int));
    if (array == NULL) {
        perror("Memory allocation failed");
        return EXIT_FAILURE;
    }
    
    // Use the allocated memory...
    
    free(array);
    return EXIT_SUCCESS;
}
```

## Best Practices for Error Handling in C

```mdx-code-block
<Tabs>
  <TabItem value="consistency" label="Be Consistent" default>
```

Use the same error handling approach throughout your code. If you decide to use return codes, use them everywhere. If you use errno, check it consistently.

```mdx-code-block
  </TabItem>
  <TabItem value="cleanup" label="Clean Up Resources">
```

Always clean up resources (free memory, close files) when errors occur to prevent resource leaks.

```c
FILE *file = fopen("data.txt", "r");
if (file == NULL) {
    perror("Error opening file");
    return 1;
}

int *data = (int *)malloc(100 * sizeof(int));
if (data == NULL) {
    perror("Memory allocation failed");
    fclose(file);  // Clean up already opened file
    return 1;
}

// If more errors occur later...
fclose(file);
free(data);
```

```mdx-code-block
  </TabItem>
  <TabItem value="specific" label="Be Specific">
```

Provide detailed error messages that include what operation failed and why.

```c
if (file == NULL) {
    fprintf(stderr, "Failed to open configuration file '%s': %s\n", 
            filename, strerror(errno));
    return 1;
}
```

```mdx-code-block
  </TabItem>
  <TabItem value="logging" label="Log Errors">
```

For larger applications, implement a logging system to record errors:

```c
void log_error(const char *format, ...) {
    va_list args;
    va_start(args, format);
    
    time_t now = time(NULL);
    char timestamp[26];
    ctime_r(&now, timestamp);
    timestamp[24] = '\0';  // Remove newline
    
    fprintf(stderr, "[%s] ERROR: ", timestamp);
    vfprintf(stderr, format, args);
    fprintf(stderr, "\n");
    
    va_end(args);
}
```

```mdx-code-block
  </TabItem>
</Tabs>
```

## Error Recovery Strategies

In C programming, you might implement several recovery strategies:

1. **Retry Operation**: For transient errors like network failures
2. **Use Default Values**: When non-critical information is unavailable
3. **Graceful Degradation**: Continue with reduced functionality
4. **Clean Exit**: When recovery is impossible, release resources and exit

## Conclusion

Error handling in C may lack the sophistication of exception-based mechanisms in other languages, but it can be just as effective when implemented properly. By consistently checking return values, using errno appropriately, and developing good error reporting habits, you can create robust C programs that handle failures gracefully.

Remember that good error handling is about:
- Detecting when something goes wrong
- Reporting the error clearly
- Taking appropriate action to recover or exit cleanly
- Preventing resource leaks

With these principles in mind, your C programs will be more reliable and easier to maintain.

## Further Reading

- [The C Programming Language](https://en.wikipedia.org/wiki/The_C_Programming_Language) by Kernighan and Ritchie
- [Advanced Programming in the UNIX Environment](https://en.wikipedia.org/wiki/Advanced_Programming_in_the_Unix_Environment) by W. Richard Stevens