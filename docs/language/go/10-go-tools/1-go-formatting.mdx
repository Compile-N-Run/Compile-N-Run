---
title: Go Formatting
description: Learn about code formatting in Go and how to use the gofmt tool to maintain consistent, idiomatic Go code

---

# Go Formatting

## Introduction

Code formatting is an essential aspect of writing clean, maintainable, and collaborative code. In the Go programming language (Golang), formatting is considered so important that it's built directly into the language ecosystem through the `gofmt` tool.

Unlike many other programming languages where formatting styles can vary widely between teams and projects, Go takes a unique "one way to format" approach. This philosophy eliminates debates about formatting styles and ensures consistency across the entire Go ecosystem.

In this guide, we'll explore:

- Why formatting matters in Go
- How the `gofmt` tool works
- Basic formatting rules in Go
- How to integrate formatting into your workflow
- Common formatting issues and their solutions

## Why Formatting Matters

Before diving into the specifics of Go formatting, let's understand why consistent formatting is particularly important in Go:

1. **Readability**: Consistent formatting makes code easier to read and understand, especially when working on a team.
2. **Collaboration**: When everyone follows the same formatting rules, code reviews focus on functionality rather than style.
3. **Learning**: For beginners, having a standard format helps learn idiomatic Go code patterns.
4. **Maintainability**: Consistently formatted code is easier to maintain over time.

Go's creator Rob Pike famously said:

> Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.

This quote captures the philosophy behind Go's approach to formatting: while the exact style might not be what every individual programmer would choose, the consistency it brings is universally beneficial.

## The `gofmt` Tool

The primary tool for formatting Go code is `gofmt` (pronounced "go format"), which comes bundled with the Go installation.

### Basic Usage

The simplest way to use `gofmt` is to run it on a file:

```bash
gofmt -w myfile.go
```

The `-w` flag tells `gofmt` to write the changes back to the file instead of outputting them to the console.

### Example: Before and After Formatting

Let's see a practical example of what `gofmt` does:

**Before formatting:**

```go
package main

import (
"fmt"
    "time"
)

func main() {
    x:=5
  y := 10
    fmt.Println(x+y)
    
    if x>3 {
fmt.Println("x is greater than 3")
    }
}
```

**After running `gofmt`:**

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	x := 5
	y := 10
	fmt.Println(x + y)

	if x > 3 {
		fmt.Println("x is greater than 3")
	}
}
```

Notice the changes:
- Imports are properly aligned and organized
- Consistent indentation (tabs, not spaces)
- Proper spacing around operators like `+`, `>`, and `:=`
- Consistent line breaks

### Formatting an Entire Directory

To format all Go files in a directory (and subdirectories), use:

```bash
gofmt -w .
```

### Alternative: `go fmt`

Go also provides a higher-level command that calls `gofmt` under the hood:

```bash
go fmt ./...
```

This command formats all Go packages in the current directory and subdirectories.

## Go's Formatting Rules

While you don't need to memorize all the formatting rules (that's what `gofmt` is for!), understanding the key principles helps write better Go code from the start:

### Indentation

- Go uses **tabs** for indentation, not spaces
- Tab width is generally visualized as 8 spaces in editors
- Each level of indentation is one tab

### Spacing

- Space after keywords (`if`, `for`, `switch`, etc.)
- No space between function name and opening parenthesis
- Spaces around binary operators (`+`, `-`, `*`, `/`, etc.)
- No spaces around unary operators (`&`, `*`, etc.)

### Line Length

- Unlike some languages, Go doesn't have a strict line length limit
- However, keeping lines reasonably short (80-100 characters) is still a good practice

### Braces

- Opening braces are always on the same line as the statement they belong to
- Closing braces are always on their own line, aligned with the start of the corresponding statement

For example:

```go
if condition {
    // code
} else {
    // more code
}
```

Not:

```go
// This is not Go style
if condition 
{
    // code
} 
else 
{
    // more code
}
```

### Imports

- Imports are grouped by standard library, then third-party packages
- Within each group, imports are alphabetically ordered
- Import groups are separated by a blank line

```go
import (
	"fmt"
	"strings"

	"github.com/example/package"
)
```

## Integrating Formatting into Your Workflow

To make formatting a seamless part of your development process:

### IDE Integration

Most Go-friendly IDEs and editors have built-in support for `gofmt`:

- **VS Code**: With the Go extension, files are automatically formatted on save
- **GoLand**: Offers automatic formatting with configurable options
- **Vim/Neovim**: Can be configured to run `gofmt` on save with plugins like vim-go

### Git Hooks

You can set up a pre-commit hook to ensure all code is properly formatted before committing:

```bash
#!/bin/sh
# Save this as .git/hooks/pre-commit and make it executable

gofiles=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$')
if [ -n "$gofiles" ]; then
  gofmt -w $gofiles
  git add $gofiles
fi
```

### CI/CD Integration

Add a formatting check to your continuous integration pipeline:

```yaml
# Example GitHub Actions workflow
name: Go Format Check

on: [push, pull_request]

jobs:
  format:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-go@v3
      with:
        go-version: '1.18'
    - name: Check formatting
      run: |
        gofmt -l . > unformatted.txt
        if [ -s unformatted.txt ]; then
          echo "The following files are not properly formatted:"
          cat unformatted.txt
          exit 1
        fi
```

## Beyond `gofmt`: Additional Formatting Tools

While `gofmt` handles basic formatting, there are more advanced tools available:

### `goimports`

The `goimports` tool extends `gofmt` by also managing your import statements:
- Adds missing imports
- Removes unused imports
- Formats imports according to Go conventions

Install it with:

```bash
go install golang.org/x/tools/cmd/goimports@latest
```

Use it similar to `gofmt`:

```bash
goimports -w myfile.go
```

### `golint`

While not strictly a formatting tool, `golint` checks for style mistakes:

```bash
go install golang.org/x/lint/golint@latest
golint ./...
```

### `go vet`

`go vet` examines code for suspicious constructs:

```bash
go vet ./...
```

## Common Formatting Issues and Solutions

### Mixed Tabs and Spaces

**Problem**:
```
mixed tabs and spaces in indentation
```

**Solution**: Let `gofmt` handle this, or ensure your editor is configured to use tabs for indentation in Go files.

### Import Organization

**Problem**: Imports are disorganized or contain unused packages.

**Solution**: Use `goimports` instead of `gofmt` to automatically fix import issues.

```bash
goimports -w file.go
```

### Long Lines

**Problem**: Some lines are excessively long, making code hard to read.

**Solution**: Break long lines into multiple lines, especially for:
- Long function declarations
- Complex expressions
- String concatenations

For example:

```go
// Before
func VeryLongFunctionName(param1 string, param2 int, param3 bool, param4 []string, param5 map[string]interface{}) (string, error) {

// After
func VeryLongFunctionName(
    param1 string,
    param2 int,
    param3 bool,
    param4 []string,
    param5 map[string]interface{},
) (string, error) {
```

## Real-World Example: API Handler Formatting

Let's see how proper formatting makes real code more readable. Here's an example of a simple HTTP API handler:

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
)

type User struct {
	ID        int       `json:"id"`
	Name      string    `json:"name"`
	Email     string    `json:"email"`
	CreatedAt time.Time `json:"created_at"`
}

func getUserHandler(w http.ResponseWriter, r *http.Request) {
	// Check if request method is GET
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// In a real app, you'd fetch this from a database
	user := User{
		ID:        1,
		Name:      "John Doe",
		Email:     "john@example.com",
		CreatedAt: time.Now(),
	}

	// Set content type and status code
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)

	// Encode and return the user
	if err := json.NewEncoder(w).Encode(user); err != nil {
		log.Printf("Error encoding response: %v", err)
		http.Error(w, "Internal server error", http.StatusInternalServerError)
	}
}

func main() {
	http.HandleFunc("/api/user", getUserHandler)
	fmt.Println("Server starting on port 8080...")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

Notice how the consistent indentation and spacing make it easy to scan the code and identify the structure of the program.

## Preventing Formatting Errors with `go fmt` Check

In a team environment, you can ensure all code follows Go formatting rules by adding a check in your CI/CD pipeline:


flowchart TD
    A[Developer commits code] --> B[CI Pipeline starts]
    B --> C[Run go fmt check]
    C -->|Formatting correct| D[Continue to other checks]
    C -->|Formatting issues| E[Pipeline fails]
    E --> F[Developer fixes formatting]
    F --> A
    D --> G[Build and test]
    G --> H[Deploy if successful]