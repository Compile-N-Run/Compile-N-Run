---
title: TypeScript Functions
description: Learn how to define and use functions in TypeScript, including function types, optional parameters, default parameters, rest parameters, and function overloading.

---

# TypeScript Functions

Functions are fundamental building blocks in JavaScript and TypeScript. TypeScript enhances JavaScript functions by adding type annotations, making your code more predictable and easier to maintain. In this tutorial, we'll explore how to define and use functions in TypeScript.

## Introduction to Functions in TypeScript

A function is a reusable block of code designed to perform a specific task. TypeScript functions are similar to JavaScript functions but with the added benefit of type checking. This helps catch errors during development rather than at runtime.

## Function Declarations in TypeScript

Let's start with the basic syntax for declaring a function in TypeScript:

```typescript
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// Using the function
const message = greet("TypeScript");
console.log(message); // Output: Hello, TypeScript!
```

In this example:
- `name: string` specifies that the `name` parameter must be a string
- `: string` after the parameter list specifies that the function returns a string

## Function Expressions

You can also define functions using function expressions:

```typescript
const greet = function(name: string): string {
  return `Hello, ${name}!`;
};

console.log(greet("TypeScript")); // Output: Hello, TypeScript!
```

## Arrow Functions

Arrow functions provide a more concise way to write function expressions:

```typescript
const greet = (name: string): string => {
  return `Hello, ${name}!`;
};

// Even more concise for single-line functions
const greetConcise = (name: string): string => `Hello, ${name}!`;

console.log(greetConcise("TypeScript")); // Output: Hello, TypeScript!
```

## Function Parameters

TypeScript offers several ways to handle function parameters:

### Optional Parameters

Use the `?` symbol to make parameters optional:

```typescript
function buildName(firstName: string, lastName?: string): string {
  if (lastName) {
    return `${firstName} ${lastName}`;
  }
  return firstName;
}

console.log(buildName("Bob")); // Output: Bob
console.log(buildName("Bob", "Johnson")); // Output: Bob Johnson
```

### Default Parameters

You can provide default values for parameters:

```typescript
function greetUser(name: string = "Guest"): string {
  return `Hello, ${name}!`;
}

console.log(greetUser()); // Output: Hello, Guest!
console.log(greetUser("Alice")); // Output: Hello, Alice!
```

### Rest Parameters

Use rest parameters to work with multiple arguments as an array:

```typescript
function sum(...numbers: number[]): number {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2)); // Output: 3
console.log(sum(1, 2, 3, 4, 5)); // Output: 15
```

## Function Types

TypeScript allows you to define the type of a function:

```typescript
// Defining a function type
type MathOperation = (x: number, y: number) => number;

// Creating functions that match the type
const add: MathOperation = (x, y) => x + y;
const subtract: MathOperation = (x, y) => x - y;

console.log(add(5, 3)); // Output: 8
console.log(subtract(5, 3)); // Output: 2
```

You can also use interfaces to define function types:

```typescript
interface MathOperation {
  (x: number, y: number): number;
}

const multiply: MathOperation = (x, y) => x * y;
console.log(multiply(5, 3)); // Output: 15
```

## Function Overloading

TypeScript supports function overloading, which allows a function to be called in different ways:

```typescript
// Overload signatures
function process(value: string): string;
function process(value: number): number;
function process(value: boolean): boolean;

// Implementation signature (needs to cover all overloads)
function process(value: string | number | boolean): string | number | boolean {
  if (typeof value === "string") {
    return value.toUpperCase();
  } else if (typeof value === "number") {
    return value * 2;
  } else {
    return !value;
  }
}

console.log(process("hello")); // Output: HELLO
console.log(process(5)); // Output: 10
console.log(process(true)); // Output: false
```

## Practical Example: API Data Processing

Here's a real-world example that shows how TypeScript functions can help you work with API data:

```typescript
// Define types for API data
interface User {
  id: number;
  name: string;
  email: string;
  active?: boolean;
}

// Function to filter active users
function getActiveUsers(users: User[]): User[] {
  return users.filter(user => user.active !== false);
}

// Function to format user data
function formatUserData(user: User): string {
  return `${user.name} (${user.email})`;
}

// Function to process user data
function processUserData(users: User[]): string[] {
  const activeUsers = getActiveUsers(users);
  return activeUsers.map(formatUserData);
}

// Sample API data
const apiUsers: User[] = [
  { id: 1, name: "Alice Smith", email: "alice@example.com", active: true },
  { id: 2, name: "Bob Johnson", email: "bob@example.com" },
  { id: 3, name: "Charlie Brown", email: "charlie@example.com", active: false }
];

// Process the data
const formattedUsers = processUserData(apiUsers);
console.log(formattedUsers);
// Output: ["Alice Smith (alice@example.com)", "Bob Johnson (bob@example.com)"]
```

This example demonstrates:
- Type definitions for API data
- Multiple specialized functions with clear purposes
- Function composition (using one function inside another)
- Type safety throughout the data processing pipeline

## Function Generics

TypeScript functions can also use generics to work with a variety of types while maintaining type safety:

```typescript
function firstElement<T>(array: T[]): T | undefined {
  return array[0];
}

const numbers = [1, 2, 3, 4, 5];
const firstNumber = firstElement(numbers);
console.log(firstNumber); // Output: 1

const strings = ["apple", "banana", "cherry"];
const firstString = firstElement(strings);
console.log(firstString); // Output: apple
```

## Summary

In this tutorial, we covered:

- Basic function syntax in TypeScript with type annotations
- Different ways to create functions (function declarations, expressions, and arrow functions)
- Working with parameters (optional, default, and rest parameters)
- Function types and interfaces
- Function overloading for flexible function behaviors
- A practical example of using functions to process API data
- Introduction to generic functions

TypeScript functions are powerful tools that combine the flexibility of JavaScript with the safety of static typing. By adding type annotations to your functions, you can catch errors earlier, improve code documentation, and enhance your development experience.

## Additional Resources and Exercises

### Exercises

1. Create a function that takes an array of numbers and returns the sum, average, and maximum value as an object.
2. Implement a generic `filter` function that can filter elements from an array based on a predicate function.
3. Create a function overload that can process either a single user or an array of users.

### Further Learning

- Explore more advanced TypeScript function patterns like currying and composition
- Learn how to use TypeScript's built-in utility types like `Parameters<T>` and `ReturnType<T>` with functions
- Study how to properly type higher-order functions (functions that take other functions as parameters)

By mastering TypeScript functions, you'll write safer, more maintainable, and more predictable code in your applications!