---
title: TypeScript Type Assertions
description: Learn how to use type assertions in TypeScript to tell the compiler about the type of a value when you know more about its type than TypeScript does.

---

# TypeScript Type Assertions

When working with TypeScript, there may be situations where you have more information about a value's type than the TypeScript compiler knows. Type assertions provide a way to tell the compiler "trust me, I know what I'm doing" by explicitly specifying a type when TypeScript cannot infer it correctly.

## Introduction to Type Assertions

Type assertions are like type casts in other languages but have no runtime impact - they are purely used by the compiler for type checking. Think of type assertions as a way to communicate to TypeScript that you, as a developer, have performed the necessary checks.

Type assertions are particularly useful when:
- Working with DOM elements
- Converting between more specific and more general types
- Working with values from JavaScript code
- When migrating from JavaScript to TypeScript

Let's dive into how type assertions work in TypeScript.

## Type Assertion Syntax

TypeScript provides two syntaxes for type assertions:

### 1. Angle Bracket Syntax

The angle bracket syntax was the original way to write type assertions:

```typescript
let someValue: any = "This is a string";
let strLength: number = (<string>someValue).length;
```

### 2. "as" Syntax

The `as` syntax was introduced later and is the preferred syntax, especially when working with JSX:

```typescript
let someValue: any = "This is a string";
let strLength: number = (someValue as string).length;
```

:::note
The `as` syntax is preferred in modern TypeScript code, especially since the angle bracket syntax cannot be used in JSX because it conflicts with XML syntax.
:::

## Basic Type Assertion Examples

Let's look at some common examples of type assertions:

### Example 1: Asserting a More Specific Type

```typescript
// We start with a variable of type 'any'
let value: any = "Hello, TypeScript!";

// Using type assertion to tell TypeScript this is a string
let length: number = (value as string).length;
console.log(length); // Output: 17

// Without the type assertion, TypeScript wouldn't recognize string methods
// value.length would cause a compilation error if 'value' was not asserted as a string
```

### Example 2: Working with DOM Elements

When working with the DOM, TypeScript often needs help understanding what element you're working with:

```typescript
// TypeScript only knows this is some kind of HTML element
const element = document.getElementById("myButton");

// Asserting it's specifically a button element
const button = element as HTMLButtonElement;

// Now we can safely use button-specific properties
button.disabled = true;
```

## Type Assertions vs. Type Casting

It's important to understand that type assertions in TypeScript are not the same as type casting in other languages:

1. Type assertions have no runtime impact - they're purely a compile-time construct
2. Type assertions don't change the actual type of the value at runtime
3. No type checking or data restructuring happens when using type assertions

```typescript
// This works at compile time but could fail at runtime
let someValue: any = 42;
let strValue = someValue as string; // No error in compilation
console.log(strValue.length);    // Runtime error: undefined
```

In the example above, the assertion tells TypeScript to treat `someValue` as a string, but at runtime, it's still a number with no `length` property.

## Double Type Assertions

Sometimes TypeScript will prevent a type assertion if the types are too different. In these cases, you might need to use a double assertion through `any`:

```typescript
// This direct assertion will fail
let num = 42;
// let str = num as string; // Error: Conversion of type 'number' to type 'string' may be a mistake

// Double assertion through 'any' works but could be dangerous
let str = num as any as string;
```

:::caution
Double assertions should be used with extreme caution as they completely bypass TypeScript's type checking. Only use them when you're absolutely certain about what you're doing.
:::

## When to Use Type Assertions

Type assertions are most useful in specific scenarios:

### 1. Working with the DOM

```typescript
// A more complete DOM example
const form = document.getElementById('myForm') as HTMLFormElement;
const nameInput = document.getElementById('name') as HTMLInputElement;
const emailInput = document.getElementById('email') as HTMLInputElement;

form.addEventListener('submit', (e) => {
  e.preventDefault();
  console.log({
    name: nameInput.value,
    email: emailInput.value
  });
});
```

### 2. Narrowing Types from Any

When working with external data like API responses:

```typescript
// Imagine this is data from an API
const userData: any = {
  id: 1,
  name: "John Doe",
  email: "john@example.com"
}

// Type assertion to work with the data safely
const user = userData as { id: number; name: string; email: string };
console.log(user.name.toUpperCase()); // JOHN DOE
```

### 3. Working with Unknown Types

The `unknown` type is a type-safe counterpart of `any`:

```typescript
function processValue(value: unknown) {
  // We need a type assertion to use methods specific to strings
  if (typeof value === "string") {
    // Even with the typeof check, TypeScript sometimes needs assertions
    return (value as string).toUpperCase();
  }
  return value;
}

console.log(processValue("hello")); // Output: HELLO
console.log(processValue(123));     // Output: 123
```

## Type Assertions with Custom Types

Type assertions are particularly useful when working with custom types and interfaces:

```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

// Imagine this comes from an API or user input
const data: any = {
  id: 1,
  name: "Jane Smith",
  email: "jane@example.com",
  role: "admin" // Extra property not in our interface
}

// We can assert this as our User type
const user = data as User;

// TypeScript now knows about these properties
console.log(user.name);  // OK
console.log(user.email); // OK

// But TypeScript doesn't know about properties not in the interface
// console.log(user.role); // Error: Property 'role' does not exist on type 'User'
```

## Type Assertions vs. Type Guards

While type assertions are useful, type guards often provide a safer alternative:

```typescript
function isString(value: any): value is string {
  return typeof value === 'string';
}

function processInput(input: unknown) {
  // Using type guard instead of assertion
  if (isString(input)) {
    // Inside this block, TypeScript knows input is a string
    // No type assertion needed
    return input.toUpperCase();
  }
  return String(input);
}
```

Type guards perform runtime checks and help TypeScript understand the type within a specific scope, while type assertions simply tell the compiler to treat a value as a certain type without verification.

## The `const` Assertion

TypeScript also has a special `const` assertion that can be used to make an object literal's properties readonly and to signal that arrays shouldn't be considered mutable:

```typescript
// Without const assertion
const colors = ["red", "green", "blue"];
// TypeScript infers: string[]

// With const assertion
const colorsConst = ["red", "green", "blue"] as const;
// TypeScript infers: readonly ["red", "green", "blue"]

// This modifies the original array (allowed)
colors.push("yellow");

// This would cause an error (not allowed with const assertion)
// colorsConst.push("yellow"); // Error: Property 'push' does not exist on type 'readonly ["red", "green", "blue"]'
```

## Best Practices for Type Assertions

To use type assertions effectively and safely:

1. **Use sparingly**: Prefer proper type declarations and type guards when possible.
2. **Verify your assumptions**: Before asserting a type, make sure your assertion is correct.
3. **Use with `unknown` rather than `any`**: The `unknown` type requires an assertion or type guard, making your code safer.
4. **Choose the `as` syntax**: It's more widely compatible, especially with JSX.
5. **Add runtime checks**: When possible, couple type assertions with runtime checks.

## Common Type Assertion Pitfalls

### Asserting Incompatible Types

```typescript
let num = 42;
// This compiles but is logically incorrect
let str = num as unknown as string;
// str is still 42 at runtime, not a string!
```

### Asserting Without Verification

```typescript
// Bad practice: blindly asserting
function getLength(value: any): number {
  return (value as string).length; // Might fail at runtime
}

// Better practice: verify before using
function getSafeLength(value: any): number {
  if (typeof value === 'string') {
    return value.length;
  }
  return 0;
}
```

## Summary

Type assertions in TypeScript provide a way to tell the compiler about the type of a value when you have more information than TypeScript can infer. While powerful, they should be used judiciously since they bypass TypeScript's type checking.

Key points to remember:
- Type assertions have two syntaxes: angle brackets `<type>` and the `as` keyword
- They don't change the runtime behavior or type of values
- They're useful for working with DOM elements, external data, and when migrating from JavaScript
- Type assertions should be used sparingly, with type guards often being a safer alternative
- The `const` assertion provides a way to make object literals and arrays more strictly typed

## Exercises

1. Convert a function that uses type assertions to use type guards instead.
2. Practice retrieving and manipulating DOM elements with appropriate type assertions.
3. Create a function that safely processes JSON data by using type assertions with appropriate checks.
4. Experiment with the `const` assertion to create strictly typed object literals.
5. Try handling an API response with type assertions to properly type the returned data.

## Additional Resources

- [TypeScript Handbook: Type Assertions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions)
- [TypeScript Deep Dive: Type Assertion](https://basarat.gitbook.io/typescript/type-system/type-assertion)
- [Understanding TypeScript's const assertions](https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/)

By mastering type assertions, you'll be able to more effectively bridge the gap between TypeScript's static type system and the dynamic nature of JavaScript, especially when working with existing JavaScript code or external APIs.