---
title: Python Creating Modules
description: Learn how to create your own Python modules to organize and reuse your code efficiently

---

# Creating Your Own Python Modules

## Introduction

In Python, a module is a file containing Python definitions and statements. The file name is the module name with the `.py` extension added. Modules allow you to logically organize your Python code, making it more maintainable and reusable. As your programs grow larger, breaking them into modules becomes increasingly important for managing complexity.

In this tutorial, we'll learn how to create our own Python modules, understand their benefits, and explore best practices for module development.

## Why Create Modules?

Before we dive into creating modules, let's understand why they're valuable:

1. **Code Organization**: Modules help you organize related code together
2. **Code Reusability**: Write once, use many times
3. **Namespace Management**: Avoid naming conflicts in large programs
4. **Maintainability**: Easier to update and debug smaller, focused files

## Creating Your First Module

Creating a Python module is as simple as creating a `.py` file. Let's create a basic module that contains mathematical helper functions.

### Step 1: Create a module file

Create a new file named `mathhelper.py` with the following content:

```python
# mathhelper.py

def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def subtract(a, b):
    """Subtract b from a and return the result."""
    return a - b

def multiply(a, b):
    """Multiply two numbers and return the result."""
    return a * b

def divide(a, b):
    """Divide a by b and return the result."""
    if b == 0:
        raise ValueError("Cannot divide by zero!")
    return a / b

# Constants
PI = 3.14159
E = 2.71828
```

### Step 2: Import and use your module

Now, let's create another file in the same directory to use our module:

```python
# main.py
import mathhelper

# Using functions from our module
result1 = mathhelper.add(5, 3)
result2 = mathhelper.multiply(4, 2)

# Using constants from our module
area = mathhelper.PI * (2 ** 2)  # Area of a circle with radius 2

print(f"5 + 3 = {result1}")
print(f"4 × 2 = {result2}")
print(f"Area of circle with radius 2: {area}")
```

When you run `main.py`, you'll see:

```
5 + 3 = 8
4 × 2 = 8
Area of circle with radius 2: 12.56636
```

## Module Variables and Scope

When you create a module, you should be aware of how Python handles variables and scope.

### The `__name__` Variable

Every module has a built-in variable called `__name__`. When you run a module directly, `__name__` is set to `'__main__'`. When you import a module, `__name__` is set to the module's name.

This behavior allows you to write code that runs only when the module is executed directly, not when imported. Let's modify our `mathhelper.py`:

```python
# mathhelper.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero!")
    return a / b

PI = 3.14159

# This will only run when the module is executed directly
if __name__ == '__main__':
    print("Testing mathhelper functions:")
    print(f"2 + 3 = {add(2, 3)}")
    print(f"5 - 2 = {subtract(5, 2)}")
    print(f"4 × 6 = {multiply(4, 6)}")
    print(f"8 ÷ 4 = {divide(8, 4)}")
```

Now when you run `mathhelper.py` directly, you'll see the test output:

```
Testing mathhelper functions:
2 + 3 = 5
5 - 2 = 3
4 × 6 = 24
8 ÷ 4 = 2.0
```

But when you import `mathhelper` in another file, the test code won't run.

## Selective Imports

There are several ways to import from a module:

### 1. Import the entire module

```python
import mathhelper

result = mathhelper.add(5, 3)
```

### 2. Import specific items

```python
from mathhelper import add, subtract

result1 = add(5, 3)       # No prefix needed
result2 = subtract(10, 4)
```

### 3. Import all items (not recommended for large modules)

```python
from mathhelper import *

result = multiply(4, 5)   # No prefix needed
```

### 4. Import with an alias

```python
import mathhelper as mh

result = mh.add(5, 3)
```

## Module Documentation

A well-documented module is easier to use. You should include:

1. A module docstring at the top of the file
2. Function/class docstrings
3. Comments for complex logic

Let's improve our `mathhelper.py`:

```python
"""
MathHelper Module

This module provides basic mathematical operations and constants.
It's designed for educational purposes to demonstrate module creation.
"""

def add(a, b):
    """
    Add two numbers and return the result.
    
    Args:
        a: First number
        b: Second number
        
    Returns:
        The sum of a and b
    """
    return a + b

# ... other functions with similar docstrings ...

# Constants
PI = 3.14159  # Approximation of π
E = 2.71828   # Approximation of e
```

## Module Location and Import System

Python searches for modules in the following locations:

1. The directory containing the input script
2. Directories in the PYTHONPATH environment variable
3. Standard library directories
4. Site-packages directories where third-party packages are installed

## Practical Example: Creating a Text Processing Module

Let's create a more practical module for text processing:

```python
# textutils.py
"""
Text Utilities Module

This module provides functions for common text processing tasks.
"""

def word_count(text):
    """Count the number of words in a text."""
    if not text:
        return 0
    return len(text.split())

def char_count(text, include_spaces=True):
    """
    Count the number of characters in a text.
    
    Args:
        text: The input text
        include_spaces: Whether to include whitespace in the count
        
    Returns:
        The character count
    """
    if not include_spaces:
        text = text.replace(" ", "")
    return len(text)

def capitalize_words(text):
    """Capitalize the first letter of each word."""
    return ' '.join(word.capitalize() for word in text.split())

def find_all(text, substring):
    """
    Find all occurrences of a substring in text.
    
    Returns a list of starting indices.
    """
    indices = []
    start = 0
    while True:
        start = text.find(substring, start)
        if start == -1:
            break
        indices.append(start)
        start += 1
    return indices

if __name__ == "__main__":
    sample = "Python is an amazing programming language. Python is versatile and powerful."
    print(f"Word count: {word_count(sample)}")
    print(f"Character count (with spaces): {char_count(sample)}")
    print(f"Character count (without spaces): {char_count(sample, include_spaces=False)}")
    print(f"Capitalized: {capitalize_words(sample.lower())}")
    print(f"Occurrences of 'Python': {find_all(sample, 'Python')}")
```

Now let's use this module:

```python
# text_analyzer.py
import textutils

text = """
Python modules are a key feature that allow programmers to organize their code.
Modules make code reusable and maintainable. Creating your own modules is
straightforward and recommended for any significant Python project.
"""

print(f"Statistics for the text sample:")
print(f"Words: {textutils.word_count(text)}")
print(f"Characters: {textutils.char_count(text)}")
print(f"Characters (no spaces): {textutils.char_count(text, False)}")
print(f"Occurrences of 'module': {textutils.find_all(text.lower(), 'module')}")
```

Output:

```
Statistics for the text sample:
Words: 29
Characters: 221
Characters (no spaces): 179
Occurrences of 'module': [7, 67]
```

## Best Practices for Creating Modules

1. **Keep modules focused**: Each module should have a specific purpose
2. **Follow naming conventions**: Use lowercase names with underscores if needed
3. **Include docstrings**: Document your module and functions
4. **Use the `if __name__ == '__main__'` pattern**: For runnable modules
5. **Don't pollute the global namespace**: Be careful when using `from module import *`
6. **Keep module size manageable**: If a module gets too large, split it into smaller modules

## Advanced Topic: Module Initialization

When you import a module, Python executes all code in the module. You can use this behavior to perform initialization tasks:

```python
# config.py
"""Configuration module for application settings."""

import os
import json

# Default settings
settings = {
    "debug_mode": False,
    "log_level": "INFO",
    "max_connections": 10
}

# Try to load settings from a config file
try:
    if os.path.exists("config.json"):
        with open("config.json", "r") as f:
            user_settings = json.load(f)
            # Update default settings with user settings
            settings.update(user_settings)
except Exception as e:
    print(f"Warning: Could not load config file: {e}")
    print("Using default settings.")

# This will be executed when the module is imported
print(f"Config loaded with debug_mode = {settings['debug_mode']}")
```

When you import this module, it will try to load settings from a file.

## Summary

Creating your own Python modules is a fundamental skill that helps you organize and reuse your code efficiently:

- A module is simply a Python file with a `.py` extension
- Modules can contain functions, classes, variables, and executable code
- The `__name__` variable helps distinguish between direct execution and import
- Well-documented modules with clear docstrings are easier to use
- Modules should be focused on specific functionality

As your Python projects grow, consider organizing related modules into packages, which we'll cover in the next lesson.

## Exercises

1. Create a module called `stringutils.py` with functions to:
   - Count the number of vowels in a string
   - Reverse a string
   - Check if a string is a palindrome

2. Create a module called `fileutils.py` with functions to:
   - Count lines in a text file
   - Find all files in a directory with a specific extension
   - Read a CSV file and return it as a list of dictionaries

3. Create a module that provides utilities for working with dates and times. Include functions for:
   - Converting between different date formats
   - Calculating the difference between two dates
   - Finding all weekdays in a given month and year

## Additional Resources

- [Python Documentation: Modules](https://docs.python.org/3/tutorial/modules.html)
- [Real Python: Python Modules and Packages](https://realpython.com/python-modules-packages/)
- [The Hitchhiker's Guide to Python: Code Structure](https://docs.python-guide.org/writing/structure/)