---
title: Python Requirements File
description: Learn how to manage package dependencies in Python projects using requirements files

---

# Python Requirements File

When working on Python projects, you'll often need to use external libraries and packages. Managing these dependencies efficiently becomes crucial as your projects grow or when you collaborate with others. This is where a **requirements file** comes into play.

## What is a Requirements File?

A requirements file is a text file that lists all the Python packages your project depends on, along with their versions. By convention, this file is usually named `requirements.txt`. It allows other developers to quickly install all the dependencies needed to run your project.

## Why Use a Requirements File?

- **Reproducibility**: Ensures your project works consistently across different environments
- **Collaboration**: Makes it easier for team members to set up the development environment
- **Deployment**: Simplifies the process of deploying your application
- **Documentation**: Acts as documentation for which external libraries your project relies on

## Creating a Requirements File

### Method 1: Manual Creation

You can create a requirements file manually by listing each package and its version. Here's a simple example:

```
numpy==1.21.5
pandas==1.4.2
matplotlib>=3.5.1
requests
```

In this file:
- `numpy==1.21.5` specifies exactly version 1.21.5
- `pandas==1.4.2` specifies exactly version 1.4.2
- `matplotlib>=3.5.1` specifies version 3.5.1 or newer
- `requests` doesn't specify a version (latest will be installed)

### Method 2: Generating from Installed Packages

A more common approach is to generate the file from packages you've already installed:

```bash
pip freeze > requirements.txt
```

This command captures all installed packages in your current environment and writes them to `requirements.txt`.

## Installing Packages from a Requirements File

To install all packages listed in a requirements file:

```bash
pip install -r requirements.txt
```

This command reads the file and installs all packages with the specified versions.

## Best Practices

### 1. Use Virtual Environments

Always use a virtual environment when working with requirements files. This ensures that your dependencies don't conflict with other projects.

```bash
# Create a virtual environment
python -m venv myenv

# Activate it (Windows)
myenv\Scripts\activate

# Activate it (macOS/Linux)
source myenv/bin/activate

# Now install or generate requirements
```

### 2. Pin Versions for Production

For production projects, pin specific versions to ensure consistency:

```
numpy==1.21.5
pandas==1.4.2
matplotlib==3.5.1
```

### 3. Specify Version Ranges for Development

For libraries used in development, you might want to allow version ranges:

```
black>=22.1.0,<23.0.0
pytest>=7.0.0
```

### 4. Separate Development Dependencies

Consider having separate requirements files for different environments:

- `requirements.txt` - Core dependencies
- `requirements-dev.txt` - Development dependencies

Example of `requirements-dev.txt`:

```
-r requirements.txt
pytest>=7.0.0
black>=22.1.0
flake8>=4.0.1
```

The `-r requirements.txt` line includes the base requirements file.

## Real-World Example

Let's walk through a real-world example of using requirements files for a small web application:

### Project Structure

```
my_web_app/
├── app.py
├── templates/
├── static/
├── requirements.txt
└── requirements-dev.txt
```

### requirements.txt

```
Flask==2.1.1
SQLAlchemy==1.4.36
gunicorn==20.1.0
python-dotenv==0.20.0
```

### requirements-dev.txt

```
-r requirements.txt
pytest==7.1.2
black==22.3.0
flake8==4.0.1
```

### Setting Up for Development

```bash
# Create and activate virtual environment
python -m venv venv
source venv/bin/activate  # or venv\Scripts\activate on Windows

# Install development dependencies
pip install -r requirements-dev.txt

# Run the application
python app.py
```

### Deploying to Production

```bash
# On production server
python -m venv venv
source venv/bin/activate

# Install only production dependencies
pip install -r requirements.txt

# Run with gunicorn
gunicorn app:app
```

## Advanced Techniques

### 1. Using pip-tools

The `pip-tools` package provides more advanced dependency management:

```bash
# Install pip-tools
pip install pip-tools

# Create requirements.in with high-level dependencies
echo "Flask" > requirements.in
echo "SQLAlchemy" >> requirements.in

# Compile to requirements.txt with all sub-dependencies pinned
pip-compile requirements.in
```

### 2. Version Constraints

Requirements files support various version specifiers:

```
package==1.0.0    # Exact version
package>=1.0.0    # Minimum version
package<=1.0.0    # Maximum version
package~=1.0.0    # Compatible release (~= 1.0.0 means >= 1.0.0, < 2.0.0)
package>=1.0,<2.0 # Version range
```

### 3. Using Environment Markers

You can specify platform-specific dependencies:

```
pywin32==303; sys_platform == "win32"
```

This will only install `pywin32` on Windows systems.

## Common Issues and Solutions

### 1. Conflicting Dependencies

If you encounter dependency conflicts, consider using tools like `pip-tools` or `pipenv` for better dependency resolution.

### 2. Too Many Dependencies

When `pip freeze` generates too many transitive dependencies, consider using `pipreqs`:

```bash
pip install pipreqs
pipreqs /path/to/project
```

This analyzes your imports and only includes directly used packages.

### 3. Environment Differences

If your application works differently across environments despite using requirements files, check for:
- Different Python versions
- Platform-specific dependencies
- Environment variables affecting behavior

## Summary

Requirements files are a simple but powerful tool for managing Python dependencies. They help ensure your projects are reproducible across different environments and make collaboration easier. By following best practices like using virtual environments, pinning versions appropriately, and separating development dependencies, you can maintain a clean and reliable development workflow.

## Additional Resources

- [Pip Documentation](https://pip.pypa.io/en/stable/user_guide/#requirements-files)
- [PyPA Guidelines](https://packaging.python.org/en/latest/guides/distributing-packages-using-setuptools/#requirements-for-installing-setuptools)
- [pip-tools Documentation](https://github.com/jazzband/pip-tools)

## Exercises

1. Create a virtual environment and install three packages of your choice. Generate a requirements file from this environment.

2. Create a simple Python application that uses at least two external libraries. Include a well-structured requirements file.

3. Set up two different requirements files for a project: one for production and one for development.

4. Take an existing Python project and add version constraints to its requirements file to improve reproducibility.