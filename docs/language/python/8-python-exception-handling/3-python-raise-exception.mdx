---
title: Python Raise Exception
description: Learn how to raise custom exceptions in Python, when to use them, and best practices for exception creation and handling.

---

# Python Raise Exception

## Introduction

In Python programming, sometimes you need to deliberately create an error when certain conditions are met. This is where the `raise` statement comes into play. Raising exceptions allows you to signal that something unexpected or erroneous has happened in your code, enabling you to handle these situations gracefully.

In this tutorial, you'll learn:
- What the `raise` statement is and why it's useful
- How to raise built-in exceptions
- How to create and raise custom exceptions
- Best practices for raising exceptions
- Real-world applications of exception raising

## Understanding the `raise` Statement

The `raise` statement in Python allows you to trigger an exception explicitly rather than waiting for Python to detect an error. This gives you control over error handling in your programs.

### Basic Syntax

```python
raise ExceptionType("Error message")
```

When this statement executes, it immediately interrupts the normal flow of your program and begins the exception handling process.

## Raising Built-in Exceptions

Python comes with many built-in exceptions that you can raise directly. Here are some common ones:

### Example 1: Raising a ValueError

```python
def set_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative")
    return age

# Example usage:
try:
    print(set_age(25))  # Output: 25
    print(set_age(-5))  # Raises ValueError
except ValueError as e:
    print(f"Error: {e}")  # Output: Error: Age cannot be negative
```

### Example 2: Raising a TypeError

```python
def add_numbers(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError("Both arguments must be numbers")
    return a + b

# Example usage:
try:
    print(add_numbers(5, 3))      # Output: 8
    print(add_numbers("5", 3))    # Raises TypeError
except TypeError as e:
    print(f"Error: {e}")          # Output: Error: Both arguments must be numbers
```

## Creating and Raising Custom Exceptions

For more specific error handling, you can create your own exception types by inheriting from the base `Exception` class or any of its subclasses.

### Defining a Custom Exception

```python
class InsufficientFundsError(Exception):
    """Raised when a withdrawal would result in a negative balance"""
    pass

class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
        
    def withdraw(self, amount):
        if amount > self.balance:
            raise InsufficientFundsError(f"Cannot withdraw ${amount}. Only ${self.balance} available.")
        self.balance -= amount
        return self.balance

# Example usage:
account = BankAccount(100)
try:
    print(account.withdraw(50))   # Output: 50
    print(account.withdraw(75))   # Raises InsufficientFundsError
except InsufficientFundsError as e:
    print(f"Transaction failed: {e}")  # Output: Transaction failed: Cannot withdraw $75. Only $50 available.
```

### Adding More Context to Custom Exceptions

You can enhance custom exceptions with additional information:

```python
class NetworkError(Exception):
    """Exception raised for network-related errors"""
    def __init__(self, message, status_code=None):
        self.message = message
        self.status_code = status_code
        super().__init__(self.message)
    
    def __str__(self):
        if self.status_code:
            return f"{self.message} (Status code: {self.status_code})"
        return self.message

# Example usage:
try:
    raise NetworkError("Failed to connect to the server", 404)
except NetworkError as e:
    print(f"Network error occurred: {e}")  
    # Output: Network error occurred: Failed to connect to the server (Status code: 404)
```

## Re-raising Exceptions

Sometimes you want to catch an exception, perform some action, and then re-raise it for handling at a higher level:

```python
def process_data(data):
    try:
        result = risky_operation(data)
        return result
    except Exception as e:
        print(f"Warning: An error occurred during processing: {e}")
        raise  # Re-raise the caught exception
        
def risky_operation(data):
    if not data:
        raise ValueError("Empty data cannot be processed")
    # Process data...
    return data.upper()

# Example usage:
try:
    process_data("")
except ValueError as e:
    print(f"Error handled at top level: {e}")
    
# Output:
# Warning: An error occurred during processing: Empty data cannot be processed
# Error handled at top level: Empty data cannot be processed
```

## Raising Exceptions with `from`

The `raise ... from ...` syntax lets you chain exceptions to provide more context:

```python
def fetch_data_from_database(query):
    try:
        # Simulate a database error
        raise ConnectionError("Database connection lost")
    except ConnectionError as original_error:
        raise ValueError("Could not fetch user data") from original_error

# Example usage:
try:
    fetch_data_from_database("SELECT * FROM users")
except ValueError as e:
    print(f"Error: {e}")
    print(f"Original error: {e.__cause__}")
    
# Output:
# Error: Could not fetch user data
# Original error: Database connection lost
```

## Conditional Exception Raising

You can use conditional statements to decide when to raise exceptions:

```python
def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("Cannot divide by zero")
    return a / b

# Function that uses divide and handles errors
def calculate_ratio(numerator, denominator):
    try:
        return divide(numerator, denominator)
    except ZeroDivisionError as e:
        return float('inf')  # Return infinity for division by zero

# Example usage:
print(calculate_ratio(10, 2))  # Output: 5.0
print(calculate_ratio(10, 0))  # Output: inf
```

## Real-world Application: Input Validation

Here's a more comprehensive example showing how to use exceptions for validating user input:

```python
class ValidationError(Exception):
    """Base exception for all validation errors"""
    pass

class UserInputValidator:
    def validate_username(self, username):
        if not username:
            raise ValidationError("Username cannot be empty")
        if len(username) < 3:
            raise ValidationError("Username must be at least 3 characters long")
        if not username.isalnum():
            raise ValidationError("Username can only contain letters and numbers")
        return username
    
    def validate_password(self, password):
        if len(password) < 8:
            raise ValidationError("Password must be at least 8 characters long")
        if not any(c.isdigit() for c in password):
            raise ValidationError("Password must contain at least one number")
        if not any(c.isupper() for c in password):
            raise ValidationError("Password must contain at least one uppercase letter")
        return password
    
    def register_user(self, username, password):
        try:
            valid_username = self.validate_username(username)
            valid_password = self.validate_password(password)
            return f"User {valid_username} registered successfully"
        except ValidationError as e:
            return f"Registration failed: {e}"

# Example usage:
validator = UserInputValidator()
print(validator.register_user("user123", "Password123"))  # Successful
print(validator.register_user("us", "password"))          # Username too short
print(validator.register_user("user@123", "Password123")) # Invalid characters in username
print(validator.register_user("user123", "password"))     # Password needs uppercase
print(validator.register_user("user123", "Password"))     # Password needs number

# Output:
# User user123 registered successfully
# Registration failed: Username must be at least 3 characters long
# Registration failed: Username can only contain letters and numbers
# Registration failed: Password must contain at least one uppercase letter
# Registration failed: Password must contain at least one number
```

## Best Practices for Raising Exceptions

1. **Be specific**: Use the most specific exception type that applies to the situation.
2. **Provide clear error messages**: Include detailed information about what went wrong.
3. **Only use exceptions for exceptional cases**: Don't use exceptions for normal flow control.
4. **Create custom exceptions for specific needs**: When built-in exceptions don't express your error well.
5. **Document your exceptions**: Make sure to document which exceptions your functions might raise.

```python
def find_user_by_id(user_id):
    """
    Find a user by their ID in the database
    
    Args:
        user_id (int): The ID of the user to find
        
    Returns:
        dict: The user data
        
    Raises:
        ValueError: If user_id is not a positive integer
        UserNotFoundError: If no user with the given ID exists
        DatabaseError: If there was an error connecting to the database
    """
    if not isinstance(user_id, int) or user_id <= 0:
        raise ValueError("User ID must be a positive integer")
    
    # Rest of the function...
```

## Summary

The `raise` statement in Python is a powerful tool that allows you to:

- Trigger exceptions when specific conditions are met
- Create custom exceptions tailored to your application's needs
- Provide meaningful error messages to aid in debugging
- Control the flow of your program in error situations
- Chain exceptions to provide more context about errors

Understanding how and when to raise exceptions helps you write more robust, error-resistant code that can gracefully handle unexpected situations.

## Exercises

1. Create a custom exception called `TemperatureError` that is raised when a temperature value is outside a valid range.
2. Write a function that validates an email address and raises appropriate exceptions for invalid formats.
3. Implement a `divide_safely` function that raises custom exceptions for different error cases (zero division, non-numeric inputs, etc.).
4. Create a simple banking system with custom exceptions for various error conditions (insufficient funds, invalid amounts, etc.).
5. Modify an existing function to use exception chaining with the `raise ... from ...` syntax to provide more context about errors.

## Additional Resources

- [Python Official Documentation on Exceptions](https://docs.python.org/3/tutorial/errors.html)
- [PEP 3134 – Exception Chaining](https://www.python.org/dev/peps/pep-3134/)
- [Python Built-in Exceptions](https://docs.python.org/3/library/exceptions.html)
- [The Python Exception Class Hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)