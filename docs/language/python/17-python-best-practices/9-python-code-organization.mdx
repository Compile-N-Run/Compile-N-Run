---
title: Python Code Organization
description: Learn how to organize your Python code effectively with proper file structure, modules, packages, and best practices for maintainable and scalable projects.

---

# Python Code Organization

Good code organization is essential for writing maintainable, readable, and scalable Python programs. As your projects grow, proper organization becomes increasingly important. This guide will help you understand how to structure your Python code effectively, from simple scripts to complex applications.

## Why Code Organization Matters

When you're just starting with Python, your programs might be single files with a few dozen lines of code. However, as you take on more complex projects, good organization becomes crucial because it:

- Makes code easier to understand and navigate
- Promotes code reuse
- Simplifies maintenance and debugging
- Enables collaboration with other developers
- Helps separate concerns in your program

## Basic Python Script Structure

Let's start with how to organize a simple Python script:

```python
#!/usr/bin/env python3
"""
This module demonstrates a well-organized Python script.
"""

# Standard library imports
import os
import sys
from datetime import datetime

# Third-party imports
import requests
import pandas as pd

# Local application imports
from mypackage import helper
from mypackage.submodule import utils

# Constants
MAX_RETRIES = 3
BASE_URL = "https://api.example.com"

# Function definitions
def fetch_data(endpoint):
    """Fetch data from the specified endpoint."""
    url = f"{BASE_URL}/{endpoint}"
    for attempt in range(MAX_RETRIES):
        try:
            response = requests.get(url)
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            print(f"Attempt {attempt + 1} failed: {e}")
            if attempt == MAX_RETRIES - 1:
                raise
    
def process_data(data):
    """Process the fetched data."""
    # Data processing logic here
    return pd.DataFrame(data)

# Main execution
def main():
    """Main function to execute the script."""
    try:
        raw_data = fetch_data("users")
        processed_data = process_data(raw_data)
        print(f"Processed {len(processed_data)} records")
        return 0
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

### Key Components Explained:

1. **Shebang Line**: `#!/usr/bin/env python3` allows the script to be executed directly on Unix-like systems
2. **Module Docstring**: A high-level description of what the script does
3. **Import Organization**: Grouped by source (standard library, third-party, local)
4. **Constants**: Defined at the module level with uppercase names
5. **Functions**: Well-documented with docstrings
6. **Main Function**: Contains the primary logic of the script
7. **Execution Guard**: `if __name__ == "__main__"` ensures code only runs when the script is executed directly

## Using Modules

A module in Python is simply a file containing Python code. Modules help you organize related code into files that can be imported where needed.

### Creating a Module

Let's create a simple module called `calculator.py`:

```python
"""
A simple calculator module with basic arithmetic functions.
"""

def add(a, b):
    """Add two numbers and return the result."""
    return a + b

def subtract(a, b):
    """Subtract b from a and return the result."""
    return a - b

def multiply(a, b):
    """Multiply two numbers and return the result."""
    return a * b

def divide(a, b):
    """Divide a by b and return the result."""
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
```

### Using the Module

Now you can import and use this module in another file:

```python
import calculator

# Using functions from the module
result1 = calculator.add(10, 5)
result2 = calculator.subtract(10, 5)

print(f"Addition: {result1}")  # Output: Addition: 15
print(f"Subtraction: {result2}")  # Output: Subtraction: 5

# Alternative import syntax
from calculator import multiply, divide

result3 = multiply(10, 5)
result4 = divide(10, 5)

print(f"Multiplication: {result3}")  # Output: Multiplication: 50
print(f"Division: {result4}")  # Output: Division: 2.0
```

## Creating Packages

A package is a way of organizing related modules into a single directory hierarchy. To create a package, you need to create a directory and include an `__init__.py` file.

### Package Structure

Here's an example of a simple package structure:

```
my_package/
│
├── __init__.py
├── module1.py
├── module2.py
│
└── subpackage/
    ├── __init__.py
    ├── submodule1.py
    └── submodule2.py
```

### Creating a Package

1. First, create the directory structure:

```bash
mkdir -p my_package/subpackage
```

2. Create the `__init__.py` files (they can be empty but are required in Python 2.x and recommended in Python 3.x):

```bash
touch my_package/__init__.py
touch my_package/subpackage/__init__.py
```

3. Create the module files:

Let's create `my_package/module1.py`:

```python
def greeting(name):
    return f"Hello, {name}!"
```

And `my_package/subpackage/submodule1.py`:

```python
def advanced_greeting(name, title="Mr."):
    return f"Greetings, {title} {name}!"
```

4. Using the package:

```python
# Import a module from the package
import my_package.module1

# Use a function from the module
message = my_package.module1.greeting("Alice")
print(message)  # Output: Hello, Alice!

# Import a function directly
from my_package.subpackage.submodule1 import advanced_greeting

# Use the imported function
message = advanced_greeting("Bob", title="Dr.")
print(message)  # Output: Greetings, Dr. Bob!
```

## Using `__init__.py` Effectively

The `__init__.py` file can be used to expose specific functions or classes from your package, making imports cleaner:

```python
# my_package/__init__.py
from .module1 import greeting
from .subpackage.submodule1 import advanced_greeting

__all__ = ['greeting', 'advanced_greeting']
```

Now users can import directly from your package:

```python
from my_package import greeting, advanced_greeting

print(greeting("Charlie"))  # Output: Hello, Charlie!
print(advanced_greeting("Dana", "Prof."))  # Output: Greetings, Prof. Dana!
```

## Project Structure for Larger Applications

For larger Python applications, consider using the following structure:

```
project_name/
│
├── README.md
├── LICENSE
├── setup.py
├── requirements.txt
│
├── project_name/
│   ├── __init__.py
│   ├── core.py
│   ├── helpers.py
│   └── subpackage/
│       ├── __init__.py
│       └── feature.py
│
├── tests/
│   ├── __init__.py
│   ├── test_core.py
│   └── test_helpers.py
│
├── docs/
│   └── index.md
│
└── examples/
    └── example_usage.py
```

### Explanation:

1. **Root directory**: Contains project metadata files
2. **Package directory**: Contains the actual Python package (same name as project)
3. **Tests directory**: Contains all test files
4. **Docs directory**: Contains documentation
5. **Examples directory**: Contains example scripts showing how to use the package

## Real-World Example: Weather Data Analyzer

Let's put everything together in a more practical example—a weather data analyzer project:

### Project Structure

```
weather_analyzer/
│
├── README.md
├── setup.py
├── requirements.txt
│
├── weather_analyzer/
│   ├── __init__.py
│   ├── config.py
│   ├── data/
│   │   ├── __init__.py
│   │   ├── loader.py
│   │   └── cleaner.py
│   ├── analysis/
│   │   ├── __init__.py
│   │   ├── temperature.py
│   │   └── precipitation.py
│   └── visualization/
│       ├── __init__.py
│       ├── plots.py
│       └── maps.py
│
└── examples/
    └── analyze_city_data.py
```

### Implementation

1. `weather_analyzer/__init__.py`:

```python
"""Weather data analysis package."""

from .data.loader import load_csv, load_json
from .analysis.temperature import average_temp
from .visualization.plots import plot_temperature_trend

__all__ = ['load_csv', 'load_json', 'average_temp', 'plot_temperature_trend']
```

2. `weather_analyzer/config.py`:

```python
"""Configuration settings for the weather analyzer."""

# API keys and configuration
WEATHER_API_KEY = "your_api_key_here"
DEFAULT_CITY = "New York"

# Data settings
DATA_DIR = "data/weather"
CACHE_EXPIRY = 3600  # seconds

# Visualization settings
DEFAULT_PLOT_SIZE = (10, 6)
TEMPERATURE_COLORS = {
    "cold": "#0000FF",  # Blue
    "mild": "#00FF00",  # Green
    "hot": "#FF0000"    # Red
}
```

3. `weather_analyzer/data/loader.py`:

```python
"""Module for loading weather data from various sources."""
import csv
import json
from pathlib import Path
import requests

from ..config import WEATHER_API_KEY

def load_csv(filepath):
    """
    Load weather data from a CSV file.
    
    Args:
        filepath (str): Path to the CSV file
        
    Returns:
        list: List of dictionaries containing weather data
    """
    data = []
    with open(filepath, 'r', newline='') as file:
        reader = csv.DictReader(file)
        for row in reader:
            data.append(row)
    return data

def load_json(filepath):
    """Load weather data from a JSON file."""
    with open(filepath, 'r') as file:
        return json.load(file)
        
def fetch_weather_data(city):
    """Fetch current weather data for a city from an external API."""
    url = f"https://api.weatherapi.com/v1/current.json?key={WEATHER_API_KEY}&q={city}"
    response = requests.get(url)
    response.raise_for_status()
    return response.json()
```

4. `weather_analyzer/analysis/temperature.py`:

```python
"""Temperature analysis functions."""

def celsius_to_fahrenheit(celsius):
    """Convert Celsius to Fahrenheit."""
    return (celsius * 9/5) + 32

def fahrenheit_to_celsius(fahrenheit):
    """Convert Fahrenheit to Celsius."""
    return (fahrenheit - 32) * 5/9

def average_temp(data, temp_field="temperature", period=None):
    """
    Calculate average temperature from weather data.
    
    Args:
        data (list): List of weather data points
        temp_field (str): Name of the temperature field
        period (str, optional): Time period to filter (e.g., 'day', 'week')
        
    Returns:
        float: Average temperature
    """
    if not data:
        return None
        
    if period:
        # Filter data by period (simplified example)
        filtered_data = [item for item in data if item.get('period') == period]
    else:
        filtered_data = data
        
    if not filtered_data:
        return None
        
    total = sum(float(item[temp_field]) for item in filtered_data if temp_field in item)
    return total / len(filtered_data)
```

5. `weather_analyzer/visualization/plots.py`:

```python
"""Functions for creating weather data visualizations."""
import matplotlib.pyplot as plt
from ..config import DEFAULT_PLOT_SIZE, TEMPERATURE_COLORS

def plot_temperature_trend(data, date_field="date", temp_field="temperature", 
                           title="Temperature Trend", save_path=None):
    """
    Plot temperature trends over time.
    
    Args:
        data (list): List of weather data points
        date_field (str): Name of the date field
        temp_field (str): Name of the temperature field
        title (str): Title for the plot
        save_path (str, optional): Path to save the plot image
        
    Returns:
        matplotlib.figure.Figure: The created figure object
    """
    dates = [item[date_field] for item in data if date_field in item]
    temps = [float(item[temp_field]) for item in data if temp_field in item]
    
    plt.figure(figsize=DEFAULT_PLOT_SIZE)
    plt.plot(dates, temps, marker='o', linestyle='-')
    
    # Color regions based on temperature
    plt.fill_between(dates, temps, alpha=0.2, 
                     color=[TEMPERATURE_COLORS["cold"] if t < 10 else 
                            TEMPERATURE_COLORS["hot"] if t > 25 else 
                            TEMPERATURE_COLORS["mild"] for t in temps])
    
    plt.title(title)
    plt.xlabel("Date")
    plt.ylabel("Temperature (°C)")
    plt.grid(True, linestyle='--', alpha=0.7)
    
    if save_path:
        plt.savefig(save_path)
        
    return plt.gcf()
```

6. `examples/analyze_city_data.py`:

```python
#!/usr/bin/env python3
"""Example script demonstrating the use of the weather_analyzer package."""

import sys
import os

# Add parent directory to path to import the package
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from weather_analyzer import load_csv, average_temp, plot_temperature_trend

def main():
    """Main function to demonstrate weather analyzer functionality."""
    # Sample data path (replace with your data path)
    data_path = "examples/sample_weather_data.csv"
    
    try:
        # Load weather data
        print("Loading weather data...")
        weather_data = load_csv(data_path)
        
        # Calculate average temperature
        avg_temp = average_temp(weather_data, temp_field="temp_c")
        print(f"Average temperature: {avg_temp:.1f}°C")
        
        # Create and show temperature trend plot
        print("Creating temperature trend plot...")
        plot_temperature_trend(
            weather_data, 
            date_field="date",
            temp_field="temp_c", 
            title="Weekly Temperature Trend",
            save_path="temperature_trend.png"
        )
        print("Plot saved as 'temperature_trend.png'")
        
        return 0
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())
```

## Best Practices Summary

Here's a summary of Python code organization best practices:

1. **Follow a consistent structure**:
   - Organize imports (standard library, third-party, local)
   - Put constants at the top level
   - Define classes and functions in a logical order

2. **Use proper naming conventions**:
   - `snake_case` for variables and functions
   - `PascalCase` for classes
   - `UPPER_CASE` for constants

3. **Modularize your code**:
   - Break large files into modules
   - Group related modules into packages
   - Use relative imports within packages

4. **Implement proper separation of concerns**:
   - Each module should have a single responsibility
   - Avoid circular dependencies
   - Keep functions focused on a single task

5. **Document your code**:
   - Add docstrings to modules, classes, and functions
   - Comment complex logic
   - Include examples where appropriate

6. **Use `if __name__ == "__main__"` guard** in executable scripts

7. **Consider configuration management**:
   - Keep configuration separate from code
   - Use environment variables or config files for settings

8. **Follow project structure conventions** for larger applications

## Exercises

To practice code organization in Python, try these exercises:

1. **Module Refactoring**: Take an existing script that's over 200 lines and refactor it into modules with proper organization.

2. **Package Creation**: Create a package with at least three modules that work together to perform a specific task (e.g., a data processing pipeline).

3. **Import Optimization**: Analyze a Python project and improve its import structure by fixing circular dependencies and organizing imports.

4. **Documentation Addition**: Add proper docstrings and comments to an existing project following Python documentation standards.

5. **Project Structure**: Create a complete project structure for a web scraping tool, including appropriate modules, packages, and configuration management.

## Additional Resources

- [Python Modules and Packages Documentation](https://docs.python.org/3/tutorial/modules.html)
- [PEP 8 - Style Guide for Python Code](https://pep8.org/)
- [Real Python - Python Application Layouts](https://realpython.com/python-application-layouts/)
- [The Hitchhiker's Guide to Python - Project Structure](https://docs.python-guide.org/writing/structure/)
- [Python Anti-Patterns](https://docs.quantifiedcode.com/python-anti-patterns/)

By following these principles and practices for code organization, you'll create more maintainable, readable, and scalable Python applications. Remember that good organization becomes increasingly important as your projects grow in complexity.