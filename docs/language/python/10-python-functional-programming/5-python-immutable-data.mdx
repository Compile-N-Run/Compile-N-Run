---
title: "Python Immutable Data"
description: "Learn about immutable data types in Python and how they form the foundation of functional programming approaches."

---

# Python Immutable Data

## Introduction

Immutability is a core concept in functional programming and plays a significant role in Python. An immutable object is one whose state cannot be modified after it's created. This concept might seem limiting at first, but it offers numerous benefits like predictability, thread safety, and easier debugging.

In this tutorial, we'll explore Python's immutable data types, understand why immutability matters in functional programming, and learn how to work effectively with immutable data structures.

## Understanding Immutability in Python

In Python, some data types are immutable by design, meaning once they're created, their values cannot be changed. When you "modify" these objects, you're actually creating new objects.

### Common Immutable Data Types in Python

Python provides several built-in immutable data types:

- **Numbers** (integers, floats, complex numbers)
- **Strings**
- **Tuples**
- **Frozen sets**
- **Booleans**

Let's explore each with examples.

## Strings: Immutable Sequences of Characters

Strings in Python are immutable sequences of Unicode characters. Once a string is created, you cannot change its contents.

```python
# Creating a string
greeting = "Hello"

# Attempting to modify the string
try:
    greeting[0] = "J"
except TypeError as e:
    print(f"Error: {e}")

# Instead, create a new string
new_greeting = "J" + greeting[1:]
print(new_greeting)
```

Output:
```
Error: 'str' object does not support item assignment
Jello
```

When you need to "modify" a string, you're actually creating a new string object. This is important to understand for both performance considerations and understanding how strings behave in memory.

## Tuples: Immutable Collections

Tuples are similar to lists but immutable. Once a tuple is created, you cannot add, remove, or modify its elements.

```python
# Creating a tuple
point = (10, 20, 30)

# Attempting to modify the tuple
try:
    point[0] = 15
except TypeError as e:
    print(f"Error: {e}")

# Creating a new tuple instead
new_point = (15,) + point[1:]
print(new_point)
```

Output:
```
Error: 'tuple' object does not support item assignment
(15, 20, 30)
```

### Important Note on Tuple Immutability

While tuples themselves are immutable, if they contain mutable objects (like lists), those objects can still be modified:

```python
# Tuple containing a list
data = (1, 2, [3, 4])

# This will work - we're not changing the tuple, just the list it references
data[2].append(5)
print(data)  # (1, 2, [3, 4, 5])

# But this won't work
try:
    data[2] = [6, 7]
except TypeError as e:
    print(f"Error: {e}")
```

Output:
```
(1, 2, [3, 4, 5])
Error: 'tuple' object does not support item assignment
```

## Numbers and Booleans

Integers, floats, complex numbers, and booleans are all immutable. When you "change" their value, you're actually creating a new object and rebinding the variable name to this new object.

```python
# Numbers are immutable
x = 5
print(f"Original x: {x}, id(x): {id(x)}")

# This creates a new object
x = x + 1
print(f"After x += 1: {x}, id(x): {id(x)}")  # Different id
```

Output:
```
Original x: 5, id(x): 140721187045608
After x += 1: 6, id(x): 140721187045640
```

## Frozen Sets

A `frozenset` is an immutable version of the set data type:

```python
# Creating a frozen set
immutable_set = frozenset([1, 2, 3, 4])
print(immutable_set)

# Attempting to modify it
try:
    immutable_set.add(5)
except AttributeError as e:
    print(f"Error: {e}")
```

Output:
```
frozenset({1, 2, 3, 4})
Error: 'frozenset' object has no attribute 'add'
```

## Benefits of Immutability in Functional Programming

Immutability brings several advantages, especially in a functional programming context:

1. **Predictability**: Immutable objects can't change, eliminating a whole class of bugs related to state changes.
  
2. **Thread Safety**: Since immutable objects can't be modified, they're inherently thread-safe without needing locks or synchronization.

3. **Simpler Debugging**: When data can't change, it's easier to track the flow of values through your program.

4. **Optimization Opportunities**: The compiler/interpreter can make certain optimizations with immutable objects.

5. **Hashability**: Immutable objects can be used as dictionary keys or in sets because their hash value won't change.

## Working with Immutable Data

### Creating Modified Versions of Immutable Data

Since you can't modify immutable objects directly, you need to create new objects:

```python
# Working with tuples
original = (1, 2, 3, 4, 5)
# Creating a new tuple with one value changed
modified = original[:2] + (10,) + original[3:]
print(f"Original: {original}")
print(f"Modified: {modified}")
```

Output:
```
Original: (1, 2, 3, 4, 5)
Modified: (1, 2, 10, 4, 5)
```

### Immutable Data in Functions

Immutability is particularly useful in functions as it helps prevent unintended side effects:

```python
def add_score(scores, player, points):
    """Add points to a player's score, returning a new tuple."""
    # Create a copy with the modification
    return scores + ((player, points),)

# Starting with an empty tuple of scores
game_scores = ()

# Adding scores for different players
game_scores = add_score(game_scores, "Alice", 100)
game_scores = add_score(game_scores, "Bob", 85)
game_scores = add_score(game_scores, "Charlie", 93)

print(game_scores)
```

Output:
```
(('Alice', 100), ('Bob', 85), ('Charlie', 93))
```

## Practical Example: Functional Data Processing with Immutable Data

Let's create a more practical example of using immutable data in a functional style. We'll simulate a basic order processing system:

```python
def add_item(order, item, price, quantity=1):
    """Add an item to an order, returning a new order tuple."""
    return order + ((item, price, quantity),)

def calculate_total(order):
    """Calculate the total price of an order."""
    return sum(price * quantity for _, price, quantity in order)

def apply_discount(order, discount_percentage):
    """Apply a discount to all items, returning a new order."""
    discount_factor = 1 - (discount_percentage / 100)
    return tuple((item, price * discount_factor, quantity) for item, price, quantity in order)

def format_order(order):
    """Format an order as a readable string."""
    lines = [f"{'Item':<15} {'Price':>8} {'Qty':>5} {'Total':>10}"]
    lines.append("-" * 40)
    
    for item, price, quantity in order:
        lines.append(f"{item:<15} ${price:>7.2f} {quantity:>5} ${price*quantity:>9.2f}")
    
    lines.append("-" * 40)
    lines.append(f"{'Total':<15} ${calculate_total(order):>23.2f}")
    
    return "\n".join(lines)

# Create and process an order
my_order = ()
my_order = add_item(my_order, "Laptop", 1200.00)
my_order = add_item(my_order, "Mouse", 25.50)
my_order = add_item(my_order, "Keyboard", 45.00)
my_order = add_item(my_order, "Monitor", 175.00, 2)

# Apply a 10% discount
discounted_order = apply_discount(my_order, 10)

# Display the final order
print(format_order(discounted_order))
```

Output:
```
Item             Price    Qty      Total
----------------------------------------
Laptop         $1080.00     1   $1080.00
Mouse           $22.95     1     $22.95
Keyboard        $40.50     1     $40.50
Monitor        $157.50     2    $315.00
----------------------------------------
Total                            $1458.45
```

In this example, all operations on the order produce new tuples rather than modifying the existing ones. This demonstrates how functional programming with immutable data can lead to clean, maintainable code.

## When to Use Mutable vs. Immutable Data

While immutability has many benefits, there are times when mutable data structures make more sense:

1. **Performance**: Creating new copies of large data structures can be inefficient.
2. **Memory usage**: Constantly creating new objects can increase memory usage.
3. **Algorithm requirements**: Some algorithms naturally require mutation.

Choose the right tool for the job, but lean toward immutability in functional programming.

## Advanced Immutability: Third-Party Libraries

For more complex immutable data structures, consider these libraries:

1. **Pyrsistent**: Provides efficient immutable data structures like PVector, PMap, etc.
2. **Immutables**: Another library with persistent, immutable data structures.
3. **Types.MappingProxyType**: For creating a read-only view of a dictionary.

```python
from types import MappingProxyType

# Create a regular dictionary
original_dict = {'a': 1, 'b': 2}

# Create an immutable view
immutable_dict = MappingProxyType(original_dict)

# This works - accessing data
print(immutable_dict['a'])  # 1

# This fails - modifying data
try:
    immutable_dict['c'] = 3
except TypeError as e:
    print(f"Error: {e}")

# The original dict can still be modified
original_dict['c'] = 3
# And changes are visible through the proxy
print(immutable_dict['c'])  # 3
```

Output:
```
1
Error: 'mappingproxy' object does not support item assignment
3
```

## Summary

Immutable data structures form the foundation of functional programming in Python. They offer benefits like predictability, thread safety, and simpler debugging at the cost of potentially increased memory usage and some performance overhead.

Python provides several built-in immutable types (strings, tuples, frozensets, numbers, booleans), and third-party libraries expand these options for more complex use cases.

By embracing immutability in your code, you can write more reliable, easier-to-reason-about programs that align with functional programming principles.

## Exercises

1. Create a function that takes a tuple of numbers and returns a new tuple with each number doubled.

2. Implement a string processing function that replaces all vowels in a string with asterisks without using any mutable data structures.

3. Design a simple address book system using immutable data structures (tuples and frozensets) that allows adding, searching, and displaying contacts.

4. Create a function that takes a tuple representing a point in 3D space and rotates it around the x-axis by a given angle, returning a new tuple.

5. Implement a shopping cart using immutable data structures that supports adding items, removing items, and calculating the total.

## Additional Resources

- [Python Documentation on Data Structures](https://docs.python.org/3/tutorial/datastructures.html)
- [Pyrsistent Library Documentation](https://pyrsistent.readthedocs.io/)
- [Functional Programming HOWTO](https://docs.python.org/3/howto/functional.html) in Python's documentation
- [Real Python's Guide to Immutability](https://realpython.com/python-immutable-types/)