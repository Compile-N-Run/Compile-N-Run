---
title: Python Abstract Classes
description: Learn how to use abstract classes in Python to create templates for other classes and enforce a common interface across subclasses.

---

# Python Abstract Classes

## Introduction

In object-oriented programming, abstract classes serve as templates or blueprints for other classes. Unlike regular classes, abstract classes cannot be instantiated directly—instead, they're meant to be subclassed by other classes that provide implementations for the abstract methods defined in the parent class.

Abstract classes are particularly useful when you want to:

- Define a common interface that derived classes must implement
- Provide some base functionality while requiring subclasses to implement specific behaviors
- Ensure consistency across related classes

In Python, abstract classes are not built into the core language as they are in languages like Java or C#. Instead, Python provides the `abc` (Abstract Base Classes) module that allows us to create abstract classes and abstract methods.

## Understanding Abstract Classes

### What is an Abstract Class?

An abstract class is a class that contains one or more abstract methods. An abstract method is a method declared in the abstract class but without implementation (it has no body). Subclasses that inherit from an abstract class must provide implementations for all of its abstract methods, or they will also be abstract.

### The `abc` Module

Python's `abc` module provides the infrastructure for defining abstract base classes. The two main components we'll use are:

- `ABC`: A class that serves as a base for abstract classes
- `abstractmethod`: A decorator that marks methods as abstract

## Creating Abstract Classes in Python

Let's start with a simple example to demonstrate how to create an abstract class:

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass
        
    @abstractmethod
    def perimeter(self):
        pass
    
    def description(self):
        return "This is a geometric shape."
```

In this example:
- `Shape` is an abstract class that inherits from `ABC`
- `area()` and `perimeter()` are abstract methods that subclasses must implement
- `description()` is a regular method that provides default implementation

## Implementing Abstract Classes

When we create subclasses of an abstract class, we must implement all the abstract methods:

```python
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)
    
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14 * self.radius
```

Now let's see what happens when we try to use these classes:

```python
# Creating instances of concrete classes
rect = Rectangle(5, 4)
circle = Circle(7)

# This works fine
print(f"Rectangle area: {rect.area()}")  # Output: Rectangle area: 20
print(f"Circle perimeter: {circle.perimeter()}")  # Output: Circle perimeter: 43.96

# Trying to instantiate the abstract class
try:
    shape = Shape()  # This will raise TypeError
except TypeError as e:
    print(f"Error: {e}")  # Output: Error: Can't instantiate abstract class Shape with abstract methods area, perimeter
```

## Real-World Example: File Handlers

Let's look at a more practical example where abstract classes are useful. Imagine we're building a file processing system that needs to handle different file types:

```python
from abc import ABC, abstractmethod

class FileHandler(ABC):
    @abstractmethod
    def open(self, filename):
        pass
    
    @abstractmethod
    def process(self, data):
        pass
    
    @abstractmethod
    def save(self, filename, processed_data):
        pass
    
    def handle_file(self, input_file, output_file):
        """Template method that defines the algorithm"""
        data = self.open(input_file)
        processed_data = self.process(data)
        self.save(output_file, processed_data)
        print(f"File processed: {input_file} → {output_file}")


class CSVHandler(FileHandler):
    def open(self, filename):
        print(f"Opening CSV file: {filename}")
        return f"data from {filename}"  # Simplified for demonstration
    
    def process(self, data):
        print("Processing CSV data...")
        return f"processed {data}"  # Simplified for demonstration
    
    def save(self, filename, processed_data):
        print(f"Saving processed data to CSV file: {filename}")
        # Actual saving would happen here
```

In this example, the `FileHandler` class defines a common interface and a template method (`handle_file()`) that orchestrates the workflow. The `CSVHandler` class implements the required methods to handle CSV files specifically.

Let's see it in action:

```python
# Create a CSV handler and process a file
csv_handler = CSVHandler()
csv_handler.handle_file("input.csv", "output.csv")
```

Output:
```
Opening CSV file: input.csv
Processing CSV data...
Saving processed data to CSV file: output.csv
File processed: input.csv → output.csv
```

## Abstract Properties

In addition to abstract methods, Python also allows you to define abstract properties:

```python
from abc import ABC, abstractmethod

class Vehicle(ABC):
    @property
    @abstractmethod
    def max_speed(self):
        pass
    
    @abstractmethod
    def start_engine(self):
        pass


class Car(Vehicle):
    @property
    def max_speed(self):
        return 180
    
    def start_engine(self):
        return "Car engine started"


car = Car()
print(f"Max speed: {car.max_speed} km/h")  # Output: Max speed: 180 km/h
print(car.start_engine())  # Output: Car engine started
```

## Abstract Classes vs. Interfaces

In many object-oriented languages, there's a distinction between abstract classes and interfaces. Python doesn't have formal interfaces, but abstract classes with only abstract methods can serve the same purpose:

```python
from abc import ABC, abstractmethod

# This is like an interface - only abstract methods
class Drawable(ABC):
    @abstractmethod
    def draw(self):
        pass
    
    @abstractmethod
    def resize(self, width, height):
        pass


# This is a more traditional abstract class with some implementation
class UIElement(ABC):
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y
    
    def move(self, new_x, new_y):
        self.x = new_x
        self.y = new_y
        print(f"Element moved to ({self.x}, {self.y})")
    
    @abstractmethod
    def render(self):
        pass


# A class implementing the "interface"
class Button(UIElement, Drawable):
    def __init__(self, x=0, y=0, label=""):
        super().__init__(x, y)
        self.label = label
    
    def draw(self):
        print(f"Drawing button with label '{self.label}'")
    
    def resize(self, width, height):
        print(f"Resizing button to {width}x{height}")
    
    def render(self):
        print(f"Rendering button at ({self.x}, {self.y})")
```

## Best Practices for Using Abstract Classes

1. **Use abstract classes to define common interfaces**: Abstract classes are excellent for establishing a common API that all subclasses must adhere to.

2. **Provide default implementations when applicable**: Abstract classes can include concrete methods that provide default behavior, reducing code duplication in subclasses.

3. **Don't over-abstract**: Only make methods abstract when they truly need to be implemented differently by each subclass.

4. **Consider using mixins with abstract classes**: For more complex hierarchies, combine abstract classes with mixin classes to achieve better code organization.

5. **Document expected behavior**: Since abstract methods only define the signature, add docstrings that explain the expected behavior for implementers.

## Common Pitfalls

1. **Forgetting to implement all abstract methods**: If you don't implement all abstract methods in a subclass, that subclass will remain abstract and can't be instantiated.

2. **Method signature mismatches**: Make sure your implementations in subclasses maintain the same method signatures as defined in the abstract class.

3. **Circular dependencies**: Be careful not to create circular dependencies between abstract classes.

## Summary

Abstract classes in Python provide a powerful way to define interfaces and partially implemented classes. They help enforce a common structure across related classes while allowing for customized implementations. Through the `abc` module, Python offers a flexible approach to abstract classes that fits well with the language's dynamic nature.

Key points to remember:
- Use `ABC` from the `abc` module as the parent class for abstract classes
- Mark abstract methods with the `@abstractmethod` decorator
- All abstract methods must be implemented by non-abstract subclasses
- Abstract classes can include both abstract and concrete methods
- Abstract classes cannot be instantiated directly

## Exercises

1. Create an abstract class `Animal` with abstract methods `make_sound()` and `move()`. Then implement concrete subclasses for at least three different animals.

2. Design an abstract class for a database connection that includes methods like `connect()`, `disconnect()`, `execute_query()`, and `fetch_data()`. Implement concrete subclasses for SQLite and MySQL.

3. Extend the `Shape` example from this tutorial to include additional shapes like Triangle and Square. Add a new abstract method `draw()` that simulates drawing the shape.

## Additional Resources

- [Python Official Documentation on ABC](https://docs.python.org/3/library/abc.html)
- [PEP 3119 – Introducing Abstract Base Classes](https://peps.python.org/pep-3119/)
- Book: "Python in a Nutshell" by Alex Martelli (covers ABC in depth)
- Book: "Fluent Python" by Luciano Ramalho (excellent coverage of Python's OOP features)