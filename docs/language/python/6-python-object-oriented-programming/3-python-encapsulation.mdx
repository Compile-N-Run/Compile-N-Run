---
title: Python Encapsulation
description: Learn about encapsulation in Python, a fundamental concept of object-oriented programming that restricts direct access to data and methods.

---

# Python Encapsulation

## Introduction

Encapsulation is one of the four fundamental concepts of Object-Oriented Programming (OOP), along with inheritance, polymorphism, and abstraction. In simple terms, encapsulation is the practice of bundling data (attributes) and methods that operate on that data into a single unit (class), and restricting direct access to some of the object's components.

In Python, encapsulation helps to:

1. **Hide implementation details** from the outside world
2. **Prevent accidental modification** of important data
3. **Control access** to class attributes and methods
4. **Make code more maintainable** by clearly defining interfaces

Let's dive into how encapsulation works in Python and why it's so valuable for writing robust code.

## Access Modifiers in Python

Unlike languages such as Java or C++, Python doesn't have strict access modifiers like `public`, `private`, or `protected`. Instead, Python follows a convention-based approach to encapsulation:

1. **Public** (default): Accessible from anywhere
2. **Protected** (prefixed with `_`): Should not be accessed directly, but technically can be
3. **Private** (prefixed with `__`): Name-mangled to avoid accidental access

Let's see how these work with examples:

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner          # Public attribute
        self._balance = balance     # Protected attribute
        self.__account_number = "12345"  # Private attribute
    
    def deposit(self, amount):
        self._balance += amount
        return self._balance
    
    def withdraw(self, amount):
        if amount <= self._balance:
            self._balance -= amount
            return True
        return False
    
    def get_balance(self):
        return self._balance
```

In this example:
- `owner` is a public attribute, accessible from anywhere
- `_balance` is protected (by convention), suggesting it shouldn't be accessed directly
- `__account_number` is private, making it harder to access from outside the class

Let's see how we can interact with this class:

```python
# Creating a bank account
account = BankAccount("Alice", 1000)

# Accessing attributes
print(account.owner)  # Output: Alice
print(account._balance)  # Output: 1000 (works, but not recommended)

# This will cause an AttributeError
try:
    print(account.__account_number)
except AttributeError as e:
    print(f"Error: {e}")  # Output: Error: 'BankAccount' object has no attribute '__account_number'

# The private attribute is name-mangled
print(account._BankAccount__account_number)  # Output: 12345 (works, but strongly discouraged)

# Using methods to interact with the object
account.deposit(500)
print(account.get_balance())  # Output: 1500
```

## Getters and Setters in Python

To properly encapsulate attributes while still allowing controlled access, we can use getters and setters. In Python, we have several approaches to implement them:

### 1. Using Methods

The simplest approach is to create specific methods to get and set values:

```python
class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age
    
    # Getter methods
    def get_name(self):
        return self.__name
    
    def get_age(self):
        return self.__age
    
    # Setter methods
    def set_name(self, name):
        self.__name = name
    
    def set_age(self, age):
        if age > 0:  # Data validation
            self.__age = age
        else:
            print("Age cannot be negative!")

# Using getters and setters
person = Person("John", 25)
print(person.get_name())  # Output: John

person.set_age(-5)  # Output: Age cannot be negative!
person.set_age(26)
print(person.get_age())  # Output: 26
```

### 2. Using Properties

Python provides a more elegant way to implement getters and setters using the `@property` decorator:

```python
class Employee:
    def __init__(self, name, salary):
        self.__name = name
        self.__salary = salary
    
    @property
    def name(self):
        return self.__name
    
    @name.setter
    def name(self, name):
        self.__name = name
    
    @property
    def salary(self):
        return self.__salary
    
    @salary.setter
    def salary(self, salary):
        if salary > 0:
            self.__salary = salary
        else:
            print("Salary cannot be negative!")

# Using properties
employee = Employee("Alice", 50000)
print(employee.name)  # Output: Alice

employee.salary = 55000  # Using the setter
print(employee.salary)  # Output: 55000

employee.salary = -1000  # Output: Salary cannot be negative!
```

Using properties allows you to access attributes with simple dot notation while still maintaining encapsulation.

## Real-World Example: Product Inventory System

Let's see a more comprehensive example that demonstrates encapsulation in a practical scenario:

```python
class Product:
    def __init__(self, name, price, stock):
        self.__name = name
        self.__price = price
        self.__stock = stock
        self.__discount = 0
    
    @property
    def name(self):
        return self.__name
    
    @property
    def price(self):
        # Apply discount if available
        return self.__price * (1 - self.__discount)
    
    @price.setter
    def price(self, price):
        if price > 0:
            self.__price = price
        else:
            raise ValueError("Price must be positive")
    
    @property
    def stock(self):
        return self.__stock
    
    def set_discount(self, discount_percent):
        if 0 <= discount_percent <= 100:
            self.__discount = discount_percent / 100
        else:
            raise ValueError("Discount must be between 0 and 100")
    
    def add_stock(self, quantity):
        if quantity > 0:
            self.__stock += quantity
            return True
        return False
    
    def sell(self, quantity):
        if quantity <= self.__stock and quantity > 0:
            self.__stock -= quantity
            return quantity * self.price  # Return the sale amount
        else:
            raise ValueError("Invalid sell quantity")


class Inventory:
    def __init__(self):
        self.__products = {}
    
    def add_product(self, product_id, product):
        if isinstance(product, Product):
            self.__products[product_id] = product
            return True
        return False
    
    def get_product(self, product_id):
        return self.__products.get(product_id)
    
    def list_products(self):
        return [(pid, p.name, p.price, p.stock) for pid, p in self.__products.items()]


# Using the inventory system
laptop = Product("Gaming Laptop", 1200, 10)
phone = Product("Smartphone", 800, 20)

# Create inventory and add products
inventory = Inventory()
inventory.add_product("LP001", laptop)
inventory.add_product("PH001", phone)

# Apply discount to laptop
laptop.set_discount(15)  # 15% discount

# Sell products
try:
    sale_amount = laptop.sell(2)
    print(f"Sold 2 laptops for ${sale_amount}")  # Output: Sold 2 laptops for $2040.0
except ValueError as e:
    print(f"Sale error: {e}")

# Check updated stock
print(f"Remaining laptop stock: {laptop.stock}")  # Output: Remaining laptop stock: 8

# List all products
print("Current Inventory:")
for pid, name, price, stock in inventory.list_products():
    print(f"{pid}: {name} - ${price:.2f} ({stock} in stock)")

# Output:
# Current Inventory:
# LP001: Gaming Laptop - $1020.00 (8 in stock)
# PH001: Smartphone - $800.00 (20 in stock)
```

In this example:

1. We encapsulate product details (name, price, stock, discount) using private attributes
2. We provide controlled access using properties and methods
3. The inventory system interacts with products through their public interface
4. Data validation is performed in setters and methods
5. The internal implementation details are hidden from users of the classes

## Benefits of Encapsulation

1. **Data Hiding**: Sensitive data is protected from accidental modification
2. **Flexibility**: You can change the internal implementation without affecting the code that uses the class
3. **Control**: You can add validation and business rules when setting values
4. **Maintainability**: Cleaner code that's easier to understand and maintain
5. **Reduces complexity**: Users of the class only need to know the public interface, not the internal details

## Common Encapsulation Patterns in Python

### 1. Encapsulating with Properties

```python
class Circle:
    def __init__(self, radius):
        self.__radius = radius
    
    @property
    def radius(self):
        return self.__radius
    
    @radius.setter
    def radius(self, value):
        if value > 0:
            self.__radius = value
        else:
            raise ValueError("Radius must be positive")
    
    @property
    def area(self):
        import math
        return math.pi * self.__radius ** 2
    
    @property
    def circumference(self):
        import math
        return 2 * math.pi * self.__radius

# Usage
circle = Circle(5)
print(f"Area: {circle.area:.2f}")  # Output: Area: 78.54
circle.radius = 7
print(f"New circumference: {circle.circumference:.2f}")  # Output: New circumference: 43.98
```

### 2. Property Factory Pattern

For classes with many similar properties:

```python
def make_property(name):
    private_name = f"__{name}"
    
    def getter(self):
        return getattr(self, private_name)
    
    def setter(self, value):
        setattr(self, private_name, value)
    
    return property(getter, setter)

class User:
    name = make_property("name")
    email = make_property("email")
    
    def __init__(self, name, email):
        self.__name = name
        self.__email = email

# Usage
user = User("Bob", "bob@example.com")
print(user.name)  # Output: Bob
user.email = "bob.smith@example.com"
print(user.email)  # Output: bob.smith@example.com
```

### 3. Encapsulating Collections

When dealing with list or dict attributes:

```python
class Team:
    def __init__(self, name):
        self.__name = name
        self.__members = []
    
    @property
    def name(self):
        return self.__name
    
    @property
    def members(self):
        # Return a copy to prevent direct modification of the internal list
        return self.__members.copy()
    
    def add_member(self, member):
        if member not in self.__members:
            self.__members.append(member)
    
    def remove_member(self, member):
        if member in self.__members:
            self.__members.remove(member)

# Usage
team = Team("Developers")
team.add_member("Alice")
team.add_member("Bob")

print(team.members)  # Output: ['Alice', 'Bob']

# Since we return a copy, this doesn't affect the internal list
members = team.members
members.append("Charlie")
print(team.members)  # Output: ['Alice', 'Bob'] (unchanged)
```

## Summary

Encapsulation in Python is a powerful concept that helps you create more robust, maintainable, and secure code. While Python doesn't enforce strict access control like some other languages, it provides conventions and features like name mangling and properties to implement effective encapsulation.

Key points to remember:

1. Use single underscore (`_attribute`) for protected attributes (convention)
2. Use double underscore (`__attribute`) for private attributes (name mangling)
3. Implement getters and setters using methods or properties
4. Use properties (`@property`) for a more Pythonic approach to encapsulation
5. Always validate data in setters to maintain object consistency
6. Return copies of mutable attributes to prevent unintended modifications

By mastering encapsulation, you'll create Python classes that are more robust, easier to maintain, and less prone to bugs and unexpected behavior.

## Exercises

1. Create a `BankAccount` class with private attributes for balance and account number. Implement methods for deposit, withdrawal, and checking the balance.

2. Modify the `Product` class from our example to include a method to calculate the total value (price × stock) and ensure that the discount can only be between 0% and 50%.

3. Create a `Temperature` class that stores a temperature value in Celsius but provides properties to get and set the value in both Celsius and Fahrenheit.

4. Design a `Library` class that manages a collection of books. Implement proper encapsulation to ensure books can only be added or removed through appropriate methods.

## Additional Resources

- [Python Official Documentation on Properties](https://docs.python.org/3/library/functions.html#property)
- [Python Data Model](https://docs.python.org/3/reference/datamodel.html)
- [Real Python - OOP in Python](https://realpython.com/python3-object-oriented-programming/)
- [Python Cookbook, 3rd Edition](https://www.oreilly.com/library/view/python-cookbook-3rd/9781449357337/) - Chapter 8 on Classes and Objects