---
title: "Python Multiple Inheritance"
description: "Learn how to use multiple inheritance in Python to inherit attributes and methods from multiple parent classes, including method resolution order and practical applications."

---

# Python Multiple Inheritance

## Introduction

Multiple inheritance is a powerful feature in Python's object-oriented programming model that allows a class to inherit attributes and methods from more than one parent class. Unlike some other programming languages that restrict classes to inherit from only a single parent (single inheritance), Python embraces multiple inheritance as part of its philosophy of providing programmers with multiple ways to solve problems.

In this tutorial, you'll learn:
- What multiple inheritance is and how it works in Python
- How to implement classes using multiple inheritance
- How Python resolves method calls using the Method Resolution Order (MRO)
- Best practices and potential pitfalls
- Real-world applications of multiple inheritance

## Understanding Multiple Inheritance

In single inheritance, a class derives from one parent class, creating a linear relationship. Multiple inheritance extends this concept by allowing a class to inherit from two or more parent classes simultaneously.

### Basic Syntax

```python
class ParentClass1:
    # Parent class 1 attributes and methods
    pass

class ParentClass2:
    # Parent class 2 attributes and methods
    pass

class ChildClass(ParentClass1, ParentClass2):
    # Child class inherits from both parent classes
    pass
```

The child class gains access to attributes and methods from all parent classes, which can be very useful for code reuse and creating flexible class hierarchies.

## Basic Example of Multiple Inheritance

Let's start with a simple example to demonstrate how multiple inheritance works:

```python
class Animal:
    def __init__(self, name):
        self.name = name
    
    def eat(self):
        return f"{self.name} is eating"

class Flyable:
    def fly(self):
        return f"{self.name} is flying"

class Bird(Animal, Flyable):
    def __init__(self, name):
        super().__init__(name)
    
    def chirp(self):
        return f"{self.name} is chirping"

# Create an instance of Bird
sparrow = Bird("Sparrow")
print(sparrow.eat())    # Inherited from Animal
print(sparrow.fly())    # Inherited from Flyable
print(sparrow.chirp())  # Bird's own method
```

**Output:**
```
Sparrow is eating
Sparrow is flying
Sparrow is chirping
```

In this example:
- `Bird` inherits from both `Animal` and `Flyable`
- It gets the `eat()` method from `Animal` and the `fly()` method from `Flyable`
- `Bird` also has its own method `chirp()`

## Method Resolution Order (MRO)

When a class inherits from multiple parents, and if the same method name exists in more than one parent class, Python needs a way to determine which method to call. This is where Method Resolution Order (MRO) comes in.

### Understanding MRO

The MRO is the order in which Python looks for methods in a class hierarchy. Python uses the C3 Linearization algorithm to determine this order, which ensures that:

1. A class always appears before its parents
2. If there are multiple parents, they're checked in the order specified in the class definition

You can check the MRO of a class using the `__mro__` attribute or the `mro()` method:

```python
class A:
    def method(self):
        return "Method from A"

class B:
    def method(self):
        return "Method from B"

class C(A, B):
    pass

class D(B, A):
    pass

print(C.__mro__)
print(D.__mro__)

# Let's see which method gets called
c = C()
d = D()
print(c.method())
print(d.method())
```

**Output:**
```
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
Method from A
Method from B
```

The output shows that for class `C`, the method from class `A` is used because `A` comes before `B` in the inheritance list. Similarly, for class `D`, the method from class `B` is used.

## The `super()` Function in Multiple Inheritance

The `super()` function becomes more complex but also more powerful in multiple inheritance scenarios. It follows the MRO to call methods from parent classes.

```python
class A:
    def greet(self):
        return "Hello from A"

class B:
    def greet(self):
        return "Hello from B"

class C(A, B):
    def greet(self):
        return super().greet() + " and C"

class D(B, A):
    def greet(self):
        return super().greet() + " and D"

c = C()
d = D()
print(c.greet())
print(d.greet())
```

**Output:**
```
Hello from A and C
Hello from B and D
```

In this example, `super().greet()` in class `C` calls `A.greet()` because `A` is first in `C`'s MRO. Similarly, `super().greet()` in class `D` calls `B.greet()` because `B` is first in `D`'s MRO.

## Diamond Problem in Multiple Inheritance

The "diamond problem" is a common issue in multiple inheritance where a class inherits from two classes that both inherit from a common base class.

```
    A
   / \
  B   C
   \ /
    D
```

In this diagram, `D` inherits from both `B` and `C`, which both inherit from `A`. The problem arises when `B` and `C` override methods from `A` differently, and `D` needs to determine which version to use.

Python's MRO resolves this issue using the C3 linearization algorithm:

```python
class A:
    def method(self):
        return "Method from A"

class B(A):
    def method(self):
        return "Method from B"

class C(A):
    def method(self):
        return "Method from C"

class D(B, C):
    pass

d = D()
print(D.__mro__)
print(d.method())
```

**Output:**
```
(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
Method from B
```

Python resolves the diamond problem by checking classes in the order specified by the MRO. In this case, `D` inherits from `B` first, so `B`'s implementation of `method()` is used.

## Practical Example: Mixins

Mixins are a common use case for multiple inheritance. A mixin is a class that provides methods for other classes but is not meant to be instantiated on its own.

Let's create a practical example with mixins for serializing objects:

```python
class JSONSerializableMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class CSVSerializableMixin:
    def to_csv(self):
        return ','.join(str(value) for value in self.__dict__.values())

class Person:
    def __init__(self, name, age, email):
        self.name = name
        self.age = age
        self.email = email

class Employee(Person, JSONSerializableMixin, CSVSerializableMixin):
    def __init__(self, name, age, email, employee_id, role):
        super().__init__(name, age, email)
        self.employee_id = employee_id
        self.role = role

# Create an employee
john = Employee("John Doe", 30, "john@example.com", "E12345", "Developer")

# Use mixin methods
print(john.to_json())
print(john.to_csv())
```

**Output:**
```
{"name": "John Doe", "age": 30, "email": "john@example.com", "employee_id": "E12345", "role": "Developer"}
John Doe,30,john@example.com,E12345,Developer
```

This example demonstrates how mixins can add specialized functionality (serialization in this case) to classes without affecting the main inheritance hierarchy.

## Real-world Application: GUI Development

Multiple inheritance is commonly used in GUI frameworks. Let's see a simplified example inspired by GUI programming:

```python
class Widget:
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
    
    def draw(self):
        return f"Drawing widget at ({self.x}, {self.y}) with dimensions {self.width}x{self.height}"

class Clickable:
    def click(self):
        return "Widget clicked!"
    
    def register_click_handler(self, handler):
        self.click_handler = handler

class Draggable:
    def drag(self, new_x, new_y):
        self.x = new_x
        self.y = new_y
        return f"Dragged to ({self.x}, {self.y})"

class Button(Widget, Clickable):
    def __init__(self, x, y, width, height, label):
        super().__init__(x, y, width, height)
        self.label = label
    
    def draw(self):
        return f"{super().draw()} with label: {self.label}"

class DraggableButton(Button, Draggable):
    pass

# Create a regular button
regular_button = Button(10, 20, 100, 30, "Click Me")
print(regular_button.draw())
print(regular_button.click())

# Create a draggable button
draggable_button = DraggableButton(10, 20, 100, 30, "Drag Me")
print(draggable_button.draw())
print(draggable_button.click())
print(draggable_button.drag(50, 60))
```

**Output:**
```
Drawing widget at (10, 20) with dimensions 100x30 with label: Click Me
Widget clicked!
Drawing widget at (10, 20) with dimensions 100x30 with label: Drag Me
Widget clicked!
Dragged to (50, 60)
```

This example shows how multiple inheritance can be used to compose complex behaviors from simpler classes, a technique commonly used in GUI frameworks and game development.

## Best Practices for Multiple Inheritance

While multiple inheritance is powerful, it can lead to complex and hard-to-maintain code if used carelessly. Here are some best practices:

1. **Keep it simple**: Use multiple inheritance only when it makes sense and simplifies your code.

2. **Prefer composition over inheritance**: Sometimes using composition (having instances of other classes as attributes) can be clearer than inheritance.

3. **Use mixins for specific functionalities**: Mixins should be focused on providing specific functionality rather than being base classes.

4. **Be aware of the MRO**: Understand how Python resolves method calls in your inheritance hierarchy.

5. **Use explicit calls when needed**: Sometimes using direct class calls (`ParentClass.method(self)`) is clearer than relying on `super()`.

6. **Document your inheritance structure**: Make sure to explain why certain classes inherit from others, especially in complex hierarchies.

## Common Pitfalls

Be aware of these common issues with multiple inheritance:

1. **Name conflicts**: Methods or attributes with the same name in different parent classes can lead to unexpected behavior.

2. **Complex MRO**: Deep or complex inheritance hierarchies can make it difficult to predict which method will be called.

3. **Initialization issues**: Ensure all parent classes are properly initialized, especially when they have their own `__init__` methods.

4. **Superclass method not called**: Forgetting to call a method in the parent class can lead to incomplete initialization or behavior.

## Summary

Multiple inheritance is a powerful feature in Python that allows a class to inherit attributes and methods from multiple parent classes. Key points to remember:

- Multiple inheritance syntax: `class Child(Parent1, Parent2, ...)`
- Method Resolution Order (MRO) determines which method gets called when names conflict
- The `super()` function works with the MRO to call parent class methods
- Python resolves the diamond problem using the C3 linearization algorithm
- Mixins are a common and effective use of multiple inheritance
- Multiple inheritance requires careful design to avoid complexity and maintenance issues

Used properly, multiple inheritance can lead to elegant and maintainable code. However, it should be used judiciously and with a good understanding of how Python resolves method calls.

## Exercises

1. Create a class hierarchy with at least three levels and multiple inheritance paths. Explore the MRO of the resulting classes.

2. Implement a logging mixin that adds logging capabilities to any class it's mixed with.

3. Create a persistence framework with different mixins for saving objects to JSON, CSV, and a database.

4. Resolve a diamond inheritance problem by properly using `super()` in all classes.

5. Refactor an existing class to use mixins instead of a deep inheritance hierarchy.

## Additional Resources

- [Python's Official Documentation on Multiple Inheritance](https://docs.python.org/3/tutorial/classes.html#multiple-inheritance)
- [Python MRO Algorithm Explained](https://www.python.org/download/releases/2.3/mro/)
- [The Composition Over Inheritance Principle](https://en.wikipedia.org/wiki/Composition_over_inheritance)
- [Design Patterns in Python](https://refactoring.guru/design-patterns/python)
- [Raymond Hettinger's "Super Considered Super!" talk](https://www.youtube.com/watch?v=EiOglTERPEo)