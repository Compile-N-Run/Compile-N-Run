---
title: Python Comprehensions
description: Learn how to use list, dictionary, and set comprehensions in Python to write more concise and efficient code for collection processing.

---

# Python Comprehensions

## Introduction

Comprehensions are a powerful feature in Python that allow you to create collections like lists, dictionaries, and sets using a single, concise line of code. They provide an elegant way to transform and filter data without writing verbose loops and conditional statements.

In this tutorial, you'll learn about three types of comprehensions:
- List comprehensions
- Dictionary comprehensions  
- Set comprehensions

Comprehensions not only make your code more readable but often result in better performance compared to traditional loops.

## List Comprehensions

### Basic Syntax

List comprehensions provide a concise way to create lists based on existing lists or other iterables. The basic syntax is:

```python
new_list = [expression for item in iterable]
```

### Simple Examples

Let's start with a simple example. Suppose we want to create a list containing the squares of numbers from 0 to 9:

**Using a traditional for loop:**

```python
squares = []
for x in range(10):
    squares.append(x ** 2)
    
print(squares)
```

**Output:**
```
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

**Using list comprehension:**

```python
squares = [x ** 2 for x in range(10)]
print(squares)
```

**Output:**
```
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

As you can see, the list comprehension is much more concise!

### Adding Conditions

You can also add conditional filtering to list comprehensions:

```python
even_squares = [x ** 2 for x in range(10) if x % 2 == 0]
print(even_squares)
```

**Output:**
```
[0, 4, 16, 36, 64]
```

This creates a list of squares of even numbers only.

### Nested Conditions

You can use if-else constructs within list comprehensions:

```python
numbers = [x if x % 2 == 0 else -x for x in range(10)]
print(numbers)
```

**Output:**
```
[0, -1, 2, -3, 4, -5, 6, -7, 8, -9]
```

This returns even numbers as-is and negates odd numbers.

### Nested Loops

You can also use nested loops in list comprehensions:

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
print(flattened)
```

**Output:**
```
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

This flattens a 2D list into a 1D list.

## Dictionary Comprehensions

Dictionary comprehensions allow you to create dictionaries using a similar syntax to list comprehensions.

### Basic Syntax

```python
new_dict = {key_expr: value_expr for item in iterable}
```

### Simple Examples

Let's create a dictionary that maps numbers to their squares:

```python
squares_dict = {x: x ** 2 for x in range(6)}
print(squares_dict)
```

**Output:**
```
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
```

### With Conditions

You can also add conditions to dictionary comprehensions:

```python
even_squares_dict = {x: x ** 2 for x in range(10) if x % 2 == 0}
print(even_squares_dict)
```

**Output:**
```
{0: 0, 2: 4, 4: 16, 6: 36, 8: 64}
```

### Transforming Dictionaries

Dictionary comprehensions are great for transforming existing dictionaries:

```python
old_prices = {'apple': 1.0, 'banana': 0.5, 'orange': 1.2}
new_prices = {item: price * 1.1 for item, price in old_prices.items()}
print(new_prices)
```

**Output:**
```
{'apple': 1.1, 'banana': 0.55, 'orange': 1.32}
```

This applies a 10% price increase to all items.

## Set Comprehensions

Set comprehensions create sets using a similar syntax to list comprehensions.

### Basic Syntax

```python
new_set = {expression for item in iterable}
```

### Simple Examples

Let's create a set of squares:

```python
squares_set = {x ** 2 for x in range(10)}
print(squares_set)
```

**Output:**
```
{0, 1, 64, 4, 36, 9, 16, 49, 81, 25}
```

Notice that the order might be different than expected because sets are unordered collections.

### With Conditions

Just like with lists and dictionaries, you can add conditions:

```python
even_squares_set = {x ** 2 for x in range(10) if x % 2 == 0}
print(even_squares_set)
```

**Output:**
```
{0, 64, 4, 16, 36}
```

## Real-World Applications

### Data Transformation

Comprehensions are ideal for data transformation tasks:

```python
# Convert Celsius temperatures to Fahrenheit
celsius = [0, 10, 20, 30, 40]
fahrenheit = [(9/5) * c + 32 for c in celsius]
print(fahrenheit)
```

**Output:**
```
[32.0, 50.0, 68.0, 86.0, 104.0]
```

### Working with Files

Comprehensions can be used to process file data:

```python
# Create a dictionary of word lengths from a text file
with open('example.txt', 'r') as f:
    content = f.read()
    word_lengths = {word: len(word) for word in content.split()}
    print(word_lengths)
```

### Extracting Data from Complex Structures

Comprehensions simplify extracting specific data from nested structures:

```python
# Extract all usernames from a list of user records
users = [
    {"id": 1, "username": "john", "email": "john@example.com"},
    {"id": 2, "username": "jane", "email": "jane@example.com"},
    {"id": 3, "username": "bob", "email": "bob@example.com"}
]

usernames = [user["username"] for user in users]
print(usernames)
```

**Output:**
```
['john', 'jane', 'bob']
```

### Creating Lookup Tables

Dictionary comprehensions are perfect for creating lookup tables:

```python
# Create a lookup table from a list of objects
fruits = ["apple", "banana", "cherry", "date"]
fruit_indices = {fruit: index for index, fruit in enumerate(fruits)}
print(fruit_indices)
```

**Output:**
```
{'apple': 0, 'banana': 1, 'cherry': 2, 'date': 3}
```

## Performance Considerations

Comprehensions are not just more concise—they're often faster than equivalent for loops because they're optimized at the C level in Python's implementation.

For small to medium-sized data, the performance difference might not be noticeable, but comprehensions become more efficient as the data size grows.

However, readability should always be your primary concern. If a comprehension becomes too complex, it's better to use a traditional loop structure.

## When to Use Comprehensions

Comprehensions are ideal when:

1. You need to transform elements in a collection
2. You want to filter elements based on a condition
3. The operation can be expressed in a single line without becoming too complex
4. You're creating a new collection rather than modifying an existing one

Avoid using comprehensions when:
1. The logic is complex and hard to read in a single line
2. You need to handle exceptions
3. The operation involves multiple steps

## Summary

Python comprehensions are a powerful feature that allows you to create collections like lists, dictionaries, and sets using a concise syntax. They combine looping, conditional logic, and collection creation in a single expression, making your code more readable and often more efficient.

Remember these key points:

- List comprehensions create lists: `[expression for item in iterable]`
- Dictionary comprehensions create dictionaries: `{key: value for item in iterable}`
- Set comprehensions create sets: `{expression for item in iterable}`
- All comprehensions can include conditions: `[... for ... if ...]`
- Complex comprehensions may be harder to read than traditional loops

## Exercises

1. Create a list comprehension that generates a list of the first 10 square numbers.
2. Write a dictionary comprehension that creates a mapping from numbers 1 to 10 to their cubes.
3. Use a list comprehension to extract all even numbers from a given list.
4. Create a set comprehension that collects all unique letters from a string.
5. Write a nested list comprehension to transpose a 3x3 matrix.

## Additional Resources

- [Python Documentation on List Comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)
- [PEP 202 – List Comprehensions](https://peps.python.org/pep-0202/)
- [PEP 274 – Dictionary Comprehensions](https://peps.python.org/pep-0274/)
- [Real Python: When to Use a List Comprehension in Python](https://realpython.com/list-comprehension-python/)