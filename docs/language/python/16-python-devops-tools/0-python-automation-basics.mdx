---
title: Python Automation Basics
description: Learn how to use Python for automating repetitive tasks, handling files, scheduling scripts, and building simple automation workflows.

---

# Python Automation Basics

## Introduction

Automation is one of the most powerful applications of programming, and Python excels at making complex automation tasks simple. Whether you're managing files, processing data, or coordinating system tasks, Python provides tools that make automation accessible even to beginners.

In this guide, we'll explore how Python can automate repetitive tasks, saving you time and reducing the potential for human error. By the end, you'll understand the core concepts of Python automation and be able to build simple scripts to automate your own workflows.

## Why Automate with Python?

Before diving into the technical details, let's understand why Python is an excellent choice for automation:

1. **Readable syntax**: Python's clean syntax makes automation scripts easy to understand and maintain
2. **Rich ecosystem**: Extensive libraries for virtually any task you need to automate
3. **Cross-platform**: Scripts work across Windows, macOS, and Linux with minimal changes
4. **Low entry barrier**: Easy for beginners to learn and create useful scripts quickly

## Getting Started with Python Automation

### Setting Up Your Environment

To follow along with this guide, you should have:

- Python 3.6+ installed
- A text editor or IDE (like VS Code, PyCharm, or even Notepad++)
- Basic Python knowledge (variables, functions, loops)

Let's start by creating a simple script to verify everything is working:

```python
# simple_automation.py
import sys

print(f"Ready to automate with Python {sys.version.split()[0]}!")
print("Current platform:", sys.platform)
```

When you run this script, you should see output similar to:

```
Ready to automate with Python 3.9.5!
Current platform: win32
```

## Automating File Operations

### Working with Files and Directories

File manipulation is a common automation task. Let's explore how to automate basic file operations:

```python
import os
import shutil

# Create a directory
def create_directory(path):
    try:
        os.makedirs(path, exist_ok=True)
        print(f"Directory created at {path}")
    except Exception as e:
        print(f"Error creating directory: {e}")

# Copy files
def copy_file(source, destination):
    try:
        shutil.copy2(source, destination)
        print(f"File copied from {source} to {destination}")
    except Exception as e:
        print(f"Error copying file: {e}")

# Usage example
if __name__ == "__main__":
    create_directory("./backup")
    copy_file("important_data.txt", "./backup/important_data_copy.txt")
```

### Batch File Processing

Often, you'll want to process multiple files at once. Here's how to batch rename files in a directory:

```python
import os

def batch_rename_files(directory, old_ext, new_ext):
    """Rename all files in directory from old extension to new extension"""
    count = 0
    
    for filename in os.listdir(directory):
        if filename.endswith(old_ext):
            # Construct new filename
            new_name = filename.replace(old_ext, new_ext)
            
            # Full paths
            old_path = os.path.join(directory, filename)
            new_path = os.path.join(directory, new_name)
            
            # Rename file
            os.rename(old_path, new_path)
            count += 1
            print(f"Renamed: {filename} → {new_name}")
    
    print(f"Total files renamed: {count}")

# Example usage
batch_rename_files("./documents", ".txt", ".md")
```

## Automating Data Processing

### CSV Data Processing

CSV files are commonly used for data exchange. Let's create a script that processes CSV data:

```python
import csv

def analyze_sales_data(csv_file):
    """Analyze sales data from a CSV file"""
    total_sales = 0
    product_counts = {}
    
    with open(csv_file, 'r') as file:
        reader = csv.DictReader(file)
        
        for row in reader:
            product = row['product']
            price = float(row['price'])
            quantity = int(row['quantity'])
            
            sales = price * quantity
            total_sales += sales
            
            if product in product_counts:
                product_counts[product] += quantity
            else:
                product_counts[product] = quantity
    
    # Print analysis results
    print(f"Total sales: ${total_sales:.2f}")
    print("\nProduct counts:")
    for product, count in product_counts.items():
        print(f"- {product}: {count} units")

# Example with sample data
# sales.csv should have headers: product,price,quantity
# and data like: Widget,9.99,5
analyze_sales_data("sales.csv")
```

Example output:

```
Total sales: $124.75

Product counts:
- Widget: 5 units
- Gadget: 3 units
- Tool: 2 units
```

## Web Automation Basics

### Simple Web Scraping

Python can automate interactions with websites. Here's a basic example using the `requests` and `BeautifulSoup` libraries:

```python
import requests
from bs4 import BeautifulSoup

def scrape_webpage_title(url):
    """Extract the title from a webpage"""
    try:
        # Send HTTP GET request
        response = requests.get(url)
        
        # Check if request was successful
        if response.status_code == 200:
            # Parse HTML content
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Extract title
            title = soup.title.string
            
            return title.strip() if title else "No title found"
        else:
            return f"Error: Received status code {response.status_code}"
    
    except Exception as e:
        return f"Error: {str(e)}"

# Example usage
websites = [
    "https://python.org",
    "https://github.com",
    "https://stackoverflow.com"
]

for site in websites:
    title = scrape_webpage_title(site)
    print(f"{site} → {title}")
```

To use this script, you'll need to install the required packages:

```bash
pip install requests beautifulsoup4
```

## Scheduling Automated Tasks

### Running Scripts on Schedule

For full automation, you'll want your scripts to run automatically on a schedule:

```python
import schedule
import time
import datetime

def backup_database():
    """Simulate backing up a database"""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] Database backup completed")

def clean_temp_files():
    """Simulate cleaning temporary files"""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] Temporary files cleaned")

# Schedule tasks
schedule.every().day.at("01:00").do(backup_database)
schedule.every().hour.do(clean_temp_files)

print("Scheduler started. Press Ctrl+C to exit.")

# Keep the script running
try:
    while True:
        schedule.run_pending()
        time.sleep(1)
except KeyboardInterrupt:
    print("Scheduler stopped.")
```

To use this script, install the schedule library:

```bash
pip install schedule
```

For production use, you'd typically use system schedulers like cron (on Linux/macOS) or Task Scheduler (on Windows) instead of keeping a Python script running continuously.

## Real-World Example: Log File Analyzer

Let's build a more comprehensive example that analyzes server log files:

```python
import re
import os
from collections import Counter
from datetime import datetime

def analyze_log_file(log_file):
    """Analyze a server log file for errors and access patterns"""
    
    if not os.path.exists(log_file):
        print(f"Error: Log file '{log_file}' not found")
        return
    
    # Patterns to match
    error_pattern = r"ERROR|CRITICAL|FAIL"
    ip_pattern = r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
    timestamp_pattern = r"\[(\d{2}/\w{3}/\d{4}:\d{2}:\d{2}:\d{2})]"
    
    # Counters
    errors = []
    ip_addresses = []
    hourly_requests = [0] * 24
    
    # Process log file
    with open(log_file, 'r') as file:
        for line in file:
            # Check for errors
            if re.search(error_pattern, line, re.IGNORECASE):
                errors.append(line.strip())
            
            # Extract IP addresses
            ip_match = re.search(ip_pattern, line)
            if ip_match:
                ip_addresses.append(ip_match.group(0))
            
            # Extract timestamp and count hourly requests
            ts_match = re.search(timestamp_pattern, line)
            if ts_match:
                try:
                    time_str = ts_match.group(1)
                    time_obj = datetime.strptime(time_str, "%d/%b/%Y:%H:%M:%S")
                    hourly_requests[time_obj.hour] += 1
                except:
                    pass
    
    # Generate report
    print(f"Log Analysis Report for {log_file}")
    print("-" * 50)
    
    print(f"\nTotal errors found: {len(errors)}")
    if errors:
        print("First 5 errors:")
        for i, error in enumerate(errors[:5]):
            print(f"  {i+1}. {error[:100]}...")
    
    print(f"\nUnique IP addresses: {len(set(ip_addresses))}")
    print("Top 5 IP addresses by frequency:")
    for ip, count in Counter(ip_addresses).most_common(5):
        print(f"  {ip}: {count} requests")
    
    print("\nHourly request distribution:")
    for hour in range(24):
        print(f"  {hour:02d}:00 - {hour+1:02d}:00: {hourly_requests[hour]} requests")

# Sample usage
analyze_log_file("server.log")
```

This script provides insights into server health by:
1. Identifying errors in the logs
2. Tracking which IP addresses make the most requests
3. Analyzing traffic patterns throughout the day

## Using Command-Line Arguments in Automation Scripts

To make your automation scripts more flexible, you can accept command-line arguments:

```python
import argparse
import os

def process_files(directory, extension, action):
    """Process files with given extension in the specified directory"""
    if not os.path.exists(directory):
        print(f"Error: Directory '{directory}' not found")
        return
    
    count = 0
    for filename in os.listdir(directory):
        if filename.endswith(extension):
            file_path = os.path.join(directory, filename)
            
            if action == "list":
                print(f"Found: {filename}")
                count += 1
            elif action == "count_lines":
                with open(file_path, 'r') as file:
                    line_count = sum(1 for _ in file)
                print(f"{filename}: {line_count} lines")
                count += 1
    
    print(f"\nProcessed {count} files with extension '{extension}'")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Process files in a directory")
    parser.add_argument("directory", help="Directory to process")
    parser.add_argument("--ext", default=".txt", help="File extension to filter (default: .txt)")
    parser.add_argument("--action", choices=["list", "count_lines"], default="list",
                        help="Action to perform on files (default: list)")
    
    args = parser.parse_args()
    process_files(args.directory, args.ext, args.action)
```

You can run this script with different arguments:

```bash
python file_processor.py ./documents --ext .py --action count_lines
```

## Summary

In this guide, you've learned the basics of Python automation:

- File manipulation for organizing and processing files
- Data processing techniques for extracting insights
- Basic web scraping for collecting information from websites
- Scheduling scripts to run automatically
- Building more complex automation scripts with real-world applications
- Using command-line arguments to make scripts flexible

Python's simplicity and powerful libraries make it an ideal language for automation tasks. The scripts we've covered are just the beginning - you can extend these concepts to automate virtually any repetitive task in your workflow.

## Additional Resources

To further develop your Python automation skills:

1. **Libraries to explore:**
   - `pathlib`: Modern approach to file path handling
   - `pandas`: For more advanced data processing
   - `selenium`: For browser automation
   - `paramiko`: For SSH automation
   - `pyautogui`: For desktop GUI automation

2. **Practice exercises:**
   - Create a script that monitors a folder and automatically organizes files by type
   - Build an automated backup system for important files
   - Develop a script that summarizes your daily email inbox
   - Create a web scraper that tracks prices of products you're interested in

3. **Further reading:**
   - [Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)
   - [Python Documentation on `os` and `shutil`](https://docs.python.org/3/library/os.html)
   - [Real Python's Automation Tutorials](https://realpython.com/tutorials/automation/)

Remember that the best way to learn automation is by identifying repetitive tasks in your own workflow and writing scripts to eliminate them. Start with small projects and gradually tackle more complex automation challenges as your skills grow.

Happy automating!