---
title: Python File Management
description: Learn how to efficiently manage files and directories in Python - creating, reading, writing, copying, moving, and deleting files and directories.

---

# Python File Management

File management is a critical skill for any programmer. Whether you're building a simple script or a complex application, you'll often need to work with files and directories on your computer's file system. Python provides several built-in modules that make file management straightforward and efficient.

## Introduction to Python File Management

File management in Python involves creating, reading, writing, copying, moving, and deleting files and directories. The primary modules we'll use for these operations are:

- `os`: For basic file and directory operations
- `shutil`: For higher-level file operations
- `pathlib`: For object-oriented file system paths (modern approach)

By mastering these modules, you'll be able to automate file-related tasks, organize data, and build more robust applications.

## Basic File Operations

### Checking if a File Exists

Before performing operations on a file, it's often necessary to check if it exists:

```python
import os

# Method 1: Using os.path.exists()
if os.path.exists('example.txt'):
    print("The file exists!")
else:
    print("The file does not exist.")

# Method 2: Using pathlib (modern approach)
from pathlib import Path
if Path('example.txt').exists():
    print("The file exists!")
else:
    print("The file does not exist.")
```

Output (assuming example.txt doesn't exist):
```
The file does not exist.
The file does not exist.
```

### Creating a New File

Python provides multiple ways to create a new file:

```python
# Method 1: Using open() with 'w' mode
with open('new_file.txt', 'w') as file:
    file.write("Hello, this is a new file!")

# Method 2: Using pathlib
from pathlib import Path
Path('another_file.txt').touch()  # Creates an empty file

# Check that files were created
print(f"new_file.txt exists: {os.path.exists('new_file.txt')}")
print(f"another_file.txt exists: {Path('another_file.txt').exists()}")
```

Output:
```
new_file.txt exists: True
another_file.txt exists: True
```

### Renaming a File

To rename a file in Python:

```python
import os
from pathlib import Path

# Method 1: Using os
if os.path.exists('new_file.txt'):
    os.rename('new_file.txt', 'renamed_file.txt')
    print("File renamed using os module!")

# Method 2: Using pathlib
file_path = Path('another_file.txt')
if file_path.exists():
    file_path.rename('another_renamed_file.txt')
    print("File renamed using pathlib module!")
```

Output:
```
File renamed using os module!
File renamed using pathlib module!
```

### Deleting a File

To delete a file:

```python
import os
from pathlib import Path

# Method 1: Using os
if os.path.exists('renamed_file.txt'):
    os.remove('renamed_file.txt')
    print("File deleted using os module!")

# Method 2: Using pathlib
file_path = Path('another_renamed_file.txt')
if file_path.exists():
    file_path.unlink()
    print("File deleted using pathlib module!")
```

Output:
```
File deleted using os module!
File deleted using pathlib module!
```

## Directory Operations

### Checking if a Directory Exists

Similar to checking if a file exists:

```python
import os
from pathlib import Path

# Using os
if os.path.isdir('my_directory'):
    print("The directory exists!")
else:
    print("The directory does not exist.")

# Using pathlib
if Path('my_directory').is_dir():
    print("The directory exists!")
else:
    print("The directory does not exist.")
```

Output (assuming my_directory doesn't exist):
```
The directory does not exist.
The directory does not exist.
```

### Creating a Directory

To create a new directory:

```python
import os
from pathlib import Path

# Method 1: Using os
if not os.path.exists('new_directory'):
    os.mkdir('new_directory')
    print("Directory created using os module!")

# Method 2: Using pathlib
directory = Path('another_directory')
if not directory.exists():
    directory.mkdir()
    print("Directory created using pathlib module!")
    
# Creating nested directories
nested_dir = Path('parent/child/grandchild')
if not nested_dir.exists():
    nested_dir.mkdir(parents=True)  # parents=True creates all needed parent directories
    print("Nested directories created!")
```

Output:
```
Directory created using os module!
Directory created using pathlib module!
Nested directories created!
```

### Listing Directory Contents

To list the contents of a directory:

```python
import os
from pathlib import Path

# Let's create some files in new_directory for demonstration
with open('new_directory/file1.txt', 'w') as f:
    f.write("File 1 content")
with open('new_directory/file2.txt', 'w') as f:
    f.write("File 2 content")

# Method 1: Using os
print("Using os.listdir():")
for item in os.listdir('new_directory'):
    print(item)

# Method 2: Using pathlib
print("\nUsing pathlib:")
directory = Path('new_directory')
for item in directory.iterdir():
    print(item.name)
```

Output:
```
Using os.listdir():
file1.txt
file2.txt

Using pathlib:
file1.txt
file2.txt
```

### Deleting a Directory

To delete a directory:

```python
import os
import shutil
from pathlib import Path

# For empty directories:
if os.path.exists('another_directory'):
    os.rmdir('another_directory')
    print("Empty directory deleted using os.rmdir()!")

# For non-empty directories (need shutil):
if os.path.exists('new_directory'):
    shutil.rmtree('new_directory')
    print("Non-empty directory deleted using shutil.rmtree()!")
    
# Using pathlib (only works for empty directories):
empty_dir = Path('parent/child/grandchild')
if empty_dir.exists():
    empty_dir.rmdir()
    print("Empty directory deleted using pathlib!")
```

Output:
```
Empty directory deleted using os.rmdir()!
Non-empty directory deleted using shutil.rmtree()!
Empty directory deleted using pathlib!
```

## Advanced File Operations

### Copying Files

The `shutil` module provides functions for copying files:

```python
import shutil
from pathlib import Path

# Create a file to copy
with open('source.txt', 'w') as f:
    f.write("This is the source file.")

# Copy file (creates destination.txt with same contents)
shutil.copy('source.txt', 'destination.txt')
print("File copied successfully!")

# Read both files to confirm copy worked
with open('source.txt', 'r') as source, open('destination.txt', 'r') as dest:
    print(f"Source content: {source.read()}")
    print(f"Destination content: {dest.read()}")
```

Output:
```
File copied successfully!
Source content: This is the source file.
Destination content: This is the source file.
```

### Moving Files

To move (or rename) a file from one location to another:

```python
import shutil
import os

# Create a test file
with open('file_to_move.txt', 'w') as f:
    f.write("This file will be moved.")

# Create a destination directory
os.makedirs('destination_folder', exist_ok=True)

# Move the file
shutil.move('file_to_move.txt', 'destination_folder/moved_file.txt')
print("File moved successfully!")

# Verify the file was moved
if os.path.exists('destination_folder/moved_file.txt'):
    print("The file exists in the new location!")
```

Output:
```
File moved successfully!
The file exists in the new location!
```

### Getting File Information

Python provides several ways to get information about files:

```python
import os
import time
from pathlib import Path

# Create a test file
with open('info_test.txt', 'w') as f:
    f.write("This is a test file for getting information.")

# Using os module
file_stats = os.stat('info_test.txt')
print(f"File size: {file_stats.st_size} bytes")
print(f"Last modified: {time.ctime(file_stats.st_mtime)}")
print(f"Last accessed: {time.ctime(file_stats.st_atime)}")

# Using pathlib
file_path = Path('info_test.txt')
print(f"\nPathlib approach:")
print(f"File size: {file_path.stat().st_size} bytes")
print(f"Is it a file? {file_path.is_file()}")
print(f"File suffix: {file_path.suffix}")
print(f"File stem: {file_path.stem}")
```

Output (the times will vary):
```
File size: 43 bytes
Last modified: Sun Apr 23 15:30:45 2023
Last accessed: Sun Apr 23 15:30:45 2023

Pathlib approach:
File size: 43 bytes
Is it a file? True
File suffix: .txt
File stem: info_test
```

## Real-World Applications

### Example 1: Log File Rotation

This example shows how to implement a simple log rotation system, which is useful for managing log files in applications:

```python
import os
from pathlib import Path
import shutil
from datetime import datetime

def rotate_logs(log_file, max_logs=5):
    """Rotate log files, keeping a limited number of backups."""
    if not os.path.exists(log_file):
        # No log file exists yet
        return
    
    # Get current date for backup filename
    date_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    base_name = Path(log_file).stem
    extension = Path(log_file).suffix
    backup_name = f"{base_name}_{date_str}{extension}"
    
    # Create backup directory if it doesn't exist
    backup_dir = "log_backups"
    Path(backup_dir).mkdir(exist_ok=True)
    
    # Copy current log to backup
    shutil.copy2(log_file, os.path.join(backup_dir, backup_name))
    print(f"Backed up log to {backup_name}")
    
    # Clear the current log file
    open(log_file, 'w').close()
    print(f"Cleared {log_file}")
    
    # Limit the number of backups
    all_backups = sorted([f for f in os.listdir(backup_dir) 
                         if f.startswith(base_name)])
    
    # Remove oldest backups if we have too many
    while len(all_backups) > max_logs:
        oldest = all_backups.pop(0)
        os.remove(os.path.join(backup_dir, oldest))
        print(f"Removed old backup: {oldest}")

# Example usage
log_file = "application.log"

# Create a log file with some content
with open(log_file, "w") as f:
    f.write("This is a log entry 1\n")
    f.write("This is a log entry 2\n")

# Rotate the logs
rotate_logs(log_file)

# Write new content to the log file
with open(log_file, "a") as f:
    f.write("This is a new log entry after rotation\n")
```

Output (will vary):
```
Backed up log to application_20230423_153045.log
Cleared application.log
```

### Example 2: File Organization Script

This script organizes files in a directory by their extension:

```python
import os
import shutil
from pathlib import Path

def organize_files(directory):
    """
    Organize files in the specified directory by their extension.
    Files will be moved to subdirectories named after their extension.
    """
    # Convert to Path object
    dir_path = Path(directory)
    
    if not dir_path.exists() or not dir_path.is_dir():
        print(f"Error: {directory} is not a valid directory.")
        return
    
    # Keep track of file counts
    moved_count = 0
    
    # Process each file in the directory
    for file_path in dir_path.iterdir():
        # Skip directories
        if file_path.is_dir():
            continue
        
        # Get the file extension (without the dot)
        file_ext = file_path.suffix.lstrip('.')
        
        # Skip files without extension
        if not file_ext:
            continue
            
        # Create a directory for this extension if it doesn't exist
        ext_dir = dir_path / file_ext
        ext_dir.mkdir(exist_ok=True)
        
        # Destination path
        dest_path = ext_dir / file_path.name
        
        # Move the file
        try:
            shutil.move(str(file_path), str(dest_path))
            moved_count += 1
            print(f"Moved {file_path.name} to {file_ext}/{file_path.name}")
        except Exception as e:
            print(f"Error moving {file_path.name}: {e}")
    
    print(f"\nOrganization complete. Moved {moved_count} files.")

# Example usage
# Create a test directory with different file types
test_dir = Path("test_organize")
test_dir.mkdir(exist_ok=True)

# Create sample files
file_types = {
    "document.txt": "This is a text file",
    "image.jpg": "Binary image data would go here",
    "script.py": "print('Hello, world!')",
    "data.csv": "name,age,city\nJohn,30,New York",
}

for filename, content in file_types.items():
    with open(test_dir / filename, 'w') as f:
        f.write(content)

print("Created sample files for organization.")
organize_files("test_organize")
```

Output:
```
Created sample files for organization.
Moved document.txt to txt/document.txt
Moved image.jpg to jpg/image.jpg
Moved script.py to py/script.py
Moved data.csv to csv/data.csv

Organization complete. Moved 4 files.
```

## Summary

Python provides powerful tools for file management through its standard library modules:

- The `os` module offers basic file and directory operations
- The `shutil` module extends these capabilities with higher-level operations
- The `pathlib` module provides an object-oriented approach to file system paths

With these tools, you can:
- Create, read, write, rename, and delete files
- Create, navigate, and remove directories
- Copy and move files between locations
- Get detailed information about files and directories

By mastering Python's file management capabilities, you can automate repetitive tasks, organize your data more efficiently, and build more robust applications that interact with the file system.

## Additional Resources and Exercises

### Additional Resources
- [Python os module documentation](https://docs.python.org/3/library/os.html)
- [Python shutil module documentation](https://docs.python.org/3/library/shutil.html)
- [Python pathlib module documentation](https://docs.python.org/3/library/pathlib.html)

### Exercises

1. **Log Analyzer**: Write a script that reads a log file, counts occurrences of different error types, and generates a summary report.

2. **Duplicate File Finder**: Create a program that scans a directory (and its subdirectories) to identify duplicate files based on their content.

3. **File Backup Tool**: Develop a script that backs up specific file types from a source directory to a backup directory, maintaining the same folder structure.

4. **File Cleanup Utility**: Write a program that identifies and removes temporary files (like .tmp or .bak files) from a directory.

5. **File Sync Tool**: Create a basic file synchronization tool that keeps two directories in sync by copying new or modified files from one to the other.

By working through these exercises, you'll gain practical experience with Python's file management capabilities and develop skills that are useful in many real-world programming scenarios.