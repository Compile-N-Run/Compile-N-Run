---
title: Git Add
description: Learn how to stage changes using the git add command, a fundamental part of the Git workflow

---

# Git Add

## Introduction

The `git add` command is one of the most fundamental operations in Git. It marks new or modified files to be included in your next commit. This operation is also known as "staging" changes, where you select which modifications you want to include in your project's history.

Understanding the `git add` command is crucial because it gives you precise control over what gets committed. Rather than automatically committing all modified files, Git allows you to carefully select exactly which changes should be included in each commit.

## The Staging Area Concept

Before diving into the `git add` command, it's important to understand Git's "staging area" (also called the "index").

```mermaid
graph LR
    A[Working Directory] -->|git add| B[Staging Area]
    B -->|git commit| C[Repository]
```

The Git workflow involves three areas:
1. **Working Directory**: Where you modify files
2. **Staging Area**: Where you prepare changes for commitment
3. **Repository**: Where committed changes are stored

The staging area acts as a middle ground, allowing you to select which changes go into the next commit. This gives you fine-grained control over your project's history.

## Basic Usage of Git Add

The simplest form of the command adds a single file to the staging area:

```bash
git add filename.txt
```

This tells Git to track the file and include its current state in the next commit.

### Example: Adding a Single File

Let's say you've created a new file called `app.js`:

```bash
# Create a new file
echo "console.log('Hello, Git!');" > app.js

# Check status - shows app.js as untracked
git status

# Add the file to staging area
git add app.js

# Check status again - app.js is now staged
git status
```

Output of `git status` before adding:

```
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        app.js

nothing added to commit but untracked files present (use "git add" to track)
```

Output after `git add app.js`:

```
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        new file:   app.js
```

## Adding Multiple Files

You can add multiple files at once by specifying them:

```bash
git add file1.js file2.js file3.css
```

### Adding All Files in the Current Directory

To add all new and modified files (but not deleted files):

```bash
git add .
```

### Adding All Changes Including Deletions

To stage all modifications, including files that have been deleted:

```bash
git add -A
# or
git add --all
```

## Interactive Add

Git provides an interactive mode for more granular control:

```bash
git add -i
# or
git add --interactive
```

This opens an interactive shell where you can select specific files or even specific parts of files to stage.

## Patch Mode: Adding Parts of a File

Sometimes you may want to stage only certain changes within a file rather than the entire file. For this, use the patch option:

```bash
git add -p filename.js
# or
git add --patch filename.js
```

This will break the changes in the file into "hunks" and prompt you to decide what to do with each one:

- `y`: stage this hunk
- `n`: do not stage this hunk
- `q`: quit; do not stage this hunk or any remaining hunks
- `a`: stage this and all remaining hunks
- `d`: do not stage this hunk or any remaining hunks
- `s`: split the current hunk into smaller hunks
- `e`: manually edit the current hunk
- `?`: display help

### Example: Using Patch Mode

Let's say you've made multiple unrelated changes to `config.js`:

```bash
# View the changes in the file
git diff config.js

# Selectively add changes
git add -p config.js
```

Now Git will show each chunk of changes and ask what to do with it, allowing you to commit logically separate changes in separate commits.

## Common Git Add Patterns

Here are some common usage patterns for `git add`:

### Adding Files by Pattern

You can use wildcard patterns to add multiple files:

```bash
# Add all JavaScript files
git add *.js

# Add all files in the src directory
git add src/

# Add all CSS files in any subdirectory
git add **/*.css
```

### Updating Already Tracked Files

If you want to add all modifications to files that are already being tracked by Git (but not new files):

```bash
git add -u
# or
git add --update
```

## Practical Workflow Examples

### Example 1: Basic Feature Development

```bash
# Create a new feature file
echo "function newFeature() { return 'awesome'; }" > feature.js

# Add the file
git add feature.js

# Commit the change
git commit -m "Add new feature function"

# Modify the file
echo "function improvedFeature() { return 'even better'; }" >> feature.js

# Stage only the changes to tracked files
git add -u

# Commit the update
git commit -m "Add improved feature function"
```

### Example 2: Selective Commits from Multiple Changes

Imagine you're working on a project and made changes to three files:
- Fixed a bug in `bugfix.js`
- Added documentation in `README.md`
- Started a new feature in `newfeature.js`

You want to commit these changes separately for a cleaner history:

```bash
# Stage and commit the bug fix first
git add bugfix.js
git commit -m "Fix null pointer exception in user authentication"

# Then stage and commit the documentation update
git add README.md
git commit -m "Update installation instructions in README"

# Finally, stage and commit the new feature
git add newfeature.js
git commit -m "Start implementing user profile export feature"
```

This creates three separate commits with clear purposes, rather than one large commit with mixed changes.

## Common Mistakes and How to Fix Them

### Accidentally Staging a File

If you've added a file by mistake, you can unstage it:

```bash
git restore --staged filename.js
# or (older Git versions)
git reset HEAD filename.js
```

### Skipping the Staging Area

While the staging area is powerful, sometimes you might want to commit all changes directly:

```bash
git commit -a -m "Commit message"
```

This automatically stages all modified tracked files (but not new files) and commits them. However, this bypasses the staging area's benefits of selective commits.

## Summary

The `git add` command is a fundamental part of the Git workflow that allows you to stage changes for commit. Key points to remember:

- `git add` moves changes from your working directory to the staging area
- You can add specific files, directories, or use patterns
- The patch mode (`git add -p`) allows you to stage parts of a file
- Staging your changes gives you control over what gets committed and when

By mastering the `git add` command and the staging concept, you'll gain more control over your project's history and be able to create more meaningful commits.

## Exercises

1. Create a new Git repository and practice adding and committing files:
   - Create multiple files with different contents
   - Add them individually
   - Check the status between operations
   - Commit the changes

2. Practice using `git add -p` by:
   - Modifying a file in several different places
   - Using patch mode to stage only some of the changes
   - Committing those changes
   - Then staging and committing the remaining changes

3. Experiment with different add commands:
   - `git add .`
   - `git add -A`
   - `git add -u`
   - Observe the differences in behavior with various file states (new, modified, deleted)

## Further Resources

- [Official Git Documentation](https://git-scm.com/docs/git-add)
- [Pro Git Book - Recording Changes to the Repository](https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository)
- [Git Add Command Examples](https://www.atlassian.com/git/tutorials/saving-changes)