---
title: Docker Resource Limits
description: Learn how to set and manage resource limits in Docker containers to optimize performance and prevent resource contention

---

# Docker Resource Limits

## Introduction

When running applications in Docker containers, understanding how to manage system resources is crucial for ensuring optimal performance. By default, Docker containers can use unlimited system resources - they can consume as much CPU, memory, and I/O as the host system allows. While this flexibility is convenient, it can lead to performance issues, especially in multi-container environments where containers may compete for the same resources.

In this guide, we'll explore how to set resource limits for Docker containers, helping you create more stable, predictable, and efficient containerized applications.

## Why Resource Limits Matter

Before diving into implementation, let's understand why resource limits are important:

1. **Preventing resource contention**: Limits ensure one container doesn't starve others of necessary resources
2. **Predictable performance**: Applications behave more consistently when their resource boundaries are clearly defined
3. **Cost optimization**: In cloud environments, proper resource allocation leads to cost savings
4. **Preventing cascading failures**: Limits can stop a single failing container from affecting the entire system

## CPU Limits

Docker allows you to control how much CPU a container can use through several options.

### CPU Shares (Relative CPU Usage)

The `--cpu-shares` flag sets the relative CPU priority of a container. By default, all containers get 1024 shares.

```bash
# Run a container with half the CPU priority
docker run -d --cpu-shares=512 nginx
```

This doesn't guarantee CPU time but rather sets priorities when containers compete for CPU.

### CPU Cores (CPUs)

The `--cpus` flag limits the number of CPU cores a container can use.

```bash
# Limit a container to use at most 1.5 CPU cores
docker run -d --cpus=1.5 nginx
```

### CPU Set (Specific CPUs)

The `--cpuset-cpus` flag assigns specific CPU cores to a container.

```bash
# Assign cores 0 and 1 to the container
docker run -d --cpuset-cpus=0,1 nginx
```

## Memory Limits

Memory limits are equally important to prevent containers from consuming all available RAM.

### Memory Limit

The `--memory` or `-m` flag sets the maximum amount of memory a container can use.

```bash
# Limit container to 512MB of memory
docker run -d --memory=512m nginx
```

If a process inside the container tries to consume more memory than its limit, the Docker engine might terminate the process with an Out of Memory (OOM) error.

### Memory Reservation

The `--memory-reservation` flag sets a soft limit, which is activated when Docker detects memory contention.

```bash
# Set a soft limit of 256MB
docker run -d --memory=512m --memory-reservation=256m nginx
```

### Memory Swap

The `--memory-swap` flag sets the total amount of memory and swap that a container can use.

```bash
# Set 512MB memory limit and 512MB swap (1GB total)
docker run -d --memory=512m --memory-swap=1g nginx
```

If `--memory-swap` is set to `-1`, the container can use unlimited swap.

## I/O Limits

I/O operations can also be limited to prevent one container from monopolizing disk access.

### Block I/O Weight

The `--blkio-weight` flag sets the relative weight for block I/O operations. Values range from 10 to 1000.

```bash
# Set the block I/O weight to 500
docker run -d --blkio-weight=500 nginx
```

### Device Read/Write Rate

You can also limit read and write rates to specific devices:

```bash
# Limit read rate to 10MB per second and write to 5MB per second
docker run -d --device-read-bps=/dev/sda:10mb --device-write-bps=/dev/sda:5mb nginx
```

## Using Docker Compose with Resource Limits

For multi-container applications managed with Docker Compose, you can specify resource limits in your `docker-compose.yml` file:

```yaml
version: '3'
services:
  webapp:
    image: nginx
    deploy:
      resources:
        limits:
          cpus: '0.50'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 256M
```

## Practical Examples

Let's explore some real-world scenarios where resource limits are crucial.

### Example 1: Database Container

Databases often require predictable resources. Here's how you might configure a PostgreSQL container:

```bash
docker run -d \
  --name postgres-db \
  --cpus=2 \
  --memory=2g \
  --memory-reservation=1.5g \
  -e POSTGRES_PASSWORD=mysecretpassword \
  postgres:13
```

This ensures the database has access to 2 CPU cores and 2GB of memory, with a soft reservation of 1.5GB.

### Example 2: Web Application Stack

A typical web application might include a web server, application server, and database:

```yaml
version: '3'
services:
  nginx:
    image: nginx
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          memory: 128M
  
  app:
    image: my-app
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 512M
        reservations:
          memory: 256M
  
  db:
    image: postgres
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 1G
        reservations:
          memory: 512M
```

### Example 3: Monitoring Resource Usage

To monitor how a container is using resources, use the `docker stats` command:

```bash
docker stats [container_id or name]
```

This provides real-time information about CPU, memory, and network usage.

## Best Practices

1. **Benchmark your application**: Understand your application's resource needs before setting limits
2. **Start conservative**: Begin with moderate limits and adjust as needed
3. **Consider overhead**: Remember that the container runtime itself requires some resources
4. **Monitor regularly**: Use tools like `docker stats` or more advanced monitoring solutions
5. **Set both CPU and memory limits**: Don't focus on just one type of resource
6. **Test under load**: Simulate production conditions to ensure limits are appropriate

## Common Issues and Troubleshooting

### Container Termination (OOM Killer)

If your container is being terminated unexpectedly, check if it's hitting memory limits:

```bash
docker logs [container_id] 2>&1 | grep -i "out of memory"
```

### Performance Degradation

If performance is poor despite adequate limits, investigate if other containers or processes on the host are competing for resources.

### Swap Usage

Be careful with swap settings. While swap can prevent OOM issues, excessive swapping can severely impact performance.

## Resource Limits in Production

In production environments, you might want to use container orchestration platforms like Kubernetes, which offer more advanced resource management:

```yaml
# Kubernetes example
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: nginx
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

## Summary

Setting appropriate resource limits for Docker containers is essential for maintaining application performance and stability. By controlling CPU, memory, and I/O usage, you can prevent resource contention issues and create more predictable environments.

Remember that resource limits should be part of a broader performance optimization strategy that includes proper application design, efficient container images, and regular monitoring.

## Additional Resources

- Explore Docker's official documentation on [resource constraints](https://docs.docker.com/config/containers/resource_constraints/)
- Learn about advanced monitoring tools like Prometheus and Grafana
- Practice setting up a multi-container application with various resource profiles to observe behavior under different conditions

## Exercises

1. Create a simple web application and experiment with different CPU limits to observe performance differences
2. Set up a container with memory limits and write a script that gradually increases memory usage until it hits the limit
3. Use Docker Compose to create a three-container application with appropriate resource limits for each service
4. Monitor container resource usage with `docker stats` and observe how changes in workload affect utilization