---
title: "Drone CI: Continuous Integration for Modern Development"
description: "Learn how to use Drone CI to automate your software testing and deployment workflows with this beginner-friendly guide."

---

# Drone CI

## Introduction

Drone CI is an open-source, container-native continuous integration and delivery platform designed to automate your software testing and deployment workflows. Unlike traditional CI/CD tools, Drone executes each step of your build process in isolated Docker containers, providing consistency, portability, and security for your pipelines.

In this guide, we'll explore how Drone CI works, how to set it up, and how to create effective pipelines for your projects. By the end, you'll understand how to leverage Drone CI to automate your software delivery process effectively.

## What is Drone CI?

Drone CI was created in 2012 and has since grown to become a popular choice for development teams looking for a lightweight, easy-to-use CI/CD solution. Some key features of Drone include:

- **Container-native**: Every build step runs in its own Docker container
- **Simple configuration**: Pipeline defined in a YAML file stored in your repository
- **Plugin ecosystem**: Extensive library of pre-built plugins for common tasks
- **Scalable architecture**: Can be deployed on a single server or across a cluster
- **Multi-platform support**: Runs on Linux, Windows, and macOS
- **Built-in secrets management**: Securely handle sensitive information

## How Drone CI Works

Drone CI operates using a simple yet powerful concept: it converts your CI/CD pipeline into a series of container-based steps. Here's a high-level overview of how Drone works:

```mermaid
graph TD
    A[Code Commit] --> B[Webhook Trigger]
    B --> C[Drone Server]
    C --> D[Parse .drone.yml]
    D --> E[Create Pipeline]
    E --> F[Execute Steps in Containers]
    F --> G[Report Results]
    G --> H[Success/Failure Notification]
```

1. A developer commits code to the repository
2. The repository's webhook notifies the Drone server of the change
3. Drone pulls the code and reads the `.drone.yml` configuration file
4. Based on the configuration, Drone creates a pipeline of steps
5. Each step runs in its own Docker container
6. Results are collected and reported
7. Success or failure notifications are sent

## Setting Up Drone CI

### Prerequisites

Before we begin, make sure you have:

- Docker installed on your machine
- A Git repository (GitHub, GitLab, Bitbucket, etc.)
- Basic understanding of YAML syntax

### Installation

The easiest way to get started with Drone is using Docker Compose. Create a `docker-compose.yml` file with the following content:

```yaml
version: '3'

services:
  drone-server:
    image: drone/drone:2
    ports:
      - 80:80
      - 443:443
    volumes:
      - /var/lib/drone:/data
    environment:
      - DRONE_GITHUB_CLIENT_ID=${DRONE_GITHUB_CLIENT_ID}
      - DRONE_GITHUB_CLIENT_SECRET=${DRONE_GITHUB_CLIENT_SECRET}
      - DRONE_RPC_SECRET=${DRONE_RPC_SECRET}
      - DRONE_SERVER_HOST=${DRONE_SERVER_HOST}
      - DRONE_SERVER_PROTO=https
      - DRONE_TLS_AUTOCERT=true

  drone-runner:
    image: drone/drone-runner-docker:1
    command: daemon
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - DRONE_RPC_PROTO=https
      - DRONE_RPC_HOST=${DRONE_SERVER_HOST}
      - DRONE_RPC_SECRET=${DRONE_RPC_SECRET}
      - DRONE_RUNNER_CAPACITY=2
      - DRONE_RUNNER_NAME=${HOSTNAME}
```

Before starting the services, you need to set up the environment variables:

```bash
export DRONE_GITHUB_CLIENT_ID=your-github-client-id
export DRONE_GITHUB_CLIENT_SECRET=your-github-client-secret
export DRONE_RPC_SECRET=$(openssl rand -hex 16)
export DRONE_SERVER_HOST=drone.your-domain.com
```

Then start the services:

```bash
docker-compose up -d
```

### Configuring OAuth

To use Drone with GitHub (or other Git providers), you need to:

1. Register a new OAuth application in your GitHub account settings
2. Set the homepage URL to your Drone server address (e.g., `https://drone.your-domain.com`)
3. Set the authorization callback URL to `https://drone.your-domain.com/login`
4. Use the generated Client ID and Client Secret in your Drone configuration

## Creating Your First Pipeline

A Drone pipeline is defined in a `.drone.yml` file at the root of your repository. Here's a simple example for a Node.js application:

```yaml
kind: pipeline
type: docker
name: default

steps:
  - name: install
    image: node:14
    commands:
      - npm install

  - name: test
    image: node:14
    commands:
      - npm test

  - name: build
    image: node:14
    commands:
      - npm run build
```

Let's break down this configuration:

- `kind: pipeline`: Defines that this is a Drone pipeline configuration
- `type: docker`: Specifies that we're using Docker containers
- `name: default`: Names our pipeline "default"
- `steps`: A list of steps to execute in sequence
  - Each step has a name, Docker image, and commands to run

When you push this file to your repository, Drone will automatically detect it and run the defined pipeline whenever changes are made.

## Advanced Pipeline Features

### Conditional Execution

You can make steps run only under certain conditions:

```yaml
steps:
  - name: deploy
    image: plugins/s3
    settings:
      bucket: my-bucket
      access_key: ${AWS_ACCESS_KEY}
      secret_key: ${AWS_SECRET_KEY}
    when:
      branch: main
```

This step will only run when changes are pushed to the `main` branch.

### Parallel Steps

You can run steps in parallel by defining them at the same level with the `depends_on` property:

```yaml
steps:
  - name: test-unit
    image: node:14
    commands:
      - npm run test:unit

  - name: test-integration
    image: node:14
    commands:
      - npm run test:integration

  - name: build
    image: node:14
    commands:
      - npm run build
    depends_on:
      - test-unit
      - test-integration
```

In this example, `test-unit` and `test-integration` run in parallel, and `build` runs only after both tests have passed.

### Using Plugins

Drone has a rich ecosystem of plugins for common tasks. For example, to send a Slack notification:

```yaml
steps:
  - name: notify
    image: plugins/slack
    settings:
      webhook: https://hooks.slack.com/services/...
      channel: builds
      template: >
        Build {{build.number}} {{build.status}} for {{repo.name}}
        {{build.link}}
```

### Working with Secrets

For sensitive information like API keys and passwords, Drone provides secrets management:

1. Add a secret via the Drone UI or CLI:

```bash
drone secret add --repository myorg/myrepo --name aws_key --data AKIAIOSFODNN7EXAMPLE
```

2. Reference it in your pipeline:

```yaml
steps:
  - name: deploy
    image: plugins/s3
    settings:
      bucket: my-bucket
      access_key:
        from_secret: aws_key
      secret_key:
        from_secret: aws_secret
```

## Real-World Example: Full CI/CD Pipeline for a React Application

Let's look at a comprehensive example for a React application that includes testing, building, and deploying to AWS S3:

```yaml
kind: pipeline
type: docker
name: react-app-pipeline

steps:
  - name: install
    image: node:16
    commands:
      - npm ci

  - name: lint
    image: node:16
    commands:
      - npm run lint
    depends_on:
      - install

  - name: test
    image: node:16
    commands:
      - npm test -- --coverage
    depends_on:
      - install

  - name: build
    image: node:16
    commands:
      - npm run build
    depends_on:
      - lint
      - test

  - name: deploy-staging
    image: plugins/s3
    settings:
      bucket: my-app-staging
      acl: public-read
      region: us-west-2
      source: build/**/*
      target: /
      access_key:
        from_secret: aws_access_key
      secret_key:
        from_secret: aws_secret_key
    when:
      branch: develop
    depends_on:
      - build

  - name: deploy-production
    image: plugins/s3
    settings:
      bucket: my-app-production
      acl: public-read
      region: us-west-2
      source: build/**/*
      target: /
      access_key:
        from_secret: aws_access_key
      secret_key:
        from_secret: aws_secret_key
    when:
      branch: main
    depends_on:
      - build

  - name: notify
    image: plugins/slack
    settings:
      webhook:
        from_secret: slack_webhook
      channel: deployments
      template: >
        {{#success build.status}}
          ✅ Build #{{build.number}} of `{{repo.name}}` succeeded!
        {{else}}
          ❌ Build #{{build.number}} of `{{repo.name}}` failed!
        {{/success}}
        Build: {{build.link}}
    depends_on:
      - deploy-staging
      - deploy-production
    when:
      status:
        - success
        - failure
```

This pipeline:
1. Installs dependencies
2. Runs linting and tests in parallel
3. Builds the application if tests and linting pass
4. Deploys to a staging environment if on the `develop` branch
5. Deploys to production if on the `main` branch
6. Sends a Slack notification about the build result

## Drone CI vs. Other CI/CD Tools

How does Drone compare to other popular CI/CD solutions?

| Feature | Drone CI | Jenkins | GitHub Actions | GitLab CI |
|---------|----------|---------|---------------|-----------|
| Configuration | YAML in repo | Jenkinsfile/UI | YAML in repo | YAML in repo |
| Architecture | Container-native | Plugin-based | Container/VM | Container/VM |
| Setup Complexity | Low | High | Very Low | Low |
| Customization | High (plugins) | Very High | High | High |
| Self-hosting | Yes | Yes | No | Yes (with GitLab) |
| Cloud Option | Yes | 3rd party | Yes | Yes |
| Learning Curve | Gentle | Steep | Gentle | Moderate |

Drone CI particularly shines for teams that:
- Already use Docker in their workflow
- Need a lightweight, self-hosted solution
- Prefer simple configuration over complex customization
- Want isolated, reproducible build environments

## Best Practices for Drone CI

To get the most out of Drone CI, consider these best practices:

1. **Keep pipelines simple**: Break complex processes into smaller, manageable steps
2. **Use caching**: Cache dependencies between builds to speed up execution
```yaml
steps:
  - name: restore-cache
    image: drillster/drone-volume-cache
    volumes:
      - name: cache
        path: /cache
    settings:
      restore: true
      mount:
        - ./node_modules
```

3. **Parameterize your pipelines**: Use environment variables and secrets for configuration
4. **Implement proper testing**: Include unit, integration, and end-to-end tests
5. **Set up notifications**: Keep the team informed about build statuses
6. **Monitor pipeline performance**: Regularly review and optimize slow steps
7. **Use official images**: Prefer official Docker images for reliability
8. **Document your pipeline**: Comment your `.drone.yml` file for better maintainability

## Troubleshooting Common Issues

### Pipeline Not Triggering

If your pipeline isn't triggering when you push code:
- Check that the webhook is properly configured
- Verify that the repository is activated in Drone
- Ensure your `.drone.yml` file is valid

### Build Failures

For failing builds:
- Check the logs for specific error messages
- Verify that your Docker images are compatible
- Test your commands locally in Docker containers
- Ensure environment variables and secrets are properly set

### Performance Issues

If builds are slow:
- Use caching for dependencies
- Run steps in parallel when possible
- Use lightweight Docker images
- Remove unnecessary steps

## Summary

Drone CI offers a modern, container-based approach to continuous integration and delivery that is both powerful and easy to use. With its simple YAML configuration, extensive plugin ecosystem, and scalable architecture, Drone is an excellent choice for teams looking to streamline their development workflows.

By following the examples and best practices in this guide, you can set up efficient CI/CD pipelines that automate your testing, building, and deployment processes, helping you deliver high-quality software faster and more reliably.

## Additional Resources

- [Official Drone CI Documentation](https://docs.drone.io/)
- [Drone CI GitHub Repository](https://github.com/harness/drone)
- [Drone Plugins Registry](https://plugins.drone.io/)

## Exercises

1. **Basic Setup**: Install Drone CI locally using Docker Compose and connect it to a Git repository.
2. **Simple Pipeline**: Create a basic `.drone.yml` file for a simple application that runs tests and builds the code.
3. **Parallel Steps**: Modify your pipeline to run tests in parallel and build only if all tests pass.
4. **Conditional Deployment**: Add a deployment step that only runs when changes are pushed to the main branch.
5. **Notifications**: Configure your pipeline to send notifications when builds succeed or fail.
6. **Advanced Project**: Create a complete CI/CD pipeline for a web application that includes testing, building, and deploying to a staging and production environment.