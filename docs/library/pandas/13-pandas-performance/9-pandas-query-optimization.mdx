---
title: "Pandas Query Optimization"
description: "Learn how to optimize pandas queries for better performance in your data analysis workflows"

---

# Pandas Query Optimization

## Introduction

Working with large datasets in pandas can sometimes lead to sluggish performance if your code isn't optimized. Query optimization in pandas involves writing more efficient code to perform data operations faster and with less memory consumption. This guide will help you understand common performance bottlenecks and teach you techniques to make your pandas code run more efficiently.

Whether you're filtering, grouping, or aggregating data, the way you structure your queries can dramatically impact performance. Let's explore how to optimize pandas queries to speed up your data analysis workflows.

## Why Query Optimization Matters

Before diving into optimization techniques, let's understand why it matters:

- **Saves time**: Optimized queries can run orders of magnitude faster
- **Reduces memory usage**: Well-structured operations use less RAM
- **Improves scalability**: Makes working with larger datasets possible
- **Enhances productivity**: Less waiting means more analyzing

## Common Performance Bottlenecks

### 1. Inefficient Filtering

One of the most common operations in pandas is filtering data. Let's look at different ways to filter and their performance implications:

```python
import pandas as pd
import numpy as np
import time

# Create a sample DataFrame
df = pd.DataFrame({
    'A': np.random.randint(0, 100, size=1000000),
    'B': np.random.randint(0, 100, size=1000000),
    'C': np.random.randint(0, 100, size=1000000)
})

# Method 1: Using bracket notation
start = time.time()
result1 = df[df['A'] > 50]
print(f"Bracket notation: {time.time() - start:.5f} seconds")

# Method 2: Using .query() method
start = time.time()
result2 = df.query('A > 50')
print(f"Query method: {time.time() - start:.5f} seconds")

# Method 3: Using .loc accessor
start = time.time()
result3 = df.loc[df['A'] > 50]
print(f"Loc accessor: {time.time() - start:.5f} seconds")
```

Output might look like:
```
Bracket notation: 0.02521 seconds
Query method: 0.01854 seconds
Loc accessor: 0.02498 seconds
```

The `.query()` method is often faster for complex filtering operations, especially when you have multiple conditions.

### 2. Loops vs Vectorized Operations

Pandas is built on NumPy, which performs vectorized operations very efficiently. Avoid using loops when possible:

```python
# Create a small sample DataFrame
df = pd.DataFrame({
    'A': range(1000),
    'B': range(1000)
})

# Slow: Using a loop
start = time.time()
for i in range(len(df)):
    df.loc[i, 'C'] = df.loc[i, 'A'] + df.loc[i, 'B']
print(f"Loop approach: {time.time() - start:.5f} seconds")

# Reset DataFrame
df = pd.DataFrame({
    'A': range(1000),
    'B': range(1000)
})

# Fast: Using vectorized operation
start = time.time()
df['C'] = df['A'] + df['B']
print(f"Vectorized approach: {time.time() - start:.5f} seconds")
```

Output:
```
Loop approach: 0.35401 seconds
Vectorized approach: 0.00104 seconds
```

The vectorized approach is dramatically faster because it processes data in bulk rather than row-by-row.

## Key Optimization Techniques

### 1. Use Efficient Data Types

Pandas automatically assigns data types when you create a DataFrame, but these might not be optimal for performance. Using appropriate data types can save memory and improve speed.

```python
# Create a DataFrame with mixed types
df = pd.DataFrame({
    'id': range(1000000),
    'value': np.random.randn(1000000),
    'category': np.random.choice(['A', 'B', 'C'], size=1000000),
    'flag': np.random.choice([True, False], size=1000000)
})

# Check memory usage
print(f"Initial memory usage: {df.memory_usage().sum() / 1e6:.2f} MB")

# Optimize data types
df['id'] = df['id'].astype('int32')  # Reduce from int64 to int32
df['category'] = df['category'].astype('category')  # Convert strings to category type

# Check memory usage after optimization
print(f"Optimized memory usage: {df.memory_usage().sum() / 1e6:.2f} MB")
```

Output:
```
Initial memory usage: 32.00 MB
Optimized memory usage: 24.00 MB
```

### 2. Use `query()` for Complex Filtering

For complex filtering conditions, the `.query()` method can be more readable and sometimes faster:

```python
df = pd.DataFrame({
    'A': np.random.randint(0, 100, size=1000000),
    'B': np.random.randint(0, 100, size=1000000),
    'C': np.random.randint(0, 100, size=1000000)
})

# Less efficient
start = time.time()
result1 = df[(df['A'] > 50) & (df['B'] < 25) | (df['C'] == 10)]
print(f"Standard filtering: {time.time() - start:.5f} seconds")

# More efficient
start = time.time()
result2 = df.query('(A > 50 & B < 25) | (C == 10)')
print(f"Query filtering: {time.time() - start:.5f} seconds")
```

### 3. Use `eval()` for Arithmetic Operations

The `.eval()` method can perform complex arithmetic operations efficiently:

```python
df = pd.DataFrame({
    'A': np.random.randn(1000000),
    'B': np.random.randn(1000000),
    'C': np.random.randn(1000000),
    'D': np.random.randn(1000000)
})

# Standard approach
start = time.time()
result1 = df['A'] + df['B'] * df['C'] - df['D']
print(f"Standard arithmetic: {time.time() - start:.5f} seconds")

# Using eval()
start = time.time()
result2 = df.eval('A + B * C - D')
print(f"Eval arithmetic: {time.time() - start:.5f} seconds")
```

### 4. Use `apply()` Wisely

The `.apply()` method is convenient but can be slow. Use it only when vectorized operations aren't possible:

```python
df = pd.DataFrame({
    'text': ['hello world', 'pandas is fast', 'optimization is key', 
             'python rocks', 'data science'] * 100000
})

# Slow: apply with a lambda function
start = time.time()
df['word_count1'] = df['text'].apply(lambda x: len(x.split()))
print(f"Apply method: {time.time() - start:.5f} seconds")

# Fast: vectorized string method
start = time.time()
df['word_count2'] = df['text'].str.split().str.len()
print(f"Vectorized string method: {time.time() - start:.5f} seconds")
```

### 5. Choose the Right Merge Strategy

When combining datasets, choosing the right merge strategy can save time:

```python
# Create sample dataframes
df1 = pd.DataFrame({
    'key': np.random.choice(['A', 'B', 'C', 'D', 'E'], size=1000000),
    'value1': np.random.randn(1000000)
})

df2 = pd.DataFrame({
    'key': ['A', 'B', 'C', 'D', 'E'],
    'value2': np.random.randn(5)
})

# Using merge (potentially slower for this case)
start = time.time()
result1 = pd.merge(df1, df2, on='key')
print(f"Merge method: {time.time() - start:.5f} seconds")

# Using map (faster for this specific case)
start = time.time()
df1_copy = df1.copy()
df1_copy['value2'] = df1_copy['key'].map(df2.set_index('key')['value2'])
print(f"Map method: {time.time() - start:.5f} seconds")
```

## Real-World Application Example

Let's put these techniques together in a practical example. Imagine we're analyzing a dataset of e-commerce transactions:

```python
# Create a sample e-commerce dataset
np.random.seed(42)
n = 1000000

# Generate data
dates = pd.date_range('2022-01-01', periods=n//1000, freq='H').repeat(1000)
customer_ids = np.random.randint(1, 10000, size=n)
product_ids = np.random.randint(1, 1000, size=n)
categories = np.random.choice(['Electronics', 'Clothing', 'Food', 'Books', 'Home'], size=n)
prices = np.random.uniform(10, 1000, size=n).round(2)
quantities = np.random.randint(1, 10, size=n)

# Create DataFrame
transactions = pd.DataFrame({
    'date': dates,
    'customer_id': customer_ids,
    'product_id': product_ids,
    'category': categories,
    'price': prices,
    'quantity': quantities
})

# Calculate total sales amount
transactions['total'] = transactions['price'] * transactions['quantity']

# Inefficient approach to find high-value electronics transactions
start = time.time()
high_value = transactions[
    (transactions['category'] == 'Electronics') & 
    (transactions['total'] > 500)
].copy()
high_value['month'] = high_value['date'].dt.month
result1 = high_value.groupby('month')['total'].sum()
print(f"Standard approach: {time.time() - start:.5f} seconds")

# Optimized approach
start = time.time()
# Use query() for filtering
# Use eval() for calculation
# Convert category to categorical type first
transactions['category'] = transactions['category'].astype('category')
result2 = (transactions
           .query('category == "Electronics" and price * quantity > 500')
           .assign(month=lambda x: x['date'].dt.month)
           .groupby('month')['total']
           .sum())
print(f"Optimized approach: {time.time() - start:.5f} seconds")
```

## Advanced Optimization Techniques

### Use Chunking for Very Large Datasets

When dealing with datasets that don't fit into memory, process them in chunks:

```python
# Example of reading and processing a large CSV in chunks
chunk_size = 100000
result = []

for chunk in pd.read_csv('large_file.csv', chunksize=chunk_size):
    # Process each chunk
    processed = chunk.query('value > 0').groupby('category').sum()
    result.append(processed)

# Combine results
final_result = pd.concat(result)
final_result = final_result.groupby(level=0).sum()
```

### Use Appropriate Indexing

Indexes can speed up operations like `.loc` access, merging, and grouping:

```python
# Without index
df = pd.DataFrame({
    'id': range(1000000),
    'value': np.random.randn(1000000)
})

start = time.time()
for _ in range(1000):
    value = df.loc[df['id'] == 500000, 'value'].iloc[0]
print(f"Without index: {time.time() - start:.5f} seconds")

# With index
df_indexed = df.set_index('id')
start = time.time()
for _ in range(1000):
    value = df_indexed.loc[500000, 'value']
print(f"With index: {time.time() - start:.5f} seconds")
```

## Summary

In this guide, we've explored various techniques to optimize pandas queries:

1. **Use efficient data types** - Especially category type for strings and smaller integer types when possible
2. **Employ vectorized operations** - Avoid loops in favor of pandas' built-in vectorized methods
3. **Use `.query()` and `.eval()`** - For complex filtering and calculations
4. **Choose appropriate merge strategies** - Use `.map()` when applicable
5. **Apply proper indexing** - For faster data lookup
6. **Process large data in chunks** - When data doesn't fit in memory

Implementing these optimization techniques will significantly speed up your pandas data processing workflows and allow you to work with larger datasets more efficiently.

## Additional Resources

- [Official Pandas Documentation on Enhancing Performance](https://pandas.pydata.org/pandas-docs/stable/user_guide/enhancingperf.html)
- [Python Data Science Handbook](https://jakevdp.github.io/PythonDataScienceHandbook/)
- [Modern Pandas Series by Tom Augspurger](https://tomaugspurger.github.io/modern-1-intro)

## Practice Exercises

1. Take a dataset of your choice and apply at least three optimization techniques discussed in this guide.
2. Compare the execution time between standard pandas operations and their optimized counterparts.
3. Experiment with different data types to see their impact on memory usage.
4. Try to optimize a data processing pipeline that involves filtering, grouping, and aggregating data.