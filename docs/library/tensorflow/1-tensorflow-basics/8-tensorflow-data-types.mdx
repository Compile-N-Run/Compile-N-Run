---
title: TensorFlow Data Types
description: Learn about different data types in TensorFlow, how to work with them, and when to use specific types for optimal model performance.

---

# TensorFlow Data Types

## Introduction

TensorFlow operates on tensors, which are multi-dimensional arrays with a uniform data type. Understanding the various data types available in TensorFlow is essential for building efficient and accurate machine learning models. Different data types can affect memory usage, computation speed, and numerical precision of your models.

In this tutorial, we'll explore the fundamental data types in TensorFlow, how to specify them, and best practices for working with them in your machine learning projects.

## Basic TensorFlow Data Types

TensorFlow provides several built-in data types that correspond roughly to NumPy data types. Here's an overview of the most commonly used ones:

```python
import tensorflow as tf
import numpy as np

# Display TensorFlow version
print(f"TensorFlow version: {tf.__version__}")
```

The primary data types in TensorFlow include:

### Numeric Data Types

| Data Type | Description | Python Type |
|-----------|-------------|-------------|
| `tf.float32` | 32-bit floating-point | `float` |
| `tf.float64` | 64-bit floating-point | `float` |
| `tf.int8` | 8-bit signed integer | `int` |
| `tf.int16` | 16-bit signed integer | `int` |
| `tf.int32` | 32-bit signed integer | `int` |
| `tf.int64` | 64-bit signed integer | `int` |
| `tf.uint8` | 8-bit unsigned integer | `int` |
| `tf.uint16` | 16-bit unsigned integer | `int` |
| `tf.uint32` | 32-bit unsigned integer | `int` |
| `tf.uint64` | 64-bit unsigned integer | `int` |

### Non-numeric Data Types

| Data Type | Description |
|-----------|-------------|
| `tf.bool` | Boolean |
| `tf.string` | String |
| `tf.complex64` | Complex number with float32 real and imaginary parts |
| `tf.complex128` | Complex number with float64 real and imaginary parts |

## Creating Tensors with Specific Data Types

You can specify the data type when creating tensors using the `dtype` parameter:

```python
# Creating tensors with specific data types
float_tensor = tf.constant([1.0, 2.0, 3.0], dtype=tf.float32)
int_tensor = tf.constant([1, 2, 3], dtype=tf.int32)
bool_tensor = tf.constant([True, False, True], dtype=tf.bool)
string_tensor = tf.constant(["TensorFlow", "Data", "Types"], dtype=tf.string)

# Display the tensors and their data types
print(f"Float tensor: {float_tensor}, dtype: {float_tensor.dtype}")
print(f"Int tensor: {int_tensor}, dtype: {int_tensor.dtype}")
print(f"Bool tensor: {bool_tensor}, dtype: {bool_tensor.dtype}")
print(f"String tensor: {string_tensor}, dtype: {string_tensor.dtype}")
```

**Output:**
```
Float tensor: [1. 2. 3.], dtype: float32
Int tensor: [1 2 3], dtype: int32
Bool tensor: [ True False  True], dtype: bool
String tensor: [b'TensorFlow' b'Data' b'Types'], dtype: string
```

## Converting Between Data Types

You can convert between different data types using the `tf.cast()` function:

```python
# Convert float tensor to int32
float_tensor = tf.constant([1.7, 2.3, 3.9])
int_tensor = tf.cast(float_tensor, dtype=tf.int32)
print(f"Original: {float_tensor} -> Converted: {int_tensor}")

# Convert int tensor to float32
int_tensor = tf.constant([1, 2, 3])
float_tensor = tf.cast(int_tensor, dtype=tf.float32)
print(f"Original: {int_tensor} -> Converted: {float_tensor}")

# Convert boolean to int
bool_tensor = tf.constant([True, False, True])
int_tensor = tf.cast(bool_tensor, dtype=tf.int32)
print(f"Original: {bool_tensor} -> Converted: {int_tensor}")
```

**Output:**
```
Original: [1.7 2.3 3.9] -> Converted: [1 2 3]
Original: [1 2 3] -> Converted: [1. 2. 3.]
Original: [ True False  True] -> Converted: [1 0 1]
```

## Default Data Types

TensorFlow has default data types for different operations. For instance, floating-point operations typically use `tf.float32` by default:

```python
# Default data type for floating-point values
tensor1 = tf.constant([1.0, 2.0, 3.0])  # tf.float32 by default
print(f"Default float tensor dtype: {tensor1.dtype}")

# Default data type for integer values
tensor2 = tf.constant([1, 2, 3])  # tf.int32 by default
print(f"Default int tensor dtype: {tensor2.dtype}")
```

**Output:**
```
Default float tensor dtype: float32
Default int tensor dtype: int32
```

## Data Type Implications for Machine Learning

The choice of data type can significantly impact your model's:

1. **Memory usage**: Lower precision types (e.g., `tf.float16`) use less memory
2. **Computation speed**: Lower precision calculations are generally faster
3. **Numerical accuracy**: Higher precision types provide better numerical stability

### Example: Memory Usage Comparison

```python
import sys

# Create tensors with different data types
float16_tensor = tf.ones((100, 100), dtype=tf.float16)
float32_tensor = tf.ones((100, 100), dtype=tf.float32)
float64_tensor = tf.ones((100, 100), dtype=tf.float64)

# Convert to NumPy to check memory usage
float16_np = float16_tensor.numpy()
float32_np = float32_tensor.numpy()
float64_np = float64_tensor.numpy()

# Display memory usage
print(f"Memory usage for 100x100 tensor:")
print(f"- float16: {float16_np.nbytes / 1024:.2f} KB")
print(f"- float32: {float32_np.nbytes / 1024:.2f} KB")
print(f"- float64: {float64_np.nbytes / 1024:.2f} KB")
```

**Output:**
```
Memory usage for 100x100 tensor:
- float16: 19.53 KB
- float32: 39.06 KB
- float64: 78.12 KB
```

## Practical Example: Mixed Precision Training

Mixed precision training uses lower precision formats (`tf.float16`) for some operations to speed up training while maintaining model accuracy. This is especially useful for large models and GPU training.

```python
import tensorflow as tf

# Enable mixed precision
policy = tf.keras.mixed_precision.Policy('mixed_float16')
tf.keras.mixed_precision.set_global_policy(policy)

# Check the current policy
print(f"Global policy: {tf.keras.mixed_precision.global_policy()}")

# Create a simple model with mixed precision
model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(784,)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(10, activation='softmax')
])

# Check the compute and variable dtypes
print(f"Compute dtype: {model.compute_dtype}")
print(f"Variable dtype: {model.variable_dtype}")
```

**Output:**
```
Global policy: mixed_float16
Compute dtype: float16
Variable dtype: float32
```

## Data Type Compatibility

When performing operations between tensors, TensorFlow follows type promotion rules similar to NumPy:

```python
# Type promotion examples
float32_tensor = tf.constant([1.0, 2.0], dtype=tf.float32)
int32_tensor = tf.constant([1, 2], dtype=tf.int32)

# Adding float32 and int32
result = float32_tensor + tf.cast(int32_tensor, dtype=tf.float32)
print(f"Result of adding float32 and int32: {result}, dtype: {result.dtype}")

# Multiplying float32 and int32
result = float32_tensor * tf.cast(int32_tensor, dtype=tf.float32)
print(f"Result of multiplying float32 and int32: {result}, dtype: {result.dtype}")
```

**Output:**
```
Result of adding float32 and int32: [2. 4.], dtype: float32
Result of multiplying float32 and int32: [1. 4.], dtype: float32
```

## Working with String Tensors

String tensors in TensorFlow have some special properties:

```python
# Create a string tensor
string_tensor = tf.constant(['Hello', 'TensorFlow', 'World'])
print(f"String tensor: {string_tensor}")

# String operations
lengths = tf.strings.length(string_tensor)
print(f"String lengths: {lengths}")

# Join strings
joined = tf.strings.join([string_tensor, string_tensor], separator=' - ')
print(f"Joined strings: {joined}")

# Split strings
split = tf.strings.split(joined, sep=' - ')
print(f"Split result: {split}")
```

**Output:**
```
String tensor: [b'Hello' b'TensorFlow' b'World']
String lengths: [5 10 5]
Joined strings: [b'Hello - Hello' b'TensorFlow - TensorFlow' b'World - World']
Split result: <RaggedTensor [['Hello', 'Hello'], ['TensorFlow', 'TensorFlow'], ['World', 'World']]>
```

## Best Practices for TensorFlow Data Types

1. **Use `tf.float32` for most models**: It offers a good balance between precision and performance.
2. **Consider using mixed precision**: For large models on GPUs, mixed precision can significantly speed up training.
3. **Be consistent with data types**: Try to use the same data types throughout your model to avoid unnecessary conversions.
4. **Match input data types**: Ensure your input data matches the expected data types of your model.
5. **Be careful with type conversions**: Conversions between types may lead to information loss (e.g., float to int truncates).

## Summary

In this tutorial, we've covered:

- The most common data types available in TensorFlow
- How to create tensors with specific data types
- Converting between different data types
- Default data types in TensorFlow
- The impact of data types on model performance and memory usage
- Working with mixed precision
- Best practices for using data types in TensorFlow

Understanding TensorFlow data types is essential for optimizing your models' performance and ensuring numerical stability. By choosing the appropriate data types for your specific use case, you can improve your model's speed, accuracy, and memory efficiency.

## Additional Resources

- [TensorFlow Data Types Documentation](https://www.tensorflow.org/api_docs/python/tf/dtypes)
- [Mixed Precision Training Guide](https://www.tensorflow.org/guide/mixed_precision)
- [NumPy Data Types](https://numpy.org/doc/stable/reference/arrays.dtypes.html) (for comparison)

## Exercises

1. Create tensors with different data types and observe their properties.
2. Experiment with mixed precision training on a simple neural network.
3. Investigate the memory usage of different data types for a large tensor.
4. Try operations between tensors with different data types and observe the automatic type conversion.
5. Benchmark the training speed difference between `float32` and `float16` on a simple model.