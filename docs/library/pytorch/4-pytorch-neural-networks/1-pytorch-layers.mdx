---
title: PyTorch Layers
description: Learn about the various neural network layers available in PyTorch, how they work, and how to use them in your deep learning models.

---

# PyTorch Layers

## Introduction

Layers are the building blocks of neural networks in PyTorch. They define the transformations that your data undergoes as it passes through the network. PyTorch provides a variety of pre-implemented layers in the `torch.nn` module that make it easy to build complex neural network architectures without having to implement the mathematical operations from scratch.

In this tutorial, we'll explore the most common types of layers in PyTorch, understand how they work, and learn how to use them effectively in your neural network models.

## Basic Concept of Layers

A layer in a neural network is a function that takes some input, applies a transformation to it, and produces an output. Layers in PyTorch are implemented as classes that inherit from `torch.nn.Module`. Each layer has parameters (weights and biases) that are learned during training.

## Common Types of PyTorch Layers

### Linear (Fully Connected) Layers

Linear layers, also known as fully connected or dense layers, apply a linear transformation to the input: `y = xW^T + b`, where `W` and `b` are learnable parameters.

```python
import torch
import torch.nn as nn

# Create a linear layer with 10 input features and 5 output features
linear_layer = nn.Linear(in_features=10, out_features=5)

# Create a random input tensor
input_tensor = torch.randn(3, 10)  # batch size of 3, 10 features

# Pass the input through the layer
output = linear_layer(input_tensor)

print(f"Input shape: {input_tensor.shape}")
print(f"Output shape: {output.shape}")
print(f"Layer weights shape: {linear_layer.weight.shape}")
print(f"Layer bias shape: {linear_layer.bias.shape}")
```

Output:
```
Input shape: torch.Size([3, 10])
Output shape: torch.Size([3, 5])
Layer weights shape: torch.Size([5, 10])
Layer bias shape: torch.Size([5])
```

### Convolutional Layers

Convolutional layers are designed to capture spatial patterns in data like images. They apply a set of learnable filters to the input.

```python
import torch
import torch.nn as nn

# Create a 2D convolutional layer
# 3 input channels, 16 output channels, 3x3 kernel
conv_layer = nn.Conv2d(in_channels=3, 
                       out_channels=16, 
                       kernel_size=3, 
                       stride=1, 
                       padding=1)

# Create a random input tensor (batch_size, channels, height, width)
input_image = torch.randn(1, 3, 32, 32)  # 1 image, 3 channels, 32x32 pixels

# Pass the input through the layer
output_feature_map = conv_layer(input_image)

print(f"Input shape: {input_image.shape}")
print(f"Output shape: {output_feature_map.shape}")
```

Output:
```
Input shape: torch.Size([1, 3, 32, 32])
Output shape: torch.Size([1, 16, 32, 32])
```

### Recurrent Layers

Recurrent layers are designed to work with sequential data by maintaining a hidden state that captures information from previous time steps.

```python
import torch
import torch.nn as nn

# Create an LSTM layer
lstm_layer = nn.LSTM(input_size=10, 
                     hidden_size=20, 
                     num_layers=1, 
                     batch_first=True)

# Create a random input tensor (batch_size, sequence_length, features)
input_sequence = torch.randn(5, 8, 10)  # 5 samples, 8 time steps, 10 features

# Pass the input through the layer
output, (hidden_state, cell_state) = lstm_layer(input_sequence)

print(f"Input shape: {input_sequence.shape}")
print(f"Output shape: {output.shape}")
print(f"Hidden state shape: {hidden_state.shape}")
print(f"Cell state shape: {cell_state.shape}")
```

Output:
```
Input shape: torch.Size([5, 8, 10])
Output shape: torch.Size([5, 8, 20])
Hidden state shape: torch.Size([1, 5, 20])
Cell state shape: torch.Size([1, 5, 20])
```

### Pooling Layers

Pooling layers reduce the spatial dimensions (height and width) of the input, which helps reduce computation and control overfitting.

```python
import torch
import torch.nn as nn

# Create a max pooling layer
max_pool = nn.MaxPool2d(kernel_size=2, stride=2)

# Create a random input tensor
input_feature_map = torch.randn(1, 16, 32, 32)

# Pass the input through the layer
output = max_pool(input_feature_map)

print(f"Input shape: {input_feature_map.shape}")
print(f"Output shape: {output.shape}")
```

Output:
```
Input shape: torch.Size([1, 16, 32, 32])
Output shape: torch.Size([1, 16, 16, 16])
```

### Normalization Layers

Normalization layers help stabilize and accelerate training by normalizing the inputs to each layer.

```python
import torch
import torch.nn as nn

# Create a batch normalization layer
batch_norm = nn.BatchNorm2d(num_features=16)

# Create a random input tensor
input_tensor = torch.randn(10, 16, 32, 32)

# Pass the input through the layer
output = batch_norm(input_tensor)

print(f"Input shape: {input_tensor.shape}")
print(f"Output shape: {output.shape}")
```

Output:
```
Input shape: torch.Size([10, 16, 32, 32])
Output shape: torch.Size([10, 16, 32, 32])
```

### Activation Layers

Activation layers apply non-linear functions to introduce non-linearity into the model, which allows the network to learn more complex patterns.

```python
import torch
import torch.nn as nn

# Create some common activation layers
relu = nn.ReLU()
sigmoid = nn.Sigmoid()
tanh = nn.Tanh()

# Create a random input tensor
input_tensor = torch.randn(5, 10)

# Pass the input through the activation layers
relu_output = relu(input_tensor)
sigmoid_output = sigmoid(input_tensor)
tanh_output = tanh(input_tensor)

print("ReLU output range:", relu_output.min().item(), "to", relu_output.max().item())
print("Sigmoid output range:", sigmoid_output.min().item(), "to", sigmoid_output.max().item())
print("Tanh output range:", tanh_output.min().item(), "to", tanh_output.max().item())
```

Output:
```
ReLU output range: 0.0 to 2.5
Sigmoid output range: 0.01 to 0.98
Tanh output range: -0.99 to 0.99
```

### Dropout Layers

Dropout randomly sets a fraction of input units to 0 at each update during training, which helps prevent overfitting.

```python
import torch
import torch.nn as nn

# Create a dropout layer with 50% dropout probability
dropout = nn.Dropout(p=0.5)

# Create a random input tensor
input_tensor = torch.ones(10, 10)  # All ones for clear demonstration

# Apply dropout (in training mode)
dropout.train()
output_train = dropout(input_tensor)

# Apply dropout (in evaluation mode)
dropout.eval()
output_eval = dropout(input_tensor)

print("Number of zeros in training output:", (output_train == 0).sum().item())
print("Number of zeros in evaluation output:", (output_eval == 0).sum().item())
```

Output:
```
Number of zeros in training output: ~50  # Approximate, will vary due to randomness
Number of zeros in evaluation output: 0
```

## Building a Neural Network with Multiple Layers

Now let's see how to combine these layers to build a complete neural network:

```python
import torch
import torch.nn as nn

class SimpleNN(nn.Module):
    def __init__(self):
        super(SimpleNN, self).__init__()
        
        # First convolutional block
        self.conv1 = nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1)
        self.bn1 = nn.BatchNorm2d(16)
        self.relu1 = nn.ReLU()
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)
        
        # Second convolutional block
        self.conv2 = nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, padding=1)
        self.bn2 = nn.BatchNorm2d(32)
        self.relu2 = nn.ReLU()
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)
        
        # Fully connected layers
        self.flatten = nn.Flatten()
        self.fc1 = nn.Linear(32 * 8 * 8, 128)
        self.relu3 = nn.ReLU()
        self.dropout = nn.Dropout(0.5)
        self.fc2 = nn.Linear(128, 10)  # 10 output classes
    
    def forward(self, x):
        # First block
        x = self.conv1(x)
        x = self.bn1(x)
        x = self.relu1(x)
        x = self.pool1(x)
        
        # Second block
        x = self.conv2(x)
        x = self.bn2(x)
        x = self.relu2(x)
        x = self.pool2(x)
        
        # Fully connected
        x = self.flatten(x)
        x = self.fc1(x)
        x = self.relu3(x)
        x = self.dropout(x)
        x = self.fc2(x)
        
        return x

# Create the model
model = SimpleNN()

# Create a random input
input_image = torch.randn(1, 3, 32, 32)  # 1 image, 3 channels, 32x32 pixels

# Pass input through the model
output = model(input_image)

print(f"Model input shape: {input_image.shape}")
print(f"Model output shape: {output.shape}")
print(f"Model architecture:\n{model}")
```

Output:
```
Model input shape: torch.Size([1, 3, 32, 32])
Model output shape: torch.Size([1, 10])
Model architecture:
SimpleNN(
  (conv1): Conv2d(3, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (bn1): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (relu1): ReLU()
  (pool1): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (conv2): Conv2d(16, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (bn2): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (relu2): ReLU()
  (pool2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (flatten): Flatten(start_dim=1, end_dim=-1)
  (fc1): Linear(in_features=2048, out_features=128, bias=True)
  (relu3): ReLU()
  (dropout): Dropout(p=0.5, inplace=False)
  (fc2): Linear(in_features=128, out_features=10, bias=True)
)
```

## Sequential Container

PyTorch provides the `nn.Sequential` container to simplify model definition when layers are applied in sequence:

```python
import torch
import torch.nn as nn

# Define a model using Sequential
model = nn.Sequential(
    nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1),
    nn.BatchNorm2d(16),
    nn.ReLU(),
    nn.MaxPool2d(kernel_size=2, stride=2),
    nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, padding=1),
    nn.BatchNorm2d(32),
    nn.ReLU(),
    nn.MaxPool2d(kernel_size=2, stride=2),
    nn.Flatten(),
    nn.Linear(32 * 8 * 8, 128),
    nn.ReLU(),
    nn.Dropout(0.5),
    nn.Linear(128, 10)
)

# Create a random input
input_image = torch.randn(1, 3, 32, 32)

# Pass input through the model
output = model(input_image)

print(f"Model input shape: {input_image.shape}")
print(f"Model output shape: {output.shape}")
print(f"Model architecture:\n{model}")
```

## Real-World Example: Image Classifier

Let's build a more practical example - a convolutional neural network for classifying CIFAR-10 images:

```python
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms

# Define the transforms for the training and test sets
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))
])

# Load CIFAR-10 dataset (example code - not executed here to save space)
# trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)
# trainloader = torch.utils.data.DataLoader(trainset, batch_size=4, shuffle=True)
# testset = torchvision.datasets.CIFAR10(root='./data', train=False, download=True, transform=transform)
# testloader = torch.utils.data.DataLoader(testset, batch_size=4, shuffle=False)

# Define the CNN architecture
class CIFAR10CNN(nn.Module):
    def __init__(self):
        super(CIFAR10CNN, self).__init__()
        # First convolutional block
        self.conv_block1 = nn.Sequential(
            nn.Conv2d(3, 32, kernel_size=3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(),
            nn.Conv2d(32, 32, kernel_size=3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        
        # Second convolutional block
        self.conv_block2 = nn.Sequential(
            nn.Conv2d(32, 64, kernel_size=3, padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU(),
            nn.Conv2d(64, 64, kernel_size=3, padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        
        # Third convolutional block
        self.conv_block3 = nn.Sequential(
            nn.Conv2d(64, 128, kernel_size=3, padding=1),
            nn.BatchNorm2d(128),
            nn.ReLU(),
            nn.MaxPool2d(kernel_size=2)
        )
        
        # Classifier
        self.classifier = nn.Sequential(
            nn.Flatten(),
            nn.Linear(128 * 4 * 4, 512),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(512, 10)
        )
    
    def forward(self, x):
        x = self.conv_block1(x)
        x = self.conv_block2(x)
        x = self.conv_block3(x)
        x = self.classifier(x)
        return x

# Initialize the model
model = CIFAR10CNN()

# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.9)

# Display model architecture
print(model)

# Training code would go here (not included to save space)
# For a complete training loop, refer to the PyTorch documentation or more advanced tutorials
```

## Custom Layers

You can also create custom layers by extending the `nn.Module` class:

```python
import torch
import torch.nn as nn
import torch.nn.functional as F

class CustomLayer(nn.Module):
    def __init__(self, in_features, out_features, bias=True):
        super(CustomLayer, self).__init__()
        self.weight = nn.Parameter(torch.Tensor(out_features, in_features))
        
        if bias:
            self.bias = nn.Parameter(torch.Tensor(out_features))
        else:
            self.register_parameter('bias', None)
            
        # Initialize weights and biases
        nn.init.kaiming_uniform_(self.weight)
        if self.bias is not None:
            nn.init.zeros_(self.bias)
    
    def forward(self, x):
        # Apply custom transformation
        x = F.linear(x, self.weight, self.bias)
        return torch.sigmoid(x) * x  # Custom activation: Sigmoid-weighted linear unit
    
# Create and test the custom layer
custom_layer = CustomLayer(10, 5)
input_tensor = torch.randn(3, 10)
output = custom_layer(input_tensor)

print(f"Input shape: {input_tensor.shape}")
print(f"Output shape: {output.shape}")
```

Output:
```
Input shape: torch.Size([3, 10])
Output shape: torch.Size([3, 5])
```

## Summary

In this tutorial, we've explored the most common types of layers in PyTorch:

1. **Linear (Fully Connected) Layers**: Transform input features through matrix multiplication
2. **Convolutional Layers**: Extract spatial features using sliding filters
3. **Recurrent Layers**: Process sequential data maintaining a hidden state
4. **Pooling Layers**: Reduce spatial dimensions to control computation and overfitting
5. **Normalization Layers**: Stabilize and accelerate training
6. **Activation Layers**: Add non-linearity to the model
7. **Dropout Layers**: Prevent overfitting by randomly zeroing elements

We also learned how to combine these layers to build neural networks, use the `nn.Sequential` container for cleaner code, and create custom layers.

Understanding these building blocks is fundamental to designing effective neural networks for various tasks in deep learning.

## Additional Resources

- [PyTorch Documentation on nn.Module](https://pytorch.org/docs/stable/nn.html)
- [PyTorch Documentation on nn.Linear](https://pytorch.org/docs/stable/generated/torch.nn.Linear.html)
- [PyTorch Documentation on nn.Conv2d](https://pytorch.org/docs/stable/generated/torch.nn.Conv2d.html)
- [PyTorch Documentation on nn.LSTM](https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html)

## Exercises

1. Create a neural network with at least one convolutional layer, one pooling layer, and two fully connected layers.
2. Implement a custom layer that applies a different activation function based on a condition.
3. Build a simple autoencoder using PyTorch layers to compress and reconstruct MNIST digits.
4. Create a recurrent neural network with LSTM layers for a text classification task.
5. Implement a residual block (as used in ResNet) using PyTorch layers.