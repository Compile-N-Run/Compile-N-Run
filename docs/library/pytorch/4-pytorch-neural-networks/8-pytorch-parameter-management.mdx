---
title: "PyTorch Parameter Management"
description: "Learn how to effectively manage parameters in PyTorch neural networks, including initialization, parameter access, sharing, and custom parameters."

---

# PyTorch Parameter Management

When building neural networks with PyTorch, understanding how to manage model parameters is crucial. Parameters are the learnable weights and biases that define your network's behavior. In this tutorial, we'll explore how PyTorch handles parameters and how you can efficiently work with them in your neural network projects.

## Introduction to Parameters in PyTorch

In PyTorch, parameters are special tensors that are automatically tracked by the framework for gradient computation during backpropagation. They are what your model learns during training. Parameters are typically initialized with random values and then optimized using gradient descent or other optimization algorithms.

Let's start with a basic example of a neural network layer and examine its parameters:

```python
import torch
import torch.nn as nn

# Create a simple linear layer
linear = nn.Linear(in_features=10, out_features=5)

# Print the layer
print(linear)
```

Output:
```
Linear(in_features=10, out_features=5, bias=True)
```

This creates a linear layer with 10 input features and 5 output features. This layer will have two sets of parameters: weights and biases.

## Accessing Parameters

PyTorch provides several ways to access the parameters of a model.

### The `parameters()` Method

The most common way to access parameters is through the `parameters()` method:

```python
# Access parameters as an iterator
params = linear.parameters()
print(type(params))

# Iterate through parameters
for param in linear.parameters():
    print(param.shape)
```

Output:
```
<class 'generator'>
torch.Size([5, 10])
torch.Size([5])
```

Here, we see that our linear layer has two parameters: a weight matrix of shape (5, 10) and a bias vector of shape (5).

### The `named_parameters()` Method

If you want to know the names of the parameters along with their values, you can use `named_parameters()`:

```python
for name, param in linear.named_parameters():
    print(f"Parameter name: {name}, Shape: {param.shape}")
```

Output:
```
Parameter name: weight, Shape: torch.Size([5, 10])
Parameter name: bias, Shape: torch.Size([5])
```

### Accessing Specific Parameters

You can directly access specific parameters using their attribute names:

```python
print(linear.weight.shape)
print(linear.bias.shape)
```

Output:
```
torch.Size([5, 10])
torch.Size([5])
```

## Parameter Initialization

Proper initialization of parameters is crucial for training deep networks effectively. PyTorch provides several ways to initialize parameters:

### Default Initialization

By default, PyTorch initializes parameters using the Kaiming uniform initialization for weights and zeros for biases:

```python
# Create a new linear layer
new_linear = nn.Linear(20, 30)

# Check the default initialization values
print(f"Weight stats: min={new_linear.weight.min().item():.4f}, max={new_linear.weight.max().item():.4f}")
print(f"Bias stats: min={new_linear.bias.min().item():.4f}, max={new_linear.bias.max().item():.4f}")
```

Output (values will vary due to random initialization):
```
Weight stats: min=-0.3034, max=0.2935
Bias stats: min=0.0000, max=0.0000
```

### Custom Initialization

You can initialize parameters with custom values using various initialization methods:

```python
import torch.nn.init as init

# Initialize weights with normal distribution
init.normal_(new_linear.weight, mean=0.0, std=0.01)

# Initialize bias with constant value
init.constant_(new_linear.bias, 0.1)

# Check the new initialization values
print(f"Weight stats after custom init: min={new_linear.weight.min().item():.4f}, max={new_linear.weight.max().item():.4f}")
print(f"Bias stats after custom init: min={new_linear.bias.min().item():.4f}, max={new_linear.bias.max().item():.4f}")
```

Output (values will vary due to random initialization):
```
Weight stats after custom init: min=-0.0318, max=0.0316
Bias stats after custom init: min=0.1000, max=0.1000
```

PyTorch offers several initialization functions:

- `init.uniform_`: Uniform distribution
- `init.normal_`: Normal distribution
- `init.kaiming_uniform_`: Kaiming uniform initialization
- `init.kaiming_normal_`: Kaiming normal initialization
- `init.xavier_uniform_`: Xavier/Glorot uniform initialization
- `init.xavier_normal_`: Xavier/Glorot normal initialization
- `init.constant_`: Constant value
- `init.ones_`: Initialize with ones
- `init.zeros_`: Initialize with zeros

## Creating a Custom Neural Network with Parameter Management

Let's build a simple neural network and explore parameter management in depth:

```python
class SimpleNN(nn.Module):
    def __init__(self, input_size, hidden_size, output_size):
        super(SimpleNN, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, output_size)
        
        # Initialize parameters
        init.kaiming_normal_(self.fc1.weight)
        init.constant_(self.fc1.bias, 0)
        init.kaiming_normal_(self.fc2.weight)
        init.constant_(self.fc2.bias, 0)
        
    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Create a model
model = SimpleNN(input_size=20, hidden_size=50, output_size=10)

# Count parameters
total_params = sum(p.numel() for p in model.parameters())
print(f"Total parameters: {total_params}")
```

Output:
```
Total parameters: 1560
```

## Parameter Groups for Optimization

When training models, you often want to apply different learning rates or optimization strategies to different parameter groups. PyTorch makes this easy:

```python
import torch.optim as optim

# Create optimizer with different learning rates for different parameter groups
optimizer = optim.SGD([
    {'params': model.fc1.parameters(), 'lr': 0.01},
    {'params': model.fc2.parameters(), 'lr': 0.001}
], momentum=0.9)

print(f"Optimizer parameter groups: {len(optimizer.param_groups)}")
print(f"Learning rate for fc1: {optimizer.param_groups[0]['lr']}")
print(f"Learning rate for fc2: {optimizer.param_groups[1]['lr']}")
```

Output:
```
Optimizer parameter groups: 2
Learning rate for fc1: 0.01
Learning rate for fc2: 0.001
```

## Parameter Sharing

Sometimes you want to share parameters between different parts of your model. This is common in architectures like Siamese networks or weight-tied autoencoders.

Let's create a simple example of parameter sharing:

```python
class SharedParamModel(nn.Module):
    def __init__(self, input_size, hidden_size):
        super(SharedParamModel, self).__init__()
        
        # Create a shared layer
        self.shared_layer = nn.Linear(input_size, hidden_size)
        
        # Output layers
        self.output1 = nn.Linear(hidden_size, 1)
        self.output2 = nn.Linear(hidden_size, 1)
        
    def forward_branch1(self, x):
        x = torch.relu(self.shared_layer(x))
        return self.output1(x)
    
    def forward_branch2(self, x):
        x = torch.relu(self.shared_layer(x))
        return self.output2(x)
    
    def forward(self, x):
        return self.forward_branch1(x), self.forward_branch2(x)

# Create model with shared parameters
shared_model = SharedParamModel(input_size=10, hidden_size=20)

# Count unique parameters
unique_params = {}
for name, param in shared_model.named_parameters():
    unique_params[param] = name

print(f"Total parameters: {len(list(shared_model.parameters()))}")
print(f"Unique parameters: {len(unique_params)}")
print("Parameter mapping:")
for param, name in unique_params.items():
    print(f"{name}: {param.shape}")
```

Output:
```
Total parameters: 6
Unique parameters: 6
Parameter mapping:
shared_layer.weight: torch.Size([20, 10])
shared_layer.bias: torch.Size([20])
output1.weight: torch.Size([1, 20])
output1.bias: torch.Size([1])
output2.weight: torch.Size([1, 20])
output2.bias: torch.Size([1])
```

## Custom Parameters with `nn.Parameter`

Sometimes you may want to create custom parameters that aren't part of standard PyTorch layers. You can do this using `nn.Parameter`:

```python
class CustomParamModel(nn.Module):
    def __init__(self, input_size):
        super(CustomParamModel, self).__init__()
        
        # Create a learnable weight vector
        self.weight = nn.Parameter(torch.randn(input_size))
        
        # Create a learnable scalar
        self.scale = nn.Parameter(torch.tensor(1.0))
        
        # Create a non-learnable tensor (not a parameter)
        self.register_buffer('running_mean', torch.zeros(input_size))
    
    def forward(self, x):
        # Update running mean (not for training, just as an example)
        with torch.no_grad():
            self.running_mean = 0.9 * self.running_mean + 0.1 * x.mean(0)
        
        # Apply custom parameters
        return self.scale * (x * self.weight - self.running_mean)

# Create model with custom parameters
custom_model = CustomParamModel(input_size=5)

# Check parameters and buffers
print("Parameters:")
for name, param in custom_model.named_parameters():
    print(f"{name}: {param.shape}, requires_grad={param.requires_grad}")

print("\nBuffers:")
for name, buffer in custom_model.named_buffers():
    print(f"{name}: {buffer.shape}, requires_grad={buffer.requires_grad}")
```

Output:
```
Parameters:
weight: torch.Size([5]), requires_grad=True
scale: torch.Size([]), requires_grad=True

Buffers:
running_mean: torch.Size([5]), requires_grad=False
```

## Saving and Loading Model Parameters

PyTorch provides convenient functions to save and load model parameters:

```python
# Saving model parameters
torch.save(model.state_dict(), 'model_params.pth')

# Loading model parameters
loaded_model = SimpleNN(input_size=20, hidden_size=50, output_size=10)
loaded_model.load_state_dict(torch.load('model_params.pth'))

# Verify parameters are identical
for (name1, param1), (name2, param2) in zip(model.named_parameters(), 
                                           loaded_model.named_parameters()):
    print(f"{name1} identical: {torch.allclose(param1, param2)}")
```

Output:
```
fc1.weight identical: True
fc1.bias identical: True
fc2.weight identical: True
fc2.bias identical: True
```

## Practical Example: Fine-tuning Pre-trained Models

Parameter management is crucial when fine-tuning pre-trained models. Let's look at an example using a pre-trained ResNet model:

```python
import torchvision.models as models

# Load a pre-trained ResNet model
resnet = models.resnet18(pretrained=True)

# Freeze all parameters
for param in resnet.parameters():
    param.requires_grad = False

# Replace the final fully connected layer
num_features = resnet.fc.in_features
resnet.fc = nn.Linear(num_features, 100)  # New layer for 100 classes

# Print trainable parameters
trainable_params = 0
all_params = 0
for name, param in resnet.named_parameters():
    all_params += param.numel()
    if param.requires_grad:
        trainable_params += param.numel()

print(f"Total parameters: {all_params}")
print(f"Trainable parameters: {trainable_params}")
print(f"Percentage of trainable parameters: {100 * trainable_params / all_params:.2f}%")
```

Output:
```
Total parameters: 11689512
Trainable parameters: 51100
Percentage of trainable parameters: 0.44%
```

This approach is common in transfer learning, where we want to leverage the feature extraction capabilities of a pre-trained model but adapt it to our specific task.

## Summary

In this tutorial, we've covered the essential aspects of parameter management in PyTorch:

- Accessing parameters using `parameters()` and `named_parameters()`
- Parameter initialization techniques
- Creating parameter groups for optimization
- Sharing parameters between layers
- Creating custom parameters with `nn.Parameter`
- Saving and loading model parameters
- Fine-tuning pre-trained models

Effective parameter management is crucial for building and training complex neural networks. It helps you control how your model learns and can significantly impact performance.

## Additional Resources

- [PyTorch Documentation on nn.Module](https://pytorch.org/docs/stable/nn.html#module)
- [PyTorch Initialization Functions](https://pytorch.org/docs/stable/nn.init.html)
- [Transfer Learning Tutorial](https://pytorch.org/tutorials/beginner/transfer_learning_tutorial.html)

## Exercises

1. Create a custom neural network with three linear layers. Initialize the first layer with Xavier initialization, the second with Kaiming initialization, and the third with normal distribution.

2. Implement a weight-tied autoencoder where the decoder weights are transposed versions of the encoder weights.

3. Create a model with parameter groups where some parameters have weight decay and others don't.

4. Implement a network that gradually unfreezes layers of a pre-trained model during training.

5. Create a custom parameter that scales based on the epoch number during training.