---
title: Python Introduction
description: A beginner-friendly introduction to Python programming language for PyTorch learners

---

# Python Introduction

## Why Python for Deep Learning?

Python has emerged as the dominant programming language in the field of machine learning and deep learning, including frameworks like PyTorch. This is not by accident - Python combines readability, extensive libraries, and powerful features that make it ideal for scientific computing.

Before diving into PyTorch, it's essential to have a solid understanding of Python fundamentals. This guide will introduce you to the core concepts of Python that will serve as the foundation for your PyTorch journey.

## Python Basics

### Installing Python

Before we start coding, you'll need Python installed on your system. The recommended way is to install Python via Anaconda, which includes many scientific packages:

1. Download Anaconda from [the official website](https://www.anaconda.com/products/distribution)
2. Follow the installation instructions for your operating system
3. Verify your installation by opening a terminal or command prompt and typing:

```python
python --version
```

This should display the Python version you've installed.

### Your First Python Program

Let's start with the classic "Hello, World!" program:

```python
print("Hello, World!")
```

**Output:**
```
Hello, World!
```

This simple line demonstrates a few things:
- `print()` is a built-in function that displays output to the console
- Text strings in Python are enclosed in single or double quotes
- Python statements don't need semicolons to terminate lines

## Python Variables and Data Types

In Python, you don't need to declare variable types explicitly. Python automatically identifies the variable type based on the value assigned.

```python
# Integer
x = 5

# Float
y = 3.14

# String
name = "PyTorch"

# Boolean
is_learning = True

# Print all variables
print(x, y, name, is_learning)
print(f"Types: {type(x)}, {type(y)}, {type(name)}, {type(is_learning)}")
```

**Output:**
```
5 3.14 PyTorch True
Types: <class 'int'>, <class 'float'>, <class 'str'>, <class 'bool'>
```

### Python Collections

Python provides several built-in collection types:

#### Lists

Lists are ordered, mutable collections that can hold different types of data:

```python
# Creating a list
my_list = [1, 2, 3, "PyTorch", True]

# Accessing elements (zero-based indexing)
print(my_list[0])  # First element
print(my_list[-1])  # Last element

# Slicing
print(my_list[1:3])  # Elements from index 1 to 2

# Adding elements
my_list.append("Learning")
print(my_list)

# Lists are mutable
my_list[0] = 100
print(my_list)
```

**Output:**
```
1
True
[2, 3]
[1, 2, 3, 'PyTorch', True, 'Learning']
[100, 2, 3, 'PyTorch', True, 'Learning']
```

#### Tuples

Tuples are similar to lists but immutable (cannot be modified after creation):

```python
# Creating a tuple
my_tuple = (1, 2, "PyTorch")

# Accessing elements
print(my_tuple[0])

# This will cause an error
# my_tuple[0] = 100  # TypeError: 'tuple' object does not support item assignment
```

**Output:**
```
1
```

#### Dictionaries

Dictionaries store key-value pairs:

```python
# Creating a dictionary
my_dict = {
    "name": "PyTorch",
    "version": 1.9,
    "is_deep_learning": True
}

# Accessing values
print(my_dict["name"])

# Adding new key-value pairs
my_dict["creator"] = "Facebook AI Research"
print(my_dict)

# Check if a key exists
if "version" in my_dict:
    print(f"Current version: {my_dict['version']}")
```

**Output:**
```
PyTorch
{'name': 'PyTorch', 'version': 1.9, 'is_deep_learning': True, 'creator': 'Facebook AI Research'}
Current version: 1.9
```

## Control Flow in Python

### Conditional Statements

Python uses indentation to define blocks of code:

```python
x = 10

if x > 5:
    print("x is greater than 5")
elif x == 5:
    print("x equals 5")
else:
    print("x is less than 5")
```

**Output:**
```
x is greater than 5
```

### Loops

Python provides two main types of loops:

#### For Loops

```python
# Iterating through a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(f"I like {fruit}")

# Using the range function
for i in range(3):  # 0, 1, 2
    print(i)
```

**Output:**
```
I like apple
I like banana
I like cherry
0
1
2
```

#### While Loops

```python
count = 0
while count < 3:
    print(f"Count: {count}")
    count += 1
```

**Output:**
```
Count: 0
Count: 1
Count: 2
```

## Functions in Python

Functions allow you to organize code into reusable blocks:

```python
# Defining a function
def greet(name, greeting="Hello"):
    """This function greets the person with the provided greeting."""
    return f"{greeting}, {name}!"

# Calling functions
print(greet("PyTorch User"))
print(greet("PyTorch User", "Welcome"))

# Function with multiple returns
def get_dimensions():
    return 10, 20  # Returns a tuple

width, height = get_dimensions()
print(f"Width: {width}, Height: {height}")
```

**Output:**
```
Hello, PyTorch User!
Welcome, PyTorch User!
Width: 10, Height: 20
```

## Python Classes and Objects

Python is an object-oriented programming language, allowing you to create classes and objects:

```python
class NeuralNetwork:
    def __init__(self, layers):
        self.layers = layers
        self.is_trained = False
    
    def train(self):
        print(f"Training a neural network with {self.layers} layers...")
        self.is_trained = True
    
    def predict(self, data):
        if not self.is_trained:
            return "Model not trained yet"
        return f"Prediction from {self.layers}-layer network"

# Creating an instance of the class
my_network = NeuralNetwork(layers=3)
print(my_network.predict([1, 2, 3]))

# Training the network
my_network.train()
print(my_network.predict([1, 2, 3]))
```

**Output:**
```
Model not trained yet
Training a neural network with 3 layers...
Prediction from 3-layer network
```

## NumPy: Essential for PyTorch

NumPy is a fundamental package for scientific computing in Python and a critical component for understanding PyTorch:

```python
import numpy as np

# Creating arrays
array1d = np.array([1, 2, 3, 4, 5])
print(f"1D Array: {array1d}")

array2d = np.array([[1, 2, 3], [4, 5, 6]])
print(f"2D Array:\n{array2d}")

# Array operations
print(f"Mean of array: {np.mean(array1d)}")
print(f"Array + 10: {array1d + 10}")
print(f"Array * 2: {array1d * 2}")

# Matrix operations
matrix_a = np.array([[1, 2], [3, 4]])
matrix_b = np.array([[5, 6], [7, 8]])
print(f"Matrix multiplication:\n{np.matmul(matrix_a, matrix_b)}")
```

**Output:**
```
1D Array: [1 2 3 4 5]
2D Array:
[[1 2 3]
 [4 5 6]]
Mean of array: 3.0
Array + 10: [11 12 13 14 15]
Array * 2: [ 2  4  6  8 10]
Matrix multiplication:
[[19 22]
 [43 50]]
```

## Real-world Application: Data Preprocessing for PyTorch

Let's apply what we've learned to preprocess a dataset for PyTorch:

```python
import numpy as np

def normalize_data(data):
    """Normalize data to have mean 0 and standard deviation 1."""
    mean = np.mean(data, axis=0)
    std = np.std(data, axis=0)
    return (data - mean) / std

def prepare_batch(data, batch_size=32):
    """Prepare data in batches."""
    num_samples = len(data)
    indices = np.random.permutation(num_samples)
    for start_idx in range(0, num_samples, batch_size):
        batch_indices = indices[start_idx:start_idx + batch_size]
        yield data[batch_indices]

# Sample data (e.g., image pixel values)
raw_data = np.random.rand(100, 3)  # 100 samples, 3 features

# Preprocess data
normalized_data = normalize_data(raw_data)
print(f"Original data mean: {np.mean(raw_data):.4f}, std: {np.std(raw_data):.4f}")
print(f"Normalized data mean: {np.mean(normalized_data):.4f}, std: {np.std(normalized_data):.4f}")

# Create batches
for i, batch in enumerate(prepare_batch(normalized_data, batch_size=32)):
    if i < 2:  # Only show first 2 batches
        print(f"Batch {i+1} shape: {batch.shape}")
```

**Output:**
```
Original data mean: 0.4939, std: 0.2887
Normalized data mean: -0.0000, std: 1.0000
Batch 1 shape: (32, 3)
Batch 2 shape: (32, 3)
```

## Summary

In this introduction, we've covered:

1. Python installation and basic syntax
2. Variables and data types
3. Collections (lists, tuples, dictionaries)
4. Control flow with conditionals and loops
5. Functions and their usage
6. Classes and object-oriented programming
7. NumPy basics for scientific computing
8. Real-world application: data preprocessing for PyTorch

These fundamentals will provide a solid foundation for learning PyTorch. Python's simplicity and readability make it an excellent language for deep learning, allowing you to focus on the concepts rather than complex syntax.

## Further Resources and Exercises

### Resources
- [Official Python Documentation](https://docs.python.org/3/)
- [NumPy Documentation](https://numpy.org/doc/stable/)
- [Python for Data Science Handbook](https://jakevdp.github.io/PythonDataScienceHandbook/)

### Exercises
1. Create a `Tensor` class that mimics basic PyTorch tensor operations (addition, multiplication, reshape)
2. Write a function to load and preprocess an image dataset (you can use sample images)
3. Implement a simple neural network class with forward method using only NumPy
4. Create a data loader function that yields batches of data with a specified batch size

Once you feel comfortable with these Python basics, you'll be ready to dive into PyTorch and start building deep learning models!