---
title: PostgreSQL Comments
description: Learn how to use comments in PostgreSQL to document your database objects and code

  - postgresql
  - sql
  - database
  - documentation
---

# PostgreSQL Comments

## Introduction

Comments are an essential aspect of any programming language or database system, and PostgreSQL is no exception. They allow developers to document their code, explain design decisions, and make databases more maintainable. In this lesson, we'll explore how to use comments effectively in PostgreSQL, covering both SQL-standard comments and PostgreSQL's built-in comment system.

## Why Use Comments?

Before diving into the syntax, let's understand why comments are crucial in database development:

1. **Documentation**: Comments help explain complex queries or database objects.
2. **Collaboration**: They make it easier for team members to understand each other's work.
3. **Maintenance**: Future developers (including yourself) will appreciate well-documented database structures.
4. **Troubleshooting**: Comments can explain why certain decisions were made, helping with debugging.

## Types of Comments in PostgreSQL

PostgreSQL supports two primary types of comments:

### 1. SQL Standard Comments

These are inline comments used within SQL statements:

#### Single-line comments

Single-line comments begin with two hyphens (`--`) and continue until the end of the line:

```sql
-- This is a single-line comment
SELECT * FROM users; -- This retrieves all users
```

#### Multi-line comments

Multi-line comments begin with `/*` and end with `*/`:

```sql
/* This is a 
   multi-line comment that
   can span several lines */
SELECT 
  first_name,
  last_name
FROM 
  customers;
```

### 2. PostgreSQL COMMENT ON Statement

PostgreSQL provides a special `COMMENT ON` statement that allows you to attach comments to database objects. These comments are stored in the database and can be retrieved later.

#### Syntax

```sql
COMMENT ON {table | column | constraint | database | domain | 
           function | index | operator | rule | schema | 
           sequence | trigger | type | view} object_name IS 'text';
```

## Using Comments in Practice

Let's explore practical examples of using comments in PostgreSQL:

### Commenting on Tables

```sql
-- Create a users table
CREATE TABLE users (
  user_id SERIAL PRIMARY KEY,
  username VARCHAR(50) UNIQUE NOT NULL,
  email VARCHAR(100) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Add a comment to the table
COMMENT ON TABLE users IS 'Stores user account information';
```

### Commenting on Columns

```sql
-- Add comments to individual columns
COMMENT ON COLUMN users.user_id IS 'Unique identifier for each user';
COMMENT ON COLUMN users.username IS 'Username for login (must be unique)';
COMMENT ON COLUMN users.email IS 'User email address for notifications';
COMMENT ON COLUMN users.created_at IS 'Timestamp when the user account was created';
```

### Commenting on Functions

```sql
-- Create a simple function
CREATE OR REPLACE FUNCTION get_user_age(birth_date DATE)
RETURNS INTEGER AS $$
BEGIN
  /* Calculate age based on the birth date
     and current date using PostgreSQL's AGE function */
  RETURN EXTRACT(YEAR FROM AGE(CURRENT_DATE, birth_date));
END;
$$ LANGUAGE plpgsql;

-- Add a comment to the function
COMMENT ON FUNCTION get_user_age(DATE) IS 'Calculates a user''s age in years based on birth date';
```

## Viewing Comments

PostgreSQL stores comments in the `pg_description` system catalog. You can view comments using various methods:

### Using psql's \d+ Command

In the psql command-line tool, you can use `\d+` to view detailed information about a table, including comments:

```
\d+ users
```

Output:
```
                                           Table "public.users"
   Column   |          Type          | Collation | Nullable |      Default       | Storage  | Description 
------------+------------------------+-----------+----------+--------------------+----------+-------------
 user_id    | integer                |           | not null | nextval('users... | plain    | Unique identifier for each user
 username   | character varying(50)  |           | not null |                    | extended | Username for login (must be unique)
 email      | character varying(100) |           | not null |                    | extended | User email address for notifications
 created_at | timestamp              |           |          | CURRENT_TIMESTAMP  | plain    | Timestamp when the user account was created
Indexes:
    "users_pkey" PRIMARY KEY, btree (user_id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)
    "users_username_key" UNIQUE CONSTRAINT, btree (username)
Table Description: Stores user account information
```

### Querying the Information Schema

You can also retrieve comments programmatically:

```sql
-- Get comments on tables
SELECT 
  obj_description(oid) AS table_comment
FROM 
  pg_class
WHERE 
  relname = 'users' AND relkind = 'r';

-- Get comments on columns
SELECT 
  a.attname AS column_name,
  pg_description.description AS column_comment
FROM 
  pg_class
  JOIN pg_attribute a ON a.attrelid = pg_class.oid
  JOIN pg_description ON pg_description.objoid = pg_class.oid 
    AND pg_description.objsubid = a.attnum
WHERE 
  pg_class.relname = 'users' AND a.attnum > 0;
```

## Real-World Application

Let's look at a real-world example where comments significantly improve database maintainability.

Imagine you're building an e-commerce database:

```sql
-- Create the products table with detailed comments
CREATE TABLE products (
  product_id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  inventory_count INTEGER NOT NULL DEFAULT 0,
  category_id INTEGER REFERENCES categories(category_id),
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Document the table purpose
COMMENT ON TABLE products IS 'Main products catalog table storing all available products';

-- Add detailed column comments
COMMENT ON COLUMN products.product_id IS 'Unique identifier for each product';
COMMENT ON COLUMN products.name IS 'Product display name shown to customers';
COMMENT ON COLUMN products.description IS 'Detailed product description';
COMMENT ON COLUMN products.price IS 'Current retail price in USD - updated daily from ERP';
COMMENT ON COLUMN products.inventory_count IS 'Current inventory count from warehouse management system';
COMMENT ON COLUMN products.category_id IS 'Foreign key to categories table';
COMMENT ON COLUMN products.is_active IS 'Flag indicating if product is currently available for purchase';
COMMENT ON COLUMN products.created_at IS 'Timestamp when product was first added';
COMMENT ON COLUMN products.updated_at IS 'Timestamp of last product information update';

-- Create a complex inventory update function with comments
CREATE OR REPLACE FUNCTION update_inventory()
RETURNS TRIGGER AS $$
BEGIN
  /* 
   * This function handles inventory updates after order processing
   * It includes special handling for:
   * - Backordered items
   * - Items with pending restocks
   * - Bundle products that consist of multiple items
   */
  UPDATE products 
  SET 
    inventory_count = inventory_count - NEW.quantity,
    -- Always update the timestamp to track the last inventory change
    updated_at = CURRENT_TIMESTAMP
  WHERE 
    product_id = NEW.product_id;
  
  -- Check if inventory is below threshold and trigger alert if needed
  IF (SELECT inventory_count FROM products WHERE product_id = NEW.product_id) < 10 THEN
    -- Logic to trigger low inventory alert would go here
    -- (Not implemented in this example)
    NULL;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add a detailed comment explaining the function's purpose and behavior
COMMENT ON FUNCTION update_inventory() IS 
'Trigger function that updates product inventory counts after an order is placed.
Also checks inventory thresholds and triggers alerts when inventory is low.
This function is called by the after_order_insert trigger.';
```

## Best Practices for PostgreSQL Comments

1. **Be Consistent**: Establish a commenting style and stick to it.
2. **Comment Complex Logic**: Explain non-obvious code or complex queries.
3. **Document Design Decisions**: Explain why something was implemented a certain way.
4. **Update Comments**: Keep comments current when database objects change.
5. **Use `COMMENT ON` for Database Objects**: For tables, columns, functions, etc.
6. **Use SQL Comments for Queries**: For complex queries and scripts.
7. **Keep Comments Professional**: Remember that other developers will read them.

## Limitations of Comments

While comments are valuable, they have some limitations:

1. **Not Enforced**: PostgreSQL doesn't enforce that comments are kept up to date.
2. **Performance Impact**: Comments don't affect performance but excessive comments can make SQL scripts harder to read.
3. **No Version Control**: Comments in the database aren't automatically version-controlled (unlike application code).

## Summary

Comments in PostgreSQL are a powerful tool for documenting your database objects and SQL code. They help improve maintainability, aid in troubleshooting, and make collaboration more effective. We've learned:

- SQL-standard single-line (`--`) and multi-line (`/* */`) comments for SQL scripts
- PostgreSQL's `COMMENT ON` statement for documenting database objects
- How to view comments using psql and SQL queries
- Best practices for effective commenting

By using comments effectively, you'll create more maintainable and understandable PostgreSQL databases that are easier to work with both for yourself and your colleagues.

## Exercises

1. Create a `customers` table with at least five columns and add appropriate comments to the table and each column.
2. Write a complex SQL query with inline comments explaining each part of the query.
3. Create a simple PostgreSQL function and document it with both inline comments and a `COMMENT ON FUNCTION` statement.
4. Write a SQL query to retrieve all the comments for columns in a table you've created.
5. Practice using both single-line and multi-line comments in a SQL script that creates multiple related tables.