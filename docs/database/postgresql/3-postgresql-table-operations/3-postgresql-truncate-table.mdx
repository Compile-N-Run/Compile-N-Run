---
title: PostgreSQL TRUNCATE TABLE
description: Learn how to efficiently remove all rows from tables using the TRUNCATE TABLE command in PostgreSQL

---

# PostgreSQL TRUNCATE TABLE

## Introduction

When working with databases, you'll often need to remove data from tables. While the `DELETE` command is commonly used for this purpose, PostgreSQL provides a more efficient alternative: the `TRUNCATE TABLE` command. This command quickly removes all rows from a table without scanning each record individually.

In this tutorial, we'll explore how to use the `TRUNCATE TABLE` command in PostgreSQL, understand its benefits and limitations, and see practical examples of when and how to use it effectively.

## What is TRUNCATE TABLE?

`TRUNCATE TABLE` is a Data Definition Language (DDL) command that removes all rows from a table quickly by deallocating the data pages. Unlike the `DELETE` command, which removes rows one by one, `TRUNCATE` essentially resets the table to its empty state.

The basic syntax is:

```sql
TRUNCATE TABLE table_name [RESTART IDENTITY] [CASCADE | RESTRICT];
```

Where:
- `table_name` is the name of the table you want to truncate
- `RESTART IDENTITY` resets any auto-incrementing columns back to their start values
- `CASCADE` automatically truncates tables that have foreign key references to the specified table
- `RESTRICT` (the default) refuses to truncate if any other tables have foreign key references to the specified table

## TRUNCATE vs. DELETE

Before diving deeper, let's understand how `TRUNCATE` differs from `DELETE`:

| Feature | TRUNCATE | DELETE |
| ------- | -------- | ------ |
| Speed | Very fast | Slower for large datasets |
| Transaction Log | Minimal logging | Logs each deleted row |
| WHERE clause | Not supported | Supported |
| Triggers | Doesn't fire row triggers | Fires row triggers |
| Auto-increment reset | Optional | No reset |
| Transaction rollback | Limited | Fully supported |
| Statement type | DDL | DML |

## Basic Usage

### Simple TRUNCATE Example

Let's start with a basic example. Assume we have a `products` table with some data:

```sql
-- Create a sample table
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10, 2),
    stock INTEGER
);

-- Insert some data
INSERT INTO products (name, price, stock) 
VALUES 
    ('Laptop', 999.99, 50),
    ('Smartphone', 699.99, 100),
    ('Headphones', 149.99, 200);

-- View the data
SELECT * FROM products;
```

Output:
```
 product_id |    name    |  price  | stock 
------------+------------+---------+-------
          1 | Laptop     |  999.99 |    50
          2 | Smartphone |  699.99 |   100
          3 | Headphones |  149.99 |   200
```

To remove all rows from this table:

```sql
-- Remove all rows
TRUNCATE TABLE products;

-- Check the table
SELECT * FROM products;
```

Output:
```
 product_id | name | price | stock 
------------+------+-------+-------
(0 rows)
```

As you can see, all data has been removed from the table.

### TRUNCATE with RESTART IDENTITY

If you want to reset the auto-incrementing sequence for the primary key, you can use the `RESTART IDENTITY` option:

```sql
-- Insert some new data
INSERT INTO products (name, price, stock) 
VALUES ('Monitor', 299.99, 75);

-- Check the data
SELECT * FROM products;
```

Output:
```
 product_id |  name   | price  | stock 
------------+---------+--------+-------
          4 | Monitor | 299.99 |    75
```

Notice that even after truncating, the `product_id` continues from where it left off (4 instead of 1). Let's reset it:

```sql
-- Truncate and reset identity
TRUNCATE TABLE products RESTART IDENTITY;

-- Insert data again
INSERT INTO products (name, price, stock) 
VALUES ('Monitor', 299.99, 75);

-- Check the data
SELECT * FROM products;
```

Output:
```
 product_id |  name   | price  | stock 
------------+---------+--------+-------
          1 | Monitor | 299.99 |    75
```

Now the `product_id` starts from 1 again.

## Advanced Usage

### Truncating Multiple Tables

You can truncate multiple tables in a single command:

```sql
-- Create another table
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_name VARCHAR(100),
    total_amount DECIMAL(10, 2)
);

-- Insert some data
INSERT INTO orders (customer_name, total_amount) 
VALUES ('John Doe', 1499.98);

-- Truncate both tables at once
TRUNCATE TABLE products, orders;

-- Check the tables
SELECT * FROM products;
SELECT * FROM orders;
```

Both tables will be empty after this operation.

### TRUNCATE with CASCADE

When dealing with tables that have foreign key relationships, you can use the `CASCADE` option to automatically truncate related tables.

```sql
-- Create tables with a relationship
CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);

CREATE TABLE category_products (
    category_id INTEGER REFERENCES categories(category_id),
    product_id INTEGER REFERENCES products(product_id),
    PRIMARY KEY (category_id, product_id)
);

-- Insert some data
INSERT INTO categories (name) VALUES ('Electronics');
INSERT INTO products (name, price, stock) VALUES ('Tablet', 399.99, 30);
INSERT INTO category_products VALUES (1, 1);

-- Try to truncate categories without CASCADE
TRUNCATE TABLE categories;
```

This will result in an error:
```
ERROR:  cannot truncate a table referenced in a foreign key constraint
DETAIL:  Table "category_products" references "categories".
HINT:  Truncate table "category_products" at the same time, or use TRUNCATE ... CASCADE.
```

Let's try with CASCADE:

```sql
-- Truncate with CASCADE
TRUNCATE TABLE categories CASCADE;

-- Check related tables
SELECT * FROM categories;
SELECT * FROM category_products;
```

Both tables will be empty, as the `CASCADE` option removed the data from all tables with foreign key relationships to the truncated table.

## Performance Considerations

### When to Use TRUNCATE

`TRUNCATE` is ideal when:
- You need to remove all rows from a table
- You don't need to filter which rows to remove
- You want a fast operation with minimal logging
- Table is large and performance is important

### When NOT to Use TRUNCATE

Avoid `TRUNCATE` when:
- You need to remove only specific rows (use `DELETE` with a `WHERE` clause instead)
- You need to preserve auto-increment values
- You need the operation to be fully transactional
- You want triggers to fire on row deletion

## Real-World Applications

### Data Warehousing

In data warehousing scenarios, it's common to completely refresh staging tables before loading new data:

```sql
-- Staging table for daily sales data
CREATE TABLE staging_daily_sales (
    sale_id SERIAL,
    product_id INTEGER,
    quantity INTEGER,
    sale_date DATE,
    amount DECIMAL(10, 2)
);

-- Daily ETL process
BEGIN;
    -- Clear staging table
    TRUNCATE TABLE staging_daily_sales RESTART IDENTITY;
    
    -- Load new data (example)
    INSERT INTO staging_daily_sales (product_id, quantity, sale_date, amount)
    SELECT product_id, quantity, sale_date, amount 
    FROM external_source_function();
    
    -- Process the data and move to production tables
    -- ...
COMMIT;
```

### Development and Testing

During development and testing, you often need to reset tables to a clean state:

```sql
-- Development reset script
TRUNCATE TABLE users, orders, products, categories CASCADE;

-- Then load test data
INSERT INTO users (username, email) VALUES 
    ('test_user', 'test@example.com'),
    ('admin_user', 'admin@example.com');
-- ... and so on
```

### Batch Processing

For batch processing systems that process data in chunks:

```sql
-- Process data in batches
BEGIN;
    -- Clear staging area
    TRUNCATE TABLE batch_processing_stage;
    
    -- Load batch #42
    INSERT INTO batch_processing_stage
    SELECT * FROM data_source WHERE batch_id = 42;
    
    -- Process the batch
    -- ...
    
    -- Move to processed data
    INSERT INTO processed_data
    SELECT processed_columns FROM batch_processing_stage;
COMMIT;
```

## Limitations and Caveats

While `TRUNCATE` is powerful, be aware of these limitations:

1. **Cannot be used with WHERE clause**: If you need to conditionally delete rows, use `DELETE` instead.

2. **Foreign Key Constraints**: By default, you cannot truncate a table referenced by a foreign key unless you use `CASCADE` (which truncates all related tables).

3. **Triggers**: `TRUNCATE` does not fire row-level triggers. Only table-level `TRUNCATE` triggers are fired.

4. **Transaction Limitations**: While `TRUNCATE` can be rolled back in a transaction, it locks the table in a way that might affect concurrent operations more than `DELETE`.

5. **Privileges**: Users need special `TRUNCATE` privilege, which is not automatically granted with basic table modification rights.

## Summary

The `TRUNCATE TABLE` command in PostgreSQL provides an efficient way to quickly remove all data from tables. Its key advantages include:

- Significantly faster performance for large tables
- Minimal transaction logging
- Option to reset identity sequences
- Ability to truncate multiple tables at once

Remember that `TRUNCATE` is a DDL command that removes all rows without firing row triggers, cannot use a `WHERE` clause, and has special considerations for tables with foreign key relationships.

Choose between `DELETE` and `TRUNCATE` based on your specific needsâ€”use `DELETE` for selective row removal and full transaction support, and `TRUNCATE` for complete table clearing with maximum performance.

## Additional Resources

Here are some exercises to help you practice using the `TRUNCATE` command:

1. Create a table with an auto-incrementing primary key, add some rows, truncate it without `RESTART IDENTITY`, add more rows, and observe the sequence behavior.

2. Set up two tables with a foreign key relationship and experiment with both `RESTRICT` and `CASCADE` options.

3. Compare the performance of `DELETE FROM table_name` versus `TRUNCATE TABLE table_name` on a large table with millions of rows.

4. Create a table-level trigger that activates on `TRUNCATE` and logs when tables are truncated.

For more information, you can refer to the [official PostgreSQL documentation on TRUNCATE](https://www.postgresql.org/docs/current/sql-truncate.html).