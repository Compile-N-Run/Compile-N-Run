---
title: PostgreSQL Enum Types
description: Learn how to create and use enumerated data types in PostgreSQL to enhance data integrity and improve database design

---

# PostgreSQL Enum Types

## Introduction

Enumerated types (enums) are data types that comprise a static, ordered set of values. They are similar to the "enum" types you might have seen in programming languages like C, Java, or TypeScript. In PostgreSQL, enum types are particularly useful when you need to restrict a column to a predefined set of values.

For example, if you're storing data about a product's status, you might want to limit the possible values to: 'in_stock', 'out_of_stock', 'discontinued'. Using an enum type in this situation ensures data integrity by preventing invalid values from being inserted.

## Creating Enum Types

In PostgreSQL, you create an enum type using the `CREATE TYPE` statement with the `AS ENUM` clause.

```sql
CREATE TYPE status AS ENUM ('in_stock', 'out_of_stock', 'discontinued');
```

This creates a new type called `status` that can only accept one of the three defined values.

## Using Enum Types in Tables

Once you've created an enum type, you can use it as a column type in your tables:

```sql
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    current_status status NOT NULL DEFAULT 'in_stock'
);
```

Now, the `current_status` column will only accept the values defined in the `status` enum.

Let's insert some data:

```sql
INSERT INTO products (name, current_status) 
VALUES ('Laptop', 'in_stock');

INSERT INTO products (name, current_status) 
VALUES ('Headphones', 'out_of_stock');

INSERT INTO products (name, current_status) 
VALUES ('Old Monitor', 'discontinued');
```

If we try to insert an invalid value, PostgreSQL will raise an error:

```sql
INSERT INTO products (name, current_status) 
VALUES ('Mouse', 'unavailable');
```

Output:
```
ERROR:  invalid input value for enum status: "unavailable"
LINE 2: VALUES ('Mouse', 'unavailable');
                         ^
```

## Advantages of Enum Types

1. **Data Integrity**: Only predefined values can be inserted, ensuring consistency.
2. **Self-Documentation**: The enum type definition serves as documentation for what values are allowed.
3. **Storage Efficiency**: Enum values are stored more efficiently than strings.
4. **Performance**: Comparisons between enum values are faster than string comparisons.

## Working with Enum Types

### Viewing Enum Values

You can view the values of an enum type using the `pg_enum` catalog:

```sql
SELECT enumlabel
FROM pg_enum
WHERE enumtypid = 'status'::regtype
ORDER BY enumsortorder;
```

Output:
```
 enumlabel
--------------
 in_stock
 out_of_stock
 discontinued
```

### Sorting by Enum Values

Enum values have a specific order based on their declaration order. You can sort by this order:

```sql
SELECT name, current_status
FROM products
ORDER BY current_status;
```

Output:
```
    name     | current_status
-------------+---------------
 Laptop      | in_stock
 Headphones  | out_of_stock
 Old Monitor | discontinued
```

### Altering Enum Types

You can add new values to an existing enum type, but you cannot remove values or change their order. To add a new value:

```sql
ALTER TYPE status ADD VALUE 'on_backorder' AFTER 'out_of_stock';
```

Now you can use 'on_backorder' in your tables:

```sql
INSERT INTO products (name, current_status) 
VALUES ('Gaming Console', 'on_backorder');
```

## Real-World Examples

### Example 1: User Roles

```sql
-- Create an enum type for user roles
CREATE TYPE user_role AS ENUM ('admin', 'moderator', 'member', 'guest');

-- Create a users table using the enum
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    role user_role NOT NULL DEFAULT 'member'
);

-- Insert different users with various roles
INSERT INTO users (username, role) VALUES 
('admin_user', 'admin'),
('mod_user', 'moderator'),
('regular_user', 'member'),
('visitor', 'guest');

-- Query users by role
SELECT username FROM users WHERE role = 'admin';
```

### Example 2: Order Processing System

```sql
-- Create an enum for order statuses
CREATE TYPE order_status AS ENUM (
    'pending', 
    'processing', 
    'shipped', 
    'delivered', 
    'cancelled'
);

-- Create an orders table
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    status order_status NOT NULL DEFAULT 'pending'
);

-- Create a function to update order status
CREATE OR REPLACE FUNCTION update_order_status(
    p_order_id INTEGER, 
    p_new_status order_status
) RETURNS VOID AS $$
BEGIN
    UPDATE orders SET status = p_new_status WHERE order_id = p_order_id;
END;
$$ LANGUAGE plpgsql;

-- Use the function
SELECT update_order_status(1, 'processing');
```

### Example 3: Weather Data Collection

```sql
-- Create an enum for weather conditions
CREATE TYPE weather_condition AS ENUM (
    'sunny', 
    'cloudy', 
    'rainy', 
    'snowy', 
    'stormy'
);

-- Create a weather_data table
CREATE TABLE weather_data (
    record_id SERIAL PRIMARY KEY,
    location_name VARCHAR(100) NOT NULL,
    record_date DATE NOT NULL,
    temperature NUMERIC(5,2) NOT NULL,
    condition weather_condition NOT NULL
);

-- Insert weather data
INSERT INTO weather_data (location_name, record_date, temperature, condition)
VALUES 
('New York', '2023-01-15', 32.5, 'snowy'),
('Miami', '2023-01-15', 75.2, 'sunny'),
('Seattle', '2023-01-15', 45.0, 'rainy');

-- Query for specific conditions
SELECT location_name, temperature 
FROM weather_data 
WHERE condition = 'sunny';
```

## Best Practices

1. **Use Enums for Static Lists**: Only use enums when the set of possible values is known and unlikely to change frequently.

2. **Plan Ahead**: Think carefully about the values and their order, as changing an enum's structure later can be challenging.

3. **Add New Values Carefully**: When adding new values to an existing enum, consider adding them at the end to avoid disrupting sorting or existing application logic.

4. **Consider Database Portability**: If you need to migrate to another database system, remember that enum types are not standardized across all SQL databases.

5. **Document Your Enums**: Always document the meaning of each enum value, especially when they are used in multiple tables or applications.

## Limitations and Considerations

1. **Cannot Remove Values**: Once you've created an enum and added values, you cannot remove them.

2. **Order Matters**: The order in which you define enum values determines their sorting order.

3. **Case Sensitivity**: Enum values are case-sensitive ('ACTIVE' and 'active' are different).

4. **Migration Challenges**: If you need to significantly change an enum structure, you might need to create a new type and migrate your data.

## Summary

PostgreSQL enum types provide a powerful way to restrict column values to a predefined set, improving data integrity and database design. They are particularly useful for status fields, categorizations, and any situation where you need to limit input to a known set of values.

By using enum types effectively, you can create more robust database designs that prevent data inconsistencies and improve query performance for certain operations.

## Additional Resources

- [PostgreSQL Official Documentation on Enumerated Types](https://www.postgresql.org/docs/current/datatype-enum.html)
- [PostgreSQL Type System](https://www.postgresql.org/docs/current/extend-type-system.html)

## Exercises

1. Create an enum type called `priority_level` with values 'low', 'medium', 'high', and 'critical', then create a `tasks` table using this type.

2. Write a query to count how many products exist in each status category using the examples from this lesson.

3. Create a function that will only allow transitions between certain enum states (e.g., an order can go from 'pending' to 'processing' but not directly to 'delivered').