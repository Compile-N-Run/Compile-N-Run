---
title: PostgreSQL tablefunc Extension
description: Learn how to use PostgreSQL's tablefunc extension to transform data and create crosstab reports with practical examples

---

# PostgreSQL tablefunc Extension

## Introduction

The `tablefunc` extension is a powerful feature in PostgreSQL that provides various table functions to transform and manipulate data in ways that might be difficult to achieve with standard SQL. The most notable function in this extension is `crosstab`, which enables you to create pivot tables and crosstab reports directly in PostgreSQL.

In this tutorial, we'll explore the `tablefunc` extension, understand its key functions, and learn how to apply them to solve real-world data transformation challenges.

## Getting Started with tablefunc

### Installation

Before using the `tablefunc` extension, you need to install it. The good news is that it comes bundled with PostgreSQL, so you just need to enable it in your database:

```sql
CREATE EXTENSION IF NOT EXISTS tablefunc;
```

You only need to run this command once per database. After executing it, all the functions provided by the `tablefunc` extension will be available.

### Key Functions in tablefunc

The `tablefunc` extension includes several useful functions:

1. `crosstab` - Creates pivot tables (the most commonly used function)
2. `normal_rand` - Generates normally distributed random numbers
3. `connectby` - Displays hierarchical data in a tree-like format

We'll focus primarily on the `crosstab` function as it's the most widely used, but we'll briefly cover the others as well.

## Using the crosstab Function

The `crosstab` function transforms rows of data into a crosstab format (also known as pivot tables). This is particularly useful when you want to convert categories in rows to columns.

### Basic Syntax

The `crosstab` function has several variants, but the basic form is:

```sql
SELECT * FROM crosstab(source_sql, category_sql) 
AS ct(row_name text, category_1 text, category_2 text, ...);
```

Where:
- `source_sql` is a SQL query that returns three columns: row_name, category, and value
- `category_sql` is a SQL query that returns distinct category values
- The `AS` clause defines the output table structure with column names and data types

### Simple Example

Let's start with a simple example. Imagine we have a table of quarterly sales data:

```sql
CREATE TABLE quarterly_sales (
    salesperson TEXT,
    quarter TEXT,
    amount NUMERIC
);

INSERT INTO quarterly_sales VALUES
    ('Alice', 'Q1', 100),
    ('Alice', 'Q2', 150),
    ('Alice', 'Q3', 200),
    ('Alice', 'Q4', 100),
    ('Bob', 'Q1', 300),
    ('Bob', 'Q2', 250),
    ('Bob', 'Q3', 200),
    ('Bob', 'Q4', 400),
    ('Charlie', 'Q1', 150),
    ('Charlie', 'Q2', 150),
    ('Charlie', 'Q3', 100),
    ('Charlie', 'Q4', 150);
```

Now, we want to create a report with salespeople as rows and quarters as columns. Here's how we can do it with `crosstab`:

```sql
SELECT * FROM crosstab(
    'SELECT salesperson, quarter, amount 
     FROM quarterly_sales 
     ORDER BY 1,2',
    'SELECT DISTINCT quarter FROM quarterly_sales ORDER BY 1'
) AS ct(
    "Salesperson" TEXT,
    "Q1" NUMERIC,
    "Q2" NUMERIC,
    "Q3" NUMERIC,
    "Q4" NUMERIC
);
```

This will produce the following output:

```
 Salesperson | Q1  | Q2  | Q3  | Q4  
-------------+-----+-----+-----+-----
 Alice       | 100 | 150 | 200 | 100
 Bob         | 300 | 250 | 200 | 400
 Charlie     | 150 | 150 | 100 | 150
```

Notice how the data has been transformed from a long format (multiple rows per salesperson) to a wide format (one row per salesperson with multiple columns).

### Important Points about crosstab

1. The source query must return exactly three columns: row identifier, category, and value.
2. The source query must be ordered by the row identifier and then by the category.
3. You must define the output structure with the correct number of columns.
4. If your data is missing some category values, `crosstab` will fill those cells with NULL.

## Advanced crosstab Usage

### Using the crosstab2, crosstab3, and crosstab4 Functions

The `tablefunc` extension also provides `crosstab2`, `crosstab3`, and `crosstab4` functions that have predefined return types for 2, 3, and 4 category columns respectively:

```sql
-- Using crosstab2 (returns two category columns)
SELECT * FROM crosstab2(
    'SELECT salesperson, quarter, amount 
     FROM quarterly_sales 
     WHERE quarter IN (''Q1'', ''Q2'')
     ORDER BY 1,2'
) AS ct("Salesperson" TEXT, "Q1" NUMERIC, "Q2" NUMERIC);
```

The benefit of these functions is that you don't need to provide the category query, as they will automatically pick the first 2, 3, or 4 categories they encounter in the data.

### Multiple Value Columns

Sometimes you might want to display multiple values for each category. For this, you can use the `crosstabN` functions:

```sql
-- First, let's create some sample data
CREATE TABLE product_metrics (
    product TEXT,
    quarter TEXT,
    sales NUMERIC,
    returns NUMERIC
);

INSERT INTO product_metrics VALUES
    ('Product A', 'Q1', 1000, 50),
    ('Product A', 'Q2', 1200, 60),
    ('Product B', 'Q1', 800, 30),
    ('Product B', 'Q2', 900, 45);

-- Now, create a crosstab with multiple values per cell
SELECT * FROM crosstab(
    'SELECT product, quarter, ARRAY[sales, returns]::TEXT[] 
     FROM product_metrics 
     ORDER BY 1,2',
    'SELECT DISTINCT quarter FROM product_metrics ORDER BY 1'
) AS ct(
    "Product" TEXT,
    "Q1" TEXT[],
    "Q2" TEXT[]
);
```

The output would show arrays containing [sales, returns] for each product and quarter.

## Using the normal_rand Function

The `normal_rand` function generates a set of normally distributed random numbers:

```sql
SELECT * FROM normal_rand(5, 100, 15);
```

This generates 5 random numbers with a mean of 100 and a standard deviation of 15.

This can be useful for:
- Creating test data
- Statistical simulations
- Generating random samples for analysis

## Using the connectby Function

The `connectby` function is used to query hierarchical or tree-structured data:

```sql
-- Create a sample employee hierarchy table
CREATE TABLE employees (
    id INT PRIMARY KEY,
    name TEXT,
    manager_id INT REFERENCES employees(id)
);

INSERT INTO employees VALUES
    (1, 'CEO', NULL),
    (2, 'CTO', 1),
    (3, 'CFO', 1),
    (4, 'Developer 1', 2),
    (5, 'Developer 2', 2),
    (6, 'Accountant', 3);

-- Query the hierarchy
SELECT * FROM connectby(
    'SELECT id, manager_id, name, id FROM employees',
    'id', 'manager_id', 'name', '1', 0, '→'
);
```

This produces a hierarchical display of employees:

```
 keyid | parent_keyid |    name     | level |       branch        
-------+--------------+-------------+-------+---------------------
 1     |              | CEO         | 0     | CEO
 2     | 1            | CTO         | 1     | CEO→CTO
 4     | 2            | Developer 1 | 2     | CEO→CTO→Developer 1
 5     | 2            | Developer 2 | 2     | CEO→CTO→Developer 2
 3     | 1            | CFO         | 1     | CEO→CFO
 6     | 3            | Accountant  | 2     | CEO→CFO→Accountant
```

## Real-World Application Examples

### Example 1: Monthly Sales Report by Product Category

Imagine you have a database of product sales and want to create a monthly sales report by product category.

```sql
-- Create and populate the sales data
CREATE TABLE product_sales (
    sale_date DATE,
    category TEXT,
    sales_amount NUMERIC
);

INSERT INTO product_sales VALUES
    ('2023-01-15', 'Electronics', 5000),
    ('2023-01-20', 'Clothing', 3000),
    ('2023-01-25', 'Home', 2000),
    ('2023-02-10', 'Electronics', 6000),
    ('2023-02-15', 'Clothing', 3500),
    ('2023-02-28', 'Home', 2500),
    ('2023-03-05', 'Electronics', 4500),
    ('2023-03-12', 'Clothing', 4000),
    ('2023-03-25', 'Home', 3000);

-- Create a crosstab report by month and category
SELECT * FROM crosstab(
    'SELECT TO_CHAR(sale_date, ''Month'') as month, 
            category, 
            SUM(sales_amount) as total
     FROM product_sales
     GROUP BY 1, 2
     ORDER BY 1, 2',
    'SELECT DISTINCT category FROM product_sales ORDER BY 1'
) AS ct(
    "Month" TEXT,
    "Clothing" NUMERIC,
    "Electronics" NUMERIC,
    "Home" NUMERIC
);
```

Result:

```
   Month    | Clothing | Electronics | Home 
------------+----------+-------------+------
 February   |     3500 |        6000 | 2500
 January    |     3000 |        5000 | 2000
 March      |     4000 |        4500 | 3000
```

### Example 2: Customer Survey Results

Let's say you've conducted a customer satisfaction survey with ratings for different aspects of your service:

```sql
-- Create and populate the survey data
CREATE TABLE survey_responses (
    customer_id INT,
    question TEXT,
    rating INT
);

INSERT INTO survey_responses VALUES
    (1, 'Service', 5),
    (1, 'Quality', 4),
    (1, 'Price', 3),
    (2, 'Service', 4),
    (2, 'Quality', 5),
    (2, 'Price', 2),
    (3, 'Service', 3),
    (3, 'Quality', 4),
    (3, 'Price', 4);

-- Create a crosstab of survey responses
SELECT * FROM crosstab(
    'SELECT customer_id, question, rating
     FROM survey_responses
     ORDER BY 1, 2',
    'SELECT DISTINCT question FROM survey_responses ORDER BY 1'
) AS ct(
    "Customer ID" INT,
    "Price" INT,
    "Quality" INT,
    "Service" INT
);
```

Result:

```
 Customer ID | Price | Quality | Service
-------------+-------+---------+---------
           1 |     3 |       4 |       5
           2 |     2 |       5 |       4
           3 |     4 |       4 |       3
```

## Performance Considerations

When working with `tablefunc` and particularly the `crosstab` function, keep these performance tips in mind:

1. **Indexing**: Ensure that columns used in the `ORDER BY` clause of the source query are properly indexed.
2. **Query Optimization**: For large datasets, optimize the source query as much as possible.
3. **Memory Usage**: Be careful with very wide crosstabs (many columns), as they can consume significant memory.
4. **Materialized Views**: For frequently used crosstabs, consider creating materialized views.

## Common Errors and Troubleshooting

When working with `tablefunc`, you might encounter these common issues:

1. **Extension Not Found**: If you get an error like "function crosstab does not exist", make sure you've created the extension with `CREATE EXTENSION tablefunc`.

2. **Column Count Mismatch**: The number of columns in your `AS` clause must match the number of categories plus one (for the row identifier).

3. **Data Type Issues**: Ensure the data types in your `AS` clause match the data types in your query.

4. **Missing Categories**: If a category specified in your output structure doesn't exist in your data, PostgreSQL will fill it with NULL values.

## Summary

The `tablefunc` extension in PostgreSQL provides powerful functions for data transformation that go beyond standard SQL capabilities. The `crosstab` function is particularly useful for creating pivot tables and transforming row-based data into column-based reports.

We've learned how to:
- Install and enable the `tablefunc` extension
- Use the `crosstab` function for basic and advanced pivot tables
- Generate random numbers with `normal_rand`
- Query hierarchical data with `connectby`
- Apply these functions to real-world scenarios

By mastering the `tablefunc` extension, you can create sophisticated reports and data transformations directly in your PostgreSQL database, often eliminating the need for external reporting tools.

## Additional Resources

- [PostgreSQL Official Documentation on tablefunc](https://www.postgresql.org/docs/current/tablefunc.html)
- [PostgreSQL Wiki: Crosstab Queries](https://wiki.postgresql.org/wiki/Crosstab_Queries)

## Exercises

Test your understanding of the `tablefunc` extension with these exercises:

1. Create a crosstab query to show total sales by product and region from a sales table.
2. Use the `normal_rand` function to generate 100 random test scores with a mean of 75 and a standard deviation of 10.
3. Create a company hierarchy using the `connectby` function, showing at least three levels of management.
4. Create a crosstab query that displays customer purchase amounts by quarter, with separate columns for each year (e.g., 2022-Q1, 2022-Q2, 2023-Q1, etc.).