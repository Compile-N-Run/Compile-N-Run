---
title: PostgreSQL Statement Triggers
description: Learn how to create and use statement-level triggers in PostgreSQL to execute functions before or after SQL commands

---

# PostgreSQL Statement Triggers

## Introduction

In PostgreSQL, triggers are database callback functions that automatically execute when specific events occur on a table. Statement triggers are a type of trigger that fire once for each SQL statement, regardless of how many rows are affected by that statement. They provide a powerful way to implement complex business rules, maintain data integrity, and automate database operations.

Unlike row triggers (which fire for each affected row), statement triggers execute once per SQL command, making them particularly useful for operations that need to consider the statement as a whole rather than individual row changes.

## Statement Triggers vs. Row Triggers

Before diving into statement triggers, let's understand how they differ from row triggers:

| Feature | Statement Triggers | Row Triggers |
|---------|-------------------|--------------|
| Execution frequency | Once per SQL statement | Once per affected row |
| When they can fire | BEFORE or AFTER the statement | BEFORE, AFTER, or INSTEAD OF each row |
| Performance impact | Lower for multi-row operations | Higher for multi-row operations |
| Access to data | Cannot access modified rows directly | Can access OLD and NEW row values |
| Use cases | Auditing, security checks, global validations | Row-level data validation, cascading updates |

## Creating Statement Triggers

The basic syntax for creating a statement trigger in PostgreSQL is:

```sql
CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE | DELETE | TRUNCATE}
ON table_name
FOR EACH STATEMENT
EXECUTE FUNCTION trigger_function();
```

The key part that makes it a statement trigger is the `FOR EACH STATEMENT` clause, which tells PostgreSQL to execute the trigger function once per SQL statement.

### Example: Creating a Statement Trigger

Let's create a statement trigger that logs information about bulk operations on a `users` table:

First, let's create our `users` table:

```sql
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

Next, we'll create an audit table to store information about bulk operations:

```sql
CREATE TABLE user_operations_audit (
    audit_id SERIAL PRIMARY KEY,
    operation_type VARCHAR(10) NOT NULL,
    table_name VARCHAR(50) NOT NULL,
    user_name VARCHAR(50) NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    affected_rows INTEGER
);
```

Now, let's create a trigger function that will be executed by our statement trigger:

```sql
CREATE OR REPLACE FUNCTION log_user_operations()
RETURNS TRIGGER AS $$
BEGIN
    -- Insert a record into our audit table
    INSERT INTO user_operations_audit (
        operation_type,
        table_name,
        user_name,
        affected_rows
    ) VALUES (
        TG_OP,                   -- Operation type (INSERT, UPDATE, DELETE)
        TG_TABLE_NAME,           -- Table name
        CURRENT_USER,            -- Database user performing the operation
        pg_stat_get_tuples_inserted(TG_RELID)  -- Number of rows affected
    );
    
    RAISE NOTICE 'Logged % operation on % table affecting % rows', 
        TG_OP, TG_TABLE_NAME, pg_stat_get_tuples_inserted(TG_RELID);
        
    RETURN NULL;  -- Return value is ignored for AFTER triggers
END;
$$ LANGUAGE plpgsql;
```

Finally, let's create the statement trigger:

```sql
CREATE TRIGGER after_user_operations
AFTER INSERT ON users
FOR EACH STATEMENT
EXECUTE FUNCTION log_user_operations();
```

## Using Statement Triggers

Now that we've created our statement trigger, let's see it in action by inserting some users:

```sql
-- Insert a single user
INSERT INTO users (username, email) 
VALUES ('john_doe', 'john@example.com');

-- Insert multiple users in one statement
INSERT INTO users (username, email) 
VALUES 
    ('jane_doe', 'jane@example.com'),
    ('bob_smith', 'bob@example.com'),
    ('alice_johnson', 'alice@example.com');
```

After executing these statements, we can check our audit table:

```sql
SELECT * FROM user_operations_audit;
```

The result would be something like:

```
 audit_id | operation_type | table_name | user_name |        timestamp        | affected_rows 
----------+----------------+------------+-----------+-------------------------+---------------
        1 | INSERT         | users      | postgres  | 2023-08-15 10:23:45.123 |             1
        2 | INSERT         | users      | postgres  | 2023-08-15 10:24:12.456 |             3
```

Notice that even though we inserted a total of 4 users, our audit table has only 2 entries—one for each SQL statement—illustrating the statement-level nature of our trigger.

## Common Use Cases for Statement Triggers

Statement triggers excel in several scenarios:

### 1. Audit Logging

As demonstrated in our example, statement triggers are excellent for logging bulk operations, capturing information about who performed an operation and when.

### 2. Security Validations

Statement triggers can enforce security policies before allowing operations:

```sql
CREATE OR REPLACE FUNCTION check_business_hours()
RETURNS TRIGGER AS $$
BEGIN
    -- Only allow operations during business hours (9 AM to 5 PM on weekdays)
    IF EXTRACT(HOUR FROM CURRENT_TIME) < 9 OR 
       EXTRACT(HOUR FROM CURRENT_TIME) >= 17 OR 
       EXTRACT(DOW FROM CURRENT_DATE) IN (0, 6) THEN
        RAISE EXCEPTION 'Database modifications only allowed during business hours';
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_business_hours
BEFORE INSERT OR UPDATE OR DELETE ON users
FOR EACH STATEMENT
EXECUTE FUNCTION check_business_hours();
```

### 3. Database Maintenance

Statement triggers can handle maintenance tasks after bulk operations:

```sql
CREATE OR REPLACE FUNCTION refresh_materialized_views()
RETURNS TRIGGER AS $$
BEGIN
    -- Refresh the user_statistics materialized view after bulk operations
    REFRESH MATERIALIZED VIEW user_statistics;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER refresh_user_stats
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH STATEMENT
EXECUTE FUNCTION refresh_materialized_views();
```

### 4. Preventing Certain Operations

Statement triggers can block operations entirely:

```sql
CREATE OR REPLACE FUNCTION prevent_truncate()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'TRUNCATE operation is not allowed on the users table';
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER no_truncate
BEFORE TRUNCATE ON users
FOR EACH STATEMENT
EXECUTE FUNCTION prevent_truncate();
```

## Advanced Techniques with Statement Triggers

### Combining with Conditional Execution

You can make statement triggers smarter by adding conditional logic:

```sql
CREATE OR REPLACE FUNCTION conditional_audit()
RETURNS TRIGGER AS $$
BEGIN
    -- Only log operations that affect more than 5 rows
    IF pg_stat_get_tuples_inserted(TG_RELID) > 5 THEN
        INSERT INTO user_operations_audit (
            operation_type, table_name, user_name, affected_rows
        ) VALUES (
            TG_OP, TG_TABLE_NAME, CURRENT_USER, pg_stat_get_tuples_inserted(TG_RELID)
        );
        
        RAISE NOTICE 'Large operation detected: % % affecting % rows', 
            TG_OP, TG_TABLE_NAME, pg_stat_get_tuples_inserted(TG_RELID);
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

### Handling Multiple Events

A single statement trigger can handle multiple types of operations:

```sql
CREATE TRIGGER multi_event_trigger
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH STATEMENT
EXECUTE FUNCTION log_user_operations();
```

Inside the trigger function, you can use `TG_OP` to determine which operation fired the trigger:

```sql
CREATE OR REPLACE FUNCTION multi_event_handler()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Handle INSERT operation
        RAISE NOTICE 'Insert operation detected';
    ELSIF TG_OP = 'UPDATE' THEN
        -- Handle UPDATE operation
        RAISE NOTICE 'Update operation detected';
    ELSIF TG_OP = 'DELETE' THEN
        -- Handle DELETE operation
        RAISE NOTICE 'Delete operation detected';
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

## Statement Trigger Limitations and Considerations

While statement triggers are powerful, they come with some limitations:

1. **No direct access to modified data**: Unlike row triggers, statement triggers can't access OLD and NEW values of rows directly.

2. **Execution timing**: Statement triggers execute either before or after the entire operation, not during it.

3. **Performance implications**: Complex logic in statement triggers can impact the performance of bulk operations.

4. **Transaction context**: Triggers execute within the same transaction as the triggering statement. If a trigger raises an exception, the entire transaction is rolled back.

5. **Limited event types**: Statement triggers can only be fired by INSERT, UPDATE, DELETE, and TRUNCATE operations.

## Best Practices

To effectively use statement triggers:

1. **Keep them lightweight**: Avoid complex processing that could slow down operations.

2. **Use specific triggers**: Create separate triggers for different purposes rather than overloading a single trigger.

3. **Document thoroughly**: Document what your triggers do as they can introduce "invisible" logic.

4. **Consider alternatives**: For some use cases, other PostgreSQL features like rules or constraints might be more appropriate.

5. **Test thoroughly**: Test triggers with various input scenarios, including edge cases.

## Real-World Example: Rate Limiting Database Operations

Here's a practical example of using a statement trigger to implement a rate-limiting mechanism that prevents too many operations from occurring within a short time period:

```sql
-- Create a table to track operation counts
CREATE TABLE operation_tracker (
    id SERIAL PRIMARY KEY,
    operation_type VARCHAR(10),
    operation_count INTEGER DEFAULT 0,
    last_reset TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Initialize with entry for each operation type
INSERT INTO operation_tracker (operation_type) VALUES ('INSERT'), ('UPDATE'), ('DELETE');

-- Create the rate limiting function
CREATE OR REPLACE FUNCTION enforce_rate_limit()
RETURNS TRIGGER AS $$
DECLARE
    current_count INTEGER;
    last_reset_time TIMESTAMP;
    max_operations INTEGER := 100; -- Maximum operations allowed in the time window
    reset_interval INTERVAL := '5 minutes';
BEGIN
    -- Get current operation count and last reset time
    SELECT operation_count, last_reset INTO current_count, last_reset_time
    FROM operation_tracker
    WHERE operation_type = TG_OP;
    
    -- Check if we should reset the counter
    IF (CURRENT_TIMESTAMP - last_reset_time) > reset_interval THEN
        UPDATE operation_tracker 
        SET operation_count = 1, last_reset = CURRENT_TIMESTAMP
        WHERE operation_type = TG_OP;
    ELSE
        -- Increment the counter
        UPDATE operation_tracker 
        SET operation_count = operation_count + 1
        WHERE operation_type = TG_OP;
        
        -- Check if we've exceeded the limit
        IF current_count + 1 > max_operations THEN
            RAISE EXCEPTION 'Rate limit exceeded: Too many % operations in a short period', TG_OP;
        END IF;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Create the trigger
CREATE TRIGGER rate_limit_operations
BEFORE INSERT OR UPDATE OR DELETE ON users
FOR EACH STATEMENT
EXECUTE FUNCTION enforce_rate_limit();
```

This example creates a rate-limiting mechanism that allows a maximum of 100 operations of each type (INSERT, UPDATE, DELETE) within a 5-minute window.

## Summary

PostgreSQL statement triggers are powerful database objects that execute once per SQL statement, making them ideal for auditing, security checks, and maintenance tasks. Unlike row triggers, which fire for each affected row, statement triggers consider the SQL statement as a whole, providing an efficient way to handle bulk operations.

Key points to remember:
- Statement triggers use the `FOR EACH STATEMENT` clause
- They execute once per SQL statement regardless of how many rows are affected
- They're useful for auditing, security validations, and maintenance tasks
- They cannot directly access the values of modified rows
- They can be combined with conditional logic for more flexibility

By understanding and leveraging statement triggers, you can implement sophisticated database behaviors that maintain data integrity and automate database operations in your PostgreSQL applications.

## Further Learning Resources

To deepen your knowledge of PostgreSQL triggers:

1. Explore the PostgreSQL documentation on [Triggers](https://www.postgresql.org/docs/current/trigger-definition.html)
2. Learn about [PL/pgSQL](https://www.postgresql.org/docs/current/plpgsql.html), the procedural language used for trigger functions
3. Study [Event Triggers](https://www.postgresql.org/docs/current/event-triggers.html), which fire on database-level events

## Practice Exercises

1. Create a statement trigger that prevents bulk deletions from occurring during peak business hours.
2. Implement a trigger that automatically updates a `last_modified` timestamp on a table whenever any modifications occur.
3. Design a trigger that logs detailed information about TRUNCATE operations, including which user performed them and when.
4. Create a trigger that enforces a "maintenance mode" during which only database administrators can modify tables.
5. Implement a rate-limiting trigger similar to our example, but with different limits for different user roles.

By mastering statement triggers, you'll have a powerful tool in your PostgreSQL toolkit for implementing complex business rules and maintaining the integrity of your database.