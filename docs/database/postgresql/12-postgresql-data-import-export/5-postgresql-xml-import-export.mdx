---
title: PostgreSQL XML Import Export
description: Learn how to import and export XML data in PostgreSQL with practical examples and step-by-step guidance

---

# PostgreSQL XML Import Export

## Introduction

XML (eXtensible Markup Language) continues to be an important format for data interchange between systems. PostgreSQL provides robust XML support, allowing you to both import XML data into your database and export your PostgreSQL data as XML. This capability is particularly useful when integrating with legacy systems, web services, or applications that use XML as their primary data exchange format.

In this tutorial, we'll explore how PostgreSQL handles XML data, including:

- PostgreSQL's XML data type
- Importing XML data into PostgreSQL
- Querying and manipulating XML data
- Exporting data from PostgreSQL as XML
- Real-world use cases and examples

## PostgreSQL XML Data Type

PostgreSQL provides a native `xml` data type specifically designed for storing XML data. This data type ensures that only well-formed XML can be stored and provides specific functions for XML processing.

Let's start by creating a table with an XML column:

```sql
CREATE TABLE product_catalog (
    id SERIAL PRIMARY KEY,
    product_data XML
);
```

## Importing XML Data into PostgreSQL

There are several ways to import XML data into PostgreSQL:

### 1. Direct XML Insertion

The simplest method is to directly insert XML data as a string:

```sql
INSERT INTO product_catalog (product_data) 
VALUES ('
<product>
    <name>Laptop Pro</name>
    <price>1299.99</price>
    <specifications>
        <cpu>Intel i7</cpu>
        <ram>16GB</ram>
        <storage>512GB SSD</storage>
    </specifications>
</product>
');
```

### 2. Using the XMLPARSE Function

For more explicit XML parsing:

```sql
INSERT INTO product_catalog (product_data) 
VALUES (XMLPARSE(DOCUMENT '
<product>
    <name>Smartphone X</name>
    <price>899.99</price>
    <specifications>
        <screen>6.7 inches</screen>
        <camera>48MP</camera>
        <storage>256GB</storage>
    </specifications>
</product>
'));
```

### 3. Loading from External XML Files

To import larger XML files, you can use PostgreSQL's functions combined with file reading capabilities:

```sql
-- Using psql's \copy feature
\set content `cat /path/to/products.xml`
INSERT INTO product_catalog (product_data) VALUES (:'content'::xml);
```

Alternatively, you can use language-specific database drivers to read XML files and insert them into PostgreSQL.

Here's an example using Python:

```python
import psycopg2
import xml.etree.ElementTree as ET

# Read XML file
tree = ET.parse('products.xml')
root = tree.getroot()
xml_data = ET.tostring(root, encoding='unicode')

# Connect to PostgreSQL
conn = psycopg2.connect("dbname=yourdb user=youruser password=yourpassword")
cur = conn.cursor()

# Insert XML data
cur.execute("INSERT INTO product_catalog (product_data) VALUES (%s)", (xml_data,))
conn.commit()
conn.close()
```

### 4. Using COPY with XML Transformation

For importing tabular data as XML, you might need to transform it first:

```sql
-- Create a temporary table for the raw data
CREATE TEMP TABLE temp_products (
    id INT,
    name TEXT,
    price NUMERIC,
    cpu TEXT,
    ram TEXT,
    storage TEXT
);

-- Import CSV data
COPY temp_products FROM '/path/to/products.csv' WITH CSV HEADER;

-- Transform and insert as XML
INSERT INTO product_catalog (product_data)
SELECT xmlelement(name product,
    xmlelement(name name, name),
    xmlelement(name price, price),
    xmlelement(name specifications,
        xmlelement(name cpu, cpu),
        xmlelement(name ram, ram),
        xmlelement(name storage, storage)
    )
)
FROM temp_products;
```

## Querying and Manipulating XML Data

Once your XML data is in PostgreSQL, you can use various XML functions to query and manipulate it.

### Basic XML Path Expressions

PostgreSQL supports XPath 1.0 for querying XML data:

```sql
-- Extract the product name
SELECT 
    id,
    (xpath('/product/name/text()', product_data))[1]::text AS product_name
FROM product_catalog;

-- Extract all specification details
SELECT 
    id,
    (xpath('/product/specifications/cpu/text()', product_data))[1]::text AS cpu,
    (xpath('/product/specifications/ram/text()', product_data))[1]::text AS ram,
    (xpath('/product/specifications/storage/text()', product_data))[1]::text AS storage
FROM product_catalog;
```

### XML Data Extraction Using xmltable

The `xmltable` function (available in PostgreSQL 10 and later) provides a more SQL-friendly way to extract XML data:

```sql
SELECT id, x.*
FROM product_catalog,
XMLTABLE('/product' PASSING product_data
    COLUMNS
        product_name TEXT PATH 'name/text()',
        price NUMERIC PATH 'price/text()',
        cpu TEXT PATH 'specifications/cpu/text()',
        ram TEXT PATH 'specifications/ram/text()',
        storage TEXT PATH 'specifications/storage/text()'
) AS x;
```

### Modifying XML Data

You can update XML content using functions like `xmlelement` and `xmlforest`:

```sql
-- Update the price in the XML data
UPDATE product_catalog
SET product_data = xmlparse(document 
    replace(
        product_data::text, 
        (xpath('/product/price/text()', product_data))[1]::text,
        '1399.99'
    )
)
WHERE id = 1;
```

## Exporting Data from PostgreSQL as XML

PostgreSQL provides several ways to export data as XML:

### 1. Using Query Results as XML

The simplest way is to use the built-in XML generation functions:

```sql
-- Export a single table as XML
SELECT xmlelement(
    name products,
    xmlagg(
        xmlelement(
            name product,
            xmlelement(name id, id),
            xmlelement(name product_data, product_data)
        )
    )
) AS xml_output
FROM product_catalog;
```

### 2. Using XMLAGG for Aggregated XML

For more complex structures:

```sql
-- Assuming we have a table with products and related categories
SELECT xmlelement(
    name product_catalog,
    (
        SELECT xmlagg(
            xmlelement(name category,
                xmlattributes(c.id AS id, c.name AS name),
                (
                    SELECT xmlagg(
                        xmlelement(name product,
                            xmlattributes(p.id AS id),
                            xmlelement(name name, p.name),
                            xmlelement(name price, p.price)
                        )
                    )
                    FROM products p
                    WHERE p.category_id = c.id
                )
            )
        )
        FROM categories c
    )
) AS xml_output;
```

### 3. Using COPY to Export XML to a File

To save the XML output to a file:

```sql
-- Using psql
\copy (SELECT xmlelement(name products, xmlagg(xmlelement(name product, product_data))) FROM product_catalog) TO '/path/to/output.xml';
```

### 4. Using a Server-Side Function

For more complex export scenarios, create a function:

```sql
CREATE OR REPLACE FUNCTION export_products_xml()
RETURNS xml AS $$
DECLARE
    result xml;
BEGIN
    SELECT xmlelement(
        name products,
        xmlagg(
            xmlelement(
                name product,
                xmlelement(name id, id),
                xmlelement(name data, product_data)
            )
        )
    ) INTO result
    FROM product_catalog;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;

-- Then call it:
SELECT export_products_xml();
```

## Real-World Applications

Let's look at some practical scenarios where PostgreSQL's XML capabilities prove valuable:

### Example 1: Integrating with a Legacy XML-based API

Imagine you need to extract data from your PostgreSQL database to send to a legacy system that accepts XML:

```sql
-- Create a function to generate XML in the required format
CREATE OR REPLACE FUNCTION get_products_for_api()
RETURNS xml AS $$
DECLARE
    result xml;
BEGIN
    SELECT xmlelement(
        name ProductCatalog,
        xmlattributes(
            'http://api.example.com/schema' AS xmlns,
            'http://www.w3.org/2001/XMLSchema-instance' AS "xmlns:xsi",
            'http://api.example.com/schema ProductCatalog.xsd' AS "xsi:schemaLocation"
        ),
        xmlelement(
            name Products,
            (
                SELECT xmlagg(
                    xmlelement(
                        name Product,
                        xmlelement(name ProductName, (xpath('/product/name/text()', product_data))[1]::text),
                        xmlelement(name ProductPrice, (xpath('/product/price/text()', product_data))[1]::text),
                        xmlelement(
                            name Specifications,
                            xmlelement(name CPU, (xpath('/product/specifications/cpu/text()', product_data))[1]::text),
                            xmlelement(name RAM, (xpath('/product/specifications/ram/text()', product_data))[1]::text),
                            xmlelement(name Storage, (xpath('/product/specifications/storage/text()', product_data))[1]::text)
                        )
                    )
                )
                FROM product_catalog
            )
        )
    ) INTO result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

### Example 2: Processing XML Data Feeds

Suppose you regularly receive product updates as XML and need to import them:

```sql
-- Create a function to process an XML feed
CREATE OR REPLACE FUNCTION process_product_feed(feed_xml xml)
RETURNS TABLE (
    product_id int,
    product_name text,
    status text
) AS $$
BEGIN
    -- Create temporary table to hold extracted data
    CREATE TEMP TABLE temp_products (
        product_id int,
        product_name text,
        price numeric,
        specs xml
    );
    
    -- Extract data from XML feed
    INSERT INTO temp_products
    SELECT 
        (xpath('id/text()', unnest.product))[1]::text::int,
        (xpath('name/text()', unnest.product))[1]::text,
        (xpath('price/text()', unnest.product))[1]::text::numeric,
        unnest.product
    FROM (
        SELECT unnest(xpath('/products/product', feed_xml)) AS product
    ) AS unnest;
    
    -- Update existing products
    UPDATE product_catalog pc
    SET product_data = tp.specs
    FROM temp_products tp
    WHERE pc.id = tp.product_id;
    
    -- Insert new products
    INSERT INTO product_catalog (id, product_data)
    SELECT tp.product_id, tp.specs
    FROM temp_products tp
    LEFT JOIN product_catalog pc ON pc.id = tp.product_id
    WHERE pc.id IS NULL;
    
    -- Return results
    RETURN QUERY
    SELECT 
        tp.product_id,
        tp.product_name,
        CASE 
            WHEN pc.id IS NULL THEN 'Inserted'
            ELSE 'Updated'
        END
    FROM temp_products tp
    LEFT JOIN product_catalog pc ON pc.id = tp.product_id;
    
    -- Clean up
    DROP TABLE temp_products;
END;
$$ LANGUAGE plpgsql;

-- Usage:
SELECT * FROM process_product_feed('
<products>
    <product>
        <id>1</id>
        <name>Updated Laptop Pro</name>
        <price>1499.99</price>
        <specifications>
            <cpu>Intel i9</cpu>
            <ram>32GB</ram>
            <storage>1TB SSD</storage>
        </specifications>
    </product>
    <product>
        <id>3</id>
        <name>New Tablet Y</name>
        <price>599.99</price>
        <specifications>
            <screen>10.5 inches</screen>
            <processor>A14</processor>
            <storage>128GB</storage>
        </specifications>
    </product>
</products>
'::xml);
```

## Performance Considerations

When working with XML in PostgreSQL, keep these performance tips in mind:

1. **Indexing XML Data**: While you cannot directly index XML content, you can create functional indexes on commonly queried XML paths:

```sql
-- Create a functional index on product name
CREATE INDEX idx_product_name ON product_catalog ((xpath('/product/name/text()', product_data))[1]::text));
```

2. **Denormalization vs. XML Storage**: For data that's frequently queried, consider extracting critical fields into separate columns rather than keeping all data in XML.

3. **XML Validation**: PostgreSQL's XML type ensures well-formedness but not validity against schemas. For schema validation, you might need additional application-level checks.

```sql
-- Create a function to validate XML against simple rules
CREATE OR REPLACE FUNCTION validate_product_xml(product_xml xml)
RETURNS boolean AS $$
BEGIN
    -- Check if required elements exist
    IF xpath_exists('/product/name', product_xml) AND
       xpath_exists('/product/price', product_xml) AND
       xpath_exists('/product/specifications', product_xml) THEN
        RETURN true;
    ELSE
        RETURN false;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Use in validation
SELECT id, validate_product_xml(product_data) AS is_valid
FROM product_catalog;
```

## Summary

PostgreSQL offers powerful capabilities for working with XML data, making it an excellent choice for applications that need to bridge relational databases with XML-based systems. In this tutorial, we've learned:

- How to use PostgreSQL's native XML data type
- Methods for importing XML data into PostgreSQL
- Techniques for querying and manipulating XML data
- Approaches for exporting data as XML
- Real-world applications and performance considerations

By leveraging these features, you can build robust applications that seamlessly integrate with XML-based systems while taking advantage of PostgreSQL's reliability and performance.

## Additional Resources and Exercises

### Resources

- [PostgreSQL Documentation on XML Types](https://www.postgresql.org/docs/current/datatype-xml.html)
- [PostgreSQL Documentation on XML Functions](https://www.postgresql.org/docs/current/functions-xml.html)

### Exercises

1. **Basic XML Import**: Create a table to store book information as XML and insert data for at least three books with details like title, author, publication year, and genre.

2. **XML Querying**: Write a query to extract and display book titles and authors from your XML book table in a tabular format.

3. **XML Generation**: Create a function that generates an XML catalog of all books, grouped by genre.

4. **XML Update**: Write a procedure that takes a book ID and new price, then updates the price in the XML structure.

5. **Advanced Integration**: Design a system that periodically imports an XML feed of new books, compares them with existing records, and updates or inserts as needed.

By mastering PostgreSQL's XML capabilities, you'll be well-equipped to handle complex data integration scenarios and work effectively with systems that use XML as their primary data format.