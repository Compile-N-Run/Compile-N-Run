---
title: MySQL Prepared Statements
description: Learn how to use MySQL prepared statements to create more secure and efficient database queries with parameterized statements, improving both performance and security against SQL injection attacks.

---

# MySQL Prepared Statements

## Introduction

Prepared statements are a powerful feature in MySQL that allow you to execute the same or similar SQL statements repeatedly with high efficiency. They represent a significant improvement over traditional query execution methods, particularly when it comes to security and performance.

At their core, prepared statements work by separating SQL logic from data. This separation provides two major benefits:

1. **Protection Against SQL Injection**: By handling user input as parameters rather than part of the SQL query, prepared statements prevent malicious users from injecting harmful SQL code.

2. **Performance Optimization**: When a prepared statement is executed multiple times, MySQL can reuse the query plan, reducing parsing overhead.

In this tutorial, we'll dive deep into MySQL prepared statements, exploring how they work, how to implement them, and why they're essential for modern database applications.

## Understanding Prepared Statements

### What Are Prepared Statements?

A prepared statement is a precompiled SQL statement that can be executed multiple times with different parameter values. The process works in three steps:

```mermaid
graph LR
    A[Prepare] --> B[Bind Parameters]
    B --> C[Execute]
    C -->|Can repeat with new parameters| B
```

1. **Prepare**: The database parses, compiles, and optimizes the SQL statement.
2. **Bind Parameters**: Values are bound to placeholders (parameters) in the statement.
3. **Execute**: The statement runs with the bound parameter values.

### Syntax in MySQL

In MySQL, prepared statements can be created using either:

- Direct SQL with `PREPARE`, `EXECUTE`, and `DEALLOCATE PREPARE` statements
- Programming language interfaces like PDO (PHP), MySQLi, or language-specific database connectors

## Basic Prepared Statements in MySQL

### Using Direct SQL Commands

Here's how to create and use a prepared statement directly in MySQL:

```sql
-- Step 1: Prepare the statement
PREPARE stmt FROM 'SELECT * FROM users WHERE username = ?';

-- Step 2: Set a variable to use as parameter
SET @username = 'john_doe';

-- Step 3: Execute the prepared statement
EXECUTE stmt USING @username;

-- Step 4: Deallocate when finished
DEALLOCATE PREPARE stmt;
```

**Output:**
```
+----+-----------+-------------------+
| id | username  | email             |
+----+-----------+-------------------+
| 1  | john_doe  | john@example.com  |
+----+-----------+-------------------+
```

### Using PHP with MySQLi

```php
// Create connection
$mysqli = new mysqli("localhost", "username", "password", "database");

// Check connection
if ($mysqli->connect_error) {
    die("Connection failed: " . $mysqli->connect_error);
}

// Prepare statement
$stmt = $mysqli->prepare("SELECT * FROM users WHERE username = ?");

// Bind parameters
$username = "john_doe";
$stmt->bind_param("s", $username); // "s" indicates string parameter

// Execute statement
$stmt->execute();

// Get results
$result = $stmt->get_result();
while ($row = $result->fetch_assoc()) {
    echo "ID: " . $row["id"] . " - Username: " . $row["username"] . "<br />";
}

// Close statement and connection
$stmt->close();
$mysqli->close();
```

**Output:**
```
ID: 1 - Username: john_doe
```

### Using PHP with PDO

```php
try {
    // Create connection
    $pdo = new PDO("mysql:host=localhost;dbname=database", "username", "password");
    
    // Set error mode
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    // Prepare statement
    $stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username");
    
    // Bind parameters
    $stmt->bindParam(':username', $username);
    $username = "john_doe";
    
    // Execute statement
    $stmt->execute();
    
    // Get results
    while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
        echo "ID: " . $row["id"] . " - Username: " . $row["username"] . "<br />";
    }
} catch(PDOException $e) {
    echo "Error: " . $e->getMessage();
}

// Connection closes automatically when script ends
```

**Output:**
```
ID: 1 - Username: john_doe
```

## Benefits of Prepared Statements

### 1. SQL Injection Prevention

SQL injection is a common attack where malicious SQL code is inserted into query parameters. Consider these examples:

**Vulnerable Code (Without Prepared Statements):**

```php
$username = $_POST['username']; // Could be malicious: "' OR 1=1 --"
$query = "SELECT * FROM users WHERE username = '$username'";
$result = $mysqli->query($query);
// This becomes: SELECT * FROM users WHERE username = '' OR 1=1 --'
// Which returns ALL users!
```

**Secure Code (With Prepared Statements):**

```php
$stmt = $mysqli->prepare("SELECT * FROM users WHERE username = ?");
$username = $_POST['username']; // Even if malicious, it's treated as a literal string
$stmt->bind_param("s", $username);
$stmt->execute();
```

### 2. Performance Improvements

When executing the same statement multiple times with different parameters, prepared statements offer significant performance advantages:

```php
// Prepare once
$stmt = $mysqli->prepare("INSERT INTO logs (user_id, action, timestamp) VALUES (?, ?, NOW())");

// Execute multiple times with different values
for ($i = 0; $i < 1000; $i++) {
    $user_id = $user_ids[$i];
    $action = $actions[$i];
    $stmt->bind_param("is", $user_id, $action);
    $stmt->execute();
}
```

The database engine:
1. Parses the query only once
2. Creates an execution plan only once
3. Simply substitutes different values on each execution

## Advanced Prepared Statement Techniques

### Multiple Parameters

You can use multiple parameters in a single prepared statement:

```php
$stmt = $mysqli->prepare("SELECT * FROM products WHERE category = ? AND price < ?");
$category = "electronics";
$max_price = 500;
$stmt->bind_param("si", $category, $max_price); // s=string, i=integer
$stmt->execute();
```

### Different Data Types

The `bind_param()` function in MySQLi requires type specifiers:

- `i` - integer
- `d` - double (float)
- `s` - string
- `b` - blob

```php
$stmt = $mysqli->prepare("INSERT INTO users (name, age, height, is_active) VALUES (?, ?, ?, ?)");
$name = "Alice";
$age = 30;
$height = 5.8;
$active = 1;
$stmt->bind_param("sidb", $name, $age, $height, $active);
$stmt->execute();
```

### Using IN Clauses

Using prepared statements with `IN` clauses requires special handling:

```php
// Prepare a statement with a variable number of placeholders
$ids = [1, 5, 9, 12];
$placeholders = str_repeat('?,', count($ids) - 1) . '?';
$stmt = $mysqli->prepare("SELECT * FROM products WHERE id IN ($placeholders)");

// Create an array with references and bind all parameters
$types = str_repeat('i', count($ids)); // All integers
$stmt->bind_param($types, ...$ids);    // Spread syntax requires PHP 5.6+
$stmt->execute();
```

## Real-World Applications

### User Registration System

```php
function registerUser($username, $email, $password) {
    global $mysqli;
    
    // Hash the password
    $password_hash = password_hash($password, PASSWORD_DEFAULT);
    
    // Prepare statement
    $stmt = $mysqli->prepare("INSERT INTO users (username, email, password_hash) VALUES (?, ?, ?)");
    $stmt->bind_param("sss", $username, $email, $password_hash);
    
    // Execute and check
    if ($stmt->execute()) {
        return $mysqli->insert_id;
    } else {
        return false;
    }
}

// Usage
$new_user_id = registerUser("new_user", "user@example.com", "secure_password123");
if ($new_user_id) {
    echo "User registered with ID: $new_user_id";
} else {
    echo "Registration failed";
}
```

### Product Search Feature

```php
function searchProducts($keyword, $category = null, $max_price = null) {
    global $pdo;
    
    $sql = "SELECT * FROM products WHERE name LIKE :keyword";
    $params = [':keyword' => "%$keyword%"];
    
    if ($category) {
        $sql .= " AND category = :category";
        $params[':category'] = $category;
    }
    
    if ($max_price) {
        $sql .= " AND price <= :price";
        $params[':price'] = $max_price;
    }
    
    $stmt = $pdo->prepare($sql);
    $stmt->execute($params);
    return $stmt->fetchAll(PDO::FETCH_ASSOC);
}

// Usage
$products = searchProducts("laptop", "electronics", 1000);
foreach ($products as $product) {
    echo $product['name'] . " - $" . $product['price'] . "<br />";
}
```

### Bulk Insert Operations

```php
function bulkInsertOrders($orders) {
    global $mysqli;
    
    $mysqli->begin_transaction();
    
    try {
        $stmt = $mysqli->prepare("INSERT INTO orders (customer_id, product_id, quantity, order_date) VALUES (?, ?, ?, NOW())");
        
        foreach ($orders as $order) {
            $stmt->bind_param("iii", $order['customer_id'], $order['product_id'], $order['quantity']);
            $stmt->execute();
            
            // Store the order ID for later use
            $order_ids[] = $mysqli->insert_id;
        }
        
        $mysqli->commit();
        return $order_ids;
    } catch (Exception $e) {
        $mysqli->rollback();
        throw $e;
    }
}

// Usage
$orders = [
    ['customer_id' => 1, 'product_id' => 156, 'quantity' => 2],
    ['customer_id' => 2, 'product_id' => 89, 'quantity' => 1],
    ['customer_id' => 1, 'product_id' => 42, 'quantity' => 3]
];

try {
    $order_ids = bulkInsertOrders($orders);
    echo "Created " . count($order_ids) . " orders successfully";
} catch (Exception $e) {
    echo "Error: " . $e->getMessage();
}
```

## Best Practices

1. **Always Use Prepared Statements for User Data**
   - Any data coming from users should be handled through prepared statements, without exception.

2. **Reuse Prepared Statements**
   - For operations that occur repeatedly, prepare the statement once and execute it multiple times.

3. **Close Statements When Done**
   - Free resources by closing statements and connections when they're no longer needed.

4. **Use Transactions for Multiple Operations**
   - For related operations, use transactions to ensure data integrity.

5. **Be Careful with Dynamic SQL**
   - When SQL structure itself varies (not just parameters), build prepared statements carefully.

6. **Use Named Parameters When Possible**
   - PDO's named parameters (`:name`) can make code more readable than positional parameters (`?`).

## Common Mistakes to Avoid

1. **String Concatenation Instead of Parameters**
   ```php
   // WRONG - SQL Injection risk
   $stmt = $mysqli->prepare("SELECT * FROM users WHERE username = '" . $username . "'");
   
   // CORRECT - Use parameters
   $stmt = $mysqli->prepare("SELECT * FROM users WHERE username = ?");
   $stmt->bind_param("s", $username);
   ```

2. **Forgetting to Check Execution Success**
   ```php
   // WRONG - No error checking
   $stmt->execute();
   
   // CORRECT - Check results
   if (!$stmt->execute()) {
       echo "Execute failed: (" . $stmt->errno . ") " . $stmt->error;
   }
   ```

3. **Incorrect Parameter Types**
   ```php
   // WRONG - Using "s" (string) for an integer
   $stmt->bind_param("s", $user_id); // $user_id is meant to be an integer
   
   // CORRECT - Use appropriate type
   $stmt->bind_param("i", $user_id);
   ```

## Summary

MySQL Prepared Statements offer a secure and efficient way to execute database queries. By separating SQL logic from data, they provide protection against SQL injection attacks and improve performance through query plan reuse.

Key takeaways:

- Prepared statements work by precompiling a query template and then applying different parameter values.
- They significantly enhance security by properly handling user input.
- Performance improvements are noticeable when executing the same query multiple times.
- Both MySQLi and PDO in PHP provide robust support for prepared statements.
- Use prepared statements for any query that involves user input or dynamic values.

By integrating prepared statements into your MySQL operations, you'll create more secure, efficient, and maintainable database interactions.

## Additional Resources and Exercises

### Resources

- [MySQL Official Documentation on Prepared Statements](https://dev.mysql.com/doc/refman/8.0/en/sql-prepared-statements.html)
- [PHP mysqli Documentation](https://www.php.net/manual/en/mysqli.quickstart.prepared-statements.php)
- [PHP PDO Documentation](https://www.php.net/manual/en/pdo.prepared-statements.php)

### Practice Exercises

1. **Basic Prepared Statement**
   Create a prepared statement that retrieves users based on their role and registration date.

2. **Multiple-Parameter Search**
   Build a product search function that filters by category, price range, and availability.

3. **Bulk Update Operation**
   Create a function that updates the status of multiple orders efficiently using prepared statements.

4. **Security Audit**
   Review an existing project and identify places where prepared statements should replace direct queries.

5. **Performance Comparison**
   Create a script that compares the performance of regular queries versus prepared statements when executing the same query many times.