---
title: MySQL Full-Text Search
description: Learn how to use MySQL's Full-Text Search capabilities to implement powerful text-based searches in your databases beyond simple pattern matching.

---

# MySQL Full-Text Search

## Introduction

When working with databases that contain large amounts of text data, simple `LIKE` or regular expression searches can become inefficient and limited. MySQL's Full-Text Search (FTS) provides a more powerful and efficient solution for searching through text content.

Full-Text Search allows you to perform natural language searches, boolean searches with complex operators, and even relevance-ranked queries on your text data. This feature is particularly valuable for applications like content management systems, blogs, document repositories, or any system where users need to search through textual content.

In this guide, we'll explore how to implement and use MySQL's Full-Text Search capabilities to enhance your applications.

## Prerequisites

Before diving into Full-Text Search, make sure you have:

- MySQL 5.6 or later installed (recommended: MySQL 8.0+)
- Basic knowledge of MySQL queries and database operations
- A database with text data you'd like to search through

## Understanding Full-Text Search

### How It's Different from Regular Searches

Traditional searches using `LIKE` or `REGEXP` have several limitations:

1. **Performance issues**: They scan every row in your table
2. **Limited functionality**: No built-in relevance ranking
3. **No natural language support**: Cannot naturally handle word forms and synonyms

Full-Text Search addresses these limitations by:

1. Creating special indexes optimized for text searching
2. Providing relevance-based result ranking
3. Offering natural language processing capabilities
4. Supporting complex search expressions through Boolean mode

### Supported Storage Engines

MySQL's Full-Text Search functionality is available for:

- InnoDB tables (since MySQL 5.6)
- MyISAM tables

InnoDB is generally recommended for most modern applications due to its transaction support and other features.

## Setting Up Full-Text Search

### Creating a Table with Full-Text Index

To use Full-Text Search, you need to create a Full-Text index on the columns you want to search. Here's how to create a new table with a Full-Text index:

```sql
CREATE TABLE articles (
  id INT NOT NULL AUTO_INCREMENT,
  title VARCHAR(255) NOT NULL,
  body TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (id),
  FULLTEXT INDEX idx_article_content (title, body)
) ENGINE=InnoDB;
```

The key part is the `FULLTEXT INDEX` definition, which creates a Full-Text index on both the `title` and `body` columns.

### Adding Full-Text Index to Existing Tables

If you already have a table and want to add a Full-Text index to it:

```sql
ALTER TABLE articles
ADD FULLTEXT INDEX idx_article_content (title, body);
```

### Let's Add Sample Data

For our examples, let's insert some sample data:

```sql
INSERT INTO articles (title, body) VALUES 
('MySQL Full-Text Search Tutorial', 'Learn how to use MySQL Full-Text Search capabilities to improve your application search functionality.'),
('Database Performance Optimization', 'Tips and tricks for optimizing your MySQL database for better performance and faster queries.'),
('Introduction to SQL Joins', 'Understanding SQL joins is essential for working with relational databases effectively.'),
('Web Development with PHP and MySQL', 'Create dynamic websites by combining PHP with MySQL database to store and retrieve data.'),
('MySQL vs PostgreSQL Comparison', 'A detailed comparison of MySQL and PostgreSQL database management systems for various use cases.');
```

## Using Full-Text Search

MySQL supports three types of Full-Text searches:

1. Natural Language Mode
2. Boolean Mode
3. Query Expansion

Let's explore each type with examples.

### Natural Language Mode

Natural language mode is the default search mode. It searches for words that match your search terms and returns results ranked by relevance:

```sql
SELECT title, body, MATCH(title, body) AGAINST('database performance') AS score
FROM articles
WHERE MATCH(title, body) AGAINST('database performance' IN NATURAL LANGUAGE MODE)
ORDER BY score DESC;
```

**Output:**

```
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------+--------+
| title                                | body                                                                                                                         | score  |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------+--------+
| Database Performance Optimization    | Tips and tricks for optimizing your MySQL database for better performance and faster queries.                                | 1.7742 |
| MySQL vs PostgreSQL Comparison       | A detailed comparison of MySQL and PostgreSQL database management systems for various use cases.                             | 0.5891 |
| Web Development with PHP and MySQL   | Create dynamic websites by combining PHP with MySQL database to store and retrieve data.                                     | 0.2946 |
+--------------------------------------+------------------------------------------------------------------------------------------------------------------------------+--------+
```

In this example:
- We're searching for documents containing "database" and "performance"
- The `MATCH(columns) AGAINST(search_expression)` syntax is the core of Full-Text Search
- We've included the relevance score in the results
- Results are ordered by relevance (highest score first)

### Boolean Mode

Boolean mode allows for more complex queries using special operators:

```sql
SELECT title, body
FROM articles
WHERE MATCH(title, body) AGAINST('mysql -postgresql +full-text' IN BOOLEAN MODE);
```

**Output:**

```
+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------+
| title                          | body                                                                                                                            |
+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------+
| MySQL Full-Text Search Tutorial| Learn how to use MySQL Full-Text Search capabilities to improve your application search functionality.                          |
+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------+
```

In this example, we're searching for documents that:
- Must contain the word "full-text" (`+` operator)
- Should contain "mysql" (no operator means optional)
- Must not contain "postgresql" (`-` operator)

#### Boolean Mode Operators

| Operator | Description                           | Example                  |
|----------|---------------------------------------|--------------------------|
| `+`      | Word must be present                  | `+mysql +search`         |
| `-`      | Word must not be present              | `mysql -indexing`        |
| `*`      | Wildcard for prefixes                 | `data*` (matches database, datatype, etc.) |
| `""`     | Exact phrase                          | `"full text search"`     |
| `()`     | Grouping                              | `+(mysql postgresql)`    |
| `>`      | Increases relevance ranking           | `>performance`           |
| `<`      | Decreases relevance ranking           | `<optimization`          |
| `~`      | Contributes negatively to relevance   | `mysql ~slow`            |

Let's try another example with more operators:

```sql
SELECT title, body
FROM articles  
WHERE MATCH(title, body) AGAINST('"MySQL database" +(performance optimization)' IN BOOLEAN MODE);
```

This searches for documents containing the exact phrase "MySQL database" and at least one of the words "performance" or "optimization".

### Query Expansion (WITH QUERY EXPANSION)

Query expansion is useful when your initial search terms are too limited. It performs two searches:

1. An initial search with your terms
2. A second search using your original terms plus relevant keywords from the top-ranked documents

```sql
SELECT title, body
FROM articles
WHERE MATCH(title, body) AGAINST('database' WITH QUERY EXPANSION);
```

Query expansion can often yield more comprehensive results, but might also introduce less relevant matches.

## Full-Text Search Configuration

### Minimum Word Length

By default, MySQL ignores words shorter than the minimum word length (3 characters for InnoDB, 4 for MyISAM). To change this:

1. Edit your MySQL configuration file (my.cnf or my.ini)
2. Add or modify these parameters:

```
[mysqld]
innodb_ft_min_token_size=2
ft_min_word_len=2
```

3. Restart MySQL server
4. Rebuild your Full-Text indexes:

```sql
ALTER TABLE articles DROP INDEX idx_article_content;
ALTER TABLE articles ADD FULLTEXT INDEX idx_article_content (title, body);
```

### Stopwords

Stopwords are common words like "the", "and", "or" that are ignored in Full-Text searches. MySQL has a default stopword list, but you can customize it:

1. Create a file with your stopwords (one per line)
2. Edit your MySQL configuration:

```
[mysqld]
innodb_ft_server_stopword_table=your_database/your_stopword_table
```

3. Restart MySQL and rebuild your indexes

## Real-World Applications

### Building a Simple Search Engine

Let's implement a basic search functionality for a blog application:

```php
<?php
// search.php
$connection = new mysqli('localhost', 'username', 'password', 'blog_db');

// Get search term and sanitize
$search = $connection->real_escape_string($_GET['q'] ?? '');

if (!empty($search)) {
    // Perform full-text search
    $query = "
        SELECT id, title, SUBSTRING(body, 1, 150) AS excerpt, 
               MATCH(title, body) AGAINST('$search' IN BOOLEAN MODE) AS relevance
        FROM blog_posts
        WHERE MATCH(title, body) AGAINST('$search' IN BOOLEAN MODE)
        ORDER BY relevance DESC
        LIMIT 10
    ";
    
    $result = $connection->query($query);
    
    // Display results
    if ($result->num_rows > 0) {
        echo "<h2>Search Results for: " . htmlspecialchars($search) . "</h2>";
        
        while ($row = $result->fetch_assoc()) {
            echo "<div class='search-result'>";
            echo "<h3><a href='post.php?id={$row['id']}'>{$row['title']}</a></h3>";
            echo "<p>{$row['excerpt']}...</p>";
            echo "</div>";
        }
    } else {
        echo "<p>No results found for: " . htmlspecialchars($search) . "</p>";
    }
}

$connection->close();
?>
```

### Implementing Auto-Complete Suggestions

You can combine Full-Text Search with AJAX to create auto-complete functionality:

```php
<?php
// suggestions.php
$connection = new mysqli('localhost', 'username', 'password', 'blog_db');

header('Content-Type: application/json');

$term = $connection->real_escape_string($_GET['term'] ?? '');

if (strlen($term) >= 3) {
    // Use Full-Text Search to find suggestions
    $query = "
        SELECT DISTINCT title
        FROM blog_posts
        WHERE MATCH(title, body) AGAINST('$term*' IN BOOLEAN MODE)
        LIMIT 5
    ";
    
    $result = $connection->query($query);
    $suggestions = [];
    
    while ($row = $result->fetch_assoc()) {
        $suggestions[] = $row['title'];
    }
    
    echo json_encode($suggestions);
} else {
    echo json_encode([]);
}

$connection->close();
?>
```

The corresponding JavaScript might look like:

```javascript
document.getElementById('search').addEventListener('input', function() {
    const term = this.value;
    
    if (term.length >= 3) {
        fetch(`/suggestions.php?term=${encodeURIComponent(term)}`)
            .then(response => response.json())
            .then(data => {
                const suggestionsList = document.getElementById('suggestions');
                suggestionsList.innerHTML = '';
                
                data.forEach(suggestion => {
                    const item = document.createElement('li');
                    item.textContent = suggestion;
                    item.addEventListener('click', function() {
                        document.getElementById('search').value = suggestion;
                        suggestionsList.innerHTML = '';
                    });
                    suggestionsList.appendChild(item);
                });
            });
    }
});
```

## Performance Considerations

While Full-Text Search is more efficient than `LIKE` queries for large text datasets, there are some considerations:

1. **Index size**: Full-Text indexes can significantly increase your database size
2. **Update overhead**: Modifying indexed columns requires index updates
3. **Memory usage**: Full-Text operations can be memory-intensive

To optimize performance:

- Only index columns that need to be searched
- Consider using separate tables for searchable content if your main tables have frequent updates
- Monitor your server's memory usage and adjust MySQL's configuration accordingly

## Limitations of Full-Text Search

MySQL's Full-Text Search is powerful but has some limitations:

1. No support for proximity searches (finding words within a certain distance)
2. Limited language support for stemming and synonyms
3. No fuzzy matching for misspellings
4. Complex queries might still be slower than dedicated search engines

For advanced search requirements, consider dedicated solutions like Elasticsearch, Solr, or commercial MySQL plugins.

## Summary

MySQL's Full-Text Search provides a powerful way to search text content within your databases, offering:

- Natural language and boolean search capabilities
- Relevance-based result ranking
- Better performance than pattern matching for large text datasets
- Configuration options for fine-tuning search behavior

By implementing Full-Text Search in your applications, you can provide users with more effective and efficient search functionality without the complexity of integrating a separate search engine.

## Practice Exercises

1. Create a table with Full-Text indexes and experiment with different search modes
2. Try using various boolean operators to refine search results
3. Build a simple web form that allows users to search through a dataset using Full-Text Search
4. Compare the performance of Full-Text Search with `LIKE` queries on a large dataset
5. Implement a search feature that highlights matching terms in the results

## Additional Resources

- [MySQL Full-Text Search Documentation](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)
- [Boolean Full-Text Searches](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html)
- [Natural Language Full-Text Searches](https://dev.mysql.com/doc/refman/8.0/en/fulltext-natural-language.html)
- [Full-Text Stopwords](https://dev.mysql.com/doc/refman/8.0/en/fulltext-stopwords.html)

With MySQL Full-Text Search, you can greatly enhance your application's search capabilities without the need for external search engines, making it an essential tool in your MySQL toolkit.