---
title: MySQL Updatable Views
description: Learn how to create, use and modify updatable views in MySQL, including their requirements, limitations, and best practices.

---

# MySQL Updatable Views

## Introduction

In MySQL, a view represents a virtual table created from the result set of a SQL query. Views simplify complex queries, add a security layer, and present data in a format that's more relevant to users. While all views in MySQL allow data retrieval, not all views permit data modification operations (INSERT, UPDATE, DELETE). Views that support these modification operations are called **updatable views**.

In this tutorial, you'll learn:
- What makes a view updatable
- How to create and use updatable views
- Limitations and restrictions
- Best practices and practical examples

## What Are Updatable Views?

An updatable view is a view that allows you to modify the underlying base tables through the view using INSERT, UPDATE, and DELETE operations. When you modify data through an updatable view, MySQL translates your modifications to appropriate operations on the underlying base tables.

## Requirements for Updatable Views

For a view to be updatable in MySQL, it typically needs to meet these requirements:

1. The view must be created from a single table
2. The view cannot contain:
   - Aggregate functions (COUNT(), MAX(), SUM(), etc.)
   - DISTINCT clause
   - GROUP BY clause
   - HAVING clause
   - UNION or UNION ALL
   - Subqueries in the SELECT list
   - Non-updatable views in the FROM clause
   - References to non-updatable views
   - Join operations (typically)

Let's create some examples to understand how updatable views work.

## Creating a Basic Updatable View

First, let's create a sample table to work with:

```sql
CREATE DATABASE view_examples;
USE view_examples;

CREATE TABLE employees (
    employee_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(15),
    department VARCHAR(50),
    salary DECIMAL(10, 2),
    hire_date DATE
);

-- Insert sample data
INSERT INTO employees (first_name, last_name, email, phone, department, salary, hire_date)
VALUES 
('John', 'Smith', 'john.smith@example.com', '555-1234', 'IT', 75000.00, '2020-01-15'),
('Sarah', 'Johnson', 'sarah.j@example.com', '555-2345', 'Marketing', 65000.00, '2019-05-22'),
('Michael', 'Davis', 'michael.d@example.com', '555-3456', 'IT', 80000.00, '2021-03-10'),
('Emma', 'Wilson', 'emma.w@example.com', '555-4567', 'HR', 60000.00, '2020-11-05'),
('Robert', 'Brown', 'robert.b@example.com', '555-5678', 'Finance', 90000.00, '2018-07-30');
```

Now, let's create a simple updatable view:

```sql
CREATE VIEW it_employees AS
SELECT employee_id, first_name, last_name, email, phone, salary
FROM employees
WHERE department = 'IT';
```

This view is updatable because it meets all the requirements. Let's check what data it contains:

```sql
SELECT * FROM it_employees;
```

Output:

```
+-------------+------------+-----------+------------------------+------------+----------+
| employee_id | first_name | last_name | email                  | phone      | salary   |
+-------------+------------+-----------+------------------------+------------+----------+
|           1 | John       | Smith     | john.smith@example.com | 555-1234   | 75000.00 |
|           3 | Michael    | Davis     | michael.d@example.com  | 555-3456   | 80000.00 |
+-------------+------------+-----------+------------------------+------------+----------+
```

## Modifying Data Through an Updatable View

### 1. UPDATE Operation

Let's update an employee's salary through the view:

```sql
UPDATE it_employees 
SET salary = 78000.00
WHERE employee_id = 1;
```

Now let's verify the change both through the view and the base table:

```sql
-- Check through the view
SELECT * FROM it_employees WHERE employee_id = 1;

-- Check through the base table
SELECT * FROM employees WHERE employee_id = 1;
```

Output from the view:

```
+-------------+------------+-----------+------------------------+------------+----------+
| employee_id | first_name | last_name | email                  | phone      | salary   |
+-------------+------------+-----------+------------------------+------------+----------+
|           1 | John       | Smith     | john.smith@example.com | 555-1234   | 78000.00 |
+-------------+------------+-----------+------------------------+------------+----------+
```

Output from the base table:

```
+-------------+------------+-----------+------------------------+------------+------------+----------+------------+
| employee_id | first_name | last_name | email                  | phone      | department | salary   | hire_date  |
+-------------+------------+-----------+------------------------+------------+------------+----------+------------+
|           1 | John       | Smith     | john.smith@example.com | 555-1234   | IT         | 78000.00 | 2020-01-15 |
+-------------+------------+-----------+------------------------+------------+------------+----------+------------+
```

### 2. INSERT Operation

We can also insert new records through the view:

```sql
INSERT INTO it_employees 
(first_name, last_name, email, phone, salary)
VALUES 
('David', 'Clark', 'david.c@example.com', '555-6789', 72000.00);
```

However, this operation will fail because our view doesn't include the `department` column, which doesn't have a default value in the base table. MySQL doesn't know what value to assign to the `department` column.

To make this work, we need to include the `department` column in our view or create a different view:

```sql
CREATE VIEW it_staff AS
SELECT employee_id, first_name, last_name, email, phone, department, salary
FROM employees
WHERE department = 'IT';
```

Now we can insert through this view:

```sql
INSERT INTO it_staff 
(first_name, last_name, email, phone, department, salary)
VALUES 
('David', 'Clark', 'david.c@example.com', '555-6789', 'IT', 72000.00);
```

This will work because all the necessary columns are included. Let's verify:

```sql
SELECT * FROM it_staff;
```

Output:

```
+-------------+------------+-----------+------------------------+------------+------------+----------+
| employee_id | first_name | last_name | email                  | phone      | department | salary   |
+-------------+------------+-----------+------------------------+------------+------------+----------+
|           1 | John       | Smith     | john.smith@example.com | 555-1234   | IT         | 78000.00 |
|           3 | Michael    | Davis     | michael.d@example.com  | 555-3456   | IT         | 80000.00 |
|           6 | David      | Clark     | david.c@example.com    | 555-6789   | IT         | 72000.00 |
+-------------+------------+-----------+------------------------+------------+------------+----------+
```

### 3. DELETE Operation

We can also delete records through an updatable view:

```sql
DELETE FROM it_employees
WHERE employee_id = 6;
```

Let's verify the delete:

```sql
SELECT * FROM employees;
```

Output (David Clark has been removed):

```
+-------------+------------+-----------+------------------------+------------+------------+----------+------------+
| employee_id | first_name | last_name | email                  | phone      | department | salary   | hire_date  |
+-------------+------------+-----------+------------------------+------------+------------+----------+------------+
|           1 | John       | Smith     | john.smith@example.com | 555-1234   | IT         | 78000.00 | 2020-01-15 |
|           2 | Sarah      | Johnson   | sarah.j@example.com    | 555-2345   | Marketing  | 65000.00 | 2019-05-22 |
|           3 | Michael    | Davis     | michael.d@example.com  | 555-3456   | IT         | 80000.00 | 2021-03-10 |
|           4 | Emma       | Wilson    | emma.w@example.com     | 555-4567   | HR         | 60000.00 | 2020-11-05 |
|           5 | Robert     | Brown     | robert.b@example.com   | 555-5678   | Finance    | 90000.00 | 2018-07-30 |
+-------------+------------+-----------+------------------------+------------+------------+----------+------------+
```

## The WITH CHECK OPTION Clause

MySQL provides a powerful option called `WITH CHECK OPTION` that ensures data modified through a view adheres to the view's defining conditions. This is useful to prevent insert or update operations that would create rows that aren't visible through the view.

Let's create a new view with this option:

```sql
CREATE VIEW high_salary_employees AS
SELECT employee_id, first_name, last_name, department, salary
FROM employees
WHERE salary > 70000
WITH CHECK OPTION;
```

Now, try to update a salary to below the threshold:

```sql
-- This will fail
UPDATE high_salary_employees
SET salary = 65000
WHERE employee_id = 1;
```

MySQL returns an error:

```
ERROR 1369 (HY000): CHECK OPTION failed 'view_examples.high_salary_employees'
```

This is because the update would create a row that doesn't meet the view's WHERE clause condition (salary > 70000).

## Using LOCAL and CASCADED Check Options

When working with nested views (views based on other views), MySQL offers two types of check options:

- **LOCAL**: Checks only the conditions in the view being operated on
- **CASCADED**: Checks conditions in the current view and all underlying views

Example:

```sql
-- Create a view with LOCAL check option
CREATE VIEW it_high_salary AS
SELECT *
FROM high_salary_employees
WHERE department = 'IT'
WITH LOCAL CHECK OPTION;

-- Create a view with CASCADED check option (default if not specified)
CREATE VIEW senior_it_staff AS
SELECT *
FROM high_salary_employees
WHERE department = 'IT'
WITH CASCADED CHECK OPTION;
```

## Common Limitations with Updatable Views

### 1. Views with JOINs

While some views with JOINs can be updatable in MySQL 5.7 and later, there are strict limitations. Let's see an example:

```sql
-- Create a department table
CREATE TABLE departments (
    department_id INT PRIMARY KEY AUTO_INCREMENT,
    department_name VARCHAR(50),
    location VARCHAR(100)
);

INSERT INTO departments (department_name, location)
VALUES 
('IT', 'Building A'),
('Marketing', 'Building B'),
('HR', 'Building A'),
('Finance', 'Building C');

-- Create a view with a JOIN
CREATE VIEW employee_details AS
SELECT 
    e.employee_id,
    e.first_name,
    e.last_name,
    e.salary,
    e.department,
    d.location
FROM 
    employees e
JOIN 
    departments d ON e.department = d.department_name;
```

This view has limited updatability. You can update some columns from the employees table but not the joined columns or those from the departments table.

```sql
-- This works
UPDATE employee_details
SET salary = 82000
WHERE employee_id = 3;

-- This will fail
UPDATE employee_details
SET location = 'Building D'
WHERE employee_id = 3;
```

### 2. Views with Derived Columns

Views with columns derived from expressions are not updatable for those specific columns:

```sql
CREATE VIEW employee_tax AS
SELECT 
    employee_id,
    first_name,
    last_name,
    salary,
    salary * 0.3 AS tax_amount
FROM employees;
```

You can update `first_name` or `salary`, but not `tax_amount`:

```sql
-- This works
UPDATE employee_tax
SET salary = 85000
WHERE employee_id = 3;

-- This will fail
UPDATE employee_tax
SET tax_amount = 25000
WHERE employee_id = 3;
```

## Checking if a View is Updatable

You can check if a view is updatable using the `INFORMATION_SCHEMA.VIEWS` table:

```sql
SELECT 
    TABLE_NAME,
    IS_UPDATABLE
FROM 
    INFORMATION_SCHEMA.VIEWS
WHERE 
    TABLE_SCHEMA = 'view_examples';
```

Output:

```
+------------------------+--------------+
| TABLE_NAME             | IS_UPDATABLE |
+------------------------+--------------+
| it_employees           | YES          |
| it_staff               | YES          |
| high_salary_employees  | YES          |
| employee_details       | NO           |
| employee_tax           | YES          |
| it_high_salary         | YES          |
| senior_it_staff        | YES          |
+------------------------+--------------+
```

## Practical Use Cases for Updatable Views

### 1. Data Security and Access Control

Updatable views can provide controlled access to specific columns or rows:

```sql
-- Create a view for HR department use
CREATE VIEW hr_employee_management AS
SELECT 
    employee_id,
    first_name, 
    last_name,
    department,
    hire_date
FROM 
    employees
WHERE 
    department != 'Executive';
```

Then grant permissions only on the view, not the underlying table:

```sql
GRANT SELECT, UPDATE, INSERT ON view_examples.hr_employee_management TO 'hr_user'@'localhost';
```

### 2. Data Validation and Business Rules

Views with CHECK OPTION can enforce business rules:

```sql
CREATE VIEW valid_employees AS
SELECT *
FROM employees
WHERE 
    salary > 0 AND
    email LIKE '%@example.com' AND
    phone LIKE '555-%'
WITH CHECK OPTION;
```

This ensures any inserts or updates through this view must adhere to these validation rules.

### 3. Simplifying Complex Tables

For tables with many columns, views can provide a simplified interface:

```sql
CREATE VIEW employee_essentials AS
SELECT
    employee_id,
    CONCAT(first_name, ' ', last_name) AS full_name,
    email,
    department
FROM 
    employees;
```

While this specific view has a derived column (full_name) and isn't fully updatable, it illustrates how views can simplify data presentation.

## Best Practices

1. **Document view behavior**: Clearly document which views are updatable and their limitations
2. **Use WITH CHECK OPTION**: Add this whenever you want to prevent modifications that would make records disappear from the view
3. **Test modifications**: Always test insert, update, and delete operations on your views
4. **Consider triggers**: For views with complex modification needs, consider using INSTEAD OF triggers (available in other database systems, not MySQL)
5. **Avoid excessive dependencies**: Be careful with creating chains of views based on other views

## Summary

Updatable views in MySQL provide a powerful way to modify underlying tables through a simplified or filtered interface. They can be used for:

- **Data security** - Limiting access to sensitive columns or rows
- **Data validation** - Enforcing business rules with CHECK OPTION
- **Data abstraction** - Presenting complex data structures in a user-friendly manner

While updatable views have limitations, particularly with JOINs, aggregations, and derived columns, they're a valuable tool in database design when used appropriately.

## Additional Resources

To deepen your understanding of MySQL views, consider exploring:

- [MySQL Official Documentation on Updatable Views](https://dev.mysql.com/doc/refman/8.0/en/view-updatability.html)
- Stored procedures as an alternative for complex data operations
- Triggers for advanced data validation logic

## Exercises

1. Create an updatable view that shows only employees with salaries between 60,000 and 80,000
2. Add the WITH CHECK OPTION to your view and test its effects
3. Create a view that calculates a bonus percentage (10% of salary) and try to update different columns
4. Create a view with a JOIN and examine which columns can be updated
5. Write queries to check which of your created views are updatable