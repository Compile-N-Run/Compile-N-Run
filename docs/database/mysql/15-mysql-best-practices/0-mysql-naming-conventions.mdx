---
title: MySQL Naming Conventions
description: Learn best practices for naming databases, tables, columns, and other MySQL objects to write clean, maintainable, and efficient SQL code.

---

# MySQL Naming Conventions

In the world of database design, consistent and meaningful naming conventions are as important as the actual schema structure. Good naming conventions make your database more readable, maintainable, and self-documenting. This guide will walk you through MySQL naming best practices that will help you create more professional database designs.

## Why Naming Conventions Matter

Before diving into specific conventions, let's understand why they're essential:

- **Readability**: Well-named objects make your database schema easier to understand
- **Maintainability**: Consistent naming makes future modifications simpler
- **Self-documentation**: Good names explain what objects do without needing comments
- **Collaboration**: Team members can understand your schema faster
- **Error prevention**: Standardized naming reduces the risk of errors and confusion

## General MySQL Naming Rules

### Character Set and Length Limitations

MySQL has specific rules regarding identifiers (names for databases, tables, columns, etc.):

- Unquoted identifiers can use alphanumeric characters, `$`, `_`
- Names are case-sensitive on Unix/Linux but case-insensitive on Windows
- Maximum length for most identifiers is 64 characters
- Names can't contain reserved words unless quoted (avoid this when possible)

### Naming Style Guidelines

Choose one of these common naming styles and use it consistently:

1. **snake_case**: Words separated by underscores (e.g., `user_account`)
2. **camelCase**: First word lowercase, subsequent words capitalized (e.g., `userAccount`)
3. **PascalCase**: All words capitalized (e.g., `UserAccount`)

In MySQL, **snake_case** is most commonly used because:
- It's easier to read for complex names
- It avoids case-sensitivity issues
- It's the style used in MySQL's own system tables

## Database Naming Conventions

When naming databases:

```sql
-- Good database names
CREATE DATABASE inventory_management;
CREATE DATABASE customer_records;

-- Avoid database names like these
CREATE DATABASE "My Database";  -- Contains spaces, needs quotes
CREATE DATABASE db1;  -- Not descriptive
```

Guidelines for database names:

- Use descriptive nouns that represent the application or function
- Use lowercase with underscores to separate words
- Avoid abbreviations unless they are widely understood
- Don't use version numbers in database names (use migration tools instead)

## Table Naming Conventions

Tables should follow these naming patterns:

```sql
-- Good table names
CREATE TABLE products;
CREATE TABLE customer_orders;
CREATE TABLE order_items;

-- Avoid table names like these
CREATE TABLE tbl_products;  -- Redundant prefix
CREATE TABLE THE_PRODUCTS;  -- Inconsistent casing
```

Guidelines for table names:

- Use plural nouns for entities (e.g., `customers`, not `customer`)
- Use lowercase with underscores to separate words
- Avoid prefixes like `tbl_` or `TB_` (they add no value)
- For junction tables (many-to-many relationships), combine the related table names:
  - Example: `student_courses` for a table connecting students and courses

## Column Naming Conventions

Column names require special attention since they're used most frequently:

```sql
-- Good column names
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    in_stock BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Avoid column names like these
CREATE TABLE products (
    ID INT PRIMARY KEY AUTO_INCREMENT,  -- Inconsistent casing
    ProductName VARCHAR(100) NOT NULL,  -- Inconsistent casing
    $price DECIMAL(10,2) NOT NULL,      -- Special character
    "in stock" BOOLEAN DEFAULT TRUE     -- Contains space, needs quotes
);
```

Guidelines for column names:

- Use singular, descriptive names
- Use lowercase with underscores to separate words
- Be consistent with similar columns across tables
- Primary keys should use `table_name_id` or simply `id` pattern
- Foreign keys should match the referenced column name
- Boolean columns should use prefixes like `is_`, `has_`, or `can_`
- Date/time columns can use suffixes like `_date`, `_time`, or `_at`

## Primary and Foreign Key Conventions

Keys deserve special attention as they define relationships:

```sql
-- Good primary and foreign key naming
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

-- Alternative approach with constraint naming
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT NOT NULL,
    order_date DATE NOT NULL,
    CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id) 
        REFERENCES customers(customer_id)
);
```

Guidelines for keys:

- Primary keys: Use `id` or `table_name_id`
- Foreign keys: Use the same name as the referenced column
- For explicit constraint names:
  - Primary key constraints: `pk_table_name`
  - Foreign key constraints: `fk_table_name_referenced_table`
  - Unique constraints: `uq_table_name_column_name`

## Index Naming Conventions

Well-named indexes help with database maintenance:

```sql
-- Good index names
CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    category_id INT NOT NULL,
    INDEX idx_products_category_id (category_id),
    UNIQUE INDEX idx_products_name (name)
);
```

Guidelines for index names:

- Prefix with `idx_` for regular indexes or `uq_` for unique indexes
- Include the table name
- Include the column name(s) being indexed
- For multi-column indexes, include all column names in order

## Stored Procedure and Function Naming

For stored routines:

```sql
-- Good stored procedure and function names
DELIMITER //

CREATE PROCEDURE get_active_customers()
BEGIN
    SELECT * FROM customers WHERE is_active = TRUE;
END//

CREATE FUNCTION calculate_order_total(order_id INT) 
RETURNS DECIMAL(10,2)
BEGIN
    DECLARE total DECIMAL(10,2);
    SELECT SUM(quantity * unit_price) INTO total
    FROM order_items WHERE order_id = order_id;
    RETURN total;
END//

DELIMITER ;
```

Guidelines for stored routines:

- Procedures: Use verb_noun format (e.g., `get_customers`, `update_inventory`)
- Functions: Use verb_noun or action_description (e.g., `calculate_total`)
- Use lowercase with underscores to separate words
- Be specific about what the routine does

## View Naming Conventions

Views should clearly indicate they're not base tables:

```sql
-- Good view names
CREATE VIEW active_customers_view AS
    SELECT * FROM customers WHERE is_active = TRUE;

CREATE VIEW orders_summary_view AS
    SELECT 
        o.order_id,
        c.name AS customer_name,
        SUM(oi.quantity * oi.unit_price) AS total_amount
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY o.order_id, c.name;
```

Guidelines for view names:

- Add suffix `_view` or prefix `v_` to distinguish from tables
- Use descriptive names that explain what the view presents
- Follow the same case convention as tables

## Trigger Naming Conventions

Triggers should indicate when and on which table they operate:

```sql
-- Good trigger names
DELIMITER //

CREATE TRIGGER before_product_update
BEFORE UPDATE ON products
FOR EACH ROW
BEGIN
    SET NEW.last_updated = NOW();
END//

CREATE TRIGGER after_order_insert
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE customer_stats 
    SET order_count = order_count + 1
    WHERE customer_id = NEW.customer_id;
END//

DELIMITER ;
```

Guidelines for trigger names:

- Format: `{timing}_{table}_{action}`
  - Timing: `before` or `after`
  - Table: The affected table name
  - Action: `insert`, `update`, or `delete`
- Use lowercase with underscores to separate words

## Real-World Application Example

Let's see these naming conventions applied to a real-world e-commerce database:

```sql
-- Database
CREATE DATABASE ecommerce_platform;

USE ecommerce_platform;

-- Tables
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash CHAR(60) NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP NULL
);

CREATE TABLE products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    sku VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10,2) NOT NULL,
    stock_quantity INT NOT NULL DEFAULT 0,
    category_id INT,
    is_featured BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_products_category_id (category_id)
);

CREATE TABLE categories (
    category_id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    parent_category_id INT NULL,
    FOREIGN KEY (parent_category_id) REFERENCES categories(category_id)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status VARCHAR(20) DEFAULT 'pending',
    shipping_address_id INT NOT NULL,
    payment_method_id INT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    INDEX idx_orders_user_id (user_id)
);

CREATE TABLE order_items (
    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    unit_price DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id),
    UNIQUE KEY uq_order_items_order_product (order_id, product_id)
);

-- View
CREATE VIEW order_summary_view AS
    SELECT 
        o.order_id,
        CONCAT(u.first_name, ' ', u.last_name) AS customer_name,
        o.order_date,
        o.status,
        SUM(oi.quantity * oi.unit_price) AS total_amount,
        COUNT(oi.product_id) AS total_items
    FROM orders o
    JOIN users u ON o.user_id = u.user_id
    JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY o.order_id, customer_name, o.order_date, o.status;

-- Stored procedure
DELIMITER //

CREATE PROCEDURE get_low_stock_products(threshold INT)
BEGIN
    SELECT 
        product_id,
        name,
        stock_quantity
    FROM products 
    WHERE stock_quantity < threshold
    ORDER BY stock_quantity ASC;
END//

DELIMITER ;
```

This example demonstrates consistent naming throughout the schema, making it clear and maintainable.

## Common Naming Mistakes to Avoid

Be careful to avoid these common naming pitfalls:

1. **Inconsistent casing**: Mixing `camelCase`, `snake_case`, and `PascalCase`
2. **Using reserved words**: Using MySQL reserved words like `SELECT`, `ORDER`, or `GROUP` as identifiers
3. **Cryptic abbreviations**: Using abbreviations only you understand
4. **Ambiguous names**: Names that don't clearly communicate purpose (e.g., `data`, `info`)
5. **Redundant prefixes/suffixes**: Like `tbl_customers_table`
6. **Using spaces or special characters**: These require quoting and can cause issues
7. **Not following your established pattern**: Inconsistency within your own database

## Summary

Adopting consistent MySQL naming conventions will pay dividends in code readability, maintenance, and collaboration. Here are the key takeaways:

- Choose one naming style (preferably `snake_case`) and use it consistently
- Use descriptive, meaningful names that reflect the purpose of objects
- Be consistent with pluralization (plural for tables, singular for columns)
- Follow established patterns for keys, indexes, and constraints
- Consider future maintenance when designing naming schemes
- Document any deviations from standard conventions

Following these conventions from the start of your project will help you build a more professional, maintainable database. As your application grows, you'll appreciate the clarity and consistency that good naming brings.

## Additional Resources

For further learning:

- [MySQL Documentation on Schema Object Names](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html)
- [SQL Style Guide](https://www.sqlstyle.guide/)
- [Database Naming Standards](https://stackoverflow.com/questions/7662/database-table-and-column-naming-conventions)

## Exercises

1. Review an existing database you've created. Identify naming inconsistencies and create a plan to standardize them.
2. Design a database schema for a library management system following the naming conventions in this guide.
3. Write a script to analyze a database and report identifiers that don't follow your chosen naming conventions.
4. Create a cheat sheet of your team's agreed-upon MySQL naming conventions for quick reference.