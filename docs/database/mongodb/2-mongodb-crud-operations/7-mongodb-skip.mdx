---
title: MongoDB Skip
description: Learn how to use the skip() method in MongoDB to control pagination and skip documents in query results

---

# MongoDB Skip

When working with large datasets in MongoDB, you often need to implement pagination or skip over certain documents in your query results. The `skip()` method provides this functionality, allowing you to bypass a specified number of documents in your query results.

## Introduction to skip()

The `skip()` method is a cursor method in MongoDB that allows you to control which documents appear in your results by skipping over a specified number of documents that match your query criteria. This is particularly useful for pagination and when you need to process large result sets in batches.

The basic syntax is:

```javascript
db.collection.find(query).skip(numberOfDocumentsToSkip)
```

## How skip() Works

When you apply the `skip()` method to a cursor:

1. MongoDB executes your query to identify matching documents
2. It then skips over the first `n` documents (where `n` is the value you provide to `skip()`)
3. The remaining documents are returned as your result set

Let's see how this works with some examples.

## Basic Usage Examples

### Simple skip() Example

Consider a collection named `products` with the following documents:

```javascript
[
  { "_id": 1, "name": "Laptop", "price": 1200 },
  { "_id": 2, "name": "Smartphone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 500 },
  { "_id": 4, "name": "Smartwatch", "price": 300 },
  { "_id": 5, "name": "Headphones", "price": 150 }
]
```

To skip the first two products and retrieve the rest:

```javascript
db.products.find().skip(2)
```

**Output:**
```javascript
[
  { "_id": 3, "name": "Tablet", "price": 500 },
  { "_id": 4, "name": "Smartwatch", "price": 300 },
  { "_id": 5, "name": "Headphones", "price": 150 }
]
```

### Combining skip() with Other Methods

The real power of `skip()` emerges when combined with other cursor methods like `limit()` and `sort()`.

#### Using skip() with limit()

To implement simple pagination, you can combine `skip()` and `limit()`:

```javascript
// Get the second page with 2 items per page
db.products.find().skip(2).limit(2)
```

**Output:**
```javascript
[
  { "_id": 3, "name": "Tablet", "price": 500 },
  { "_id": 4, "name": "Smartwatch", "price": 300 }
]
```

#### Using skip() with sort()

To get the second and third most expensive products:

```javascript
db.products.find().sort({ price: -1 }).skip(1).limit(2)
```

**Output:**
```javascript
[
  { "_id": 2, "name": "Smartphone", "price": 800 },
  { "_id": 3, "name": "Tablet", "price": 500 }
]
```

## Implementing Pagination with skip()

One of the most common use cases for `skip()` is implementing pagination in applications. Here's how you can structure a pagination system:

```javascript
// Configuration
const pageSize = 2;  // Number of documents per page
const pageNumber = 2; // Page number (1-based)

// Calculate skip value
const skipValue = (pageNumber - 1) * pageSize;

// Execute query with pagination
db.products.find().skip(skipValue).limit(pageSize);
```

This will retrieve the second page of products with 2 items per page.

### Using in a Node.js Application

Here's how you might implement pagination in a Node.js application using the MongoDB driver:

```javascript
const { MongoClient } = require('mongodb');

async function paginateResults(pageNumber, pageSize) {
  const uri = "mongodb://localhost:27017";
  const client = new MongoClient(uri);
  
  try {
    await client.connect();
    const database = client.db("store");
    const products = database.collection("products");
    
    // Calculate skip value
    const skipValue = (pageNumber - 1) * pageSize;
    
    // Find documents with pagination
    const cursor = products.find()
                           .skip(skipValue)
                           .limit(pageSize);
    
    // Convert to array
    const results = await cursor.toArray();
    console.log(`Page ${pageNumber} results:`, results);
    return results;
  } finally {
    await client.close();
  }
}

// Example usage
paginateResults(2, 2)
  .then(results => console.log("Pagination complete"))
  .catch(console.error);
```

## Performance Considerations

While `skip()` is useful, there are some important performance considerations to keep in mind:

1. **Efficiency with large values**: The `skip()` operation becomes slower as the number of skipped documents increases because MongoDB still needs to scan and count all the skipped documents.

2. **Alternative for large datasets**: For large datasets, consider using range queries on an indexed field instead of `skip()`. For example:

```javascript
// Instead of this (inefficient for large skip values):
db.products.find().sort({ _id: 1 }).skip(10000).limit(10);

// Use this approach with an indexed field:
// First, get the last _id from the previous page
const lastId = getLastIdFromPreviousPage();
db.products.find({ _id: { $gt: lastId } }).limit(10);
```

3. **Indexes**: Ensure you have proper indexes in place, especially when combining `skip()` with `sort()`.

## Common Patterns and Real-world Applications

### API Pagination

RESTful APIs commonly use pagination to limit the amount of data returned:

```javascript
// API endpoint: /api/products?page=2&limit=10

const page = parseInt(req.query.page) || 1;
const limit = parseInt(req.query.limit) || 10;
const skip = (page - 1) * limit;

const products = await db.collection('products')
  .find()
  .skip(skip)
  .limit(limit)
  .toArray();

// Return results with pagination metadata
res.json({
  currentPage: page,
  totalPages: Math.ceil(totalProducts / limit),
  pageSize: limit,
  totalProducts: totalProducts,
  products: products
});
```

### Data Processing in Batches

When processing large collections, you can use `skip()` and `limit()` to process data in manageable batches:

```javascript
const batchSize = 1000;
let currentBatch = 0;
let processedCount = 0;
let hasMore = true;

while (hasMore) {
  const documents = await db.collection('largeCollection')
    .find()
    .skip(currentBatch * batchSize)
    .limit(batchSize)
    .toArray();
  
  if (documents.length === 0) {
    hasMore = false;
  } else {
    // Process batch
    await processBatch(documents);
    processedCount += documents.length;
    currentBatch++;
    
    console.log(`Processed ${processedCount} documents so far`);
  }
}
```

## Skip() in Aggregation Pipeline

You can also use `$skip` as a stage in an aggregation pipeline:

```javascript
db.products.aggregate([
  { $match: { inStock: true } },
  { $sort: { price: -1 } },
  { $skip: 5 },
  { $limit: 10 },
  { $project: { name: 1, price: 1, _id: 0 } }
])
```

This example finds in-stock products, sorts them by price (descending), skips the first 5 results, limits to 10 results, and projects only the name and price fields.

## Common Mistakes and How to Avoid Them

### Mistake 1: Using skip() with large values

**Problem:** Using large skip values is inefficient as MongoDB must still scan all the skipped documents.

**Solution:** Use range queries on indexed fields for better performance as shown in the performance considerations section.

### Mistake 2: Not accounting for changing data

**Problem:** When paginating, new documents might be added or removed between page requests, causing documents to appear twice or be skipped entirely.

**Solution:** Use consistent sorting based on a unique field and implement cursor-based pagination for dynamic datasets:

```javascript
// Instead of page-based pagination:
db.products.find().skip(page * limit).limit(limit);

// Use cursor-based pagination with a unique, indexed field:
// For the next page:
db.products.find({ _id: { $gt: lastId } }).limit(limit);
```

## Summary

The MongoDB `skip()` method is a valuable tool for controlling which documents appear in your query results. It's particularly useful for implementing pagination and processing large datasets in batches. Remember these key points:

- Use `skip()` to bypass a specified number of documents in query results
- Combine with `limit()` for effective pagination
- Consider performance implications when using large skip values
- For large datasets, consider alternatives like range queries on indexed fields
- The `$skip` stage can also be used in aggregation pipelines

## Practice Exercises

1. Create a collection of 20 documents and implement a paginated query that shows 5 documents per page.

2. Build a simple REST API endpoint that returns paginated results from a MongoDB collection.

3. Implement cursor-based pagination using the `_id` field instead of `skip()` for a collection with frequently changing data.

4. Create an aggregation pipeline that groups documents by a category, sorts by the count of documents in each category, and then uses `$skip` and `$limit` to paginate the results.

## Further Reading

- [MongoDB Documentation on cursor.skip()](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/)
- [Efficient Pagination Using the Skip Method](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/#pagination)
- [MongoDB Aggregation Pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/)
- [Cursor-based Pagination Implementation Strategies](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/#cursor-based-pagination)