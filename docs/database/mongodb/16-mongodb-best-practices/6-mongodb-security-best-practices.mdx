---
title: MongoDB Security Best Practices
description: Learn essential security practices to protect your MongoDB databases from unauthorized access and potential threats. This guide covers authentication, authorization, encryption, and other crucial security measures.

---

# MongoDB Security Best Practices

## Introduction

Security is a critical aspect of any database system, and MongoDB is no exception. As MongoDB databases often store sensitive information, implementing robust security measures is essential to protect your data from unauthorized access, breaches, and other security threats.

This guide covers fundamental security practices that every MongoDB developer should implement, from basic authentication and authorization to advanced encryption techniques and network security considerations.

## Why MongoDB Security Matters

MongoDB databases are often targets for malicious actors due to their widespread adoption and the valuable data they contain. Without proper security measures:

- Unauthorized users could access sensitive information
- Data could be modified, deleted, or stolen
- Your application could experience downtime or performance issues
- Your organization might face legal and financial consequences

## Essential MongoDB Security Best Practices

### 1. Enable Authentication

By default, MongoDB instances can be accessed without authentication, which poses significant security risks. Always enable authentication to ensure only authorized users can access your database.

#### Setting Up Authentication

First, create an admin user:

```javascript
use admin
db.createUser({
  user: "adminUser",
  pwd: "securePassword123",
  roles: ["userAdminAnyDatabase", "dbAdminAnyDatabase", "readWriteAnyDatabase"]
})
```

Then, edit your MongoDB configuration file (`mongod.conf`) to enable authentication:

```yaml
security:
  authorization: enabled
```

Restart MongoDB to apply the changes:

```bash
sudo systemctl restart mongod
```

Now, you must authenticate to access your databases:

```javascript
// Connect to MongoDB with authentication
mongo --host localhost --port 27017 -u "adminUser" -p "securePassword123" --authenticationDatabase "admin"

// Or authenticate after connecting
use admin
db.auth("adminUser", "securePassword123")
```

### 2. Implement Role-Based Access Control (RBAC)

MongoDB offers a robust role-based access control system that allows you to grant specific permissions to users based on their roles.

#### Creating Users with Specific Roles

```javascript
// Create a read-only user for a specific database
use myDatabase
db.createUser({
  user: "readOnlyUser",
  pwd: "password456",
  roles: [{ role: "read", db: "myDatabase" }]
})

// Create a user with write permissions
db.createUser({
  user: "readWriteUser",
  pwd: "password789",
  roles: [{ role: "readWrite", db: "myDatabase" }]
})
```

#### Available Built-in Roles

MongoDB provides several built-in roles:

- `read`: Read-only access to specified databases
- `readWrite`: Read and write access to specified databases
- `dbAdmin`: Database administration privileges
- `userAdmin`: User administration privileges
- `clusterAdmin`: Cluster administration privileges
- `readAnyDatabase`: Read-only access to all databases
- `readWriteAnyDatabase`: Read and write access to all databases
- `root`: Full access to all resources

### 3. Network Security

#### Bind to Localhost Only

By default, MongoDB should only bind to localhost, preventing external access. Configure this in your `mongod.conf`:

```yaml
net:
  bindIp: 127.0.0.1
```

If you need to allow remote connections, specify the IP addresses:

```yaml
net:
  bindIp: 127.0.0.1,192.168.1.100
```

#### Use Firewalls

Configure your firewall to limit access to your MongoDB port (default: 27017):

```bash
# Ubuntu/Debian
sudo ufw allow from 192.168.1.0/24 to any port 27017

# CentOS/RHEL
sudo firewall-cmd --permanent --add-rich-rule 'rule family="ipv4" source address="192.168.1.0/24" port port="27017" protocol="tcp" accept'
sudo firewall-cmd --reload
```

### 4. Enable TLS/SSL Encryption

TLS/SSL encryption secures data in transit between the client and server.

#### Generate Self-Signed Certificate (for testing)

```bash
# Create directory for certificates
mkdir -p /etc/ssl/mongodb

# Generate CA certificate
openssl genrsa -out /etc/ssl/mongodb/ca.key 4096
openssl req -new -x509 -days 1826 -key /etc/ssl/mongodb/ca.key -out /etc/ssl/mongodb/ca.crt -subj "/CN=MongoDB CA"

# Generate server certificate
openssl genrsa -out /etc/ssl/mongodb/server.key 4096
openssl req -new -key /etc/ssl/mongodb/server.key -out /etc/ssl/mongodb/server.csr -subj "/CN=mongodb.example.com"
openssl x509 -req -in /etc/ssl/mongodb/server.csr -CA /etc/ssl/mongodb/ca.crt -CAkey /etc/ssl/mongodb/ca.key -CAcreateserial -out /etc/ssl/mongodb/server.crt -days 365
```

#### Configure MongoDB to Use TLS/SSL

Update your MongoDB configuration file:

```yaml
net:
  ssl:
    mode: requireSSL
    PEMKeyFile: /etc/ssl/mongodb/server.pem
    CAFile: /etc/ssl/mongodb/ca.crt
```

#### Connect Using TLS/SSL

```javascript
mongo --ssl --host mongodb.example.com --sslCAFile /etc/ssl/mongodb/ca.crt --sslPEMKeyFile /etc/ssl/mongodb/client.pem
```

In your Node.js application:

```javascript
const { MongoClient } = require('mongodb');

const uri = "mongodb://username:password@mongodb.example.com:27017/myDatabase?ssl=true";
const client = new MongoClient(uri, {
  sslCA: fs.readFileSync('/etc/ssl/mongodb/ca.crt'),
  sslKey: fs.readFileSync('/etc/ssl/mongodb/client.key'),
  sslCert: fs.readFileSync('/etc/ssl/mongodb/client.crt')
});

async function connect() {
  await client.connect();
  console.log("Connected securely to MongoDB");
  // Operations here
  await client.close();
}

connect().catch(console.error);
```

### 5. Encrypt Data at Rest

#### Using MongoDB Enterprise Encryption

MongoDB Enterprise offers built-in encryption at rest:

```yaml
security:
  enableEncryption: true
  encryptionKeyFile: /path/to/key/file
```

#### Using Field-Level Encryption (Client-Side)

MongoDB 4.2+ supports client-side field-level encryption:

```javascript
const { MongoClient, ClientEncryption } = require('mongodb');
const fs = require('fs');

// Create a key for encryption
const localMasterKey = fs.readFileSync('master-key.bin');

const kmsProviders = {
  local: {
    key: localMasterKey
  }
};

const client = new MongoClient('mongodb://localhost:27017', {
  autoEncryption: {
    keyVaultNamespace: 'encryption.__keyVault',
    kmsProviders: kmsProviders,
    schemaMap: {
      'myDatabase.patients': {
        properties: {
          ssn: {
            encrypt: {
              keyId: [UUID],
              bsonType: 'string',
              algorithm: 'AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic'
            }
          }
        }
      }
    }
  }
});

async function insertEncryptedData() {
  await client.connect();
  
  const patients = client.db('myDatabase').collection('patients');
  await patients.insertOne({
    name: 'John Doe',
    ssn: '123-45-6789',  // This field will be encrypted
    address: '123 Main St'
  });
  
  console.log('Inserted encrypted document');
  await client.close();
}

insertEncryptedData().catch(console.error);
```

### 6. Audit System Activity

MongoDB Enterprise includes auditing capabilities to track system events:

```yaml
auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.json
  filter: '{ atype: { $in: ["authenticate", "createCollection", "dropCollection"] } }'
```

### 7. Regular Security Audits and Updates

#### Keep MongoDB Updated

Always run the latest stable version with security patches:

```bash
# Check current version
mongod --version

# Update MongoDB (Ubuntu/Debian)
sudo apt-get update
sudo apt-get install mongodb-org
```

#### Security Scan Tools

Use tools like MongoDB Compass or third-party security scanners to identify vulnerabilities.

### 8. Secure MongoDB Deployment Architecture

A recommended architecture for securing MongoDB:

```mermaid
flowchart TB
    Internet(Internet) --> FW[Firewall]
    FW --> APP[Application Servers]
    APP --> FW2[Internal Firewall]
    FW2 --> DB1[(MongoDB Primary)]
    FW2 --> DB2[(MongoDB Secondary)]
    FW2 --> DB3[(MongoDB Secondary)]
```

## Real-World Security Implementation

Let's walk through a complete example of securing a MongoDB deployment for a healthcare application:

### Step 1: Configure MongoDB with Authentication and Encryption

```yaml
# mongod.conf
security:
  authorization: enabled
  enableEncryption: true
  encryptionKeyFile: /etc/mongodb/encryption-key

net:
  bindIp: 127.0.0.1,192.168.10.5
  port: 27017
  ssl:
    mode: requireSSL
    PEMKeyFile: /etc/ssl/mongodb/server.pem
    CAFile: /etc/ssl/mongodb/ca.crt

auditLog:
  destination: file
  format: JSON
  path: /var/log/mongodb/audit.json
```

### Step 2: Create Role-Based User Accounts

```javascript
// Connect to MongoDB as admin
use admin
db.auth("adminUser", "adminPassword")

// Create database for healthcare application
use healthcareDB

// Create user roles
db.createRole({
  role: "patientDataAccess",
  privileges: [
    { resource: { db: "healthcareDB", collection: "patients" }, actions: ["find"] },
    { resource: { db: "healthcareDB", collection: "appointments" }, actions: ["find"] }
  ],
  roles: []
})

db.createRole({
  role: "doctorDataAccess",
  privileges: [
    { resource: { db: "healthcareDB", collection: "patients" }, actions: ["find", "update"] },
    { resource: { db: "healthcareDB", collection: "appointments" }, actions: ["find", "update", "insert"] },
    { resource: { db: "healthcareDB", collection: "medicalRecords" }, actions: ["find", "update", "insert"] }
  ],
  roles: []
})

// Create users with specific roles
db.createUser({
  user: "nurseUser",
  pwd: "secureNursePassword",
  roles: ["patientDataAccess"]
})

db.createUser({
  user: "doctorUser",
  pwd: "secureDoctorPassword",
  roles: ["doctorDataAccess"]
})

db.createUser({
  user: "adminUser",
  pwd: "secureAdminPassword",
  roles: [{ role: "dbAdmin", db: "healthcareDB" }]
})
```

### Step 3: Connect from Application with Proper Security

```javascript
const { MongoClient } = require('mongodb');
const fs = require('fs');

// Connection URI with authentication
const uri = "mongodb://doctorUser:secureDoctorPassword@192.168.10.5:27017/healthcareDB?ssl=true&authSource=healthcareDB";

// Connection options
const options = {
  sslCA: fs.readFileSync('/etc/ssl/mongodb/ca.crt'),
  sslKey: fs.readFileSync('/etc/ssl/mongodb/client.key'),
  sslCert: fs.readFileSync('/etc/ssl/mongodb/client.crt'),
  useNewUrlParser: true,
  useUnifiedTopology: true,
  monitorCommands: true
};

const client = new MongoClient(uri, options);

async function run() {
  try {
    await client.connect();
    console.log("Connected successfully to MongoDB");
    
    // Access patient records (authorized for doctors)
    const patientsCollection = client.db("healthcareDB").collection("patients");
    const patient = await patientsCollection.findOne({ patientId: "P12345" });
    
    console.log("Patient record accessed:", patient.name);
    
    // Update medical record (authorized for doctors)
    const medicalRecordsCollection = client.db("healthcareDB").collection("medicalRecords");
    await medicalRecordsCollection.updateOne(
      { patientId: "P12345" },
      { 
        $push: { 
          visits: {
            date: new Date(),
            diagnosis: "Common cold",
            treatment: "Rest and fluids",
            doctor: "Dr. Smith"
          } 
        } 
      }
    );
    
    console.log("Medical record updated successfully");
    
  } finally {
    await client.close();
  }
}

run().catch(console.error);
```

## Summary

Securing your MongoDB database is a critical responsibility that involves multiple layers of protection:

1. **Authentication and Authorization**: Always enable authentication and use role-based access control to limit user permissions.
2. **Network Security**: Restrict access to your MongoDB instances through IP binding and firewalls.
3. **Encryption**: Implement TLS/SSL for data in transit and encryption at rest for sensitive data.
4. **Auditing**: Track database activities to detect suspicious behavior.
5. **Regular Updates**: Keep your MongoDB installation updated with the latest security patches.
6. **Secure Architecture**: Design your deployment with security in mind, using features like VPCs, firewalls, and logical separation.

By implementing these security best practices, you can significantly reduce the risk of unauthorized access and data breaches in your MongoDB deployments.

## Additional Resources

- [MongoDB Security Documentation](https://docs.mongodb.com/manual/security/)
- [MongoDB University Security Course](https://university.mongodb.com/courses/M310/about)
- [OWASP Database Security Guidelines](https://owasp.org/www-project-top-ten/)

## Practice Exercises

1. Set up a MongoDB instance with authentication and create users with different permission levels.
2. Implement TLS/SSL encryption for a MongoDB connection in a Node.js application.
3. Configure field-level encryption for sensitive fields in a collection.
4. Create an audit log for tracking critical operations in your MongoDB database.
5. Perform a security audit on an existing MongoDB deployment and identify potential vulnerabilities.

By completing these exercises, you'll gain practical experience in implementing MongoDB security best practices in real-world scenarios.