---
title: RabbitMQ Federation Plugin
description: Learn how to scale RabbitMQ across distributed environments using the Federation Plugin

---

# RabbitMQ Federation Plugin

## Introduction

The RabbitMQ Federation Plugin is a powerful extension that allows you to connect multiple RabbitMQ brokers together across various networks, data centers, or geographic regions. Unlike clustering (which requires all nodes to be on the same network), federation creates loose coupling between brokers, making it ideal for distributed systems that span across different locations.

Federation works by establishing unidirectional connections between exchanges and queues, allowing messages to flow from upstream to downstream brokers without requiring tight coupling. This approach helps you build resilient, geographically distributed messaging systems with reduced latency for local consumers.

## Federation vs. Clustering

Before diving into federation, let's clarify how it differs from RabbitMQ clustering:

| Feature | Federation | Clustering |
|---------|------------|------------|
| Network Requirements | Can work across WAN, internet | Requires LAN with low latency |
| Data Replication | Only forwards messages as needed | Replicates all metadata |
| Node Connection | Loose coupling | Tight coupling |
| Use Case | Geographically distributed deployments | Local high availability |
| Setup Complexity | Moderate | Simple |
| Failure Isolation | High | Low |

## How Federation Works

Federation creates links between exchanges or queues across different RabbitMQ brokers:

```mermaid
graph LR
    subgraph "Data Center A"
        A[Broker A]
    end
    subgraph "Data Center B"
        B[Broker B]
    end
    A -->|Federation Link| B
    style A fill:#c8e6c9
    style B fill:#c8e6c9
```

When you federate:

1. The downstream broker creates a consumer on the upstream broker
2. Messages published to the upstream are forwarded to the downstream
3. The messages are then re-published locally on the downstream broker
4. Local consumers receive messages with minimal latency

## Prerequisites

Before setting up federation, ensure you have:

1. Multiple RabbitMQ brokers running (at least version 3.8.0+)
2. Network connectivity between brokers
3. Management plugin enabled (helpful for configuration)
4. Federation plugin enabled on all participating nodes

## Enabling the Federation Plugin

To enable the federation plugin, run the following command on each broker:

```bash
rabbitmq-plugins enable rabbitmq_federation
rabbitmq-plugins enable rabbitmq_federation_management  # Optional but recommended
```

You can verify the plugins are enabled with:

```bash
rabbitmq-plugins list
```

Output should include:

```
[e] rabbitmq_federation               3.8.14
[e] rabbitmq_federation_management    3.8.14
```

## Configuring Federation

### Step 1: Define Upstream Servers

First, define which upstream brokers you want to connect to. You can do this via the management UI or using the `rabbitmqctl` command:

```bash
rabbitmqctl set_parameter federation-upstream my-upstream '{"uri":"amqp://username:password@upstream-host:5672","expires":3600000}'
```

This creates an upstream configuration named "my-upstream" that points to another RabbitMQ broker.

### Step 2: Set Up Federation Policies

Next, create a policy that determines which exchanges or queues should be federated:

```bash
rabbitmqctl set_policy --apply-to exchanges federation-policy "^federated\." '{"federation-upstream":"my-upstream"}' 
```

This policy will federate all exchanges whose names start with "federated." using the upstream we defined earlier.

For queues:

```bash
rabbitmqctl set_policy --apply-to queues federation-queue-policy "^federated\." '{"federation-upstream":"my-upstream"}'
```

### Step 3: Verify Federation Status

You can check the status of federation links in the RabbitMQ management UI under the "Admin" > "Federation Status" tab or with the command:

```bash
rabbitmqctl eval 'rabbit_federation_status:status().'
```

A healthy federation link will show status "running".

## Federation Patterns and Examples

Let's explore some common federation patterns with examples:

### Example 1: Hub and Spoke Topology

In this pattern, a central broker (the hub) federates with multiple regional brokers (the spokes):

```mermaid
graph TD
    Hub[Central Hub Broker] --> Spoke1[Region A Broker]
    Hub --> Spoke2[Region B Broker]
    Hub --> Spoke3[Region C Broker]
    style Hub fill:#bbdefb
    style Spoke1 fill:#c8e6c9
    style Spoke2 fill:#c8e6c9
    style Spoke3 fill:#c8e6c9
```

Configuration (on each spoke):

```bash
# On Region A Broker
rabbitmqctl set_parameter federation-upstream central-hub '{"uri":"amqp://username:password@central-hub-host:5672"}'
rabbitmqctl set_policy --apply-to exchanges regional-updates "^updates\." '{"federation-upstream":"central-hub"}'
```

This allows each regional broker to receive messages published to the central hub, while maintaining local message delivery for regional clients.

### Example 2: Bidirectional Federation

For two-way communication between brokers, you need to set up federation in both directions:

```mermaid
graph LR
    A[Broker A] -->|Federation Link| B[Broker B]
    B -->|Federation Link| A
    style A fill:#c8e6c9
    style B fill:#c8e6c9
```

Configuration:

```bash
# On Broker A
rabbitmqctl set_parameter federation-upstream broker-b '{"uri":"amqp://username:password@broker-b-host:5672"}'
rabbitmqctl set_policy --apply-to exchanges federation-to-b "^shared\." '{"federation-upstream":"broker-b"}'

# On Broker B
rabbitmqctl set_parameter federation-upstream broker-a '{"uri":"amqp://username:password@broker-a-host:5672"}'
rabbitmqctl set_policy --apply-to exchanges federation-to-a "^shared\." '{"federation-upstream":"broker-a"}'
```

### Example 3: Federated Queues for Load Distribution

Federated queues allow messages to flow from upstream queues to downstream queues:

```javascript
// Publishing to the upstream queue
const amqp = require('amqplib');

async function publishToUpstream() {
  const connection = await amqp.connect('amqp://localhost:5672');
  const channel = await connection.createChannel();
  
  const queue = 'federated.tasks';
  await channel.assertQueue(queue, { durable: true });
  
  // Publish 100 messages
  for (let i = 0; i < 100; i++) {
    const message = `Task ${i} from upstream`;
    channel.sendToQueue(queue, Buffer.from(message));
    console.log(`Sent: ${message}`);
  }
  
  await channel.close();
  await connection.close();
}

publishToUpstream();
```

On the downstream broker, consumers will receive messages when the upstream queue has messages and the downstream queue has capacity:

```javascript
// Consuming from the downstream federated queue
const amqp = require('amqplib');

async function consumeFromDownstream() {
  const connection = await amqp.connect('amqp://localhost:5673');  // Different port for downstream
  const channel = await connection.createChannel();
  
  const queue = 'federated.tasks';
  await channel.assertQueue(queue, { durable: true });
  
  console.log('Waiting for messages...');
  
  channel.consume(queue, (msg) => {
    console.log(`Received: ${msg.content.toString()}`);
    channel.ack(msg);
  });
}

consumeFromDownstream();
```

## Advanced Federation Configuration

### Upstream Sets

You can define multiple upstreams in a set for more complex topologies:

```bash
rabbitmqctl set_parameter federation-upstream-set all-upstreams '[{"upstream":"upstream-a"},{"upstream":"upstream-b"}]'
rabbitmqctl set_policy --apply-to exchanges federation-policy "^federated\." '{"federation-upstream-set":"all-upstreams"}'
```

### Overriding Exchange Types

When federating exchanges, you can specify the type of exchange to be created downstream:

```bash
rabbitmqctl set_parameter federation-upstream my-upstream '{
  "uri":"amqp://username:password@upstream-host:5672",
  "exchange-type":"fanout"
}'
```

### Message Transformation

You can transform messages as they pass through federation using the Shovel plugin for more advanced routing logic.

## Monitoring Federation

Proper monitoring is essential for federated setups. Key metrics to watch:

1. Federation link status
2. Message rates across federation links
3. Consumer counts
4. Queue lengths on both sides

You can access these metrics through:

- RabbitMQ Management UI
- HTTP API
- Prometheus and Grafana using the RabbitMQ Prometheus plugin

Example Prometheus query to monitor federation links:

```
rabbitmq_federation_link_status
```

## Troubleshooting Federation

Common issues and their solutions:

1. **Federation link not starting**
   - Check network connectivity
   - Verify credentials in the upstream URI
   - Ensure the upstream exchange/queue exists

2. **Messages not flowing**
   - Verify the federation policy pattern matches your exchanges/queues
   - Check if bindings exist on the downstream broker
   - Look for any error messages in the RabbitMQ logs

3. **High latency or performance issues**
   - Consider network quality between brokers
   - Check for queue backing up on either side
   - Look at resource usage (CPU, memory, network)

## Real-World Use Case: Multi-Region Application

Consider an e-commerce application with users across multiple geographic regions:

```mermaid
graph TD
    subgraph "US Region"
        US_Pub[Publishers] --> US_Broker[US Broker]
        US_Broker --> US_Con[Consumers]
    end
    
    subgraph "EU Region"
        EU_Pub[Publishers] --> EU_Broker[EU Broker]
        EU_Broker --> EU_Con[Consumers]
    end
    
    subgraph "Asia Region"
        Asia_Pub[Publishers] --> Asia_Broker[Asia Broker]
        Asia_Broker --> Asia_Con[Consumers]
    end
    
    US_Broker -->|Federation| EU_Broker
    US_Broker -->|Federation| Asia_Broker
    EU_Broker -->|Federation| US_Broker
    EU_Broker -->|Federation| Asia_Broker
    Asia_Broker -->|Federation| US_Broker
    Asia_Broker -->|Federation| EU_Broker
    
    style US_Broker fill:#bbdefb
    style EU_Broker fill:#bbdefb
    style Asia_Broker fill:#bbdefb
```

Benefits of this setup:

1. **Low latency**: Local users connect to their regional broker
2. **High availability**: If one region is down, others continue to function
3. **Data locality**: Most messages are processed locally
4. **Global consistency**: Critical updates propagate to all regions

Implementation involves:

```bash
# On each broker, set up federation to the other two brokers
rabbitmqctl set_parameter federation-upstream-set all-regions '[{"upstream":"us-upstream"},{"upstream":"eu-upstream"},{"upstream":"asia-upstream"}]'

# Federate specific exchanges that need global visibility
rabbitmqctl set_policy --apply-to exchanges global-events "^global\." '{"federation-upstream-set":"all-regions"}'

# Keep other exchanges local
rabbitmqctl set_policy --apply-to exchanges local-only "^local\." '{}'
```

## Summary

The RabbitMQ Federation Plugin provides a flexible way to connect multiple RabbitMQ brokers across geographic regions or network boundaries. Unlike clustering, federation offers loose coupling that works well over WANs and unreliable networks.

Key takeaways:

- Federation creates unidirectional links between exchanges or queues
- It's ideal for geographically distributed applications
- Federation complements rather than replaces clustering
- Setup involves configuring upstreams and policies
- Proper monitoring and troubleshooting are essential for production deployments

## Exercises

1. Set up a basic federation between two local RabbitMQ instances on different ports
2. Create a federated exchange and verify messages flow from upstream to downstream
3. Configure bidirectional federation and test message flow in both directions
4. Experiment with different exchange types in a federated setup
5. Set up a federation upstream set with multiple sources

## Additional Resources

- [Official RabbitMQ Federation Documentation](https://www.rabbitmq.com/federation.html)
- [RabbitMQ Federation Plugin Reference](https://www.rabbitmq.com/federation-reference.html)
- [RabbitMQ Management HTTP API](https://www.rabbitmq.com/management.html#http-api)
- [Reliable Message Delivery Patterns](https://www.rabbitmq.com/reliability.html)

Remember that federation is just one tool in the RabbitMQ high availability toolkit. Consider your specific requirements carefully when choosing between federation, clustering, or other solutions like the Shovel plugin.