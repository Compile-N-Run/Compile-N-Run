---
title: RabbitMQ Mirroring Policies
description: Learn how to configure and manage mirroring policies in RabbitMQ to ensure high availability of your message queues

---

# RabbitMQ Mirroring Policies

## Introduction

In distributed systems, ensuring your message broker remains available even when individual nodes fail is critical. RabbitMQ, a popular message broker, addresses this challenge through **queue mirroring**. 

Mirroring policies in RabbitMQ allow you to configure how your queues are replicated across multiple nodes in a cluster. This replication ensures that if one node goes down, your messages and queue configurations remain accessible through other nodes, providing high availability for your messaging infrastructure.

In this guide, we'll explore how RabbitMQ mirroring policies work, how to configure them effectively, and best practices for implementing them in production environments.

## Understanding Queue Mirroring

Before diving into policies, let's understand the basic concept of queue mirroring in RabbitMQ.

### Mirrored Queues Explained

In a RabbitMQ cluster, a mirrored queue consists of:

- One **master** (or primary) node that handles all operations
- One or more **mirror** (or replica) nodes that maintain copies of the queue

```mermaid
graph TD
    A[Producer] -->|Publishes message| B[RabbitMQ Cluster]
    subgraph B[RabbitMQ Cluster]
        C[Node 1: Queue Master] 
        D[Node 2: Queue Mirror]
        E[Node 3: Queue Mirror]
        C ---|Replicates data| D
        C ---|Replicates data| E
    end
    B -->|Delivers message| F[Consumer]
```

When a message is published to a mirrored queue:

1. The message is first written to the master queue
2. The master then replicates the message to all mirrors
3. Once all mirrors acknowledge receipt, the operation is considered complete

If the master node fails, one of the mirrors is automatically promoted to become the new master, ensuring continued operation.

## Configuring Mirroring Policies

RabbitMQ uses **policies** to define how queues should be mirrored. These policies are rules that match queues by name and apply mirroring configurations to them.

### Basic Policy Structure

A mirroring policy consists of:

- A **name** that identifies the policy
- A **pattern** that matches queue names
- **Definition** that specifies mirroring parameters
- **Priority** that determines which policy applies when multiple policies match

### Creating a Basic Mirroring Policy

You can create policies using the RabbitMQ management UI, HTTP API, or command line tools. Here's how to create a basic policy using the `rabbitmqctl` command:

```bash
rabbitmqctl set_policy my-ha-policy "^ha\." '{"ha-mode":"all"}' --apply-to queues
```

This command:
- Creates a policy named `my-ha-policy`
- Applies to all queues with names starting with "ha."
- Sets the `ha-mode` to `all`, meaning the queue will be mirrored to all nodes in the cluster

### Common Mirroring Parameters

RabbitMQ offers several parameters to fine-tune your mirroring policies:

| Parameter | Description | Values |
|-----------|-------------|--------|
| `ha-mode` | Determines how mirrors are distributed | `all`, `exactly`, `nodes` |
| `ha-params` | Additional parameters for the ha-mode | Depends on ha-mode |
| `ha-sync-mode` | Controls queue synchronization behavior | `automatic`, `manual` |
| `ha-promote-on-shutdown` | Specifies which mirrors can be promoted if the master shuts down | `always`, `when-synced` |
| `ha-promote-on-failure` | Specifies which mirrors can be promoted if the master fails | `always`, `when-synced` |

## Mirroring Modes Explained

Let's explore the different mirroring modes available in RabbitMQ:

### ha-mode: all

When you set `ha-mode` to `all`, the queue is mirrored to all nodes in the cluster:

```bash
rabbitmqctl set_policy ha-all "^production\." '{"ha-mode":"all"}' --apply-to queues
```

**Pros**: Maximizes availability as the queue remains available as long as at least one node is running.
**Cons**: Increases resource usage and network traffic as the number of nodes grows.

### ha-mode: exactly

The `exactly` mode allows you to specify exactly how many mirrors you want:

```bash
rabbitmqctl set_policy ha-exactly "^critical\." '{"ha-mode":"exactly","ha-params":3}' --apply-to queues
```

This creates queues with one master and two mirrors (for a total of 3 nodes).

**Pros**: Balances availability and resource usage.
**Cons**: If you have fewer nodes than specified, mirroring will be incomplete.

### ha-mode: nodes

The `nodes` mode allows you to specify exactly which nodes should host mirrors:

```bash
rabbitmqctl set_policy ha-nodes "^specific\." '{"ha-mode":"nodes","ha-params":["rabbit@node1", "rabbit@node2"]}' --apply-to queues
```

**Pros**: Provides precise control over where queues are mirrored.
**Cons**: Requires manual updates when cluster topology changes.

## Queue Synchronization Strategies

When a new mirror joins a mirrored queue, it needs to synchronize its content with the master. RabbitMQ offers two synchronization modes:

### Automatic Synchronization

With automatic synchronization, mirrors synchronize as soon as they join:

```bash
rabbitmqctl set_policy ha-sync "^auto-sync\." '{"ha-mode":"all","ha-sync-mode":"automatic"}' --apply-to queues
```

**Pros**: Ensures mirrors have all messages as soon as possible.
**Cons**: Can cause performance issues with large queues during synchronization.

### Manual Synchronization

With manual synchronization, you control when synchronization happens:

```bash
rabbitmqctl set_policy ha-manual "^manual-sync\." '{"ha-mode":"all","ha-sync-mode":"manual"}' --apply-to queues
```

To trigger synchronization manually:

```bash
rabbitmqctl sync_queue queue_name
```

**Pros**: Gives you control over when to impact performance.
**Cons**: Mirrors won't have all messages until synchronized, which can lead to message loss if the master fails before synchronization.

## Real-World Examples

Let's look at some practical examples of mirroring policies for different scenarios:

### Example 1: High-Priority Queues

For critical business operations where downtime must be minimized:

```bash
rabbitmqctl set_policy critical-operations "^critical\." '{"ha-mode":"all","ha-sync-mode":"automatic","ha-promote-on-failure":"always"}' --priority 10 --apply-to queues
```

### Example 2: Balance Between Availability and Performance

For queues that need high availability but have high message throughput:

```bash
rabbitmqctl set_policy balanced-ha "^standard\." '{"ha-mode":"exactly","ha-params":3,"ha-sync-mode":"manual"}' --priority 5 --apply-to queues
```

### Example 3: Regional Mirroring

For applications deployed across multiple regions or data centers:

```bash
rabbitmqctl set_policy regional-mirror "^region1\." '{"ha-mode":"nodes","ha-params":["rabbit@region1-node1", "rabbit@region1-node2", "rabbit@region2-node1"]}' --apply-to queues
```

## Implementing Mirroring in Your Application

When working with mirrored queues, consider these implementation tips:

### Java Client Example

Here's a simple example using the Java client library:

```java
ConnectionFactory factory = new ConnectionFactory();
factory.setHost("rabbit-host");
factory.setUsername("user");
factory.setPassword("password");

// Create connection and channel
Connection connection = factory.newConnection();
Channel channel = connection.createChannel();

// Declare a queue (will be mirrored according to matching policies)
channel.queueDeclare("critical.orders", true, false, false, null);

// Publish with publisher confirms for extra reliability
channel.confirmSelect();
channel.basicPublish("", "critical.orders", 
                    new AMQP.BasicProperties.Builder()
                        .deliveryMode(2) // persistent
                        .build(),
                    "Hello World".getBytes());
channel.waitForConfirmsOrDie(5000);
```

### Node.js Client Example

Here's how to use mirrored queues with amqplib in Node.js:

```javascript
const amqp = require('amqplib');

async function publishToMirroredQueue() {
  try {
    // Connect to RabbitMQ server
    const connection = await amqp.connect('amqp://user:password@rabbit-host');
    const channel = await connection.createChannel();
    
    // Declare a queue (will be mirrored according to matching policies)
    await channel.assertQueue('critical.orders', {
      durable: true
    });
    
    // Send a message
    channel.sendToQueue('critical.orders', Buffer.from('Hello World'), {
      persistent: true
    });
    
    console.log("Message sent");
    
    // Close connection
    setTimeout(() => {
      connection.close();
    }, 500);
  } catch (error) {
    console.error(error);
  }
}

publishToMirroredQueue();
```

## Monitoring Mirrored Queues

To ensure your mirroring setup is working correctly, you should monitor:

1. **Queue synchronization status**: Check if mirrors are in sync with masters
2. **Queue length imbalances**: Significant differences may indicate synchronization issues
3. **Network partitions**: These can disrupt mirroring and cause split-brain scenarios

You can view this information in the RabbitMQ Management UI or use the HTTP API:

```bash
# List queues with their mirroring status
rabbitmqctl list_queues name slave_nodes synchronised_slave_nodes

# Get detailed information about a specific queue
curl -u user:password http://rabbit-host:15672/api/queues/%2F/queue-name
```

## Best Practices

Here are some best practices for working with RabbitMQ mirroring policies:

1. **Don't mirror everything**: Only mirror queues that truly need high availability
2. **Use reasonable mirror counts**: More mirrors increase availability but reduce performance
3. **Consider network topology**: Place mirrors in different failure domains (racks/availability zones)
4. **Use publisher confirms**: Ensure messages are safely replicated before considering them sent
5. **Monitor synchronization status**: Unsynchronized mirrors can lead to message loss
6. **Test failover scenarios**: Regular testing ensures your setup works when needed
7. **Update policies gradually**: Making sweeping changes can overload your cluster

## Common Pitfalls and Solutions

| Pitfall | Solution |
|---------|----------|
| Performance degradation due to excessive mirroring | Mirror only critical queues, use `exactly` mode |
| Message loss during node failures | Use `ha-promote-on-failure: when-synced` and publisher confirms |
| Network bandwidth consumption | Limit mirroring to specific nodes or use fewer mirrors |
| Slow queue synchronization | Use `manual` synchronization for large queues |
| Policy conflicts | Set appropriate priorities for your policies |

## Summary

RabbitMQ mirroring policies provide a powerful way to ensure high availability of your message queues. By understanding the different mirroring modes, synchronization strategies, and best practices, you can build a robust messaging infrastructure that remains available even when individual nodes fail.

Remember these key points:

- Mirrored queues consist of one master and multiple mirrors
- Use policies to define which queues should be mirrored and how
- Choose the right ha-mode (`all`, `exactly`, or `nodes`) based on your requirements
- Consider synchronization strategies for new mirrors
- Monitor your mirrored queues regularly
- Follow best practices to balance availability and performance

## Additional Resources

For further learning about RabbitMQ mirroring policies:

- Practice creating different mirroring policies and observe their behavior
- Experiment with failover scenarios by stopping nodes
- Try implementing mirroring in a small test application before deploying to production

## Exercises

1. Create a policy that mirrors all queues with names starting with "exercise." to exactly 2 nodes.
2. Write a simple producer and consumer application that uses a mirrored queue.
3. Test what happens when you stop the node hosting the master of your mirrored queue.
4. Monitor the synchronization status of your mirrored queues using the Management UI.
5. Create a policy with manual synchronization and practice synchronizing a queue.