---
title: Ubuntu Input Output
description: Learn how to handle input and output operations in the Ubuntu terminal with practical examples and real-world applications

---

# Ubuntu Input Output

## Introduction

Input and output (I/O) operations are fundamental concepts in any computing environment, including Ubuntu. When working with the terminal, understanding how to control the flow of information into programs (input) and how to manage the results produced by those programs (output) is essential for effective command-line usage.

In this guide, we'll explore how Ubuntu handles input and output streams, how to redirect these streams, and how to combine commands using pipes to create powerful command sequences.

## Standard I/O Streams

Every command or program running in the Ubuntu terminal has three standard streams:

1. **Standard Input (stdin)** - Stream for data going into a program (by default from keyboard)
2. **Standard Output (stdout)** - Stream for normal output from a program (by default to terminal screen)
3. **Standard Error (stderr)** - Stream for error messages (by default to terminal screen)

```mermaid
graph LR
    A[Keyboard] -->|stdin| B[Command/Program]
    B -->|stdout| C[Terminal Screen]
    B -->|stderr| C
```

Let's look at each of these streams in detail and how to manipulate them.

## Standard Input (stdin)

Standard input is the default data stream that feeds into a command. By default, this is your keyboard. When you type a command and provide input, you're using stdin.

### Example: Using `cat` to Read from stdin

The `cat` command without arguments reads from stdin and outputs to stdout:

```bash
cat
```

Try typing the command above, then enter some text, and press Enter. The text will be repeated back to you. To exit, press `Ctrl+D` (which sends an EOF - End of File - signal).

Example session:
```
$ cat
Hello, Ubuntu!
Hello, Ubuntu!
This is stdin in action.
This is stdin in action.
^D
$
```

## Standard Output (stdout)

Standard output is where a command sends its normal output. By default, this is displayed on your terminal screen.

### Example: Commands Producing stdout

```bash
echo "Hello, Ubuntu!"
ls
date
```

Output example:
```
$ echo "Hello, Ubuntu!"
Hello, Ubuntu!

$ ls
Documents  Downloads  Music  Pictures  Videos

$ date
Thu Mar 13 14:30:45 UTC 2025
```

## Standard Error (stderr)

Standard error is a separate output stream specifically for error messages. By default, it's also displayed on your terminal screen (which can make it look identical to stdout).

### Example: Command Producing stderr

```bash
ls /nonexistent
```

Output example:
```
$ ls /nonexistent
ls: cannot access '/nonexistent': No such file or directory
```

## I/O Redirection

One of the most powerful features of the Ubuntu terminal is the ability to redirect these standard streams.

### Redirecting stdout (>)

To redirect stdout to a file instead of the screen:

```bash
ls > file_list.txt
```

This creates a file named `file_list.txt` containing the output of the `ls` command. If the file already exists, it will be overwritten.

To append output to an existing file, use `>>`:

```bash
echo "Additional content" >> file_list.txt
```

### Redirecting stderr (2>)

To redirect stderr to a file:

```bash
ls /nonexistent 2> errors.txt
```

The error message is now in the `errors.txt` file instead of being displayed on the screen.

### Redirecting Both stdout and stderr

To redirect both outputs to different files:

```bash
ls /home /nonexistent > output.txt 2> errors.txt
```

To redirect both to the same file:

```bash
ls /home /nonexistent > all_output.txt 2>&1
```

Alternatively, in Bash, you can use a more modern syntax:

```bash
ls /home /nonexistent &> all_output.txt
```

### Redirecting stdin (`<`)

To use a file as input instead of the keyboard:

```bash
sort < names.txt
```

This feeds the contents of `names.txt` to the `sort` command.

## Using Pipes (|)

Pipes allow you to connect the stdout of one command to the stdin of another, creating a pipeline of operations.

```bash
ls -l | grep "txt"
```

This command takes the output of `ls -l` and sends it to `grep`, which filters for lines containing "txt".

### Example: Counting Files in a Directory

```bash
ls | wc -l
```

The output of `ls` is piped to `wc -l`, which counts the number of lines.

## Practical Examples

### Example 1: Finding and Sorting Large Files

```bash
find /home -type f -size +10M -exec ls -lh {} \; | sort -k5hr | head -n 10
```

This command:
1. Finds all files larger than 10MB in the /home directory
2. Lists them with detailed information
3. Sorts them by size (largest first)
4. Shows only the top 10

### Example 2: Creating a Log of System Information

```bash
{
  echo "System Report: $(date)"
  echo "-------------------"
  echo "Kernel Version:"
  uname -a
  echo -e "
Disk Space:"
  df -h
  echo -e "
Memory Usage:"
  free -h
} > system_report.txt
```

This creates a comprehensive system report in a single file.

### Example 3: Processing a CSV File

Assuming you have a CSV file with user data:

```bash
cat users.csv | grep "active" | cut -d',' -f1,3 > active_users.csv
```

This extracts only the active users and saves only the 1st and 3rd fields to a new file.

### Example 4: Monitoring Log Files in Real-time

```bash
tail -f /var/log/syslog | grep ERROR
```

This command continuously monitors the syslog file for new entries and displays only lines containing "ERROR".

## Advanced I/O Concepts

### Here Documents (`<<`)

A "here document" is a way to provide multiline input to a command:

```bash
cat << EOF > multiline.txt
This is line 1
This is line 2
This is the final line
EOF
```

This creates a file called `multiline.txt` with the content between the `<<EOF` and the final `EOF`.

### /dev/null - The Null Device

When you want to discard output completely, redirect it to `/dev/null`:

```bash
ls /nonexistent 2>/dev/null
```

This runs the command but discards any error messages.

### Process Substitution

Process substitution allows you to use the output of a command where a file name is expected:

```bash
diff <(ls dir1) <(ls dir2)
```

This compares the outputs of `ls dir1` and `ls dir2` without creating temporary files.

## Summary

Understanding input and output in the Ubuntu terminal provides powerful tools for:

- Redirecting program output to files (`>`, `>>`)
- Redirecting error messages (`2>`)
- Using files as input (`<`)
- Connecting commands together with pipes (`|`)
- Creating complex command sequences for data processing

These I/O manipulation techniques are fundamental to effective shell scripting and command-line usage in Ubuntu.

## Exercises

1. Create a script that counts the number of words in all text files in a directory.
2. Redirect both stdout and stderr from the `find` command to different files.
3. Use `grep` with pipes to filter the output of the `ps aux` command for a specific user.
4. Create a simple logging system that appends date-stamped entries to a log file.
5. Use process substitution to compare the sizes of files in two different directories.

## Additional Resources

- The Ubuntu manual pages for Bash: `man bash`
- Learn more about stream redirection with: `help redirection` (in Bash)
- Practice with grep and pipes: `man grep`