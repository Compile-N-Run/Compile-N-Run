---
title: "Django Test Database"
description: "Learn how Django handles databases during testing, including test database creation, isolation, and configuration options for effective testing practices."

---

# Django Test Database

## Introduction

When testing a Django application, you need to ensure that your tests don't affect your production database. Django solves this problem by creating a separate test database during the testing process. This test database provides an isolated environment where your tests can freely create, modify, and delete data without affecting your actual application data.

In this guide, we'll explore how Django handles test databases, how to configure them, and best practices for working with them effectively.

## How Django Test Databases Work

When you run tests in Django, the following database-related processes occur:

1. Django creates a test database based on your database settings
2. Django applies all migrations to set up the database schema
3. Your tests run, manipulating data in the test database
4. After tests complete, Django destroys the test database

This process ensures that your tests have a fresh, isolated database environment each time they run.

## Creating and Using Test Databases

### Default Behavior

By default, Django's test runner creates a test database by adding a `test_` prefix to your database name. For example, if your database is named `myproject`, the test database will be named `test_myproject`.

Let's see how Django handles this process:

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

When tests run with these settings, Django will create a test database named `test_db.sqlite3` for testing.

### Writing Tests with Database Operations

Here's a simple example of a test that interacts with the database:

```python
# myapp/tests.py
from django.test import TestCase
from myapp.models import Product

class ProductModelTest(TestCase):
    def setUp(self):
        # This data is created in the test database
        self.product = Product.objects.create(
            name="Test Product",
            price=99.99,
            description="This is a test product"
        )
    
    def test_product_creation(self):
        # This query runs against the test database
        product = Product.objects.get(id=self.product.id)
        self.assertEqual(product.name, "Test Product")
        self.assertEqual(product.price, 99.99)
```

This test creates a `Product` object in the test database and verifies that it was created correctly. After the test completes, the test database is destroyed, and your production database remains unchanged.

## Test Database Configuration

Django offers several options for configuring test databases to match your testing needs.

### Using a Different Database for Testing

You can configure Django to use a different database engine for testing:

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myproject',
        'USER': 'postgres',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
        'TEST': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'test_db.sqlite3',
        },
    }
}
```

This configuration uses PostgreSQL for your production database but switches to SQLite for testing, which can speed up tests significantly.

### Using Named Test Databases

You can explicitly name your test database:

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myproject',
        'USER': 'postgres',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
        'TEST': {
            'NAME': 'mytestdatabase',
        },
    }
}
```

This configuration will use the name `mytestdatabase` for your test database instead of the default `test_myproject`.

## Keeping Test Databases

By default, Django destroys the test database after testing. Sometimes, you might want to keep the test database for debugging. You can do this by using the `--keepdb` flag:

```bash
python manage.py test --keepdb
```

With this flag, Django will reuse the existing test database if it exists, or create a new one if it doesn't. This can significantly speed up the test execution process during development.

## Test Database Performance Tips

### Using In-Memory SQLite

For faster tests, you can configure Django to use an in-memory SQLite database:

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myproject',
        # Other PostgreSQL settings...
        'TEST': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': ':memory:',
        },
    }
}
```

This configuration loads the entire database into memory, eliminating disk I/O and making tests run significantly faster. However, it may not accurately reflect the behavior of your production database.

### Using Database Fixtures

Fixtures are initial data that Django can load into your test database. They're useful for setting up consistent test conditions:

```python
# myapp/tests.py
from django.test import TestCase

class ProductViewTest(TestCase):
    fixtures = ['test_products.json']
    
    def test_product_list_view(self):
        response = self.client.get('/products/')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context['products']), 3)  # Assuming 3 products in fixture
```

You can create fixtures by using the `dumpdata` management command:

```bash
python manage.py dumpdata myapp.Product --indent 4 > myapp/fixtures/test_products.json
```

## Multiple Databases for Testing

If your application uses multiple databases, Django creates test versions for each one:

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'primary_db',
        # Other settings...
    },
    'analytics': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'analytics_db',
        # Other settings...
    }
}
```

When running tests, Django creates test databases for both the `default` and `analytics` databases.

You can specify which database to use in your tests with the `using` method:

```python
# myapp/tests.py
from django.test import TestCase
from myapp.models import AnalyticsData

class AnalyticsTest(TestCase):
    def setUp(self):
        AnalyticsData.objects.using('analytics').create(
            page_views=100,
            unique_visitors=50
        )
    
    def test_analytics_data(self):
        data = AnalyticsData.objects.using('analytics').first()
        self.assertEqual(data.page_views, 100)
```

## Real-World Example: Testing an E-commerce System

Let's see a comprehensive example of testing an e-commerce system with database interactions:

```python
# store/models.py
from django.db import models
from django.contrib.auth.models import User

class Product(models.Model):
    name = models.CharField(max_length=200)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    stock = models.IntegerField(default=0)
    
    def is_in_stock(self):
        return self.stock > 0
    
class Order(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    completed = models.BooleanField(default=False)
    
    def get_total(self):
        return sum(item.product.price * item.quantity for item in self.orderitem_set.all())

class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.IntegerField(default=1)
```

Now let's test the order system:

```python
# store/tests.py
from decimal import Decimal
from django.test import TestCase
from django.contrib.auth.models import User
from .models import Product, Order, OrderItem

class OrderSystemTest(TestCase):
    def setUp(self):
        # Create a test user
        self.user = User.objects.create_user(
            username='testuser',
            password='12345'
        )
        
        # Create some products
        self.product1 = Product.objects.create(
            name='Laptop',
            price=999.99,
            stock=10
        )
        
        self.product2 = Product.objects.create(
            name='Mouse',
            price=24.99,
            stock=5
        )
        
        # Create an order
        self.order = Order.objects.create(user=self.user)
        
        # Add items to the order
        OrderItem.objects.create(
            order=self.order,
            product=self.product1,
            quantity=1
        )
        
        OrderItem.objects.create(
            order=self.order,
            product=self.product2,
            quantity=2
        )
    
    def test_order_total(self):
        # Expected total: Laptop ($999.99) + 2 × Mouse ($24.99 × 2) = $1049.97
        expected_total = Decimal('1049.97')
        self.assertEqual(self.order.get_total(), expected_total)
    
    def test_product_stock_status(self):
        self.assertTrue(self.product1.is_in_stock())
        
        # Update product to be out of stock
        self.product1.stock = 0
        self.product1.save()
        
        # Refresh from database to ensure we get the updated value
        self.product1.refresh_from_db()
        self.assertFalse(self.product1.is_in_stock())
```

This example demonstrates how Django's test database allows you to create users, products, and orders, manipulate them, and test their relationships and behaviors—all without affecting your production data.

## Transaction Management in Tests

Django's `TestCase` class wraps each test in a transaction and rolls it back after the test completes. This ensures that tests don't affect each other, even when they run sequentially.

If you need finer control over transactions, you can use `TransactionTestCase`:

```python
from django.test import TransactionTestCase
from myapp.models import Product

class ProductTransactionTest(TransactionTestCase):
    def test_database_interaction(self):
        # This test operates without automatic transaction rollback
        Product.objects.create(name="Test Product", price=99.99)
        self.assertEqual(Product.objects.count(), 1)
```

`TransactionTestCase` doesn't wrap tests in transactions, which is useful for testing scenarios involving transaction behavior, but tests run slower than with standard `TestCase`.

## Summary

Django's test database system is a powerful feature that allows you to write comprehensive tests without worrying about affecting your production data. Key points to remember:

1. Django automatically creates a separate test database for running tests
2. The test database is created fresh for each test run, ensuring test isolation
3. You can configure various aspects of the test database, including its name, engine, and other settings
4. For performance, you can use in-memory databases or keep databases between test runs
5. Django supports testing with multiple databases and provides features like fixtures for loading initial test data

By understanding and properly utilizing Django's test database features, you can write more effective and reliable tests for your applications.

## Additional Resources

- [Django Testing Documentation](https://docs.djangoproject.com/en/stable/topics/testing/overview/)
- [Django Database Testing Configuration](https://docs.djangoproject.com/en/stable/topics/testing/advanced/#topics-testing-advanced-multidb)
- [Django Fixture Documentation](https://docs.djangoproject.com/en/stable/howto/initial-data/)

## Exercises

1. Create a Django project with a simple model and write tests that create, read, update, and delete instances of that model.
2. Configure your Django project to use an in-memory SQLite database for testing and compare the test execution time with a file-based SQLite database.
3. Create a fixture containing sample data for your model and write tests that use this fixture.
4. Implement a test involving multiple related models with foreign key relationships.
5. Write a test that uses `TransactionTestCase` to verify a scenario where transaction rollbacks are important.