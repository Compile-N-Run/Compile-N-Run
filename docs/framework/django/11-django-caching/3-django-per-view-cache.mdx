---
title: "Django Per-View Cache"
description: "Learn how to implement per-view caching in Django to optimize specific views in your web application"

---

# Django Per-View Cache

## Introduction

Django's caching framework provides several levels of granularity when it comes to caching, and per-view caching is one of the most useful approaches. Per-view caching allows you to cache the output of specific views for a designated period, which can significantly improve performance for views that are computationally expensive or frequently accessed.

Unlike site-wide caching, per-view caching lets you be selective about which views deserve caching, giving you fine-grained control over your application's performance optimizations. This is particularly useful when some views display dynamic, personalized content while others show the same content to all users.

## Prerequisites

Before diving into per-view caching, make sure you have:

- A basic Django project set up
- Django's caching framework configured (in `settings.py`)
- Basic understanding of Django views

## Setting Up Cache Backend

First, let's ensure we have a cache backend configured in our Django settings:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake',
    }
}
```

For production environments, you might want to use a more robust cache backend like Redis or Memcached:

```python
# Redis example
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
    }
}

# Memcached example
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
```

## Using the `cache_page` Decorator

Django provides a simple decorator called `cache_page` that you can use to cache the output of entire views. This is the easiest way to implement per-view caching.

### Basic Usage

Here's how to use the `cache_page` decorator:

```python
from django.views.decorators.cache import cache_page

# Cache this view for 15 minutes (60 seconds * 15)
@cache_page(60 * 15)
def my_view(request):
    # Your view logic here
    return render(request, 'my_template.html', {'data': expensive_operation()})
```

### Complete Example

Let's see a more complete example:

```python
# views.py
from django.views.decorators.cache import cache_page
from django.shortcuts import render
import time

# Cache this view for 5 minutes
@cache_page(60 * 5)
def product_list(request):
    # Simulate an expensive database query
    time.sleep(2)  # This delay will only happen on cache miss
    products = [
        {'id': 1, 'name': 'Product 1', 'price': 99.99},
        {'id': 2, 'name': 'Product 2', 'price': 149.99},
        {'id': 3, 'name': 'Product 3', 'price': 199.99},
    ]
    
    return render(request, 'products/list.html', {'products': products})
```

Now, when a user requests the `product_list` view, Django will check if the response is already in the cache. If it is, Django will return the cached response immediately, skipping the view's execution. If not, Django will execute the view, cache its response, and then return it to the user.

On subsequent visits within the 5-minute window, users will get the cached response instantly without the 2-second delay.

## Using Different Cache Backends for Specific Views

You can use different cache backends for different views. This is useful if, for example, you want to cache some views in memory and others in a more persistent store.

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
    },
    'persistent': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}

# views.py
from django.views.decorators.cache import cache_page

@cache_page(60 * 15, cache="default")
def quick_view(request):
    # Uses the default in-memory cache
    return render(request, 'quick_template.html')

@cache_page(60 * 60 * 24, cache="persistent")
def slow_view(request):
    # Uses the persistent file-based cache
    return render(request, 'slow_template.html')
```

## Varying the Cache by Request Headers

Sometimes your view's output depends on specific HTTP headers, such as language preferences. You can tell Django to vary the cache based on specific headers:

```python
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_headers

@cache_page(60 * 15)
@vary_on_headers('Accept-Language')
def multilingual_view(request):
    # Content will be cached separately for each language
    return render(request, 'multilingual.html')
```

## Varying the Cache by Cookies

Similarly, if your view output depends on cookies (like for logged-in users), you can vary the cache by cookies:

```python
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_cookie

@cache_page(60 * 15)
@vary_on_cookie
def user_dashboard(request):
    # Each user gets their own cached version
    return render(request, 'dashboard.html')
```

## Controlling Cache Per URL Parameter

Sometimes you need different cache responses based on URL parameters. Django doesn't have a built-in decorator for this, but you can create a custom solution:

```python
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator
from functools import wraps

def cache_page_with_params(*args, **kwargs):
    def decorator(view_func):
        @wraps(view_func)
        def _wrapped_view(request, *args, **kwargs):
            # Calculate cache key based on request.GET
            query_params = request.GET.copy()
            cache_key = f"{request.path}?{query_params.urlencode()}"
            
            # Use Django's cache mechanism to store the response
            # Implementation would depend on your needs
            
            return view_func(request, *args, **kwargs)
        return _wrapped_view
    return decorator

# Usage
@cache_page_with_params(60 * 15)
def product_search(request):
    query = request.GET.get('q', '')
    category = request.GET.get('category', '')
    
    # Search logic here
    
    return render(request, 'search_results.html', {'results': results})
```

## Practical Example: Caching a Blog Post View

Let's create a practical example of caching a blog post view, which is a common use case:

```python
# models.py
from django.db import models

class BlogPost(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    published_date = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.title

# views.py
from django.shortcuts import render, get_object_or_404
from django.views.decorators.cache import cache_page
from .models import BlogPost

# Cache blog list for 10 minutes
@cache_page(60 * 10)
def blog_list(request):
    posts = BlogPost.objects.all().order_by('-published_date')
    return render(request, 'blog/list.html', {'posts': posts})

# Cache individual posts for 30 minutes
@cache_page(60 * 30)
def blog_detail(request, post_id):
    post = get_object_or_404(BlogPost, pk=post_id)
    return render(request, 'blog/detail.html', {'post': post})
```

In the above example:
- The blog listing page is cached for 10 minutes
- Individual blog post pages are cached for 30 minutes
- This significantly reduces database queries for frequently read content

## Working with Cache Invalidation

One of the challenges with caching is knowing when to invalidate the cache. When content changes, you need to ensure users see the updated content rather than stale cached versions.

### Manual Cache Invalidation

You can manually invalidate cache when models are updated:

```python
from django.core.cache import cache
from django.urls import reverse

def update_blog_post(request, post_id):
    post = get_object_or_404(BlogPost, pk=post_id)
    
    if request.method == 'POST':
        # Update post logic
        post.title = request.POST.get('title')
        post.content = request.POST.get('content')
        post.save()
        
        # Invalidate the cache for this specific post
        cache_key = reverse('blog_detail', kwargs={'post_id': post_id})
        cache.delete(cache_key)
        
        # You might also need to invalidate list views
        cache.delete(reverse('blog_list'))
        
        return redirect('blog_detail', post_id=post_id)
    
    return render(request, 'blog/edit.html', {'post': post})
```

## When Not to Use Per-View Cache

Per-view caching isn't appropriate in all scenarios:

1. **Highly personalized content**: If a view shows different content to every user, caching might not help or could cause data leaks
2. **Frequently changing data**: For content that changes every few seconds, caching might result in stale data
3. **Form submissions**: Pages that handle form submissions should generally not be cached
4. **Security-sensitive views**: Be cautious with caching views that display sensitive information

## Best Practices for Per-View Caching

1. **Choose appropriate cache durations**: Match cache times to how frequently your data changes
2. **Use cache versioning**: Include a version in your cache keys to make bulk invalidation easier
3. **Monitor cache hit rates**: Track how effective your caching is
4. **Be careful with user-specific data**: Use `vary_on_cookie` or avoid caching entirely for personalized views
5. **Cache at the lowest level possible**: If you can cache a database query instead of an entire view, that's often better

## Summary

Django's per-view caching provides an easy way to improve your application's performance by caching the output of specific views. By using the `cache_page` decorator, you can:

- Cache entire view responses for specified durations
- Use different cache backends for different views
- Vary caching based on headers or cookies
- Dramatically improve response times for expensive operations

Remember that while caching can greatly improve performance, it also introduces complexity around cache invalidation and can potentially serve stale content if not managed properly. Using per-view caching judiciously, with appropriate cache durations and invalidation strategies, will help you achieve the right balance between performance and freshness.

## Additional Resources

- [Django's Cache Framework Documentation](https://docs.djangoproject.com/en/stable/topics/cache/)
- [Advanced Caching Patterns in Django](https://realpython.com/caching-in-django-with-redis/)
- [Cache Invalidation Strategies](https://www.soberkoder.com/cache-invalidation-strategies/)

## Exercises

1. Implement per-view caching for a Django project's homepage with a 15-minute cache duration
2. Create a view that displays weather data and cache it for 1 hour
3. Implement a solution that varies the cache by both language preference and user authentication status
4. Build a blog with cached list and detail views, plus manual cache invalidation when posts are updated
5. Create a dashboard that conditionally caches different sections based on user permissions