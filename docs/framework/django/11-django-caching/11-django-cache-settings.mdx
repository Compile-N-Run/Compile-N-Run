---
title: Django Cache Settings
description: Learn how to configure and optimize Django's cache settings for improved application performance

---

# Django Cache Settings

## Introduction

Caching is a powerful technique for improving the performance of Django applications by storing expensive-to-compute results so they can be quickly retrieved later. Django provides a robust caching framework with multiple backends and configuration options to suit different application needs.

In this tutorial, we'll explore Django's cache settings in depth, understanding how to configure different caching backends, set timeout values, define cache keys, and implement various caching strategies. By the end, you'll be able to effectively implement caching to boost your Django application's performance.

## Basic Cache Configuration

Django's caching system requires some configuration before you can use it. The configuration is done in your project's `settings.py` file.

### Setting Up a Cache Backend

Django supports several built-in cache backends:

1. **Memcached**: A memory-based, high-performance caching system
2. **Database**: Uses your database to store cache data
3. **File-based**: Stores cached data in files
4. **Local-memory**: A per-process memory cache
5. **Dummy**: A development cache that doesn't actually cache anything

The most basic cache configuration looks like this:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake',
    }
}
```

This sets up a local memory cache, which is suitable for development but not ideal for production.

## Common Cache Backends

### Memcached Configuration

Memcached is one of the most popular and efficient cache backends. It's an external memory-based caching system that Django can connect to:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
```

For multiple Memcached servers:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': [
            '172.19.26.240:11211',
            '172.19.26.242:11211',
        ]
    }
}
```

### Redis Configuration

Redis is another popular caching backend, though it requires a third-party package. First, install `django-redis`:

```bash
pip install django-redis
```

Then, configure it in your settings:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}
```

### Database Cache

Django can use your database as a cache. First, create the cache table:

```bash
python manage.py createcachetable
```

Then configure it:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}
```

### File-based Cache

File-based caching stores each cache value in a separate file:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',  # Directory where cache files will be stored
    }
}
```

## Advanced Cache Settings

Besides specifying the cache backend, Django provides several additional settings to fine-tune your caching configuration:

### Timeout Setting

The `TIMEOUT` setting defines how long (in seconds) a cached item should be stored before being considered stale:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'TIMEOUT': 300,  # 5 minutes in seconds
    }
}
```

Setting `TIMEOUT` to `None` means cached items never expire.

### Key Prefix

`KEY_PREFIX` is added to the beginning of all cache keys to avoid collisions when multiple Django applications share a cache:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'KEY_PREFIX': 'myapp',
    }
}
```

### Version Setting

The `VERSION` setting helps with cache invalidation when you deploy new code that changes the structure of cached objects:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'VERSION': 2,  # Increment this when you want to invalidate all cache entries
    }
}
```

### Defining Multiple Caches

Django supports multiple cache configurations. This is useful when you have different caching needs for different parts of your application:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'TIMEOUT': 300,
    },
    'session': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'sessions_cache_table',
        'TIMEOUT': 86400,  # 1 day
    },
    'long_term': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_long_term_cache',
        'TIMEOUT': 604800,  # 1 week
    }
}
```

You can then specify which cache to use in your code:

```python
from django.core.cache import caches

# Using different cache backends
default_cache = caches['default']
session_cache = caches['session']
long_term_cache = caches['long_term']

# Set values in different caches
default_cache.set('my_key', 'my_value', 60)  # Cache for 60 seconds
session_cache.set('user_data', user_data)  # Cache using session cache's settings
long_term_cache.set('site_stats', stats_data)  # Cache in long-term cache
```

## Real-world Application: Optimizing Cache Settings

Let's explore a practical example of configuring caching for a blog application with different caching requirements for different components:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'TIMEOUT': 60,  # 1 minute default timeout
        'KEY_PREFIX': 'blog',
        'OPTIONS': {
            'MAX_ENTRIES': 1000,  # Maximum number of entries before old values are purged
            'CULL_FREQUENCY': 3,  # 1/3 of entries will be purged when MAX_ENTRIES is reached
        }
    },
    'page': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'TIMEOUT': 1800,  # 30 minutes
        'KEY_PREFIX': 'blog_page',
    },
    'feed': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'TIMEOUT': 300,  # 5 minutes
        'KEY_PREFIX': 'blog_feed',
    }
}
```

Now let's implement this in a Django application:

```python
# views.py
from django.core.cache import caches
from django.views.decorators.cache import cache_page
from django.views.decorators.vary import vary_on_cookie

# Use the default cache for model instances
def get_post(request, post_id):
    cache_key = f'post_{post_id}'
    post = caches['default'].get(cache_key)
    
    if not post:
        post = Post.objects.get(id=post_id)
        caches['default'].set(cache_key, post)
    
    return render(request, 'blog/post.html', {'post': post})

# Use the page cache for entire rendered pages
@cache_page(60 * 30, cache='page')  # Cache for 30 minutes using page cache
@vary_on_cookie  # Vary the cache by user cookies
def home_page(request):
    posts = Post.objects.all()[:10]
    return render(request, 'blog/home.html', {'posts': posts})

# Use the feed cache for API responses
@cache_page(60 * 5, cache='feed')  # Cache for 5 minutes using feed cache
def post_feed(request):
    posts = Post.objects.all().order_by('-created_at')[:20]
    data = [{'title': post.title, 'content': post.content} for post in posts]
    return JsonResponse({'posts': data})
```

## Per-Site Cache Settings

Django also provides middleware for site-wide caching. To enable this, add the following to your `settings.py`:

```python
MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',  # This should come first
    # ... other middleware ...
    'django.middleware.cache.FetchFromCacheMiddleware',  # This should come last
]

CACHE_MIDDLEWARE_ALIAS = 'page'  # Which cache to use
CACHE_MIDDLEWARE_SECONDS = 600  # Cache timeout in seconds (10 minutes)
CACHE_MIDDLEWARE_KEY_PREFIX = 'site_cache'  # Prefix for cache keys
```

## Cache Key Construction

Understanding how Django constructs cache keys can be important when debugging or for manually invalidating specific cache entries:

```python
# Default cache key format
def make_key(key, key_prefix, version):
    return f"{key_prefix}:{version}:{key}"

# Example of how Django constructs a key
# If KEY_PREFIX is "blog", VERSION is "2", and your key is "post_1":
# The full cache key would be "blog:2:post_1"
```

You can override this behavior by defining your own key function:

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'KEY_FUNCTION': 'myapp.utils.custom_key_function',
    }
}

# myapp/utils.py
def custom_key_function(key, key_prefix, version):
    """Custom function for constructing cache keys"""
    return f"{key_prefix}:{version}:{key}:{settings.SITE_ID}"
```

## Cache Settings for Development vs. Production

It's often helpful to use different cache settings for development and production environments:

```python
# settings.py
if DEBUG:
    # Development settings
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
        }
    }
else:
    # Production settings
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
            'LOCATION': '127.0.0.1:11211',
            'TIMEOUT': 300,
            'OPTIONS': {
                'SERVER_MAX_VALUE_LENGTH': 1024 * 1024 * 2,  # 2MB
            }
        }
    }
```

## Summary

Django's cache settings provide a flexible framework for implementing various caching strategies in your application:

- Choose from different backends including Memcached, Redis, database, file-based, or local-memory
- Configure timeout values to control how long items remain in the cache
- Use key prefixes and versioning to manage cache keys and invalidate entries
- Define multiple caches for different parts of your application with unique requirements
- Apply global cache settings with middleware for site-wide caching

Effective cache configuration can dramatically improve your application's performance by reducing database load and computation time. Remember to carefully consider your caching needs, and be mindful of cache invalidation concerns when data changes.

## Additional Resources and Exercises

### Resources
- [Django's Official Caching Documentation](https://docs.djangoproject.com/en/stable/topics/cache/)
- [Memcached Documentation](https://memcached.org/documentation)
- [Redis Documentation](https://redis.io/documentation)

### Exercises

1. **Configuration Practice**: Set up three different cache backends (local-memory, file-based, and database) and benchmark their performance with the same workload.

2. **Advanced Configuration**: Create a configuration with multiple cache backends that uses:
   - Fast memory-based cache for session data
   - Database cache for infrequently changed model data
   - File-based cache for template fragments

3. **Cache Debugging**: Write a management command that displays all keys in your cache along with their expiration times.

4. **Cache Invalidation**: Implement a signal handler that automatically invalidates relevant cache entries when a model instance is updated.

5. **Production-Ready Setup**: Create a comprehensive cache configuration for a production environment that includes:
   - Proper error handling for when the cache server is down
   - Monitoring for cache hit/miss rates
   - A strategy for cache warming after deployment

By mastering Django's cache settings, you'll be able to significantly improve your application's performance and scalability while providing a better experience for your users.