---
title: Django File-based Cache
description: Learn how to implement and use file-based caching in Django to improve your web application's performance by storing cached data directly on your server's file system.

---

# Django File-based Cache

## Introduction

In web development, performance is crucial, and caching is one of the most effective ways to improve it. Django provides several caching backends to help developers optimize their applications. The file-based cache is one of the simplest yet effective caching mechanisms offered by Django.

File-based caching is a system where Django stores cached data as files on your server's file system. When a request comes in, Django can retrieve the cached data from these files instead of regenerating it, which significantly reduces processing time and database queries.

In this tutorial, you'll learn how to set up, configure, and use Django's file-based cache system to improve your web application's performance.

## Prerequisites

Before diving into file-based caching, make sure you have:

- A basic understanding of Django
- Django installed in your development environment
- A Django project set up

## Setting Up File-based Cache

### 1. Configure the Cache in Settings

The first step is to configure Django to use file-based caching by adding or modifying the `CACHES` setting in your project's `settings.py` file:

```python
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',  # Directory where cache files will be stored
        'TIMEOUT': 60 * 15,  # Cache timeout in seconds (15 minutes)
        'OPTIONS': {
            'MAX_ENTRIES': 1000,  # Maximum number of entries in the cache
            'CULL_FREQUENCY': 2,  # Fraction of entries to purge when MAX_ENTRIES is reached
        }
    }
}
```

Let's break down these settings:

- `BACKEND`: Specifies the cache implementation to use, in this case, the file-based cache.
- `LOCATION`: The directory where Django will store cache files. Make sure this directory exists and is writable.
- `TIMEOUT`: How long (in seconds) cached items should remain valid. Default is 300 seconds (5 minutes).
- `MAX_ENTRIES`: The maximum number of entries allowed in the cache before old entries are deleted.
- `CULL_FREQUENCY`: When the max entries are reached, this determines how many entries are removed. Here, 1/2 of the entries will be removed.

:::tip
For Windows users, use a Windows-style path: `'LOCATION': 'C:\\path\\to\\cache\\directory'`
:::

### 2. Create the Cache Directory

Make sure the directory specified in `LOCATION` exists and has the proper permissions:

```bash
mkdir -p /var/tmp/django_cache
chmod 777 /var/tmp/django_cache  # Adjust permissions according to your security needs
```

## Using File-based Cache

Django provides several ways to use caching in your application:

### 1. Per-View Caching

You can cache the output of individual views using the `@cache_page` decorator:

```python
from django.views.decorators.cache import cache_page

@cache_page(60 * 15)  # Cache for 15 minutes
def my_view(request):
    # View logic here
    return render(request, 'mytemplate.html', {'data': data})
```

When a user first visits the page, Django will execute the view function and store the result in the cache. For subsequent requests (within the next 15 minutes), Django will skip executing the view function and directly return the cached response.

### 2. Template Fragment Caching

For more granular control, you can cache specific portions of a template:

```html
{% load cache %}

{% cache 900 sidebar request.user.username %}
    {# Expensive template logic here #}
    <div class="sidebar">
        <!-- Heavy sidebar content -->
    </div>
{% endcache %}
```

This caches just the sidebar portion of the template for 900 seconds (15 minutes).

### 3. Low-Level Cache API

For more detailed control, Django provides a low-level API to work with the cache directly:

```python
from django.core.cache import cache

# Store a value in the cache
cache.set('my_key', 'my_value', timeout=300)  # Cache for 5 minutes

# Retrieve a value from the cache
value = cache.get('my_key')
if value is None:
    # Value wasn't in the cache, recalculate
    value = calculate_expensive_value()
    cache.set('my_key', value, timeout=300)

# Delete a value from the cache
cache.delete('my_key')

# Clear the entire cache
cache.clear()
```

## Practical Example: Caching Database Queries

Let's see a practical example of caching expensive database queries:

```python
from django.core.cache import cache
from django.shortcuts import render
from .models import Product

def product_list(request):
    # Try to get the product list from the cache
    product_list = cache.get('all_products')
    
    if product_list is None:
        # If not in cache, query the database
        print("Fetching products from database...")  # For demonstration
        product_list = Product.objects.all()
        
        # Store the result in the cache for 30 minutes
        cache.set('all_products', product_list, 60 * 30)
    else:
        print("Fetching products from cache...")  # For demonstration
    
    return render(request, 'products/list.html', {'products': product_list})
```

When this view is first accessed, it will query the database and store the results in the cache. Subsequent requests will retrieve the product list directly from the cache, avoiding the database query entirely.

### Output Comparison

Without caching:
- Every request performs a database query
- Response time might vary based on database load
- Database experiences more load

With caching:
- Only the first request (or requests after the cache expires) performs a database query
- Response time is consistent and fast for cached responses
- Database experiences less load

## Cache Invalidation

One important aspect of caching is knowing when to invalidate (delete) cached data. When your data changes, you may need to update or clear your cache:

```python
from django.core.cache import cache
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Product

@receiver(post_save, sender=Product)
def invalidate_product_cache(sender, instance, **kwargs):
    # Clear the cache when a product is saved or updated
    cache.delete('all_products')
    # You might also want to delete specific product caches
    cache.delete(f'product_{instance.id}')
```

This signal handler automatically invalidates the relevant caches whenever a product is saved or updated.

## Monitoring Your Cache

When using file-based cache, you can check the cache directory to see the cache files:

```bash
ls -la /var/tmp/django_cache
```

Each cache entry will be stored as a separate file, usually with a name derived from a hash of the cache key.

## Advanced: Cache Middleware

Django also provides middleware for site-wide caching. Add the following to your `MIDDLEWARE` setting:

```python
MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',
    # ... other middleware ...
    'django.middleware.cache.FetchFromCacheMiddleware',
]

# Additional cache settings
CACHE_MIDDLEWARE_ALIAS = 'default'
CACHE_MIDDLEWARE_SECONDS = 600
CACHE_MIDDLEWARE_KEY_PREFIX = ''
```

This setup caches entire pages for all users, so use it with caution, especially on sites with user-specific content.

## Pros and Cons of File-based Cache

### Pros
1. **Simple to set up**: No additional services required
2. **Persistent**: Survives server restarts
3. **Good for development**: Easy to inspect and debug

### Cons
1. **Not as fast**: Slower than memory-based caching like Memcached or Redis
2. **Disk I/O**: Can become a bottleneck under high load
3. **File locking issues**: Can cause contention in highly concurrent environments
4. **Not suitable for distributed setups**: Only works on a single server

## Summary

File-based caching is a simple yet effective way to improve your Django application's performance. It's particularly useful for development environments or small to medium-sized applications. By storing cached data as files on your server's file system, you can significantly reduce database load and improve response times.

Key points to remember:
- Configure the cache in `settings.py` with appropriate parameters
- Use the `@cache_page` decorator for view-level caching
- Use the template cache tag for fragment caching
- Use the low-level API for more granular control
- Implement proper cache invalidation strategies
- Consider the pros and cons when deciding if file-based cache is right for your application

## Additional Resources

- [Django's Official Caching Documentation](https://docs.djangoproject.com/en/stable/topics/cache/)
- [Django's Cache Framework](https://docs.djangoproject.com/en/stable/topics/cache/#the-per-site-cache)
- [Cache-related Settings Reference](https://docs.djangoproject.com/en/stable/ref/settings/#cache)

## Exercises

1. Set up file-based caching in a Django project and cache a computationally expensive view.
2. Implement cache invalidation when a model is updated.
3. Compare the performance of an uncached view versus a cached view using Django Debug Toolbar.
4. Implement fragment caching for a specific part of a template that displays data that doesn't change often.
5. Create a system to automatically refresh your cache at specific times of the day using Django management commands and cron jobs.