---
title: Django Form Processing
description: Learn how to process form submissions in Django, validate form data, and work with form instances to create interactive web applications

---

# Django Form Processing

When building web applications, handling user input through forms is one of the most common tasks. Django provides a powerful forms framework that simplifies form creation, validation, and processing. This guide will walk you through the process of handling form submissions in Django applications.

## Introduction to Form Processing

Form processing in Django involves several steps:
1. Creating a form (either as a Django Form class or in a template)
2. Rendering the form in a template
3. Handling form submission
4. Validating form data
5. Processing valid form data
6. Handling form errors and redisplaying the form if necessary

Django's form processing follows a pattern that helps maintain clean code and separation of concerns.

## Creating a Basic Form

Let's start by creating a simple contact form:

```python
# forms.py
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)
```

This simple form has three fields: name, email, and message.

## Rendering the Form in a Template

To display this form to users, we need to render it in a template:

```python
# views.py
from django.shortcuts import render
from .forms import ContactForm

def contact_view(request):
    form = ContactForm()
    return render(request, 'contact.html', {'form': form})
```

And in our template:

```html
<!-- contact.html -->
<form method="post">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Submit</button>
</form>
```

The `{{ form.as_p }}` tag renders each form field wrapped in a `<p>` element. Django also provides `{{ form.as_table }}` and `{{ form.as_ul }}` for different rendering styles.

## Processing Form Submissions

Now let's handle form submissions by updating our view:

```python
# views.py
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import ContactForm

def contact_view(request):
    if request.method == 'POST':
        # Form was submitted
        form = ContactForm(request.POST)
        if form.is_valid():
            # Process the valid data
            name = form.cleaned_data['name']
            email = form.cleaned_data['email']
            message = form.cleaned_data['message']
            
            # Do something with the data (e.g., send email)
            # ...
            
            # Add a success message
            messages.success(request, "Your message has been sent!")
            
            # Redirect to prevent form resubmission
            return redirect('contact')
    else:
        # This is a GET request, create an empty form
        form = ContactForm()
    
    # Render the template with the form
    return render(request, 'contact.html', {'form': form})
```

## Key Concepts in Form Processing

### The `is_valid()` Method

The `is_valid()` method checks if the form data is valid according to the field type and any validation rules you've defined. If all validations pass, it returns `True` and populates the `cleaned_data` dictionary with the validated data.

### The `cleaned_data` Dictionary

After successful validation, form data is available in the `cleaned_data` dictionary. This data has been "cleaned" (converted to the appropriate Python types) and validated.

### Form Resubmission and PRG Pattern

The Post/Redirect/Get (PRG) pattern is used to prevent form resubmission. When a form is successfully processed, we redirect the user to another page rather than rendering the response directly. This prevents duplicate form submissions when users refresh the page.

## Adding Custom Validation

Sometimes you need custom validation logic beyond what Django's field types provide:

```python
# forms.py
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)
    
    def clean_name(self):
        """Custom validation for the name field"""
        name = self.cleaned_data['name']
        if len(name) < 3:
            raise forms.ValidationError("Name must be at least 3 characters long.")
        return name
    
    def clean(self):
        """Cross-field validation"""
        cleaned_data = super().clean()
        name = cleaned_data.get('name')
        email = cleaned_data.get('email')
        
        if name and email and name.lower() in email.lower():
            raise forms.ValidationError("Email cannot contain your name for security reasons")
        
        return cleaned_data
```

## Handling File Uploads

When handling file uploads, you need to include the `enctype="multipart/form-data"` attribute in your form tag and pass `request.FILES` to the form:

```python
# forms.py
class DocumentForm(forms.Form):
    name = forms.CharField(max_length=100)
    document = forms.FileField()
```

```html
<!-- template.html -->
<form method="post" enctype="multipart/form-data">
  {% csrf_token %}
  {{ form.as_p }}
  <button type="submit">Upload</button>
</form>
```

```python
# views.py
def upload_document(request):
    if request.method == 'POST':
        form = DocumentForm(request.POST, request.FILES)
        if form.is_valid():
            # Access the uploaded file
            document = form.cleaned_data['document']
            # Process the file (save it, etc.)
            # ...
            return redirect('success')
    else:
        form = DocumentForm()
    return render(request, 'upload.html', {'form': form})
```

## Working with ModelForms

ModelForms automatically create form fields based on the model fields:

```python
# models.py
from django.db import models

class Contact(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
```

```python
# forms.py
from django import forms
from .models import Contact

class ContactModelForm(forms.ModelForm):
    class Meta:
        model = Contact
        fields = ['name', 'email', 'message']  # or use '__all__' for all fields
```

Processing a ModelForm is even simpler:

```python
# views.py
from django.shortcuts import render, redirect
from .forms import ContactModelForm

def contact_view(request):
    if request.method == 'POST':
        form = ContactModelForm(request.POST)
        if form.is_valid():
            # Save the form data directly to the database
            contact = form.save()
            return redirect('success')
    else:
        form = ContactModelForm()
    
    return render(request, 'contact.html', {'form': form})
```

## Real-World Example: User Registration Form

Let's implement a complete user registration form with validation:

```python
# forms.py
from django import forms
from django.contrib.auth.models import User
from django.contrib.auth.password_validation import validate_password

class UserRegistrationForm(forms.Form):
    username = forms.CharField(max_length=150)
    email = forms.EmailField()
    password1 = forms.CharField(
        label="Password", 
        widget=forms.PasswordInput,
        validators=[validate_password]
    )
    password2 = forms.CharField(
        label="Confirm Password", 
        widget=forms.PasswordInput
    )
    
    def clean_username(self):
        username = self.cleaned_data['username']
        if User.objects.filter(username=username).exists():
            raise forms.ValidationError("Username already exists.")
        return username
    
    def clean_email(self):
        email = self.cleaned_data['email']
        if User.objects.filter(email=email).exists():
            raise forms.ValidationError("Email already registered.")
        return email
    
    def clean(self):
        cleaned_data = super().clean()
        password1 = cleaned_data.get('password1')
        password2 = cleaned_data.get('password2')
        
        if password1 and password2 and password1 != password2:
            self.add_error('password2', "Passwords don't match.")
        
        return cleaned_data
```

And the view to process this form:

```python
# views.py
from django.shortcuts import render, redirect
from django.contrib.auth.models import User
from django.contrib.auth import login
from .forms import UserRegistrationForm

def register_view(request):
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            # Create the user
            user = User.objects.create_user(
                username=form.cleaned_data['username'],
                email=form.cleaned_data['email'],
                password=form.cleaned_data['password1']
            )
            
            # Log the user in
            login(request, user)
            
            # Redirect to home page
            return redirect('home')
    else:
        form = UserRegistrationForm()
    
    return render(request, 'register.html', {'form': form})
```

## Form Rendering with Bootstrap

To make your forms look better, you might want to style them with Bootstrap:

```html
<!-- bootstrap_form.html -->
<form method="post">
  {% csrf_token %}
  
  {% for field in form %}
    <div class="mb-3">
      <label for="{{ field.id_for_label }}" class="form-label">
        {{ field.label }}
      </label>
      {{ field|add_class:"form-control" }}
      
      {% if field.help_text %}
        <div class="form-text">{{ field.help_text }}</div>
      {% endif %}
      
      {% for error in field.errors %}
        <div class="invalid-feedback d-block">
          {{ error }}
        </div>
      {% endfor %}
    </div>
  {% endfor %}
  
  <button type="submit" class="btn btn-primary">Submit</button>
</form>
```

Note: The `add_class` filter is not built into Django. You'll need to install `django-widget-tweaks` to use it:

```
pip install django-widget-tweaks
```

And add it to your `INSTALLED_APPS` in `settings.py`:

```python
INSTALLED_APPS = [
    # ...
    'widget_tweaks',
    # ...
]
```

## Summary

Django's form handling system provides a robust framework for processing user input. Here's what we've covered:

1. Creating form classes in Django
2. Rendering forms in templates
3. Processing form submissions
4. Validating form data
5. Working with ModelForms
6. Handling file uploads
7. Implementing custom validation
8. Styling forms with Bootstrap

By following Django's form processing patterns, you can create secure, efficient, and user-friendly forms for your web applications.

## Additional Resources

- [Django Forms Documentation](https://docs.djangoproject.com/en/stable/topics/forms/)
- [Django ModelForms Documentation](https://docs.djangoproject.com/en/stable/topics/forms/modelforms/)
- [Django Form Field Types](https://docs.djangoproject.com/en/stable/ref/forms/fields/)
- [Django Form Validation](https://docs.djangoproject.com/en/stable/ref/forms/validation/)

## Exercises

1. Create a blog post form that allows users to submit a title, content, and optional image.
2. Implement a contact form that sends an email using Django's email functionality.
3. Build a multi-step form process using Django sessions to store intermediate data.
4. Create a ModelForm for a product review system with ratings, comments, and validation.
5. Implement AJAX form submission for a more responsive user experience.