---
title: Django Static Files Deployment
description: Learn how to properly manage and deploy static files in Django applications for production environments.

---

# Django Static Files Deployment

## Introduction

When deploying a Django application to production, handling static files (CSS, JavaScript, images) properly is crucial for your website to look and function correctly. In development, Django's built-in server handles static files automatically, but in production, this responsibility shifts to your web server or a dedicated static file service.

In this tutorial, we'll explore how to configure, collect, and serve static files in a production environment. We'll cover the Django settings needed, how to use the `collectstatic` command, and common deployment patterns with various web servers.

## Understanding Static Files in Django

Static files are the assets that don't change frequently in your web application - typically CSS files, JavaScript files, images, fonts, and other media. Django provides a framework for organizing and serving these files efficiently.

### Key Concepts

1. **STATIC_URL**: The URL to use when referring to static files in templates
2. **STATIC_ROOT**: The absolute path to the directory where `collectstatic` will gather static files for deployment
3. **STATICFILES_DIRS**: Additional locations where Django looks for static files
4. **STATICFILES_STORAGE**: The storage engine to use for static files

## Setting Up Static Files for Production

### Step 1: Configure Django Settings

First, let's configure the necessary settings in your `settings.py` file:

```python
# settings.py

# Base URL at which static files will be served
STATIC_URL = '/static/'

# List of directories where Django will also look for static files
STATICFILES_DIRS = [
    BASE_DIR / "static",
]

# Directory where collectstatic will gather files for deployment
STATIC_ROOT = BASE_DIR / "staticfiles"

# Storage backend to use
STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.ManifestStaticFilesStorage'
```

The `ManifestStaticFilesStorage` adds hashes to filenames for cache busting, which is recommended for production.

### Step 2: Organize Your Static Files

Structure your static files in your application directories following Django conventions:

```
my_project/
    my_app/
        static/
            my_app/
                css/
                    styles.css
                js/
                    script.js
                images/
                    logo.png
```

This nested structure (`my_app/static/my_app/...`) prevents namespace collisions between applications.

### Step 3: Collect Static Files

Before deployment, run Django's `collectstatic` command to gather all static files into a single directory defined by `STATIC_ROOT`:

```bash
python manage.py collectstatic
```

Output:
```
130 static files copied to '/path/to/your/project/staticfiles'.
```

This command finds all static files from your applications and copies them to the `STATIC_ROOT` directory, making them easy to serve in production.

## Serving Static Files in Production

Unlike in development, Django doesn't serve static files in production. Here's how to configure different deployment options:

### Option 1: Using a Web Server (Nginx)

Nginx can efficiently serve static files directly:

```nginx
# nginx.conf example
server {
    listen 80;
    server_name example.com;

    location /static/ {
        alias /path/to/your/project/staticfiles/;
        expires 30d;  # Add cache headers
    }

    location / {
        proxy_pass http://localhost:8000;  # Your Django app
        # other proxy settings...
    }
}
```

### Option 2: Using a CDN

For better performance, you can use a Content Delivery Network (CDN):

```python
# settings.py for CDN configuration
STATIC_URL = 'https://my-cdn.example.com/static/'
```

Then upload your static files to your CDN after running `collectstatic`.

### Option 3: Using WhiteNoise

[WhiteNoise](http://whitenoise.evans.io/en/stable/) lets your Python application serve its own static files:

1. Install WhiteNoise:

```bash
pip install whitenoise
```

2. Add it to your Django settings:

```python
# settings.py

MIDDLEWARE = [
    # ...
    'whitenoise.middleware.WhiteNoiseMiddleware',
    # ...
]

STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
```

WhiteNoise adds appropriate caching headers and serves compressed files, making it a good solution for many deployments.

## Real-World Example: Deploying to Heroku

Here's a complete example of setting up static files for a Heroku deployment:

### 1. Install required packages:

```bash
pip install whitenoise dj-database-url gunicorn
pip freeze > requirements.txt
```

### 2. Configure your settings.py:

```python
# settings.py

import os
import dj_database_url

# Static files settings
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STATIC_URL = '/static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]

# WhiteNoise configuration
MIDDLEWARE = [
    # ...
    'whitenoise.middleware.WhiteNoiseMiddleware',
    # ...
]

STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'

# Production settings when deployed to Heroku
if 'DATABASE_URL' in os.environ:
    DATABASES['default'] = dj_database_url.config(conn_max_age=600)
    DEBUG = False
    ALLOWED_HOSTS = ['your-app-name.herokuapp.com']
```

### 3. Create a Procfile for Heroku:

```
web: gunicorn myproject.wsgi --log-file -
```

### 4. Deploy to Heroku:

```bash
git add .
git commit -m "Ready for deployment"
git push heroku master
```

Heroku will automatically run `collectstatic` during deployment, and WhiteNoise will handle serving your static files efficiently.

## Common Issues and Solutions

### Problem: Static Files Not Found in Production

**Solution:** Verify that:
- `collectstatic` was run before deployment
- `STATIC_ROOT` is set correctly
- Your web server is configured to serve files from `STATIC_ROOT`
- File permissions allow the web server to access the static files

### Problem: CSS/JS Changes Not Showing Up

**Solution:** This could be a caching issue. Try:
- Using `ManifestStaticFilesStorage` to add cache-busting hashes to filenames
- Adding proper cache headers to your web server configuration
- Hard-refreshing your browser (Ctrl+F5)
- Running `collectstatic` with the `--clear` flag:

```bash
python manage.py collectstatic --clear
```

### Problem: Static Files Missing in Admin Interface

**Solution:**
- Ensure Django's admin application is in your `INSTALLED_APPS`
- Verify that `collectstatic` copied the admin static files
- Check web server configuration for the admin URL path

## Best Practices for Static Files in Production

1. **Use version control for source files** but exclude the `STATIC_ROOT` directory
2. **Add cache headers** to improve performance
3. **Compress files** using gzip or brotli
4. **Consider a CDN** for global applications
5. **Optimize asset size** by minifying CSS/JS and compressing images
6. **Use integrity hashes** for security with subresource integrity
7. **Automate the collectstatic process** in your deployment pipeline

## Summary

Properly handling static files in Django production deployments involves:

1. Configuring Django settings (`STATIC_URL`, `STATIC_ROOT`, etc.)
2. Organizing static files within your applications
3. Using `collectstatic` to gather files for deployment
4. Configuring your web server or a tool like WhiteNoise to serve static files
5. Following best practices for performance and security

By following these steps, your Django application will serve static files efficiently in production, ensuring your site looks and functions as intended.

## Additional Resources

- [Django Static Files Documentation](https://docs.djangoproject.com/en/stable/howto/static-files/)
- [WhiteNoise Documentation](http://whitenoise.evans.io/en/stable/)
- [Django Deployment Checklist](https://docs.djangoproject.com/en/stable/howto/deployment/checklist/)

## Exercises

1. Configure your Django project to use WhiteNoise for static file serving
2. Set up a local Nginx server to serve static files from your Django project
3. Implement a custom storage backend that uploads static files to AWS S3
4. Create a deployment script that automates the `collectstatic` process
5. Add cache headers and compression to your static file setup for performance optimization