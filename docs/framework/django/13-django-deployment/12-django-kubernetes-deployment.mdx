---
title: Django Kubernetes Deployment
description: Learn how to deploy Django applications using Kubernetes for scalable, resilient, and containerized deployments.

---

# Django Kubernetes Deployment

In today's cloud-native world, Kubernetes has become the industry standard for container orchestration. For Django applications, Kubernetes offers powerful capabilities to ensure your application is scalable, resilient, and easy to manage. This guide will walk you through the process of deploying a Django application on Kubernetes.

## What is Kubernetes?

Kubernetes (often abbreviated as K8s) is an open-source platform for automating deployment, scaling, and management of containerized applications. It provides a framework to run distributed systems resiliently, taking care of scaling and failover for your application, providing deployment patterns, and more.

## Prerequisites

Before we begin, make sure you have:

1. A working Django application
2. Docker installed and basic Docker knowledge
3. kubectl command-line tool installed
4. Access to a Kubernetes cluster (can be local like Minikube or cloud-based)
5. Basic understanding of YAML files

## Step 1: Containerize Your Django Application

The first step is to create a Docker container for your Django application.

### Create a Dockerfile

Create a `Dockerfile` in your project root:

```dockerfile
FROM python:3.9-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project
COPY . .

# Run migrations and collect static files
RUN python manage.py migrate
RUN python manage.py collectstatic --noinput

# Expose the port the app runs on
EXPOSE 8000

# Command to run the application
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "myproject.wsgi:application"]
```

### Create a .dockerignore File

```
.git
.gitignore
.env
*.pyc
__pycache__/
*.py[cod]
*$py.class
media/
staticfiles/
.DS_Store
```

### Build the Docker Image

```bash
docker build -t mydjangoapp:v1 .
```

### Test Your Container Locally

```bash
docker run -p 8000:8000 mydjangoapp:v1
```

Visit `http://localhost:8000` to verify your app is running correctly.

## Step 2: Push Your Docker Image to a Registry

For Kubernetes to access your image, it needs to be stored in a container registry.

```bash
# Tag your image (if using Docker Hub)
docker tag mydjangoapp:v1 yourusername/mydjangoapp:v1

# Push to the registry
docker push yourusername/mydjangoapp:v1
```

## Step 3: Create Kubernetes Configuration Files

Kubernetes uses YAML files for configuration. Let's create the necessary files for our Django deployment.

### Create a Deployment Configuration

Create a file named `django-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: django-app
  labels:
    app: django
spec:
  replicas: 3
  selector:
    matchLabels:
      app: django
  template:
    metadata:
      labels:
        app: django
    spec:
      containers:
      - name: django
        image: yourusername/mydjangoapp:v1
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: django-secrets
              key: database-url
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: django-secrets
              key: secret-key
        resources:
          limits:
            cpu: "500m"
            memory: "512Mi"
          requests:
            cpu: "200m"
            memory: "256Mi"
```

### Create a Service Configuration

Create a file named `django-service.yaml`:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: django-service
spec:
  selector:
    app: django
  ports:
  - port: 80
    targetPort: 8000
  type: LoadBalancer
```

### Create Secrets

Create a file named `django-secrets.yaml`:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: django-secrets
type: Opaque
stringData:
  database-url: "postgresql://user:password@postgres-service:5432/dbname"
  secret-key: "your-django-secret-key-here"
```

**Note:** For production, use proper secret management like Kubernetes Secrets, Vault, or a cloud provider's secret management service.

## Step 4: Deploy to Kubernetes

Now let's deploy our application to Kubernetes:

```bash
# Apply the secrets
kubectl apply -f django-secrets.yaml

# Apply the deployment
kubectl apply -f django-deployment.yaml

# Apply the service
kubectl apply -f django-service.yaml
```

### Check Deployment Status

```bash
# Check if pods are running
kubectl get pods

# Check the deployment
kubectl get deployment django-app

# Check the service
kubectl get service django-service
```

Example output:

```
NAME                         READY   STATUS    RESTARTS   AGE
django-app-6d9f8c8c4-abcd1   1/1     Running   0          2m
django-app-6d9f8c8c4-efgh2   1/1     Running   0          2m
django-app-6d9f8c8c4-ijkl3   1/1     Running   0          2m
```

## Step 5: Setup Database in Kubernetes

In production, you'll likely want a dedicated database. Here's a basic PostgreSQL setup:

### Create a Persistent Volume Claim

Create a file named `postgres-pvc.yaml`:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

### Create PostgreSQL Deployment

Create a file named `postgres-deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:13
        env:
        - name: POSTGRES_DB
          value: dbname
        - name: POSTGRES_USER
          value: user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secrets
              key: password
        ports:
        - containerPort: 5432
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
      volumes:
      - name: postgres-storage
        persistentVolumeClaim:
          claimName: postgres-pvc
```

### Create PostgreSQL Service

Create a file named `postgres-service.yaml`:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  type: ClusterIP
```

### Create PostgreSQL Secrets

Create a file named `postgres-secrets.yaml`:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secrets
type: Opaque
stringData:
  password: "your-secure-password"
```

Apply these configurations:

```bash
kubectl apply -f postgres-pvc.yaml
kubectl apply -f postgres-secrets.yaml
kubectl apply -f postgres-deployment.yaml
kubectl apply -f postgres-service.yaml
```

## Step 6: Configure Ingress (Optional)

If you're using Ingress for routing:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: django-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - host: your-domain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: django-service
            port:
              number: 80
```

Apply it:

```bash
kubectl apply -f django-ingress.yaml
```

## Step 7: Run Migrations and Create Superuser

You can run Django management commands in a pod:

```bash
# Get a pod name
kubectl get pods

# Run migrations
kubectl exec -it django-app-6d9f8c8c4-abcd1 -- python manage.py migrate

# Create a superuser
kubectl exec -it django-app-6d9f8c8c4-abcd1 -- python manage.py createsuperuser
```

## Real-World Example: Scaling Django in Production

Let's look at a real-world scenario where your Django application traffic suddenly increases.

### Horizontal Pod Autoscaling

Create a file named `django-hpa.yaml`:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: django-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: django-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

Apply it:

```bash
kubectl apply -f django-hpa.yaml
```

Now your Django deployment will automatically scale between 3 and 10 replicas based on CPU utilization.

### Update Your Application

When you need to deploy a new version:

1. Build a new Docker image with a new tag:
   ```bash
   docker build -t yourusername/mydjangoapp:v2 .
   docker push yourusername/mydjangoapp:v2
   ```

2. Update the deployment:
   ```bash
   kubectl set image deployment/django-app django=yourusername/mydjangoapp:v2
   ```

3. Watch the rollout:
   ```bash
   kubectl rollout status deployment/django-app
   ```

If something goes wrong, you can roll back:
```bash
kubectl rollout undo deployment/django-app
```

## Best Practices

1. **Use Helm Charts**: Consider using Helm for managing your Kubernetes applications, as it provides templating and package management.

2. **Health Checks**: Implement readiness and liveness probes:
   ```yaml
   containers:
   - name: django
     # ...
     livenessProbe:
       httpGet:
         path: /health/
         port: 8000
       initialDelaySeconds: 30
       periodSeconds: 10
     readinessProbe:
       httpGet:
         path: /health/
         port: 8000
       initialDelaySeconds: 5
       periodSeconds: 5
   ```

3. **Production Settings**: Use environment-specific settings:
   ```yaml
   env:
   - name: DJANGO_SETTINGS_MODULE
     value: "myproject.settings.production"
   ```

4. **Resource Limits**: Always set resource limits to prevent resource contention.

5. **StatefulSets**: If your Django application has stateful components beyond the database, consider using StatefulSets.

## Summary

In this guide, we've covered the essential steps for deploying a Django application to Kubernetes:

1. Containerizing your Django application with Docker
2. Pushing your image to a container registry
3. Creating Kubernetes configurations for deployment, services, and secrets
4. Deploying and managing a PostgreSQL database
5. Setting up ingress and autoscaling
6. Implementing best practices for production environments

Kubernetes provides a powerful platform for running Django applications at scale. While the initial setup might seem complex, the benefits of automatic scaling, self-healing, rolling updates, and declarative configuration make it an excellent choice for production Django deployments.

## Additional Resources

1. [Official Kubernetes Documentation](https://kubernetes.io/docs/home/)
2. [Django on Kubernetes Tutorial by DigitalOcean](https://www.digitalocean.com/community/tutorials/how-to-deploy-a-scalable-and-secure-django-application-with-kubernetes)
3. [Helm Charts for Django](https://github.com/bitnami/charts/tree/master/bitnami/django)
4. [Django documentation on deployment](https://docs.djangoproject.com/en/stable/howto/deployment/)

## Exercises

1. Deploy a simple Django "Hello World" application to a local Minikube cluster.
2. Modify your Kubernetes configuration to use a ConfigMap for environment-specific settings.
3. Implement health check endpoints in your Django application and configure liveness and readiness probes.
4. Set up a CI/CD pipeline that automatically builds and deploys your Django application to Kubernetes when changes are pushed to your repository.
5. Create a Helm chart for your Django application to simplify deployment.

By mastering Kubernetes deployments for Django applications, you'll be equipped with powerful tools to build and manage applications that can scale to millions of users.