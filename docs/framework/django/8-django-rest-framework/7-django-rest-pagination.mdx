---
title: "Django REST Pagination"
description: "Learn how to implement pagination in Django REST Framework to optimize API performance and improve user experience by breaking large result sets into manageable pages."

---

# Django REST Pagination

When building APIs, you'll often need to return large collections of data. Rather than returning all data at once and potentially overwhelming the client, pagination allows you to break the data into smaller, more manageable chunks or "pages." Django REST Framework (DRF) provides robust pagination capabilities that are easy to implement and customize.

## Why Use Pagination?

Before diving into implementation, let's understand why pagination is crucial:

1. **Performance**: Smaller responses mean faster load times and less bandwidth usage
2. **User Experience**: Allows users to navigate through large datasets efficiently
3. **Server Load**: Reduces the strain on your database and application server
4. **Mobile Optimization**: Particularly important for mobile clients with limited resources

## Pagination Classes in Django REST Framework

Django REST Framework offers several built-in pagination classes:

1. `PageNumberPagination`: Classic page number-based style (e.g., `?page=2`)
2. `LimitOffsetPagination`: Limit and offset parameters (e.g., `?limit=10&offset=20`)
3. `CursorPagination`: Cursor-based pagination for use with ordered data

Let's explore each of these options with examples.

## Setting Up Pagination Globally

You can configure pagination globally in your Django project's `settings.py`:

```python
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10
}
```

With this configuration, all your API list views will automatically paginate results, returning 10 items per page.

## PageNumberPagination

This is the simplest pagination style where clients request a specific page number.

### Basic Implementation

```python
# views.py
from rest_framework import generics
from rest_framework.pagination import PageNumberPagination
from .models import Book
from .serializers import BookSerializer

class StandardResultsSetPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 100

class BookListView(generics.ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    pagination_class = StandardResultsSetPagination
```

### Example API Response

When you make a request to `/api/books/`, the response would look like:

```json
{
    "count": 87,
    "next": "http://example.org/api/books/?page=2",
    "previous": null,
    "results": [
        {
            "id": 1,
            "title": "Django for Beginners",
            "author": "William S. Vincent",
            "published_date": "2020-01-01"
        },
        // 9 more books...
    ]
}
```

### Customizing Page Size

Clients can specify the page size using the defined query parameter:

```
/api/books/?page=2&page_size=5
```

## LimitOffsetPagination

This pagination style allows clients to specify both the maximum number of items to return (limit) and the starting position (offset).

### Implementation

```python
# views.py
from rest_framework.pagination import LimitOffsetPagination

class BookLimitOffsetPagination(LimitOffsetPagination):
    default_limit = 10
    max_limit = 50

class BookListView(generics.ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    pagination_class = BookLimitOffsetPagination
```

### Example API Request and Response

Request:
```
GET /api/books/?limit=5&offset=10
```

Response:
```json
{
    "count": 87,
    "next": "http://example.org/api/books/?limit=5&offset=15",
    "previous": "http://example.org/api/books/?limit=5&offset=5",
    "results": [
        // 5 books starting from the 11th book
    ]
}
```

## CursorPagination

Cursor pagination uses a "cursor" (a pointer to a specific record) to paginate through results. It's especially useful for frequently changing datasets, as it ensures users don't see the same item twice when new items are added.

### Implementation

```python
# views.py
from rest_framework.pagination import CursorPagination

class BookCursorPagination(CursorPagination):
    page_size = 10
    cursor_query_param = 'cursor'
    ordering = '-created_at'  # Must specify an ordering

class BookListView(generics.ListAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    pagination_class = BookCursorPagination
```

### Example API Response

```json
{
    "next": "http://example.org/api/books/?cursor=cD0yMDIwLTAxLTEx",
    "previous": null,
    "results": [
        // 10 books in descending order of creation date
    ]
}
```

## Custom Pagination Classes

You can create fully custom pagination classes by extending `BasePagination` or modifying existing classes.

### Example: Modified PageNumberPagination

```python
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response

class CustomPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 100
    
    def get_paginated_response(self, data):
        return Response({
            'links': {
                'next': self.get_next_link(),
                'previous': self.get_previous_link()
            },
            'count': self.page.paginator.count,
            'total_pages': self.page.paginator.num_pages,
            'current_page': self.page.number,
            'results': data
        })
```

This custom pagination class adds additional information like `total_pages` and `current_page` to the response.

## Pagination with Function-Based Views

If you're using function-based views instead of class-based views, you can still use pagination:

```python
from rest_framework.decorators import api_view
from rest_framework.pagination import PageNumberPagination
from rest_framework.response import Response

@api_view(['GET'])
def book_list(request):
    books = Book.objects.all()
    
    # Create the paginator instance
    paginator = PageNumberPagination()
    paginator.page_size = 10
    
    # Paginate the queryset
    result_page = paginator.paginate_queryset(books, request)
    
    # Serialize the paginated results
    serializer = BookSerializer(result_page, many=True)
    
    # Return the paginated response
    return paginator.get_paginated_response(serializer.data)
```

## Handling Pagination in Frontend Applications

Consuming paginated APIs in frontend applications involves navigating through pages. Here's a simple example using JavaScript fetch:

```javascript
async function fetchBooks(page = 1) {
    const response = await fetch(`/api/books/?page=${page}`);
    const data = await response.json();
    
    // Display the current page data
    displayBooks(data.results);
    
    // Update pagination controls
    updatePaginationControls({
        next: data.next,
        previous: data.previous,
        count: data.count
    });
}

function updatePaginationControls({ next, previous, count }) {
    const prevButton = document.getElementById('prev-button');
    const nextButton = document.getElementById('next-button');
    
    prevButton.disabled = !previous;
    nextButton.disabled = !next;
    
    // Update event listeners with the appropriate page numbers
    if (previous) {
        const prevPage = new URL(previous).searchParams.get('page') || 1;
        prevButton.onclick = () => fetchBooks(prevPage);
    }
    
    if (next) {
        const nextPage = new URL(next).searchParams.get('page');
        nextButton.onclick = () => fetchBooks(nextPage);
    }
}
```

## Performance Considerations

1. **Optimizing Database Queries**: Always use `.select_related()` and `.prefetch_related()` for related fields
2. **Caching**: Consider caching paginated responses
3. **Indexing**: Ensure your ordering fields are properly indexed

```python
# Optimized query with related data
class BookListView(generics.ListAPIView):
    queryset = Book.objects.select_related('publisher').prefetch_related('authors')
    serializer_class = BookSerializer
    pagination_class = StandardResultsSetPagination
```

## Summary

Pagination is an essential component of any API that returns collections of data. Django REST Framework makes implementing pagination straightforward with its built-in classes, while also providing the flexibility to create custom pagination behavior.

Key points to remember:

1. Use pagination to improve API performance and user experience
2. Choose the pagination style that best fits your application's needs
3. Configure pagination globally or per-view
4. Consider custom pagination classes for specialized requirements
5. Optimize database queries in paginated views

## Exercises

1. Implement `PageNumberPagination` in an API view and test it with different page sizes
2. Create a custom pagination class that adds metadata about the total number of items per category
3. Build a simple React component that navigates through paginated API results
4. Compare the performance of different pagination styles with a large dataset
5. Implement infinite scroll pagination in a frontend application using cursor pagination

## Additional Resources

- [Django REST Framework Pagination Documentation](https://www.django-rest-framework.org/api-guide/pagination/)
- [Performance Optimization with Django ORM](https://docs.djangoproject.com/en/stable/topics/db/optimization/)
- [Building Paginated APIs with Django REST Framework](https://testdriven.io/blog/django-pagination/)
- [React Hooks for Pagination with Django REST API](https://www.saaspegasus.com/guides/modern-javascript-for-django-developers/pagination/)

Happy coding!