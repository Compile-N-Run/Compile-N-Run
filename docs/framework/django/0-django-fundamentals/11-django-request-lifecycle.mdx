---
title: Django Request Lifecycle
description: Understanding how Django processes HTTP requests from start to finish, including middleware, URL resolution, view execution, and response generation.

---

# Django Request Lifecycle

## Introduction

When you build a web application with Django, understanding how the framework processes HTTP requests is fundamental to becoming an effective developer. The Django request lifecycle describes the journey of an HTTP request from the moment it reaches your Django application until a response is sent back to the user's browser.

In this tutorial, we'll break down the Django request lifecycle into clear, manageable steps. You'll learn how Django transforms an incoming HTTP request into a rendered web page or API response, what happens at each stage of processing, and how you can customize this behavior.

## The Django Request Lifecycle Overview

At a high level, Django processes requests through these main phases:

1. **HTTP Request Reception**
2. **Middleware Processing (Request phase)**
3. **URL Resolution**
4. **View Execution**
5. **Middleware Processing (Response phase)**
6. **Response Delivery**

Let's dive into each of these phases in detail.

## 1. HTTP Request Reception

When a user visits your Django website, their browser sends an HTTP request to your web server. This request contains important information such as:

- The HTTP method (GET, POST, etc.)
- Headers (including cookies)
- The requested URL
- Query parameters
- Body content (for POST, PUT requests)

Django receives this request and creates a `HttpRequest` object that encapsulates all this information. This object will be passed through the entire request handling process.

Here's what a simplified HTTP request might look like:

```
GET /blog/article/42/ HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) Firefox/89.0
Accept: text/html,application/xhtml+xml
Cookie: sessionid=abc123; csrftoken=xyz789
```

Django transforms this raw HTTP request into a Python `HttpRequest` object that you can access in your views.

## 2. Middleware Processing (Request phase)

After creating the request object, Django passes it through a series of middleware components. Middleware are Python classes that process requests and responses globally before they reach your view functions or after your view generates a response.

The middleware stack runs in the order defined in your `MIDDLEWARE` setting in `settings.py`:

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

During the request phase, Django calls each middleware's `process_request()` method in order. If any middleware returns an `HttpResponse` object, the process stops there, and that response is returned to the user without executing the next middlewares or the view.

### Example: Custom Middleware

Here's an example of a custom middleware that logs information about each request:

```python
class RequestLoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Code executed for each request before the view
        print(f"Request received: {request.method} {request.path}")
        
        # Call the next middleware or view
        response = self.get_response(request)
        
        # Code executed for each response after the view
        print(f"Response status: {response.status_code}")
        
        return response
```

To activate this middleware, add it to your `MIDDLEWARE` setting:

```python
MIDDLEWARE = [
    # ... other middleware
    'path.to.RequestLoggingMiddleware',
    # ... other middleware
]
```

## 3. URL Resolution

After passing through all middleware, Django needs to determine which view should handle the request. It does this by matching the requested URL against the URL patterns defined in your `urls.py` files.

Django starts with the root URLconf module specified in the `ROOT_URLCONF` setting (typically `your_project.urls`), and then proceeds through any included URL patterns.

Here's a simple example of URL patterns:

```python
# project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls')),
    path('', include('homepage.urls')),
]
```

```python
# blog/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.blog_index, name='blog_index'),
    path('article/<int:article_id>/', views.article_detail, name='article_detail'),
]
```

For a request to `/blog/article/42/`, Django will match it to the `article_detail` view in `blog/views.py` and extract `42` as the `article_id` parameter.

## 4. View Execution

Once Django has found the matching URL pattern, it calls the associated view function or class. The view is responsible for processing the request and returning an HTTP response.

The view function receives:
- The `HttpRequest` object
- Any captured URL parameters
- Any additional arguments provided by the URL pattern

### Function-based View Example:

```python
# blog/views.py
from django.shortcuts import render, get_object_or_404
from .models import Article

def article_detail(request, article_id):
    article = get_object_or_404(Article, id=article_id)
    context = {'article': article}
    return render(request, 'blog/article_detail.html', context)
```

### Class-based View Example:

```python
# blog/views.py
from django.views.generic import DetailView
from .models import Article

class ArticleDetailView(DetailView):
    model = Article
    template_name = 'blog/article_detail.html'
    pk_url_kwarg = 'article_id'
```

```python
# blog/urls.py
from django.urls import path
from .views import ArticleDetailView

urlpatterns = [
    # ...
    path('article/<int:article_id>/', ArticleDetailView.as_view(), name='article_detail'),
]
```

Inside the view function or class, you typically:
1. Fetch data from models or external services
2. Process form data
3. Apply business logic
4. Choose a template to render
5. Return an HttpResponse object

If your view raises an exception, Django will call the appropriate error handler view (like your 404 or 500 error pages).

## 5. Middleware Processing (Response phase)

After the view generates a response, Django passes it back through the middleware stack in reverse order, calling each middleware's `process_response()` method.

This gives middleware a chance to modify the response before it's sent to the user. Common operations in this phase include:

- Adding headers
- Compressing content
- Caching
- Processing cookies

In our earlier middleware example, the second print statement runs during this phase.

## 6. Response Delivery

Finally, Django sends the HTTP response back to the user's browser. The response includes:

- An HTTP status code (200 OK, 404 Not Found, etc.)
- Headers
- The response body (typically HTML, JSON, or other content)

Here's an example of a simplified HTTP response:

```
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Set-Cookie: sessionid=new123; Path=/; HttpOnly
X-Frame-Options: DENY

<!DOCTYPE html>
<html>
    <head>
        <title>Article Title</title>
    </head>
    <body>
        <h1>Article Title</h1>
        <p>Article content here...</p>
    </body>
</html>
```

## Real-world Application: Customizing the Request Lifecycle

Understanding the request lifecycle allows you to customize Django's behavior at various points. Let's look at some practical examples:

### 1. Custom Authentication Middleware

If you want to implement a custom authentication system, you could create a middleware that checks for an API key in the request headers:

```python
class ApiKeyMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Check for API key in the request
        api_key = request.headers.get('X-API-Key')
        
        # Skip API key check for certain paths
        if not request.path.startswith('/api/'):
            return self.get_response(request)
        
        if not api_key:
            from django.http import JsonResponse
            return JsonResponse({'error': 'Missing API key'}, status=401)
        
        if not self._validate_api_key(api_key):
            from django.http import JsonResponse
            return JsonResponse({'error': 'Invalid API key'}, status=403)
        
        # API key is valid, continue processing
        return self.get_response(request)
        
    def _validate_api_key(self, key):
        # Implementation of API key validation
        valid_keys = ['secret123', 'demo456']
        return key in valid_keys
```

### 2. Request Timing

You might want to measure how long your views take to execute:

```python
import time

class RequestTimingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Start timing
        start_time = time.time()
        
        # Process the request
        response = self.get_response(request)
        
        # Calculate execution time
        execution_time = time.time() - start_time
        
        # Add timing header to response
        response['X-Execution-Time'] = f"{execution_time:.4f} seconds"
        
        if execution_time > 1.0:
            print(f"SLOW REQUEST: {request.path} took {execution_time:.4f} seconds")
            
        return response
```

### 3. Custom Error Handling

You can customize how Django handles exceptions by creating custom middleware:

```python
class CustomErrorMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        return self.get_response(request)
        
    def process_exception(self, request, exception):
        if isinstance(exception, ValueError):
            from django.http import HttpResponse
            return HttpResponse("A value error occurred.", status=400)
            
        # For other exceptions, let Django's default handler take over
        return None
```

## Summary

The Django request lifecycle provides a structured way to process HTTP requests through multiple stages. To recap:

1. Django receives an HTTP request and creates an `HttpRequest` object
2. The request passes through middleware in the order defined in settings
3. URL patterns are matched to find the appropriate view
4. The view processes the request and returns a response
5. The response passes back through middleware in reverse order
6. The final response is sent to the user

Understanding this lifecycle allows you to:
- Debug problems more effectively
- Create custom middleware to add global functionality
- Optimize your application's performance
- Implement custom authentication and authorization

By mastering the Django request lifecycle, you gain deeper control over how your web application processes requests and generates responses, leading to more robust and efficient Django applications.

## Additional Resources

- [Official Django Documentation: Request and Response Objects](https://docs.djangoproject.com/en/stable/ref/request-response/)
- [Django Middleware Documentation](https://docs.djangoproject.com/en/stable/topics/http/middleware/)
- [Django URL Dispatcher Documentation](https://docs.djangoproject.com/en/stable/topics/http/urls/)

## Practice Exercises

1. Create a middleware that logs all database queries made during request processing.
2. Implement a rate-limiting middleware that restricts users to 100 requests per minute.
3. Build a middleware that detects mobile browsers and sets a `is_mobile` attribute on the request object.
4. Create a custom 404 handler that suggests related pages when a user encounters a "Page Not Found" error.
5. Implement a "maintenance mode" middleware that shows a maintenance page for all requests except those from admin users.