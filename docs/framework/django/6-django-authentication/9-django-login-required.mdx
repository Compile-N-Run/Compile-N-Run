---
title: Django Login Required
description: Learn how to restrict access to views in Django using the login_required decorator and other authentication methods for securing your web application.

---

# Django Login Required

## Introduction

Web applications often contain areas that should only be accessible to authenticated users. Django provides several ways to restrict access to views, with the `login_required` decorator being one of the simplest and most commonly used methods. In this tutorial, we'll explore how to use Django's authentication system to protect views and control access to different parts of your application.

## Understanding View Protection in Django

When building web applications, you'll frequently need to:

- Restrict certain pages to logged-in users only
- Redirect unauthenticated users to login pages
- Create different experiences for authenticated vs. anonymous users

Django's authentication system provides tools that make implementing these requirements straightforward and secure.

## The `login_required` Decorator

The `login_required` decorator is the simplest way to restrict access to a view. It ensures that only authenticated users can access the decorated view.

### Basic Usage

```python
from django.contrib.auth.decorators import login_required

@login_required
def my_protected_view(request):
    # This view is only accessible to logged-in users
    return render(request, 'protected_page.html')
```

When an unauthenticated user tries to access this view, Django will:

1. Redirect the user to the login page
2. Append the current URL as a `next` parameter in the query string
3. After successful login, redirect back to the originally requested page

### Customizing the Login URL

By default, `login_required` redirects to `settings.LOGIN_URL`, which is set to `/accounts/login/` unless you've changed it. You can customize this by:

1. Setting the `LOGIN_URL` in your `settings.py`:

```python
# In settings.py
LOGIN_URL = '/users/login/'
```

2. Or by passing a specific URL to the decorator:

```python
@login_required(login_url='/custom/login/')
def my_protected_view(request):
    return render(request, 'protected_page.html')
```

## Protecting Class-Based Views

For class-based views, you can use the `LoginRequiredMixin` instead of the decorator:

```python
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.generic import TemplateView

class ProtectedView(LoginRequiredMixin, TemplateView):
    template_name = 'protected_page.html'
    login_url = '/login/'  # Optional: override the default login URL
    redirect_field_name = 'next'  # Optional: change the redirect field name
```

## Practical Example: Building a User Dashboard

Let's create a simple user dashboard that's protected with `login_required`:

### 1. First, define your URLs in `urls.py`:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('dashboard/', views.dashboard, name='dashboard'),
    path('login/', views.login_view, name='login'),
    path('logout/', views.logout_view, name='logout'),
]
```

### 2. Create the views in `views.py`:

```python
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.contrib import messages

def home(request):
    return render(request, 'home.html')

@login_required
def dashboard(request):
    # Access user information with request.user
    user_posts = request.user.post_set.all()  # Assuming a Post model with user ForeignKey
    return render(request, 'dashboard.html', {
        'user_posts': user_posts
    })

def login_view(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        
        if user is not None:
            login(request, user)
            # Redirect to the 'next' parameter if it exists
            next_url = request.GET.get('next', 'dashboard')
            return redirect(next_url)
        else:
            messages.error(request, "Invalid username or password.")
    
    return render(request, 'login.html')

def logout_view(request):
    logout(request)
    return redirect('home')
```

### 3. Create the templates:

**home.html**
```html
{% extends 'base.html' %}

{% block content %}
<h1>Welcome to Our Site</h1>
{% if user.is_authenticated %}
    <p>Hello, {{ user.username }}!</p>
    <a href="{% url 'dashboard' %}">Go to Dashboard</a>
    <a href="{% url 'logout' %}">Logout</a>
{% else %}
    <p>Please log in to access your dashboard.</p>
    <a href="{% url 'login' %}">Login</a>
{% endif %}
{% endblock %}
```

**dashboard.html**
```html
{% extends 'base.html' %}

{% block content %}
<h1>Your Dashboard</h1>
<p>Welcome, {{ user.username }}!</p>

<h2>Your Posts</h2>
{% if user_posts %}
    <ul>
    {% for post in user_posts %}
        <li>{{ post.title }}</li>
    {% endfor %}
    </ul>
{% else %}
    <p>You haven't created any posts yet.</p>
{% endif %}

<a href="{% url 'home' %}">Home</a>
<a href="{% url 'logout' %}">Logout</a>
{% endblock %}
```

**login.html**
```html
{% extends 'base.html' %}

{% block content %}
<h1>Login</h1>

{% if messages %}
<div class="messages">
    {% for message in messages %}
    <p{% if message.tags %} class="{{ message.tags }}"{% endif %}>{{ message }}</p>
    {% endfor %}
</div>
{% endif %}

<form method="post">
    {% csrf_token %}
    <div>
        <label for="username">Username:</label>
        <input type="text" name="username" required>
    </div>
    <div>
        <label for="password">Password:</label>
        <input type="password" name="password" required>
    </div>
    <button type="submit">Login</button>
</form>
{% endblock %}
```

## Advanced Authentication Controls

### Checking Authentication in Templates

In Django templates, you can check if a user is authenticated using:

```html
{% if user.is_authenticated %}
    <!-- Content for logged-in users -->
    <p>Welcome, {{ user.username }}</p>
{% else %}
    <!-- Content for anonymous users -->
    <p><a href="{% url 'login' %}">Login</a></p>
{% endif %}
```

### User Tests in Views

You can also check authentication status directly in views:

```python
def my_view(request):
    if request.user.is_authenticated:
        # Do something for authenticated users
        return render(request, 'logged_in_template.html')
    else:
        # Do something for anonymous users
        return render(request, 'anonymous_template.html')
```

### Permission-Based Access Control

If you need more granular control than just checking if a user is logged in, Django provides the `permission_required` decorator:

```python
from django.contrib.auth.decorators import permission_required

@permission_required('app.view_model')
def view_protected_model(request):
    # Only users with the 'app.view_model' permission can access this view
    return render(request, 'model_detail.html')
```

For class-based views, use `PermissionRequiredMixin`:

```python
from django.contrib.auth.mixins import PermissionRequiredMixin

class ProtectedView(PermissionRequiredMixin, TemplateView):
    template_name = 'protected_page.html'
    permission_required = 'app.view_model'
```

## Common Best Practices

1. **Security in Layers**: Don't rely solely on view protection. Also implement model-level permissions.

2. **CSRF Protection**: Django's authentication system handles CSRF protection, but ensure it's not disabled.

3. **Secure Password Handling**: Django handles password hashing for you, never store plain text passwords.

4. **Use HTTPS**: Always use HTTPS when deploying authentication systems.

5. **Session Security**: Configure proper session timeouts in your settings:

```python
# In settings.py
SESSION_COOKIE_AGE = 1800  # 30 minutes in seconds
SESSION_EXPIRE_AT_BROWSER_CLOSE = True  # Session expires when browser closes
```

## Summary

Django's `login_required` decorator and authentication system provide powerful tools for restricting access to views based on user authentication status. By combining these with Django's template system and permission framework, you can create secure applications with different experiences for different types of users.

The key takeaways are:
- Use `@login_required` to protect function-based views
- Use `LoginRequiredMixin` for class-based views
- Customize the login URL through settings or directly in decorators/mixins
- Check authentication status in templates with `user.is_authenticated`
- Implement more granular control with Django's permission system

## Additional Resources

- [Django Authentication Documentation](https://docs.djangoproject.com/en/stable/topics/auth/)
- [Django Login Required Decorator Documentation](https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.decorators.login_required)
- [Class-Based Views Authentication Documentation](https://docs.djangoproject.com/en/stable/topics/auth/default/#the-loginrequired-mixin)

## Practice Exercises

1. Create a simple Django blog where only authenticated users can create posts, but anyone can view them.
2. Implement a user profile system where users can only edit their own profile.
3. Build a multi-level permission system where admins can access an admin dashboard, content creators can create content, and subscribers can access premium content.