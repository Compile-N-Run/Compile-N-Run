---
title: Django Time Zones
description: Learn how to handle time zones in Django applications for proper internationalization

---

# Django Time Zones

Working with dates and times in applications with users across different geographic locations can be challenging. Django provides robust support for time zone handling, ensuring that your application displays the correct time for each user regardless of where they are located or where your server is hosted.

## Introduction to Time Zones in Django

When building an international web application, displaying dates and times in the user's local time zone greatly enhances the user experience. Django's time zone support allows you to store dates and times in the database in UTC (Coordinated Universal Time) while displaying them to users in their local time.

By default, Django sets the time zone to `America/Chicago`, but you can easily configure it to work with any time zone in the world. Let's explore how to properly set up and use time zones in your Django application.

## Setting Up Time Zone Support

### Step 1: Configure Settings

First, you need to enable time zone support in your Django project by modifying your `settings.py` file:

```python
# settings.py

USE_TZ = True
TIME_ZONE = 'UTC'  # The default server time zone
```

Setting `USE_TZ` to `True` tells Django to use timezone-aware datetime objects internally. The `TIME_ZONE` setting specifies the default time zone for your application server.

### Step 2: Understanding Time Zone Concepts

Before diving deeper, let's clarify a few important concepts:

1. **Naive datetime** - A datetime object without time zone information
2. **Aware datetime** - A datetime object that includes time zone information
3. **UTC** - The standard time zone reference, from which all other time zones are calculated

## Working with Time Zones in Views

### Getting the Current Time

To get the current time in your views:

```python
from django.utils import timezone

def current_time_view(request):
    # Gets current time in UTC
    now = timezone.now()
    
    # Display to the template
    return render(request, 'current_time.html', {'current_time': now})
```

The output will be a timezone-aware datetime object like:
```
2023-09-01 14:30:45.123456+00:00
```

### Converting Between Time Zones

You can convert between time zones using Django's utilities:

```python
from django.utils import timezone
import pytz

def time_conversion_view(request):
    # Get current UTC time
    utc_now = timezone.now()
    
    # Convert to a specific time zone
    tokyo_tz = pytz.timezone('Asia/Tokyo')
    tokyo_time = utc_now.astimezone(tokyo_tz)
    
    # Convert to another time zone
    new_york_tz = pytz.timezone('America/New_York')
    new_york_time = utc_now.astimezone(new_york_tz)
    
    context = {
        'utc_time': utc_now,
        'tokyo_time': tokyo_time,
        'new_york_time': new_york_time,
    }
    
    return render(request, 'time_zones.html', context)
```

Output might look like:
```
UTC: 2023-09-01 14:30:45+00:00
Tokyo: 2023-09-01 23:30:45+09:00
New York: 2023-09-01 10:30:45-04:00
```

### User's Local Time Zone

To respect a user's local time zone, you can:

1. Store the user's preferred time zone in their profile
2. Use JavaScript to detect their time zone
3. Let them select it from preferences

Here's an example of setting a user's time zone preference:

```python
from django.utils import timezone
import pytz

def set_timezone(request):
    if request.method == 'POST':
        request.session['django_timezone'] = request.POST['timezone']
        return redirect('/')
    else:
        return render(request, 'set_timezone.html', {'timezones': pytz.common_timezones})
```

And the corresponding template `set_timezone.html`:

```html
<form method="POST">
    {% csrf_token %}
    <select name="timezone">
        {% for tz in timezones %}
            <option value="{{ tz }}">{{ tz }}</option>
        {% endfor %}
    </select>
    <input type="submit" value="Set time zone">
</form>
```

## Middleware for Automatic Time Zone Activation

You can create a custom middleware to automatically set the time zone for each request based on the user's preference:

```python
# middleware.py
import pytz
from django.utils import timezone

class TimezoneMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Check if user has a timezone preference
        tzname = request.session.get('django_timezone')
        if tzname:
            try:
                timezone.activate(pytz.timezone(tzname))
            except pytz.exceptions.UnknownTimeZoneError:
                pass
        
        response = self.get_response(request)
        return response
```

Add this middleware to your `settings.py`:

```python
MIDDLEWARE = [
    # other middleware
    'yourapp.middleware.TimezoneMiddleware',
]
```

## Formatting Dates and Times in Templates

In your templates, you can format dates and times using Django's built-in template filters:

```html
<p>Current time: {{ current_time }}</p>
<p>Formatted date: {{ current_time|date:"Y-m-d" }}</p>
<p>Formatted time: {{ current_time|time:"H:i" }}</p>
<p>Short format: {{ current_time|date:"SHORT_DATETIME_FORMAT" }}</p>
```

Output might look like:
```
Current time: Sept. 1, 2023, 2:30 p.m.
Formatted date: 2023-09-01
Formatted time: 14:30
Short format: 09/01/2023 2:30 p.m.
```

## Working with Forms

When accepting date/time input from forms, Django automatically converts the input to UTC for storage:

```python
from django import forms
from django.utils import timezone

class EventForm(forms.Form):
    name = forms.CharField(max_length=100)
    start_time = forms.DateTimeField(
        input_formats=['%Y-%m-%d %H:%M'],
        widget=forms.DateTimeInput(attrs={'type': 'datetime-local'})
    )
    
def create_event(request):
    if request.method == 'POST':
        form = EventForm(request.POST)
        if form.is_valid():
            # form.cleaned_data['start_time'] will be a timezone-aware datetime
            # in the current time zone (as set by activate())
            event_name = form.cleaned_data['name']
            event_time = form.cleaned_data['start_time']
            
            # Save to database (datetime is converted to UTC automatically)
            Event.objects.create(name=event_name, start_time=event_time)
            return redirect('event_list')
    else:
        form = EventForm()
    
    return render(request, 'create_event.html', {'form': form})
```

## Common Time Zone Issues and Solutions

### Issue 1: Database Storage

Always store datetime values in UTC in your database to avoid confusion. Django does this automatically when `USE_TZ = True`.

### Issue 2: Time Zone Arithmetic

Be careful when performing date arithmetic across DST (Daylight Saving Time) boundaries:

```python
from django.utils import timezone
import pytz

def dst_example():
    # Create a datetime just before DST ends
    la_tz = pytz.timezone('America/Los_Angeles')
    dt = la_tz.localize(datetime.datetime(2023, 11, 5, 1, 30))
    
    # Add 1 hour - this will handle the DST transition correctly
    dt_plus_1h = dt + datetime.timedelta(hours=1)
    
    print(f"Original: {dt}")  # 2023-11-05 01:30:00-07:00
    print(f"Plus 1 hour: {dt_plus_1h}")  # 2023-11-05 01:30:00-08:00 (not 02:30 because DST ended)
```

### Issue 3: Comparing Datetimes

Always ensure you're comparing timezone-aware datetimes with other timezone-aware datetimes:

```python
from django.utils import timezone
import datetime

def compare_dates():
    now = timezone.now()
    
    # This is wrong - naive and aware datetime comparison
    naive_date = datetime.datetime.now()
    if now > naive_date:  # TypeError: can't compare offset-naive and offset-aware datetimes
        print("This will raise an error")
    
    # This is correct
    aware_date = timezone.make_aware(datetime.datetime.now())
    if now > aware_date:
        print("This works correctly")
```

## Real-world Application: Event Scheduling System

Here's a complete example of a simple event scheduling system that respects user time zones:

```python
# models.py
from django.db import models
from django.conf import settings

class UserProfile(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    timezone = models.CharField(max_length=50, default='UTC')

class Event(models.Model):
    title = models.CharField(max_length=200)
    start_time = models.DateTimeField()
    end_time = models.DateTimeField()
    creator = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    
    def __str__(self):
        return self.title
```

```python
# views.py
from django.shortcuts import render, redirect
from django.utils import timezone
import pytz
from .models import Event, UserProfile
from .forms import EventForm

def event_list(request):
    # Get all events
    events = Event.objects.all()
    
    # Get user timezone preference
    user_timezone = 'UTC'
    if request.user.is_authenticated:
        try:
            profile = UserProfile.objects.get(user=request.user)
            user_timezone = profile.timezone
        except UserProfile.DoesNotExist:
            pass
    
    # Convert event times to user's timezone
    user_tz = pytz.timezone(user_timezone)
    for event in events:
        event.start_time = event.start_time.astimezone(user_tz)
        event.end_time = event.end_time.astimezone(user_tz)
    
    return render(request, 'events/list.html', {
        'events': events,
        'user_timezone': user_timezone
    })

def create_event(request):
    if request.method == 'POST':
        form = EventForm(request.POST)
        if form.is_valid():
            event = form.save(commit=False)
            event.creator = request.user
            event.save()
            return redirect('event_list')
    else:
        form = EventForm()
    
    return render(request, 'events/create.html', {'form': form})
```

```python
# forms.py
from django import forms
from .models import Event

class EventForm(forms.ModelForm):
    class Meta:
        model = Event
        fields = ['title', 'start_time', 'end_time']
        widgets = {
            'start_time': forms.DateTimeInput(attrs={'type': 'datetime-local'}),
            'end_time': forms.DateTimeInput(attrs={'type': 'datetime-local'}),
        }
```

Template for the event list:

```html
<!-- templates/events/list.html -->
<h1>Events (Times shown in {{ user_timezone }})</h1>

<ul>
{% for event in events %}
    <li>
        <h3>{{ event.title }}</h3>
        <p>Start: {{ event.start_time|date:"F j, Y, g:i a" }}</p>
        <p>End: {{ event.end_time|date:"F j, Y, g:i a" }}</p>
        <p>Creator: {{ event.creator.username }}</p>
    </li>
{% endfor %}
</ul>

<a href="{% url 'create_event' %}">Create New Event</a>
```

## Summary

Working with time zones in Django requires understanding a few key concepts:

1. Enable time zone support with `USE_TZ = True` in settings
2. Store all dates in UTC in the database (Django does this automatically)
3. Use `timezone.now()` to get the current time 
4. Convert between time zones using `pytz` and `astimezone()`
5. Consider user preferences for time zone display
6. Be careful with time zone arithmetic, especially around DST changes

By following these best practices, your Django application can properly handle dates and times for users across different time zones, creating a more user-friendly experience.

## Additional Resources

- [Django Documentation on Time Zones](https://docs.djangoproject.com/en/stable/topics/i18n/timezones/)
- [pytz Documentation](https://pythonhosted.org/pytz/)
- [List of Time Zone Database Names](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)

## Exercises

1. Create a Django application that displays the current time in three different time zones of your choice.
2. Modify the event scheduling example to add email notifications that are sent at the appropriate time in each recipient's time zone.
3. Build a world clock application that shows the current time in multiple cities around the world.
4. Create a meeting scheduler that allows users from different time zones to find a mutually convenient meeting time.