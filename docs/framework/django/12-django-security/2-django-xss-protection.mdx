---
title: Django XSS Protection
description: Learn how Django protects your web application from cross-site scripting (XSS) attacks, how the template system provides automatic escaping, and how to implement additional security measures.

---

# Django XSS Protection

Cross-Site Scripting (XSS) attacks are one of the most common vulnerabilities found in web applications. Django provides robust protection against XSS attacks out of the box, but understanding how this protection works and when you might need additional measures is crucial for developing secure applications.

## What is Cross-Site Scripting (XSS)?

Before diving into Django's protections, let's understand what XSS is:

Cross-Site Scripting (XSS) occurs when an attacker injects malicious code (usually JavaScript) into web pages that are then viewed by other users. When these scripts execute in the victim's browser, they can:

- Steal session cookies
- Redirect to phishing sites
- Manipulate page content
- Perform actions on behalf of the victim

## Django's Built-in XSS Protection

### Automatic Escaping in Templates

Django's template system automatically escapes the output of template variables. This means that potentially dangerous characters like `<`, `>`, `'`, `"`, and `&` are converted to their HTML entity equivalents.

```python
# views.py
def example_view(request):
    dangerous_input = "<script>alert('XSS')</script>"
    return render(request, 'example.html', {'dangerous_input': dangerous_input})
```

```html
<!-- example.html -->
<div>{{ dangerous_input }}</div>

<!-- Output in browser source -->
<div>&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;</div>
```

This prevents the browser from interpreting the script tag as actual JavaScript code, displaying it as plain text instead.

### When Automatic Escaping Happens

Django automatically escapes:

1. Variables in templates using the `{{ variable }}` syntax
2. Data passed through the `render()` function
3. Data used with the `safe` filter excluded

## Disabling Escaping (Use with Caution!)

There are legitimate cases where you might need to include HTML in your templates. Django provides several ways to do this:

### The `safe` Filter

```html
{{ variable|safe }}
```

This tells Django that the content is safe and doesn't need escaping.

### The `autoescape` Tag

You can disable autoescaping for a block of template code:

```html
{% autoescape off %}
    {{ variable }}
{% endautoescape %}
```

### The `mark_safe` Function

In your Python code:

```python
from django.utils.safestring import mark_safe

def example_view(request):
    html_content = mark_safe("<p>This HTML will not be escaped</p>")
    return render(request, 'example.html', {'html_content': html_content})
```

## ⚠️ Warning: Security Implications

When you disable escaping, you take on the responsibility for ensuring that the content is safe. Only use these methods when:

1. You fully control the HTML content
2. You've sanitized any user input thoroughly
3. You absolutely need to render HTML in that specific context

## Common XSS Vulnerabilities in Django Applications

### 1. JavaScript in Templates

When you include JavaScript that uses template variables:

```html
<!-- VULNERABLE CODE - DO NOT USE -->
<script>
    var username = "{{ username }}";
</script>
```

If `username` contains JavaScript code with quotes, it could break out of the string context.

**Secure approach:**

```html
<script>
    var username = JSON.parse("{{ username|escapejs|safe }}");
</script>
```

### 2. URL Parameters in `href` Attributes

```html
<!-- VULNERABLE CODE - DO NOT USE -->
<a href="{{ user_provided_url }}">Click here</a>
```

An attacker could set `user_provided_url` to `javascript:alert('XSS')`.

**Secure approach:**

```html
<a href="{% if user_provided_url|slice:':4' == 'http' %}{{ user_provided_url }}{% endif %}">Click here</a>
```

### 3. Raw HTML in User-Generated Content

For applications that need to allow some HTML (like comments or blog posts):

1. Use a library like `bleach` to sanitize HTML:

```python
import bleach

def save_comment(request):
    raw_comment = request.POST.get('comment', '')
    # Allow only specific tags and attributes
    clean_comment = bleach.clean(
        raw_comment,
        tags=['p', 'strong', 'em', 'u', 'a'],
        attributes={'a': ['href']},
        strip=True
    )
    # Save clean_comment to database
```

## Django Content Security Policy (CSP)

For additional protection, consider implementing Content Security Policy. While Django doesn't include CSP headers by default, you can add them using middleware:

```python
# middleware.py
class CSPMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        response['Content-Security-Policy'] = "default-src 'self'; script-src 'self'"
        return response

# settings.py
MIDDLEWARE = [
    # other middleware...
    'yourapp.middleware.CSPMiddleware',
]
```

## Real-World Example: Building a Secure Comment System

Let's build a simple but secure comment system for a blog:

1. **Models:**

```python
# models.py
from django.db import models
from django.conf import settings

class Comment(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    is_approved = models.BooleanField(default=False)
```

2. **Forms with Validation:**

```python
# forms.py
from django import forms
import bleach
from .models import Comment

class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment
        fields = ['content']
    
    def clean_content(self):
        content = self.cleaned_data['content']
        # Allow limited formatting but no scripts or dangerous content
        cleaned_content = bleach.clean(
            content,
            tags=['p', 'strong', 'em', 'br'],
            attributes={},
            strip=True
        )
        return cleaned_content
```

3. **View:**

```python
# views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from .forms import CommentForm
from .models import Comment

@login_required
def add_comment(request):
    if request.method == 'POST':
        form = CommentForm(request.POST)
        if form.is_valid():
            comment = form.save(commit=False)
            comment.user = request.user
            comment.save()
            return redirect('post_detail', pk=post_id)
    else:
        form = CommentForm()
    return render(request, 'add_comment.html', {'form': form})
```

4. **Template:**

```html
<!-- comments.html -->
{% for comment in comments %}
    <div class="comment">
        <p class="author">{{ comment.user.username }} said:</p>
        <div class="content">
            {{ comment.content|safe }}
        </div>
        <small>{{ comment.created_at|date:"F j, Y" }}</small>
    </div>
{% endfor %}
```

Note that we use `|safe` because we've already sanitized the content using bleach when the comment was saved.

## Best Practices for XSS Prevention in Django

1. **Trust Django's autoescaping** - Don't disable it unless absolutely necessary
2. **Sanitize any HTML content** - Use libraries like `bleach` when you need to allow some HTML
3. **Validate input data** - Use Django forms for validation and cleaning
4. **Consider Content Security Policy** - Add CSP headers for additional protection
5. **Be cautious with JavaScript** - Never insert user data directly into JavaScript
6. **Keep Django updated** - Security patches are regularly released
7. **Use HTTPS** - Prevents man-in-the-middle attacks that could inject scripts

## Summary

Django's template system provides strong protection against XSS attacks through automatic escaping. However, developers need to be careful when disabling this protection or when inserting content into JavaScript or URL contexts.

By understanding how XSS works and following best practices, you can ensure your Django applications remain secure against this common vulnerability.

## Additional Resources

1. [Django Security documentation](https://docs.djangoproject.com/en/stable/topics/security/)
2. [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
3. [Bleach library documentation](https://bleach.readthedocs.io/)
4. [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)

## Practice Exercises

1. Create a Django form that accepts HTML input, sanitizes it, and displays it safely
2. Add CSP headers to an existing Django project and test that they block inline scripts
3. Review an existing Django application for potential XSS vulnerabilities
4. Implement a markdown parser with proper XSS protection for a comment system