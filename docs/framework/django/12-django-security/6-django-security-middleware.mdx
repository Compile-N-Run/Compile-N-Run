---
title: Django Security Middleware
description: A comprehensive guide to Django's built-in security middleware, how they protect your web applications, and how to configure them properly.

---

# Django Security Middleware

Django includes several built-in security middleware components that help protect your web application from common vulnerabilities and attacks. In this article, we'll explore these middleware components, understand how they work, and learn how to configure them properly.

## What is Middleware in Django?

Before diving into security middleware specifically, let's briefly understand what middleware is in Django.

Middleware is a framework of hooks into Django's request/response processing. It's a light, low-level plugin system for globally altering Django's input or output. Each middleware component is responsible for doing some specific function during the request-response cycle.

```python
# Middleware execution order during request and response
Request → Middleware 1 → Middleware 2 → ... → View → ... → Middleware 2 → Middleware 1 → Response
```

## Django's Security Middleware Components

Django comes with several security middleware components pre-installed. Let's explore each one:

### 1. SecurityMiddleware

The `SecurityMiddleware` is a core component that handles several security features:

- HTTPS redirects
- HSTS (HTTP Strict Transport Security)
- XSS (Cross-site scripting) protection
- Content-Type sniffing prevention
- Referrer policy configuration

Here's how it works in your Django settings:

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # other middleware components...
]

# SecurityMiddleware settings
SECURE_HSTS_SECONDS = 3600  # 1 hour
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_SSL_REDIRECT = True
SECURE_REFERRER_POLICY = 'same-origin'
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True  # Deprecated in newer browsers which have their own protections
```

#### Setting Explanations:

- `SECURE_HSTS_SECONDS`: Sets the duration (in seconds) that browsers should remember your site should only be accessed using HTTPS.
- `SECURE_HSTS_INCLUDE_SUBDOMAINS`: If True, all subdomains will also use HSTS.
- `SECURE_HSTS_PRELOAD`: Adds your site to browser preload lists (requires manual submission).
- `SECURE_SSL_REDIRECT`: Redirects all HTTP requests to HTTPS.
- `SECURE_REFERRER_POLICY`: Controls how much referrer information is sent.
- `SECURE_CONTENT_TYPE_NOSNIFF`: Prevents browsers from MIME-sniffing a response.
- `SECURE_BROWSER_XSS_FILTER`: Enables cross-site scripting filter in browsers.

### 2. CsrfViewMiddleware

CSRF (Cross-Site Request Forgery) protection is crucial for Django applications. This middleware ensures that POST, PUT, PATCH, and DELETE requests require a valid CSRF token.

```python
MIDDLEWARE = [
    # other middleware...
    'django.middleware.csrf.CsrfViewMiddleware',
    # other middleware...
]
```

In your templates, you need to include the CSRF token in your forms:

```html
<form method="post">
    {% csrf_token %}
    <!-- form fields -->
    <button type="submit">Submit</button>
</form>
```

For AJAX requests, you'll need to include the CSRF token in the headers:

```javascript
// JavaScript example for including CSRF token in AJAX requests
const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value;

fetch('/api/endpoint/', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': csrftoken
    },
    body: JSON.stringify(data)
})
```

### 3. XFrameOptionsMiddleware

This middleware helps prevent clickjacking attacks by including the X-Frame-Options header in responses.

```python
MIDDLEWARE = [
    # other middleware...
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # other middleware...
]

# Configuration
X_FRAME_OPTIONS = 'DENY'  # Options: 'DENY', 'SAMEORIGIN', or 'ALLOW-FROM uri'
```

The `X_FRAME_OPTIONS` setting controls whether your pages can be loaded within frames on other sites, protecting against clickjacking attacks:
- `DENY`: The page cannot be displayed in a frame
- `SAMEORIGIN`: The page can only be displayed in a frame on the same origin
- `ALLOW-FROM uri`: The page can only be displayed in a frame on the specified origin

### 4. SessionMiddleware

While not exclusively for security, `SessionMiddleware` is important for many security features as it handles session cookies.

```python
MIDDLEWARE = [
    # other middleware...
    'django.contrib.sessions.middleware.SessionMiddleware',
    # other middleware...
]

# Security-related session settings
SESSION_COOKIE_SECURE = True  # Only send cookies over HTTPS
SESSION_COOKIE_HTTPONLY = True  # Prevent JavaScript access to cookies
SESSION_COOKIE_SAMESITE = 'Lax'  # Controls when cookies are sent with cross-site requests
```

## Real-World Example: Configuring Security Middleware for Production

Let's look at a comprehensive example of properly configuring security middleware for a production environment:

```python
# settings.py for production environment

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# HTTPS settings
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# HSTS settings
SECURE_HSTS_SECONDS = 31536000  # 1 year
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True

# Content security
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
SECURE_REFERRER_POLICY = 'same-origin'

# Session security
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Lax'
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Lax'
```

## Creating Custom Security Middleware

Sometimes you might need to implement custom security measures. Here's an example of creating a simple middleware to add security headers:

```python
# In a file like myproject/middleware.py

class CustomSecurityHeadersMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        
        # Add Content-Security-Policy header
        response['Content-Security-Policy'] = "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';"
        
        # Add Feature-Policy header
        response['Feature-Policy'] = "geolocation 'self'; microphone 'none'; camera 'none'"
        
        return response
```

Then add it to your `MIDDLEWARE` setting:

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # other middleware...
    'myproject.middleware.CustomSecurityHeadersMiddleware',
]
```

## Testing Your Security Middleware

It's important to test that your security middleware is functioning correctly. Here's a simple test case for checking that the CSRF middleware is working:

```python
# In your tests.py
from django.test import TestCase, Client
from django.urls import reverse

class CsrfSecurityTest(TestCase):
    def test_csrf_protection(self):
        client = Client(enforce_csrf_checks=True)
        url = reverse('my_form_view')
        
        # This should fail because no CSRF token is provided
        response = client.post(url, {'data': 'test'})
        self.assertEqual(response.status_code, 403)
```

## Common Security Middleware Issues and Solutions

### Issue 1: CSRF Token Verification Failed

**Problem**: You're getting 403 Forbidden errors when submitting forms.

**Solution**: 
1. Ensure `{% csrf_token %}` is included in your form
2. For AJAX requests, include the CSRF token in headers
3. Check if any middleware is removing the CSRF cookie

```python
# For AJAX with jQuery
$.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {
            xhr.setRequestHeader("X-CSRFToken", getCookie('csrftoken'));
        }
    }
});
```

### Issue 2: Mixed Content Warnings

**Problem**: HTTPS site has resources loaded over HTTP.

**Solution**: Set `SECURE_SSL_REDIRECT = True` and update your URLs to use HTTPS or protocol-relative URLs:

```html
<!-- Instead of this -->
<script src="http://example.com/script.js"></script>

<!-- Use this -->
<script src="https://example.com/script.js"></script>
<!-- Or this -->
<script src="//example.com/script.js"></script>
```

## Summary

Django's security middleware components provide a robust set of protections against common web vulnerabilities:

- `SecurityMiddleware` handles HTTPS, HSTS, XSS protection, and content-type sniffing prevention
- `CsrfViewMiddleware` protects against cross-site request forgery
- `XFrameOptionsMiddleware` prevents clickjacking attacks
- `SessionMiddleware` helps secure your session cookies

Properly configuring these security middleware components is essential for protecting your Django application. Always enable these protections in production environments, and consider the security implications of disabling any of them.

## Additional Resources

- [Django Security Documentation](https://docs.djangoproject.com/en/stable/topics/security/)
- [OWASP Web Security Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security.html)

## Exercises

1. Set up a Django project with all security middleware enabled and use tools like [Mozilla Observatory](https://observatory.mozilla.org/) to test your security headers.
2. Create a custom middleware that logs all failed CSRF attempts to help detect potential attacks.
3. Configure Content-Security-Policy headers through a custom middleware and test that they block unauthorized script execution.
4. Implement rate limiting middleware to prevent brute force attacks on your login forms.

By following these guidelines and implementing Django's security middleware properly, you'll have a solid foundation for building secure web applications with Django.