---
title: Django Security Introduction
description: An introduction to security concepts in Django and best practices for building secure web applications

---

# Django Security Introduction

## What is Django Security?

Django is renowned for its "batteries-included" approach to web development, and security is one area where this philosophy truly shines. Django's security features are robust, well-maintained, and designed to protect your web applications against common web vulnerabilities right out of the box.

In this introduction, we'll explore what makes Django a secure framework and the fundamental security concepts every Django developer should understand.

## Why Security Matters

Before diving into Django's security features, let's understand why web security is crucial:

- **Data Protection**: Secure applications protect sensitive user information.
- **Service Reliability**: Security breaches can cause downtime and service disruption.
- **Reputation**: Security incidents damage user trust and company reputation.
- **Compliance**: Many industries require adherence to security standards.
- **Financial Impact**: Security breaches often lead to significant financial losses.

## Django's Security Philosophy

Django follows several security principles:

1. **Secure by Default**: Many protections are enabled automatically.
2. **Defense in Depth**: Multiple layers of security are implemented.
3. **Explicit is Better than Implicit**: Security features are transparent and documented.
4. **Don't Reinvent the Wheel**: Django uses established security practices.

## Key Security Features in Django

### 1. Cross-Site Scripting (XSS) Protection

XSS attacks occur when malicious scripts are injected into trusted websites. Django's template system automatically escapes special characters in template variables, preventing XSS attacks:

```python
# Django automatically escapes this, preventing XSS
def profile(request):
    username = request.GET.get('username', '')
    return render(request, 'profile.html', {'username': username})
```

In template:
```html
<h1>Welcome, {{ username }}</h1>  <!-- Automatically escaped -->
```

If `username` contains malicious JavaScript like `<script>alert('hacked')</script>`, Django escapes it to display as text rather than executing it.

### 2. Cross-Site Request Forgery (CSRF) Protection

CSRF attacks trick authenticated users into performing unintended actions. Django provides CSRF protection by including a token in forms:

```python
# views.py
from django.shortcuts import render

def change_password(request):
    if request.method == 'POST':
        # Process form data, Django automatically checks CSRF token
        pass
    return render(request, 'change_password.html')
```

In template:
```html
<form method="post" action="/change-password/">
    {% csrf_token %}
    <input type="password" name="new_password">
    <button type="submit">Change Password</button>
</form>
```

The `{% csrf_token %}` tag generates a hidden input field containing a token that Django verifies to ensure the request came from your site.

### 3. SQL Injection Protection

SQL injection attacks occur when untrusted data is used in SQL queries. Django's ORM (Object-Relational Mapping) automatically parameterizes queries:

```python
# Unsafe raw SQL query (don't do this!)
User.objects.raw("SELECT * FROM auth_user WHERE username = '%s'" % username)

# Django ORM (safe, handles parameterization automatically)
User.objects.filter(username=username)
```

### 4. Clickjacking Protection

Django helps prevent clickjacking attacks (where your site is loaded in an invisible iframe) through the `X-Frame-Options` middleware that's enabled by default:

```python
# In settings.py, this is enabled by default
MIDDLEWARE = [
    # ...
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # ...
]

# Default setting sends 'X-Frame-Options: SAMEORIGIN' header
X_FRAME_OPTIONS = 'SAMEORIGIN'
```

### 5. HTTPS/SSL Support

Django makes it easy to enforce HTTPS:

```python
# In settings.py
SECURE_SSL_REDIRECT = True  # Redirects HTTP to HTTPS
SESSION_COOKIE_SECURE = True  # Cookies only sent over HTTPS
CSRF_COOKIE_SECURE = True  # CSRF cookies only sent over HTTPS
```

## Real-world Security Implementation Example

Let's create a simple but secure user registration system:

```python
# settings.py (security settings)
DEBUG = False  # Disable debug mode in production
SECRET_KEY = 'your-very-secret-key'  # Keep this secret and secure
ALLOWED_HOSTS = ['yourdomain.com']  # Restrict allowed hosts
PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.Argon2PasswordHasher',
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
]
```

```python
# models.py
from django.db import models
from django.contrib.auth.models import User

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    phone_number = models.CharField(max_length=15, blank=True)
    
    def __str__(self):
        return self.user.username
```

```python
# views.py
from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.decorators import login_required
from .models import UserProfile

def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            # Create user profile
            UserProfile.objects.create(user=user)
            return redirect('login')
    else:
        form = UserCreationForm()
    return render(request, 'register.html', {'form': form})

@login_required
def profile(request):
    return render(request, 'profile.html')
```

```html
<!-- templates/register.html -->
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Register</button>
</form>
```

This example demonstrates several security best practices:
- CSRF protection with `{% csrf_token %}`
- Password hashing with modern algorithms
- User authentication
- Protection of views with `@login_required`
- Proper form validation

## Django Security Checklist

For your Django projects, ensure you follow these basic security practices:

1. ✅ Keep Django updated to the latest security release
2. ✅ Use environment variables for sensitive settings like `SECRET_KEY`
3. ✅ Set `DEBUG = False` in production
4. ✅ Use HTTPS in production
5. ✅ Implement proper authentication and authorization
6. ✅ Validate and sanitize all user inputs
7. ✅ Include `{% csrf_token %}` in all forms
8. ✅ Use Django's ORM instead of raw SQL queries
9. ✅ Properly configure `ALLOWED_HOSTS` in production
10. ✅ Regularly backup your database

## Summary

Django's built-in security features provide strong protection against common web vulnerabilities, including XSS, CSRF, SQL injection, and clickjacking attacks. The framework is designed with security in mind, adopting a "secure by default" approach that helps developers build safer applications.

However, it's important to remember that security is a continuous process, not a one-time implementation. Understanding these security features and keeping up with best practices is crucial for maintaining secure Django applications.

## Additional Resources

- [Django's Security Documentation](https://docs.djangoproject.com/en/stable/topics/security/)
- [OWASP Top 10 Web Application Security Risks](https://owasp.org/www-project-top-ten/)
- [Django Security Checklist](https://docs.djangoproject.com/en/stable/howto/deployment/checklist/)

## Exercises

1. Create a Django project and examine the default security settings in `settings.py`.
2. Build a form that accepts user input and implement proper validation.
3. Configure your Django project to use HTTPS locally for testing.
4. Review the Django Admin interface and identify security features it implements.
5. Research how to implement Django's permission system to secure different views.