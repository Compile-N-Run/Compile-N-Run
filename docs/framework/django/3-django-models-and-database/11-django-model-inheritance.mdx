---
title: Django Model Inheritance
description: Learn how to use Django's model inheritance to create reusable model components, reduce code duplication, and organize your data models efficiently.

---

# Django Model Inheritance

In object-oriented programming, inheritance is a powerful feature that allows us to define a class that inherits all the methods and properties from another class. Django models, being Python classes, also support inheritance. This allows you to create reusable model components, reduce code duplication, and organize your data models in a more efficient way.

## Introduction to Model Inheritance

Django offers three styles of model inheritance:

1. **Abstract base classes** - Create a parent class that holds common information but won't be used to create any database tables
2. **Multi-table inheritance** - Each model has its own database table
3. **Proxy models** - Modify the Python-level behavior of a model without changing the database structure

Let's explore each type in detail with examples to understand when and how to use them.

## Abstract Base Classes

Abstract base classes are useful when you want to put some common information into multiple models. The base class isn't used to create any database table itself. Instead, when the child models are created, the fields from the abstract base class are added to the child models' tables.

### How to Create Abstract Base Classes

To designate a model as abstract, you need to set `abstract = True` in the model's `Meta` class.

```python
from django.db import models

class BaseItem(models.Model):
    name = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        abstract = True
        
class Book(BaseItem):
    author = models.CharField(max_length=100)
    isbn = models.CharField(max_length=13)
    
class Electronics(BaseItem):
    manufacturer = models.CharField(max_length=100)
    model_number = models.CharField(max_length=50)
```

In the above example:
- `BaseItem` is an abstract base class with common fields (`name`, `created_at`, `updated_at`)
- `Book` and `Electronics` inherit from `BaseItem` and have all its fields plus their specific fields
- Django will create only two tables in the database: one for `Book` and one for `Electronics`

### When to Use Abstract Base Classes

Abstract base classes are ideal when:
- You have common fields or methods that should be present across multiple models
- You want to avoid duplicating the same fields in different models
- You don't need to query the base class directly

## Multi-table Inheritance

In multi-table inheritance, each model in the inheritance hierarchy corresponds to a database table. Django creates an implicit one-to-one relationship between the child and parent models.

### How to Create Multi-table Inheritance Models

```python
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=100)
    date_of_birth = models.DateField()
    
class Student(Person):
    school = models.CharField(max_length=100)
    grade = models.CharField(max_length=2)
    
class Employee(Person):
    company = models.CharField(max_length=100)
    salary = models.DecimalField(max_digits=10, decimal_places=2)
```

In this example:
- Django creates three separate tables: `Person`, `Student`, and `Employee`
- The `Student` and `Employee` tables contain a one-to-one link to the `Person` table
- A `Student` instance has access to all fields from `Person` plus its own fields

### Querying Multi-table Inheritance Models

You can query the models in multiple ways:

```python
# Create a student
student = Student.objects.create(
    name="John Doe",
    date_of_birth="2000-01-15",
    school="Django High School",
    grade="A"
)

# Query from the child model
student = Student.objects.get(name="John Doe")
print(student.name)  # "John Doe"
print(student.school)  # "Django High School"

# Query from the parent model
person = Person.objects.get(name="John Doe")
print(person.name)  # "John Doe"

# Access the child model from the parent
student_from_person = person.student
print(student_from_person.grade)  # "A"
```

### When to Use Multi-table Inheritance

Multi-table inheritance is useful when:
- You want a separate table for the base model that can be queried independently
- You need to have instances of the parent model without necessarily being instances of child models
- You want to represent different types of entities that share common information but are fundamentally different

## Proxy Models

Proxy models allow you to modify the Python behavior of a model without changing the database structure. This is useful when you want to add methods, change the default manager, or modify the Meta options of a model.

### How to Create Proxy Models

To create a proxy model, set `proxy = True` in the model's Meta class.

```python
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name}"

class OrderedPerson(Person):
    class Meta:
        proxy = True
        ordering = ['last_name']
    
    def say_hello(self):
        return f"Hello, my name is {self.first_name}!"
```

In this example:
- `OrderedPerson` is a proxy model of `Person`
- Django won't create a new table for `OrderedPerson`
- `OrderedPerson` changes the default ordering and adds a new method

### Using Proxy Models

```python
# Create a person
Person.objects.create(first_name="John", last_name="Doe")
Person.objects.create(first_name="Jane", last_name="Smith")

# Query using the proxy model (will be sorted by last_name)
ordered_people = OrderedPerson.objects.all()
# The result will be ordered by last_name: Jane Smith, John Doe

# Use the new method on the proxy model
person = OrderedPerson.objects.first()
print(person.say_hello())  # "Hello, my name is Jane!"
```

### When to Use Proxy Models

Proxy models are useful when:
- You want to change the Python behavior of a model (adding methods, changing default manager)
- You want different default orderings for the same model
- You want to organize your models logically without changing the database structure

## Real-world Application: E-commerce Product Hierarchy

Let's see a practical example of using model inheritance in an e-commerce application:

```python
from django.db import models

# Abstract base class for all products
class Product(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    sku = models.CharField(max_length=20, unique=True)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        abstract = True
    
    def __str__(self):
        return self.name
    
    def discount_price(self, percentage):
        return self.price * (1 - percentage / 100)

# Physical products that need shipping
class PhysicalProduct(Product):
    weight = models.FloatField(help_text="Weight in kilograms")
    width = models.FloatField(help_text="Width in centimeters")
    height = models.FloatField(help_text="Height in centimeters")
    depth = models.FloatField(help_text="Depth in centimeters")
    stock_quantity = models.PositiveIntegerField(default=0)
    
    def shipping_cost(self, distance_km):
        base_cost = 5.00
        weight_factor = self.weight * 0.5
        return base_cost + weight_factor + (distance_km * 0.01)

# Digital products for download
class DigitalProduct(Product):
    file_size_mb = models.FloatField()
    download_link = models.URLField()
    
    def generate_download_link(self):
        # Logic to generate a temporary download link
        return f"{self.download_link}?temp_token=xyz123"

# Specific product categories (multi-table inheritance)
class Book(PhysicalProduct):
    author = models.CharField(max_length=100)
    publisher = models.CharField(max_length=100)
    isbn = models.CharField(max_length=13)
    pages = models.PositiveIntegerField()

class Software(DigitalProduct):
    version = models.CharField(max_length=20)
    system_requirements = models.TextField()
    license_type = models.CharField(max_length=50)
```

In this example:
- `Product` is an abstract base class with common fields and methods for all products
- `PhysicalProduct` and `DigitalProduct` are also abstract base classes that inherit from `Product`
- `Book` and `Software` are concrete models that inherit from `PhysicalProduct` and `DigitalProduct` respectively
- This hierarchy allows for code reuse and logical organization of different product types

## Best Practices for Model Inheritance

1. **Choose the right inheritance type** for your needs:
   - Use abstract base classes for common fields across models
   - Use multi-table inheritance when you need to query the parent model independently
   - Use proxy models for modifying behavior without changing the database structure

2. **Keep inheritance hierarchies shallow** - Deep inheritance hierarchies can be complex to understand and may lead to performance issues

3. **Consider using composition** instead of inheritance in some cases - Sometimes including a model as a ForeignKey can be cleaner than inheriting from it

4. **Document your models** clearly - Inheritance can make the database structure less obvious, so good documentation is essential

5. **Be aware of the performance implications** - Especially with multi-table inheritance, which can result in additional JOINs when querying

## Summary

Django offers three types of model inheritance:
- **Abstract base classes** for sharing common fields and methods without creating database tables
- **Multi-table inheritance** for creating separate but related tables in a proper inheritance hierarchy
- **Proxy models** for modifying the Python behavior of a model without altering the database structure

Each type has its use cases, advantages, and limitations. Choosing the right type depends on your specific requirements and how you plan to interact with your models and database.

## Additional Resources and Exercises

### Additional Resources
- [Django Documentation on Model Inheritance](https://docs.djangoproject.com/en/stable/topics/db/models/#model-inheritance)
- [Django ORM Cookbook](https://books.agiliq.com/projects/django-orm-cookbook/en/latest/inheritance.html)

### Exercises

1. **Basic Practice**: Create an abstract base class called `TimeStampedModel` with `created_at` and `updated_at` fields, then create two models that inherit from it.

2. **Multi-table Inheritance**: Create a `Person` model with basic personal information and then create `Customer` and `Employee` models that inherit from `Person`. Add specific fields to each child model.

3. **Proxy Models**: Create a `User` model and then create a proxy model called `AdminUser` that has a custom manager to filter only users with admin privileges.

4. **Real-world Challenge**: Design a content management system with a hierarchy of content types (Article, Video, Podcast) using the most appropriate inheritance type for each relationship.

Remember that the choice of inheritance type should be driven by your specific requirements and how you intend to interact with your models and database.