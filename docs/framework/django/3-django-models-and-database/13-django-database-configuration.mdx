---
title: Django Database Configuration
description: Learn how to configure and manage database connections in Django projects, including different database backends, settings, and best practices.

---

# Django Database Configuration

## Introduction

Database configuration is a fundamental aspect of any Django project. Django's Object-Relational Mapping (ORM) system simplifies database operations by allowing you to interact with your database using Python code instead of writing SQL queries directly. Before you can use Django's powerful ORM features, you need to properly configure your database connection.

In this tutorial, we'll explore how to set up different types of databases with Django, understand the configuration options, and implement best practices for database management in your Django applications.

## Database Setup Basics

Django supports several database backends out of the box:

- PostgreSQL (recommended for production)
- MySQL / MariaDB
- SQLite (default, great for development)
- Oracle

Each database backend requires specific configuration in your project's `settings.py` file.

### Default Configuration

When you create a new Django project using `django-admin startproject`, Django automatically configures SQLite as the default database:

```python
# settings.py (default configuration)
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```

This simple configuration creates an SQLite database file in your project's root directory. It's perfect for development but typically not recommended for production environments with high traffic.

## Configuring Different Database Backends

Let's explore how to configure the most common database backends used with Django.

### PostgreSQL Configuration

PostgreSQL is a powerful, open-source relational database that works exceptionally well with Django. To use PostgreSQL, you first need to install the `psycopg2` package:

```bash
pip install psycopg2-binary
```

Then update your `settings.py` file:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_database_password',
        'HOST': 'localhost',  # Or the IP address of your database server
        'PORT': '5432',       # Default PostgreSQL port
    }
}
```

### MySQL Configuration

To use MySQL with Django, install the `mysqlclient` package:

```bash
pip install mysqlclient
```

Then configure your database settings:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_database_password',
        'HOST': 'localhost',
        'PORT': '3306',      # Default MySQL port
        'OPTIONS': {
            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",
        },
    }
}
```

### SQLite Configuration (Detailed)

While SQLite is the default, let's look at a more detailed configuration:

```python
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
        'TIMEOUT': 20,  # In seconds
        'OPTIONS': {
            # SQLite-specific options
            'timeout': 20,
            'check_same_thread': False,  # Use with caution in multi-threaded environments
        }
    }
}
```

## Advanced Database Configuration Options

Django's database configuration offers several advanced options to fine-tune your database connection.

### Connection Pooling

For production applications, connection pooling can significantly improve performance by reusing database connections:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_database_password',
        'HOST': 'localhost',
        'PORT': '5432',
        # Connection pooling settings
        'CONN_MAX_AGE': 600,  # Keep connections alive for 10 minutes
    }
}
```

### Multiple Databases

Django supports using multiple databases in a single project. This is useful for read/write splitting or separating different types of data:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'main_db',
        # Other settings...
    },
    'users': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'users_db',
        # Other settings...
    },
    'analytics': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'analytics_db',
        # Other settings...
    }
}

DATABASE_ROUTERS = ['myproject.routers.AuthRouter', 'myproject.routers.AnalyticsRouter']
```

You would then need to create router classes to determine which database to use for each model:

```python
# myproject/routers.py
class AuthRouter:
    route_app_labels = {'auth', 'contenttypes', 'sessions', 'users'}
    
    def db_for_read(self, model, **hints):
        if model._meta.app_label in self.route_app_labels:
            return 'users'
        return None
    
    def db_for_write(self, model, **hints):
        if model._meta.app_label in self.route_app_labels:
            return 'users'
        return None
    
    def allow_relation(self, obj1, obj2, **hints):
        if (obj1._meta.app_label in self.route_app_labels or
            obj2._meta.app_label in self.route_app_labels):
            return True
        return None
    
    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if app_label in self.route_app_labels:
            return db == 'users'
        return None
```

## Database Configuration in Different Environments

It's a best practice to use different database configurations for development, testing, and production environments. You can use environment variables to manage this:

```python
import os
import dj_database_url

# Default local database configuration
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Override with environment variable if available
if os.environ.get('DATABASE_URL'):
    DATABASES['default'] = dj_database_url.config(
        default=os.environ.get('DATABASE_URL'),
        conn_max_age=600
    )
```

To use this approach, you'll need to install the `dj-database-url` package:

```bash
pip install dj-database-url
```

Then you can set the `DATABASE_URL` environment variable in different environments:

- Development: `sqlite:///path/to/db.sqlite3`
- Production: `postgres://user:password@host:port/database_name`

## Best Practices for Database Configuration

Here are some recommendations for configuring your Django database:

1. **Keep credentials secure**: Never commit sensitive database credentials to version control. Use environment variables instead.

2. **Use different databases for different environments**:
   - SQLite for development
   - PostgreSQL for production

3. **Set appropriate timeouts and connection age**:
   ```python
   DATABASES = {
       'default': {
           # Other settings...
           'CONN_MAX_AGE': 600,  # 10 minutes
           'OPTIONS': {
               'connect_timeout': 10,
           }
       }
   }
   ```

4. **Configure database-specific features**:
   ```python
   # PostgreSQL-specific settings
   DATABASES = {
       'default': {
           'ENGINE': 'django.db.backends.postgresql',
           # Other settings...
           'OPTIONS': {
               'client_encoding': 'UTF8',
               'sslmode': 'require',  # For secure connections
           }
       }
   }
   ```

5. **Set up proper test settings**:
   ```python
   if 'test' in sys.argv:
       DATABASES['default'] = {
           'ENGINE': 'django.db.backends.sqlite3',
           'NAME': ':memory:',
       }
   ```

## Real-world Example: Complete Project Setup

Let's put everything together with a complete example of a Django project with environment-specific database configurations:

```python
# settings.py
import os
import sys
from pathlib import Path
from decouple import config, Csv
import dj_database_url

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Environment-specific settings
DEBUG = config('DEBUG', default=False, cast=bool)
ENVIRONMENT = config('ENVIRONMENT', default='development')

# Database configuration
if ENVIRONMENT == 'production':
    # Production database (from environment variable)
    DATABASES = {
        'default': dj_database_url.config(
            default=config('DATABASE_URL'),
            conn_max_age=600,
            ssl_require=True,
        )
    }
elif ENVIRONMENT == 'development':
    # Development database (local PostgreSQL)
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.postgresql',
            'NAME': config('DB_NAME', default='dev_database'),
            'USER': config('DB_USER', default='postgres'),
            'PASSWORD': config('DB_PASSWORD', default=''),
            'HOST': config('DB_HOST', default='localhost'),
            'PORT': config('DB_PORT', default='5432'),
        }
    }
else:
    # Default to SQLite for other environments
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'db.sqlite3',
        }
    }

# Override for testing with in-memory SQLite
if 'test' in sys.argv:
    DATABASES['default'] = {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:',
    }
```

To use this configuration, you'll need to install a few packages:

```bash
pip install python-decouple dj-database-url
```

And set up a `.env` file in your project root:

```
DEBUG=True
ENVIRONMENT=development
DB_NAME=my_project
DB_USER=postgres
DB_PASSWORD=secret
DB_HOST=localhost
DB_PORT=5432
# For production
# DATABASE_URL=postgres://user:password@host:port/database
```

## Testing Your Database Configuration

After setting up your database configuration, you should test it to ensure everything is working properly:

```bash
python manage.py check
```

If the configuration is correct, you can then create the database schema:

```bash
python manage.py migrate
```

To verify the connection, try creating a superuser:

```bash
python manage.py createsuperuser
```

## Summary

In this tutorial, we've covered:

1. Basic database configuration in Django's `settings.py`
2. How to set up different database backends (PostgreSQL, MySQL, SQLite)
3. Advanced configuration options like connection pooling and multiple databases
4. Environment-specific database configurations
5. Best practices for database management in Django projects
6. A complete real-world example of database configuration

Proper database configuration is essential for the performance, security, and scalability of your Django application. By following the best practices and examples in this tutorial, you'll be able to set up a robust database infrastructure for your projects.

## Additional Resources

- [Django's official database documentation](https://docs.djangoproject.com/en/stable/ref/databases/)
- [PostgreSQL with Django](https://docs.djangoproject.com/en/stable/ref/databases/#postgresql-notes)
- [Database optimization techniques](https://docs.djangoproject.com/en/stable/topics/db/optimization/)
- [Multiple database configuration](https://docs.djangoproject.com/en/stable/topics/db/multi-db/)

## Practice Exercises

1. Configure a PostgreSQL database for your Django project.
2. Create a configuration that uses different databases for development and testing.
3. Implement database routing to use separate databases for user data and application data.
4. Set up a secure production database configuration using environment variables.
5. Create a Django command that tests and validates your database connection.