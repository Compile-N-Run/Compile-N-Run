---
title: Django Model Methods
description: Learn how to add custom functionality to your Django models using model methods, including common built-in methods and how to create your own custom methods.

---

# Django Model Methods

In Django applications, models represent your database tables. But models are more than just database definitions - they're full-featured Python classes. This means you can add custom methods to your models to encapsulate business logic and complex operations related to your data.

## Introduction to Model Methods

Django model methods allow you to add custom functionality directly to your model classes. This keeps related code together and follows the principle of encapsulation from object-oriented programming. Instead of writing separate functions to handle data manipulation, you can define these behaviors directly on the model itself.

## Types of Model Methods

Django models support several types of methods:

1. **Built-in methods** - Methods Django provides that you can override
2. **Custom instance methods** - Methods you define that operate on a single instance
3. **Custom class methods** - Methods that operate on the model class rather than instances
4. **Property methods** - Methods that act like attributes using the `@property` decorator

Let's explore each type with examples.

## Built-in Methods

Django models come with several built-in methods that you can override to customize behavior.

### `__str__()` Method

One of the most common methods to override is `__str__()`, which determines how the object is represented as a string.

```python
class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    
    def __str__(self):
        return f"{self.title} by {self.author}"
```

Without this method, the Django admin and shell would show objects as something like `<Book: Book object (1)>`. With our custom `__str__()`, we get a more readable `<Book: The Hobbit by J.R.R. Tolkien>`.

### `save()` Method

The `save()` method is called when you save an object. By overriding it, you can add custom behavior like validation or data preprocessing:

```python
class Article(models.Model):
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    
    def save(self, *args, **kwargs):
        # Generate slug from title if not provided
        if not self.slug:
            self.slug = slugify(self.title)
        
        # Call the parent class's save method
        super().save(*args, **kwargs)
```

Remember to always call `super().save(*args, **kwargs)` in your custom save method, or the object won't be saved to the database!

### `delete()` Method

Similarly, you can override the `delete()` method to add custom logic before deletion:

```python
class Document(models.Model):
    title = models.CharField(max_length=200)
    file = models.FileField(upload_to='documents/')
    
    def delete(self, *args, **kwargs):
        # Delete the associated file from storage first
        if self.file:
            storage, path = self.file.storage, self.file.path
            storage.delete(path)
            
        # Call the parent class's delete method
        super().delete(*args, **kwargs)
```

## Custom Instance Methods

Custom instance methods operate on a specific instance of a model and can encapsulate business logic related to that instance.

```python
from django.utils import timezone
from datetime import timedelta

class Subscription(models.Model):
    user = models.ForeignKey('auth.User', on_delete=models.CASCADE)
    plan = models.CharField(max_length=20, choices=[
        ('FREE', 'Free'),
        ('PRO', 'Professional'),
        ('ENT', 'Enterprise'),
    ])
    start_date = models.DateTimeField(auto_now_add=True)
    end_date = models.DateTimeField()
    
    def is_active(self):
        """Check if subscription is currently active"""
        now = timezone.now()
        return self.start_date <= now <= self.end_date
    
    def days_remaining(self):
        """Calculate days remaining in subscription"""
        if not self.is_active():
            return 0
        
        remaining = self.end_date - timezone.now()
        return max(0, remaining.days)
    
    def extend_by_days(self, days):
        """Extend subscription by specified number of days"""
        self.end_date = self.end_date + timedelta(days=days)
        self.save()
```

Using these methods makes your code more intuitive:

```python
# Get a subscription object
sub = Subscription.objects.get(user=request.user)

# Check if it's active
if sub.is_active():
    print(f"Your subscription is active with {sub.days_remaining()} days remaining")
    
    # Extend subscription as a reward
    sub.extend_by_days(7)
    print("We've added 7 days to your subscription!")
```

## Class Methods

While instance methods work on a specific model instance, class methods operate on the model class as a whole. In Django, there are two types:

### Regular Class Methods

Use the `@classmethod` decorator to define class methods:

```python
class Product(models.Model):
    name = models.CharField(max_length=200)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    in_stock = models.BooleanField(default=True)
    
    @classmethod
    def get_available_products(cls):
        """Get all available products"""
        return cls.objects.filter(in_stock=True)
    
    @classmethod
    def get_price_range(cls):
        """Get min and max product prices"""
        from django.db.models import Min, Max
        result = cls.objects.aggregate(min_price=Min('price'), max_price=Max('price'))
        return result
```

Usage example:

```python
# Get all available products
available = Product.get_available_products()

# Get price range information
price_range = Product.get_price_range()
print(f"Products range from ${price_range['min_price']} to ${price_range['max_price']}")
```

### Manager Methods

A more Django-specific approach is to add methods to the model's `Manager` using `objects`:

```python
class StudentManager(models.Manager):
    def active(self):
        return self.filter(is_active=True)
        
    def honor_roll(self):
        return self.filter(gpa__gte=3.5)

class Student(models.Model):
    name = models.CharField(max_length=100)
    gpa = models.FloatField()
    is_active = models.BooleanField(default=True)
    
    # Use custom manager
    objects = StudentManager()
```

This lets you chain queries in a more natural way:

```python
# Get active students on honor roll
top_students = Student.objects.active().honor_roll()
```

## Property Methods

Using the `@property` decorator, you can create methods that behave like attributes:

```python
from django.utils import timezone

class Order(models.Model):
    PENDING = 'P'
    SHIPPED = 'S'
    DELIVERED = 'D'
    STATUS_CHOICES = [
        (PENDING, 'Pending'),
        (SHIPPED, 'Shipped'),
        (DELIVERED, 'Delivered'),
    ]
    
    customer = models.ForeignKey('Customer', on_delete=models.CASCADE)
    items = models.ManyToManyField('Product', through='OrderItem')
    ordered_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=1, choices=STATUS_CHOICES, default=PENDING)
    
    @property
    def total_price(self):
        """Calculate the total price of the order"""
        from django.db.models import Sum, F
        result = self.orderitem_set.aggregate(
            total=Sum(F('quantity') * F('product__price'))
        )
        return result['total'] or 0
    
    @property
    def is_new(self):
        """Check if order is less than 24 hours old"""
        return (timezone.now() - self.ordered_at).days < 1
    
    @property
    def status_display(self):
        """Get user-friendly status"""
        return dict(self.STATUS_CHOICES)[self.status]
```

Then you can use these methods as if they were attributes:

```python
order = Order.objects.get(id=123)

print(f"Order #{order.id}")
print(f"Status: {order.status_display}")
print(f"Total: ${order.total_price}")

if order.is_new:
    print("This is a recent order!")
```

## Real-World Example: Blog Post Model

Let's see a complete example of a blog post model with various types of methods:

```python
from django.db import models
from django.utils.text import slugify
from django.utils import timezone
from django.urls import reverse
from django.contrib.auth.models import User

class PostManager(models.Manager):
    def published(self):
        """Get only published posts"""
        return self.filter(status=Post.PUBLISHED)
    
    def get_popular(self):
        """Get popular posts by view count"""
        return self.published().order_by('-views')[:5]

class Post(models.Model):
    DRAFT = 'D'
    PUBLISHED = 'P'
    ARCHIVED = 'A'
    STATUS_CHOICES = [
        (DRAFT, 'Draft'),
        (PUBLISHED, 'Published'),
        (ARCHIVED, 'Archived'),
    ]
    
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    status = models.CharField(max_length=1, choices=STATUS_CHOICES, default=DRAFT)
    views = models.PositiveIntegerField(default=0)
    
    # Custom manager
    objects = PostManager()
    
    def __str__(self):
        return self.title
    
    def save(self, *args, **kwargs):
        # Generate slug from title if not provided
        if not self.slug:
            self.slug = slugify(self.title)
            
        # Ensure slugs are unique
        base_slug = self.slug
        counter = 1
        while Post.objects.filter(slug=self.slug).exclude(id=self.id).exists():
            self.slug = f"{base_slug}-{counter}"
            counter += 1
            
        super().save(*args, **kwargs)
    
    def get_absolute_url(self):
        """Get the URL of the post detail page"""
        return reverse('post_detail', kwargs={'slug': self.slug})
    
    def publish(self):
        """Publish the post"""
        self.status = self.PUBLISHED
        self.save()
    
    def increment_views(self):
        """Increment the view count"""
        self.views += 1
        self.save(update_fields=['views'])
    
    @property
    def is_published(self):
        """Check if post is published"""
        return self.status == self.PUBLISHED
    
    @property
    def is_recent(self):
        """Check if post was published within the last week"""
        if not self.is_published:
            return False
        return (timezone.now() - self.updated).days < 7
    
    @classmethod
    def get_monthly_statistics(cls):
        """Get count of posts by month"""
        from django.db.models import Count
        return cls.objects.annotate(
            month=models.functions.TruncMonth('created')
        ).values('month').annotate(count=Count('id')).order_by('month')
```

Using this model in a view:

```python
def post_detail(request, slug):
    post = get_object_or_404(Post, slug=slug)
    
    # Increment view count
    post.increment_views()
    
    # Check if we should display a "New!" badge
    show_new_badge = post.is_recent
    
    # Get related posts by same author
    related_posts = Post.objects.published().filter(author=post.author).exclude(id=post.id)[:3]
    
    return render(request, 'blog/post_detail.html', {
        'post': post,
        'show_new_badge': show_new_badge,
        'related_posts': related_posts,
    })

def dashboard(request):
    # Get monthly statistics
    stats = Post.get_monthly_statistics()
    # Get popular posts
    popular_posts = Post.objects.get_popular()
    
    return render(request, 'blog/dashboard.html', {
        'stats': stats,
        'popular_posts': popular_posts,
    })
```

## Best Practices for Model Methods

1. **Keep methods focused** - Each method should do one thing well
2. **Use descriptive names** - Method names should clearly indicate what they do
3. **Add docstrings** - Document your methods, especially for complex logic
4. **Consider performance** - Be careful with methods that might trigger additional database queries
5. **Don't duplicate code** - If multiple models need the same functionality, consider using mixins or abstract base classes
6. **Follow Django conventions** - Methods like `get_absolute_url()` are recognized by Django's framework

## Summary

Django model methods are powerful tools that help you maintain clean, readable, and maintainable code. By adding behavior directly to your models, you can encapsulate business logic and make your codebase more intuitive. The different types of methods (built-in methods, custom instance methods, class methods, and property methods) give you flexibility to handle various use cases.

Remember that models should be more than just data containers - they're the perfect place for behavior that's closely related to your data. By using model methods effectively, you'll build more robust Django applications with clearer separation of concerns.

## Exercises

1. Create a `Profile` model with a method that calculates the user's age based on their birth date.

2. Add a custom manager to a `Product` model that provides methods for finding on-sale items.

3. Implement a `send_reminder_email()` method on an `Event` model that sends an email to all registered participants.

4. Create a `BankAccount` model with methods for `deposit()`, `withdraw()`, and a property that determines if the account is `overdrawn`.

5. Implement a logging system by overriding the `save()` and `delete()` methods on a model.

## Additional Resources

- [Django Documentation on Model Methods](https://docs.djangoproject.com/en/stable/topics/db/models/#model-methods)
- [Django Models: Beyond the Basics](https://djangostars.com/blog/django-models-beyond-the-basics/)
- [Django Design Patterns and Best Practices](https://www.packtpub.com/product/django-design-patterns-and-best-practices/9781788831345)