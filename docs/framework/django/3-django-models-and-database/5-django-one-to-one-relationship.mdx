---
title: Django One-to-One Relationship
description: Learn how to create and use one-to-one relationships in Django models for your database design. Perfect for beginners learning Django ORM.

---

# Django One-to-One Relationship

In database design, relationships between data are critical for creating well-structured applications. Django, as a powerful web framework, provides excellent tools for managing these relationships. In this tutorial, we'll focus on the **one-to-one relationship**, one of the fundamental relationship types in Django models.

## What is a One-to-One Relationship?

A one-to-one relationship is exactly what it sounds like: a relationship where one record in a table is related to exactly one record in another table, and vice versa. Think of it as a special case of a one-to-many relationship where the "many" side is constrained to have only one item.

Common examples include:
- A user having exactly one detailed profile
- A product having exactly one technical specification sheet
- A person having exactly one government ID

## Creating a One-to-One Relationship in Django

Django makes it easy to define one-to-one relationships using the `OneToOneField`. Let's see how to implement this with a practical example.

### Basic Syntax

```python
from django.db import models
from django.contrib.auth.models import User

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    bio = models.TextField(blank=True)
    birth_date = models.DateField(null=True, blank=True)
    profile_picture = models.ImageField(upload_to='profile_pics/', null=True, blank=True)
```

In this example, we're extending Django's built-in `User` model with a `UserProfile` model. The `OneToOneField` creates a relationship where each user can have exactly one profile, and each profile belongs to exactly one user.

### Key Parameters

The `OneToOneField` has several important parameters:

- **to**: The model to relate to (in our example, `User`)
- **on_delete**: What happens when the referenced object is deleted
  - `CASCADE`: Delete the related object too
  - `PROTECT`: Prevent deletion of the referenced object
  - `SET_NULL`: Set the reference to NULL (requires `null=True`)
  - `SET_DEFAULT`: Set the reference to its default value
  - `DO_NOTHING`: Take no action

## Creating and Accessing Related Objects

Let's see how to work with one-to-one relationships in practice.

### Creating Related Objects

```python
# Creating a user and profile
from django.contrib.auth.models import User
from myapp.models import UserProfile

# Create a new user
user = User.objects.create_user('johndoe', 'john@example.com', 'password123')

# Create a profile for the user
profile = UserProfile.objects.create(
    user=user,
    bio="I'm a Django developer",
    birth_date="1990-01-01"
)

# Alternative approach: create user first, then profile
new_user = User.objects.create_user('janedoe', 'jane@example.com', 'password456')
new_profile = UserProfile(user=new_user, bio="Python enthusiast")
new_profile.save()
```

### Accessing Related Objects

Once you've set up a one-to-one relationship, Django makes it easy to access the related object in either direction:

```python
# From user to profile
user = User.objects.get(username='johndoe')
bio = user.userprofile.bio  # Access the profile's bio field

# From profile to user
profile = UserProfile.objects.get(bio__contains="Django developer")
email = profile.user.email  # Access the user's email field
```

### Handling Missing Related Objects

One challenge with one-to-one relationships is that the related object might not exist. For example, a user might not have created a profile yet.

```python
user = User.objects.get(username='newuser')

# This might raise a DoesNotExist exception if no profile exists
try:
    bio = user.userprofile.bio
except UserProfile.DoesNotExist:
    bio = "No profile available"

# Alternative approach: using hasattr
if hasattr(user, 'userprofile'):
    bio = user.userprofile.bio
else:
    bio = "No profile available"
```

## Real-World Example: E-commerce Customer Extension

Let's look at a real-world example for an e-commerce site where we want to extend customer information:

```python
from django.db import models
from django.contrib.auth.models import User

class Customer(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    phone_number = models.CharField(max_length=15, blank=True)
    shipping_address = models.TextField()
    loyalty_points = models.IntegerField(default=0)
    
    def __str__(self):
        return f"{self.user.username}'s customer profile"
    
class Order(models.Model):
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    order_date = models.DateTimeField(auto_now_add=True)
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    
    def __str__(self):
        return f"Order {self.id} by {self.customer.user.username}"
```

In this example, we have:
1. A `Customer` model with a one-to-one relationship to `User`
2. An `Order` model with a many-to-one relationship to `Customer`

### Using the Model

```python
# Creating a new customer for an existing user
existing_user = User.objects.get(username='johndoe')
customer = Customer.objects.create(
    user=existing_user,
    phone_number="555-123-4567",
    shipping_address="123 Django St, Python City, 12345",
)

# Creating a new order
new_order = Order.objects.create(
    customer=customer,
    total_amount=99.99
)

# Accessing user information from an order
order = Order.objects.get(id=1)
username = order.customer.user.username
email = order.customer.user.email
```

## Signals for Automatic Profile Creation

A common pattern is to automatically create a profile when a user is created. Django's signals make this easy:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from myapp.models import UserProfile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    if hasattr(instance, 'userprofile'):
        instance.userprofile.save()
```

Place this code in your app's `signals.py` and import it in your app's `__init__.py` or `apps.py` to ensure it's loaded when your app starts.

## When to Use a One-to-One Relationship

One-to-one relationships are particularly useful for:

1. **Model extension**: When you want to extend an existing model (like User) without modifying its code
2. **Data segregation**: Separating rarely accessed data into different tables to improve performance
3. **Optional components**: When related data is optional and might not exist for all instances
4. **Reducing model complexity**: Breaking a large model into logical components

## Common Pitfalls and Best Practices

### Pitfalls to Avoid

1. **Overuse**: Not every related model needs a one-to-one relationship; sometimes fields can just be added to the main model
2. **Missing relationships**: Always handle the possibility that the related object might not exist
3. **Circular dependencies**: Be careful when creating two models that have one-to-one relationships with each other

### Best Practices

1. **Use cascade deletion** when appropriate (usually for profile-type extensions)
2. **Consider using signals** to automatically create related objects
3. **Add related_name** if you have multiple OneToOneFields to the same model
4. **Use select_related** in querysets to optimize database access when you know you'll need the related model

```python
# Optimized query using select_related
customers = Customer.objects.select_related('user').all()

# Now you can access customer.user without additional database queries
for customer in customers:
    print(f"{customer.user.username}: {customer.shipping_address}")
```

## Summary

One-to-one relationships in Django provide a powerful way to extend models and create clear, logical separations in your database schema. They're particularly useful for extending existing models like User, or for breaking complex models into more manageable components.

Key points to remember:

1. Use `OneToOneField` to define the relationship
2. Always specify an appropriate `on_delete` behavior
3. Handle the possibility of missing related objects
4. Consider using signals for automatic creation of related objects
5. Use `select_related` to optimize database queries

By properly implementing one-to-one relationships, you'll create more maintainable and efficient Django applications.

## Practice Exercises

1. Create a `StudentProfile` one-to-one extension for a `Student` model that includes fields for GPA, major, and graduation year.
2. Implement automatic profile creation using signals when a new `Student` is created.
3. Build a simple view that displays both `Student` and `StudentProfile` information on a single page.
4. Create a form that allows users to update both their `User` and `UserProfile` information simultaneously.

## Additional Resources

- [Django Documentation on One-to-One Relationships](https://docs.djangoproject.com/en/stable/topics/db/examples/one_to_one/)
- [Django Documentation on Signals](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Django ORM Optimization Techniques](https://docs.djangoproject.com/en/stable/topics/db/optimization/)

Happy coding with Django's one-to-one relationships!