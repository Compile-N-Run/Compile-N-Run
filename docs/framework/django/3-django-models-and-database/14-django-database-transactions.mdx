---
title: Django Database Transactions
description: Learn how to use database transactions in Django to ensure data integrity and handle complex database operations effectively.

---

# Django Database Transactions

When building web applications with Django, ensuring data consistency is crucial. Database transactions provide a way to group multiple database operations into a single atomic unit of work. This means either all operations succeed or none of them do, preventing partial updates that could leave your database in an inconsistent state.

In this tutorial, you'll learn how to use Django's transaction management system to maintain data integrity in your applications.

## What Are Database Transactions?

A database transaction is a sequence of database operations that are treated as a single logical unit of work. Transactions follow the ACID principles:

- **Atomicity**: All operations within a transaction are completed successfully, or none are applied.
- **Consistency**: A transaction brings the database from one valid state to another.
- **Isolation**: Transactions don't interfere with each other.
- **Durability**: Once a transaction is committed, its changes are permanent.

## Why Use Transactions in Django?

Consider this scenario: You're building a banking application where money is transferred from one account to another. This involves two operations:
1. Deduct money from account A
2. Add money to account B

If the system crashes after the first step but before the second, money would simply disappear! Transactions ensure that both operations either complete successfully or don't happen at all.

## Django's Transaction Management

Django provides several ways to manage database transactions:

### 1. Auto-commit Mode (Default)

By default, Django runs in auto-commit mode, where each SQL query is immediately committed to the database. This is the simplest mode but offers the least control.

### 2. Atomic Transactions

Django's `atomic` decorator/context manager is the recommended way to handle transactions. Let's see how it works.

## Using the `atomic` Context Manager

The `atomic` context manager ensures that a block of code executes within a transaction:

```python
from django.db import transaction

def transfer_funds(from_account, to_account, amount):
    with transaction.atomic():
        from_account.balance -= amount
        to_account.balance += amount
        from_account.save()
        to_account.save()
```

In this example, if any part of the code within the `atomic` block raises an exception, the entire transaction is rolled back, and no changes are made to the database.

## Using the `atomic` Decorator

You can also use `atomic` as a decorator:

```python
from django.db import transaction

@transaction.atomic
def create_user_profile(user_data, profile_data):
    user = User.objects.create_user(**user_data)
    profile = Profile.objects.create(user=user, **profile_data)
    return user, profile
```

## Handling Errors in Transactions

When an exception occurs within an `atomic` block, Django automatically rolls back the transaction. However, you can explicitly control this behavior:

```python
from django.db import transaction, IntegrityError

def create_order(items, customer):
    try:
        with transaction.atomic():
            order = Order.objects.create(customer=customer)
            
            for item in items:
                if not item.is_in_stock():
                    # This will cause the transaction to roll back
                    raise Exception("Item out of stock")
                
                OrderItem.objects.create(order=order, product=item)
                item.reduce_stock()
                item.save()
            
            return order
    except Exception as e:
        # Handle the exception (e.g., notify user)
        return None
```

## Savepoints: Transactions Within Transactions

Sometimes you may want to roll back only part of a transaction. Django allows you to create savepoints:

```python
from django.db import transaction

def complex_operation():
    with transaction.atomic():
        # Operation 1
        model1.field = 'value1'
        model1.save()
        
        # Create a savepoint
        sid = transaction.savepoint()
        try:
            # Operation 2 - might fail
            model2.field = 'value2'
            model2.save()
            risky_operation()
        except IntegrityError:
            # Roll back to savepoint if there's a problem
            transaction.savepoint_rollback(sid)
            # Continue with alternative approach
            alternative_operation()
        else:
            # Operation 2 succeeded, commit the savepoint
            transaction.savepoint_commit(sid)
        
        # Operation 3 - will execute regardless of whether Operation 2 succeeded
        model3.field = 'value3'
        model3.save()
```

## Transaction Management Strategies

### 1. Request-level Transactions

In some cases, you might want an entire HTTP request to be wrapped in a transaction. You can use Django middleware for this:

```python
# In your custom middleware.py file
from django.db import transaction

class TransactionMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        with transaction.atomic():
            response = self.get_response(request)
        return response

# Then add this to MIDDLEWARE in settings.py
# 'yourapp.middleware.TransactionMiddleware',
```

However, be careful with this approach as it can lead to long-running transactions, which might reduce database performance.

### 2. Function-based Transactions

The most common approach is to wrap specific functions or views with transactions:

```python
from django.db import transaction
from django.http import JsonResponse

@transaction.atomic
def create_order_view(request):
    if request.method == 'POST':
        # Extract data from request
        items = request.POST.getlist('items')
        customer_id = request.POST.get('customer_id')
        
        # Create order and items in a transaction
        order = Order.objects.create(customer_id=customer_id)
        for item_id in items:
            OrderItem.objects.create(order=order, item_id=item_id)
        
        return JsonResponse({'order_id': order.id})
```

## Transaction Isolation Levels

Django supports setting transaction isolation levels, which determine how changes made by one transaction are visible to other concurrent transactions:

```python
from django.db import transaction

# Using a specific isolation level
with transaction.atomic(isolation_level='READ COMMITTED'):
    # Your code here
```

Common isolation levels include:
- `READ UNCOMMITTED`: Lowest isolation, allows dirty reads
- `READ COMMITTED`: Prevents dirty reads
- `REPEATABLE READ`: Prevents non-repeatable reads
- `SERIALIZABLE`: Highest isolation, prevents phantom reads

Note that supported isolation levels depend on your database backend.

## Real-world Example: Online Shopping System

Let's look at a complete example of using transactions in an e-commerce system:

```python
from django.db import transaction
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from .models import Product, Order, OrderItem, PaymentTransaction

@require_POST
@transaction.atomic
def checkout(request):
    cart_items = request.session.get('cart', {})
    user = request.user
    
    if not cart_items:
        return JsonResponse({'error': 'Cart is empty'}, status=400)
    
    # Create order
    order = Order.objects.create(user=user, status='PENDING')
    
    total_amount = 0
    try:
        # Add items to order
        for product_id, quantity in cart_items.items():
            product = Product.objects.select_for_update().get(id=product_id)
            
            # Check if enough stock
            if product.stock < quantity:
                # This will cause the transaction to roll back
                raise ValueError(f"Not enough stock for {product.name}")
            
            # Reduce stock
            product.stock -= quantity
            product.save()
            
            # Create order item
            price = product.price
            OrderItem.objects.create(
                order=order,
                product=product,
                quantity=quantity,
                unit_price=price
            )
            
            total_amount += price * quantity
        
        # Process payment
        payment = PaymentTransaction.objects.create(
            order=order,
            amount=total_amount,
            status='COMPLETED'  # In a real app, you'd integrate with a payment provider
        )
        
        # Update order status
        order.status = 'PAID'
        order.save()
        
        # Clear cart
        request.session['cart'] = {}
        
        return JsonResponse({
            'success': True,
            'order_id': order.id,
            'total': total_amount
        })
        
    except ValueError as e:
        # The transaction will be rolled back automatically
        return JsonResponse({'error': str(e)}, status=400)
```

In this example:

1. We wrap the entire checkout process in a transaction using the `@transaction.atomic` decorator
2. We use `select_for_update()` to lock the products being purchased, preventing concurrent modifications
3. If any condition fails (like insufficient stock), the transaction rolls back, and no changes are made to the database
4. Only if all operations succeed will the customer's order be processed and stock levels updated

## Performance Considerations

While transactions ensure data integrity, they come with some performance overhead:

1. **Transaction length**: Keep transactions as short as possible to reduce lock contention
2. **Operation count**: Minimize the number of database operations within a transaction
3. **Lock scope**: Use `select_for_update()` only when necessary, as it can reduce concurrency

## Common Pitfalls

### 1. Nested Transactions

Django's `atomic` blocks can be nested. However, by default, only the outermost `atomic` block actually creates a database transaction:

```python
@transaction.atomic
def outer_function():
    # Start of transaction
    model1.save()
    
    inner_function()  # This runs in the same transaction
    
    # End of transaction

@transaction.atomic
def inner_function():
    # This doesn't start a new transaction, it runs in the outer one
    model2.save()
```

### 2. ORM Operations Outside the Transaction

Remember that a transaction only protects operations that happen within it. This won't work as expected:

```python
# Wrong approach
user = User.objects.create(username='tempuser')  # This is committed immediately

with transaction.atomic():
    profile = Profile.objects.create(user=user)  # If this fails, the user will still exist
```

Instead, ensure all related operations are within the transaction:

```python
# Correct approach
with transaction.atomic():
    user = User.objects.create(username='tempuser')
    profile = Profile.objects.create(user=user)
```

### 3. Non-Database Operations

Transactions only affect database operations. Other changes (like file operations or API calls) won't be rolled back:

```python
with transaction.atomic():
    user.save()
    with open('some_file.txt', 'w') as f:  # This won't be undone if the transaction fails
        f.write('data')
    third_party_api.send_email()  # This won't be undone either
```

## Summary

Database transactions are a powerful feature in Django that help maintain data integrity. By grouping related operations into atomic units, you ensure that your database remains in a consistent state, even when errors occur.

Key points to remember:
- Use `transaction.atomic()` as a context manager or decorator to define transaction boundaries
- All database operations within an atomic block either succeed together or fail together
- Use savepoints for more granular control over rollbacks
- Be mindful of transaction isolation levels and performance implications

By mastering Django's transaction management, you'll build more robust applications that handle complex database operations reliably.

## Exercises

1. Create a simple bank account transfer system with two models: `Account` and `Transaction`. Implement a function that transfers money between accounts using transactions.

2. Modify the checkout example to include inventory checks and implement a "reserve inventory" feature that temporarily holds items for 15 minutes.

3. Implement a function that imports data from a CSV file into multiple related models, using transactions to ensure that either all records are imported successfully or none are.

## Additional Resources

- [Django Documentation on Transactions](https://docs.djangoproject.com/en/stable/topics/db/transactions/)
- [PostgreSQL Transaction Documentation](https://www.postgresql.org/docs/current/tutorial-transactions.html)
- [MySQL Transaction Documentation](https://dev.mysql.com/doc/refman/8.0/en/commit.html)
- [Database ACID Properties Explained](https://vladmihalcea.com/a-beginners-guide-to-acid-and-database-transactions/)