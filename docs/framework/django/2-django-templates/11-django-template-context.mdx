---
title: Django Template Context
description: Learn how to pass data from your Django views to templates using context dictionaries, making your templates dynamic and data-driven.

---

# Django Template Context

When building web applications with Django, one of the most important concepts to understand is how data flows from your Python views to your HTML templates. This is where **template context** comes in — it's the bridge that connects your application's data to your presentation layer.

## What is a Template Context?

A template context is simply a dictionary (or dictionary-like object) that maps variable names to Python objects. When Django renders a template, it uses this context to replace variables in the template with their actual values.

Think of context as a messenger carrying data from your view function to your template, allowing your templates to display dynamic content rather than just static HTML.

## How Context Works in Django

Let's start with a simple example to illustrate how context works:

### Basic Context Example

**View function:**

```python
from django.shortcuts import render

def greeting_view(request):
    # Create a context dictionary with data to pass to the template
    context = {
        'name': 'Django Learner',
        'time_of_day': 'morning'
    }
    # Render the template with the context
    return render(request, 'greeting.html', context)
```

**Template (greeting.html):**

```html
<!DOCTYPE html>
<html>
<head>
    <title>Greeting</title>
</head>
<body>
    <h1>Hello, {{ name }}!</h1>
    <p>Good {{ time_of_day }}!</p>
</body>
</html>
```

**Output in browser:**
```
Hello, Django Learner!
Good morning!
```

In this example, the view function creates a context dictionary with two keys: `name` and `time_of_day`. When the template is rendered, Django replaces `{{ name }}` with "Django Learner" and `{{ time_of_day }}` with "morning".

## Creating and Using Context in Views

There are several ways to create and pass context to templates in Django:

### Method 1: Dictionary in Function-Based Views

This is the most straightforward approach:

```python
from django.shortcuts import render

def book_list(request):
    books = [
        {'title': 'Django for Beginners', 'author': 'William S. Vincent', 'year': 2020},
        {'title': 'Two Scoops of Django', 'author': 'Daniel & Audrey Feldroy', 'year': 2019},
        {'title': 'Django Unleashed', 'author': 'Andrew Pinkham', 'year': 2015}
    ]
    
    context = {
        'books': books,
        'page_title': 'My Django Book Collection',
        'total_books': len(books)
    }
    
    return render(request, 'books/book_list.html', context)
```

### Method 2: Class-Based Views with get_context_data

Django's class-based views provide a structured way to handle context:

```python
from django.views.generic import TemplateView

class BookListView(TemplateView):
    template_name = 'books/book_list.html'
    
    def get_context_data(self, **kwargs):
        # First, get the existing context from the parent class
        context = super().get_context_data(**kwargs)
        
        # Add our custom context data
        context['books'] = [
            {'title': 'Django for Beginners', 'author': 'William S. Vincent', 'year': 2020},
            {'title': 'Two Scoops of Django', 'author': 'Daniel & Audrey Feldroy', 'year': 2019},
            {'title': 'Django Unleashed', 'author': 'Andrew Pinkham', 'year': 2015}
        ]
        context['page_title'] = 'My Django Book Collection'
        context['total_books'] = len(context['books'])
        
        return context
```

## Accessing Context Data in Templates

Once you've passed a context to a template, you can access its data using the template variable syntax: `{{ variable_name }}`.

### Simple Variable Access

```html
<h1>{{ page_title }}</h1>
<p>Total books: {{ total_books }}</p>
```

### Looping Through Lists

```html
<ul>
{% for book in books %}
    <li>
        <strong>{{ book.title }}</strong> by {{ book.author }} ({{ book.year }})
    </li>
{% endfor %}
</ul>
```

### Accessing Dictionary Values and Object Attributes

Django's template language uses dot notation for both dictionary access and attribute access:

```html
<!-- If user is a dictionary -->
{{ user.name }}  <!-- Accesses user['name'] -->

<!-- If user is an object -->
{{ user.name }}  <!-- Accesses user.name attribute -->
```

Django is smart enough to figure out whether to use dictionary lookup or attribute access.

## Context Processors: Adding Global Context

Sometimes you want certain variables available in all templates across your project. Django provides context processors for this purpose.

Context processors are Python functions that take a request object as their argument and return a dictionary that gets added to the template context.

### Built-in Context Processors

Django includes several useful built-in context processors:

- `django.template.context_processors.debug`
- `django.template.context_processors.request`
- `django.template.context_processors.auth`
- `django.template.context_processors.media`
- `django.template.context_processors.static`
- `django.template.context_processors.csrf`

These are typically enabled in your `settings.py` file:

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

### Creating Custom Context Processors

You can create your own context processors to make information available to all templates:

1. Create a file, e.g., `context_processors.py` in one of your Django apps

```python
# myapp/context_processors.py

def website_info(request):
    return {
        'site_name': 'Django Explorer',
        'site_version': '1.0.0',
        'current_year': 2023
    }
```

2. Add it to your `settings.py` file:

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                # ... other context processors
                'myapp.context_processors.website_info',
            ],
        },
    },
]
```

3. Now `site_name`, `site_version`, and `current_year` will be available in all your templates:

```html
<footer>
    © {{ current_year }} {{ site_name }} v{{ site_version }}
</footer>
```

## Real-World Example: Blog Post Application

Let's see a more complete example with a blog post application:

### View Function

```python
from django.shortcuts import render, get_object_or_404
from .models import Post, Category

def post_detail(request, post_id):
    # Get the requested post or return a 404 error
    post = get_object_or_404(Post, id=post_id)
    
    # Get related posts (same category)
    related_posts = Post.objects.filter(
        category=post.category
    ).exclude(id=post.id)[:3]
    
    # Check if the user is the author of the post
    is_author = post.author == request.user if request.user.is_authenticated else False
    
    # Build the context dictionary
    context = {
        'post': post,
        'related_posts': related_posts,
        'is_author': is_author,
        'categories': Category.objects.all(),
        'meta': {
            'title': post.title,
            'description': post.excerpt[:150]
        }
    }
    
    return render(request, 'blog/post_detail.html', context)
```

### Template (post_detail.html)

```html
{% extends "base.html" %}

{% block title %}{{ meta.title }}{% endblock %}

{% block meta %}
<meta name="description" content="{{ meta.description }}">
{% endblock %}

{% block content %}
<article class="post">
    <header>
        <h1>{{ post.title }}</h1>
        <div class="meta">
            <span class="date">{{ post.published_date|date:"F j, Y" }}</span>
            <span class="author">by {{ post.author.get_full_name }}</span>
            <span class="category">in {{ post.category.name }}</span>
        </div>
    </header>
    
    <div class="content">
        {{ post.content|safe }}
    </div>
    
    {% if is_author %}
    <div class="admin-actions">
        <a href="{% url 'edit_post' post.id %}" class="btn">Edit Post</a>
        <a href="{% url 'delete_post' post.id %}" class="btn btn-danger">Delete</a>
    </div>
    {% endif %}
</article>

{% if related_posts %}
<section class="related-posts">
    <h2>Related Posts</h2>
    <div class="post-grid">
        {% for related in related_posts %}
        <div class="post-card">
            <h3><a href="{% url 'post_detail' related.id %}">{{ related.title }}</a></h3>
            <p>{{ related.excerpt }}</p>
        </div>
        {% endfor %}
    </div>
</section>
{% endif %}

<aside class="sidebar">
    <h3>Categories</h3>
    <ul>
        {% for category in categories %}
        <li><a href="{% url 'category_detail' category.slug %}">
            {{ category.name }} ({{ category.post_set.count }})
        </a></li>
        {% endfor %}
    </ul>
</aside>
{% endblock %}
```

This example shows how to:
- Pass a complex context with nested data
- Use conditionals based on context values (`is_author`)
- Display related data dynamically
- Format dates with template filters
- Use the context in different template blocks

## Common Patterns and Best Practices

### 1. Keep Context Organization Clear

For complex views with a lot of context data, consider organizing your context keys logically:

```python
context = {
    # Page metadata
    'meta': {
        'title': 'Dashboard',
        'description': 'User dashboard overview'
    },
    
    # User-related data
    'user_data': {
        'recent_activities': recent_activities,
        'preferences': user_preferences
    },
    
    # Statistics and metrics
    'metrics': {
        'daily_visits': daily_visits,
        'monthly_growth': monthly_growth
    }
}
```

### 2. Don't Put Too Much Logic in Templates

Avoid putting complex logic in templates. Process and prepare your data in views before passing it to the template:

```python
# Better - process in view
def product_list(request):
    products = Product.objects.all()
    featured_products = [p for p in products if p.is_featured]
    
    context = {
        'products': products,
        'featured_products': featured_products
    }
    return render(request, 'products/list.html', context)

# Instead of doing complex filtering in the template
```

### 3. Use Defaults for Optional Context

For variables that might not always be present, use Django's template default filter:

```html
<h1>Welcome{{ name|default:", Guest" }}!</h1>
```

## Summary

The template context is a critical part of Django's MVT (Model-View-Template) architecture that allows you to pass data from your views to your templates. Here's what we've covered:

- Template context is a dictionary that maps variable names to Python objects
- There are multiple ways to create contexts in function-based and class-based views
- Context processors provide a way to add global variables to all templates
- Complex context structures can help organize your template data
- Following best practices can keep your code clean and maintainable

With a good understanding of template context, you can create dynamic, data-driven Django templates that effectively display your application's data.

## Additional Resources and Exercises

### Resources
- [Django Documentation on Templates](https://docs.djangoproject.com/en/stable/topics/templates/)
- [Django Template Language Reference](https://docs.djangoproject.com/en/stable/ref/templates/language/)
- [Class-based Views and Context](https://docs.djangoproject.com/en/stable/topics/class-based-views/)

### Exercises

1. **Basic Context Practice**:  
   Create a view that displays different greeting messages based on the time of day (morning, afternoon, evening).

2. **Context Processors**:  
   Create a custom context processor that adds the current date and time to all templates.

3. **Advanced Context Usage**:  
   Build a "product catalog" view that organizes products by category and displays different information based on user permissions.

4. **Debug Context**:  
   Create a template tag that displays all available context variables (useful for debugging). Remember to disable this in production!

5. **Context with Forms**:  
   Create a view that handles a form submission and displays different context data on success vs. failure.

By practicing these exercises, you'll gain practical experience with Django template contexts and enhance your web development skills.