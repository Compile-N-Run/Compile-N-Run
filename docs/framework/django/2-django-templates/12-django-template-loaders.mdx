---
title: Django Template Loaders
description: Learn how Django's template loading system works, explore different template loaders, and understand how to customize template loading in your Django applications.

---

# Django Template Loaders

## Introduction

In Django's template system, template loaders are components responsible for finding and loading template files. They are a crucial part of Django's rendering pipeline that transforms template files into rendered HTML pages. Template loaders determine where Django looks for templates, how it accesses them, and how they are processed before rendering.

Understanding template loaders helps you:
- Organize your templates efficiently
- Customize where Django looks for templates
- Optimize template loading for performance
- Create advanced template hierarchies

Let's dive into how Django's template loading system works and how you can leverage it in your projects!

## How Template Loading Works in Django

When you render a template in Django using a function like `render()`, Django needs to locate the template file first. The template loading process follows these steps:

1. Django checks each template loader defined in your settings
2. Each loader searches for the template in its designated location
3. The first loader to find the template returns it
4. If no loader finds the template, a `TemplateDoesNotExist` exception is raised

Here's a typical code example showing how templates are rendered:

```python
from django.shortcuts import render

def my_view(request):
    # Django will search for this template using configured loaders
    return render(request, 'my_app/template.html', {'context': 'data'})
```

## Default Template Loaders in Django

Django comes with several built-in template loaders, each designed for different use cases. These loaders are defined in the `TEMPLATES` setting in your `settings.py` file:

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

In this default configuration, Django uses two template loaders:

1. **FileSystemLoader** - Loads templates from directories specified in `DIRS`
2. **AppDirectoriesLoader** - Loads templates from the `templates` directory in each installed app (when `APP_DIRS` is `True`)

### FileSystemLoader

The `FileSystemLoader` looks for templates in the directories specified in the `DIRS` list in your template settings. This is useful for project-wide templates that aren't tied to a specific app.

Example directory structure:
```
myproject/
├── myproject/
│   ├── settings.py
│   ├── urls.py
│   └── ...
├── templates/  <- FileSystemLoader looks here when DIRS includes this path
│   ├── base.html
│   └── home.html
└── ...
```

To use this loader, ensure your `DIRS` includes the path:

```python
'DIRS': [os.path.join(BASE_DIR, 'templates')],
```

### AppDirectoriesLoader

The `AppDirectoriesLoader` looks for templates in a `templates` directory inside each installed app. This is enabled when `APP_DIRS` is set to `True` and encourages app-specific templates.

Example directory structure:
```
myproject/
├── myapp/
│   ├── templates/  <- AppDirectoriesLoader looks here
│   │   └── myapp/  <- Namespace to avoid template name collisions
│   │       ├── index.html
│   │       └── detail.html
│   ├── views.py
│   └── ...
└── ...
```

To use a template from this app in your view:

```python
def my_view(request):
    # This will look for myapp/templates/myapp/index.html
    return render(request, 'myapp/index.html', {})
```

## Other Built-in Template Loaders

Django provides additional template loaders for specific use cases:

### PackageDirectoriesLoader

This loader finds templates in Django packages installed via pip. Similar to `AppDirectoriesLoader`, but for reusable packages.

### CachedLoader

The `CachedLoader` wraps other loaders to improve performance by caching templates in memory. This is especially useful in production environments.

To configure a cached loader:

```python
TEMPLATES = [{
    # ...
    'OPTIONS': {
        'loaders': [
            ('django.template.loaders.cached.Loader', [
                'django.template.loaders.filesystem.Loader',
                'django.template.loaders.app_directories.Loader',
            ]),
        ],
    },
}]
```

### LocMemLoader

This loader isn't normally used in applications but is useful in tests. It loads templates from a dictionary in memory.

## Customizing Template Loading

You can control template loading by modifying the `TEMPLATES` setting. Here are some common customizations:

### Specifying Custom Template Directories

To add additional template directories:

```python
TEMPLATES = [{
    # ...
    'DIRS': [
        os.path.join(BASE_DIR, 'templates'),
        os.path.join(BASE_DIR, 'custom_templates'),
        '/absolute/path/to/templates',
    ],
}]
```

### Custom Template Loader Order

You can explicitly define which loaders to use and in what order:

```python
TEMPLATES = [{
    # ...
    'APP_DIRS': False,  # Disable default app directories loader
    'OPTIONS': {
        'loaders': [
            'django.template.loaders.filesystem.Loader',
            'django.template.loaders.app_directories.Loader',
            'path.to.my.custom.Loader',
        ],
    },
}]
```

### Writing a Custom Template Loader

For advanced use cases, you can create your own template loader by subclassing `django.template.loaders.base.Loader`:

```python
from django.template.loaders.base import Loader
from django.template.exceptions import TemplateDoesNotExist

class CustomLoader(Loader):
    def get_template_sources(self, template_name):
        # Return paths or sources where templates might be found
        yield f"/custom/location/{template_name}"
    
    def get_contents(self, origin):
        # Load the template from the source and return the content
        try:
            with open(origin.name, encoding=self.engine.file_charset) as fp:
                return fp.read()
        except (FileNotFoundError, IsADirectoryError):
            raise TemplateDoesNotExist(origin)
```

## Practical Example: Template Inheritance with Multiple Loaders

One powerful pattern in Django is template inheritance across apps. Let's see how multiple loaders work together:

1. Create a base template in the project-wide templates directory:

```html
<!-- templates/base.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}Default Title{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/main.css">
</head>
<body>
    <header>{% block header %}Site Header{% endblock %}</header>
    <main>
        {% block content %}
        {% endblock %}
    </main>
    <footer>{% block footer %}Site Footer{% endblock %}</footer>
</body>
</html>
```

2. Create an app-specific template that extends the base:

```html
<!-- myapp/templates/myapp/page.html -->
{% extends 'base.html' %}

{% block title %}My App Page{% endblock %}

{% block content %}
    <h1>Welcome to My App</h1>
    <p>This is content specific to this app page.</p>
{% endblock %}
```

3. Render the template in a view:

```python
# myapp/views.py
from django.shortcuts import render

def page_view(request):
    return render(request, 'myapp/page.html', {'user': request.user})
```

In this example:
1. `AppDirectoriesLoader` finds `myapp/page.html` in the app's templates folder
2. The template extends `base.html`
3. `FileSystemLoader` finds `base.html` in the project-wide templates directory
4. Django combines both templates to create the final HTML

## Performance Considerations

Template loading can affect performance, especially in production. Here are some tips:

1. **Use the CachedLoader in production** - This avoids file system operations by caching templates in memory:

```python
if not DEBUG:
    TEMPLATES[0]['OPTIONS']['loaders'] = [
        ('django.template.loaders.cached.Loader', [
            'django.template.loaders.filesystem.Loader',
            'django.template.loaders.app_directories.Loader',
        ]),
    ]
```

2. **Minimize the number of DIRS** - More directories mean more places to search

3. **Keep APP_DIRS=True only if needed** - If you don't use app-specific templates, disable this feature

4. **Use template inheritance wisely** - Excessive inheritance adds overhead

## Summary

Django's template loaders provide a flexible system for finding and loading templates from various sources. Understanding how they work helps you organize your template files effectively and optimize performance.

Key takeaways:
- FileSystemLoader looks for templates in directories you specify in DIRS
- AppDirectoriesLoader looks in each app's templates directory
- CachedLoader improves performance by storing templates in memory
- You can customize the loading system to meet your specific needs
- Template loading impacts performance, so configure it appropriately for production

## Additional Resources

- [Django Documentation on Template Loaders](https://docs.djangoproject.com/en/stable/ref/templates/api/#loader-types)
- [Django Source Code for Template Loaders](https://github.com/django/django/tree/main/django/template/loaders)

## Exercises

1. Set up a Django project with two apps and create templates in both the project-wide templates directory and each app's templates directory. Experiment with template inheritance across these locations.

2. Implement the CachedLoader in your development environment and measure the performance difference when rendering templates repeatedly.

3. Write a custom template loader that loads templates from a database table instead of the file system.

4. Create a template hierarchy with three levels of inheritance (base → section → page) and trace how Django resolves the template chain.