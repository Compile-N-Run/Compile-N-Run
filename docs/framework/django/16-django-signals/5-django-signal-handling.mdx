---
title: Django Signal Handling
description: Learn how to handle Django signals, connect signal handlers, and manage signal dispatching in your Django applications.

---

# Django Signal Handling

In this tutorial, we'll dive deep into how to handle signals in Django. By the end, you'll understand how to connect signal handlers, implement receivers, and leverage signal dispatching for creating more efficient, decoupled code.

## Introduction to Signal Handling

Django's signal framework allows certain senders to notify a set of receivers when actions occur. This works like an event-driven architecture where one component emits events that other components listen for. Signal handling is the process of connecting functions (receivers) to specific signals and configuring how they respond when those signals are dispatched.

Key benefits of proper signal handling include:

- **Decoupled code**: Components can communicate without direct dependencies
- **Centralized hooks**: React to system events from anywhere in your codebase
- **Clean architecture**: Separate business logic from event responses

## Understanding Signal Receivers

A signal receiver (or handler) is a function that gets executed when a signal is sent. Let's look at the basic structure:

```python
def my_signal_receiver(sender, **kwargs):
    # Process the signal
    print(f"Signal received from {sender}")
    
    # Access additional information
    instance = kwargs.get('instance')
    if instance:
        print(f"Instance: {instance}")
```

### Key Components of a Signal Handler:

1. **sender**: The model class that sent the signal
2. **kwargs**: Contains contextual information like:
   - `instance`: The actual model instance
   - `created`: Boolean flag for `post_save` signals
   - Other signal-specific parameters

## Connecting Signal Handlers

There are several ways to connect a handler to a signal.

### Method 1: Using the `@receiver` Decorator

The most elegant approach is using the `@receiver` decorator:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from myapp.models import Profile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)
        print(f"Profile created for user {instance.username}")
```

In this example:
- We listen for the `post_save` signal from the `User` model
- When a User is created, we automatically create a Profile for them
- The `created` parameter tells us if this is a new record

### Method 2: Using `connect()`

You can also manually connect signals using the `connect()` method:

```python
from django.db.models.signals import pre_delete
from django.contrib.auth.models import User

def archive_user_data(sender, instance, **kwargs):
    print(f"Archiving data for user {instance.username} before deletion")
    # Archive logic here
    
# Connect the handler
pre_delete.connect(archive_user_data, sender=User)
```

## Signal Dispatch Workflow

When a signal is dispatched, Django:

1. Identifies all receivers registered for that signal and sender
2. Executes each receiver with the appropriate arguments
3. Handles any exceptions raised by receivers (without affecting other receivers)

Here's a visualization of the process:

```
Model Action → Signal Dispatched → Django Signal Framework → All Connected Receivers Execute
```

## Using Signal Parameters Effectively

Different signals provide different parameters in the `kwargs` dictionary. Let's examine some common ones:

### For `post_save` Signals:

```python
@receiver(post_save, sender=Article)
def index_article(sender, instance, created, raw, using, update_fields, **kwargs):
    if created and not raw:
        print(f"Indexing new article: {instance.title}")
        # Code to index article in search engine
```

Parameters explained:
- `created`: Boolean indicating if this is a new record
- `raw`: Boolean indicating if the save was from loading fixtures
- `using`: Database alias being used
- `update_fields`: Set of fields being updated (if specified in save)

### For `pre_delete` Signals:

```python
@receiver(pre_delete, sender=Document)
def backup_document(sender, instance, using, **kwargs):
    print(f"Backing up document {instance.title} before deletion")
    # Backup logic here
```

## Practical Examples

Let's explore some real-world applications of signal handling in Django:

### Example 1: Automatically Setting Slugs

```python
from django.db.models.signals import pre_save
from django.dispatch import receiver
from django.utils.text import slugify
from myapp.models import BlogPost

@receiver(pre_save, sender=BlogPost)
def set_slug(sender, instance, **kwargs):
    if not instance.slug:
        instance.slug = slugify(instance.title)
        print(f"Slug automatically set to: {instance.slug}")
```

Output when saving a post with title "Hello World":
```
Slug automatically set to: hello-world
```

### Example 2: Activity Logging System

```python
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.contrib.auth.models import User
from myapp.models import Product, ActivityLog

@receiver([post_save, post_delete], sender=Product)
def log_product_activity(sender, instance, **kwargs):
    action = 'created' if kwargs.get('created', False) else 'deleted' if 'created' not in kwargs else 'updated'
    
    ActivityLog.objects.create(
        action=action,
        model_name='Product',
        object_id=instance.id,
        object_repr=str(instance),
        user=instance.last_modified_by if hasattr(instance, 'last_modified_by') else None
    )
    
    print(f"Activity logged: {action} {instance}")
```

This system logs all product changes across the application.

### Example 3: Cache Invalidation

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.core.cache import cache
from myapp.models import Category, Product

@receiver(post_save, sender=Product)
def invalidate_product_cache(sender, instance, **kwargs):
    # Clear specific product cache
    cache_key = f"product_{instance.id}"
    cache.delete(cache_key)
    
    # Clear category product listing caches
    cache_key = f"category_{instance.category.id}_products"
    cache.delete(cache_key)
    
    print(f"Cache invalidated for product {instance.name}")
```

## Best Practices for Signal Handling

1. **Consider Performance**: Signal handling adds overhead. For high-volume operations, consider alternatives.

2. **Avoid Circular Signals**: Be careful not to create signal loops where one signal triggers another that triggers the first.

```python
# Potential infinite loop!
@receiver(post_save, sender=User)
def update_user_info(sender, instance, **kwargs):
    if not kwargs.get('created'):
        # This will trigger another post_save
        instance.save()  # DON'T DO THIS!
```

3. **Handle Exceptions**: Signal handlers should gracefully handle exceptions to prevent disrupting the application flow:

```python
@receiver(post_save, sender=Product)
def notify_inventory_manager(sender, instance, **kwargs):
    try:
        if instance.stock_level < instance.reorder_threshold:
            # Send notification logic
            print(f"Low stock alert for {instance.name}")
    except Exception as e:
        print(f"Error in notify_inventory_manager: {e}")
        # Log the error but don't re-raise
```

4. **Organize Signal Handlers**: Keep signal handlers in a dedicated `signals.py` file within each app and import them in the app config:

```python
# myapp/signals.py
# All signal handlers here

# myapp/apps.py
from django.apps import AppConfig

class MyAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'
    
    def ready(self):
        import myapp.signals  # Import signals when app is ready
```

5. **Be Specific with Senders**: Always specify the sender when possible to avoid unnecessary signal processing.

## Signal Handling Patterns

### Pattern 1: Conditional Signal Registration

Register signals based on settings or environment:

```python
from django.conf import settings
from django.db.models.signals import post_save

def register_signals():
    if settings.ENABLE_AUDIT_LOGGING:
        from myapp.models import Product
        from myapp.signals import log_product_changes
        post_save.connect(log_product_changes, sender=Product)

# Call this in your AppConfig.ready() method
```

### Pattern 2: Signal Dispatch with Delay

For non-urgent signal processing, use a task queue:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from myapp.models import LargeDataModel
from django.core.cache import cache

@receiver(post_save, sender=LargeDataModel)
def process_large_data(sender, instance, **kwargs):
    # Instead of processing directly, queue a background task
    from myapp.tasks import process_data_task
    process_data_task.delay(instance.id)
    
    print(f"Data processing queued for {instance.id}")
```

## Summary

Signal handling in Django provides a powerful way to respond to events throughout your application. By connecting receivers to signals, you can build decoupled systems that react elegantly to changes without tightly coupling your components.

In this tutorial, we've covered:
- Basic signal handler structure and connection methods
- How signals are dispatched in Django
- Working with signal parameters
- Real-world examples and patterns
- Best practices for efficient signal handling

With these techniques, you can implement sophisticated event-driven architectures in your Django applications that are both maintainable and scalable.

## Additional Resources

- [Django Signals Documentation](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Django Signal Dispatcher API](https://docs.djangoproject.com/en/stable/ref/signals/)
- [Built-in Signal Reference](https://docs.djangoproject.com/en/stable/ref/signals/#module-django.db.models.signals)

## Exercises

1. Create a signal handler that sets a `last_modified` timestamp on a model whenever it's saved.
2. Implement a notification system using signals that alerts users when a comment is left on their content.
3. Build a caching system that automatically invalidates cache entries when their related models are updated.
4. Create a custom signal in your application and dispatch it when certain business logic conditions are met.