---
title: Django Signal Dispatch
description: Learn how Django's signal dispatch system works, how to connect receivers to signals, and how to create custom signals for your Django applications.

---

# Django Signal Dispatch

Django's signal dispatch system is a powerful feature that allows certain senders to notify a set of receivers when certain actions occur. It's a way to decouple components in your application and allow them to communicate with each other without being directly linked. In this tutorial, we'll explore how Django's signal dispatch system works and how you can leverage it in your projects.

## Introduction to Signal Dispatch

The signal dispatch system in Django follows the observer pattern, where "signals" are events that can be sent by "senders" and picked up by "receivers" (functions that listen for specific signals). This allows for loose coupling between components, making your code more maintainable and reusable.

Signal dispatching involves three main components:

1. **Signals**: Pre-defined or custom events that occur during Django's execution
2. **Senders**: The objects that send signals when certain events occur
3. **Receivers**: Functions or methods that "listen" for signals and perform actions when they are dispatched

## How Django Signal Dispatch Works

When an action occurs in Django that has a corresponding signal (like a model being saved or a request finishing), Django sends that signal. Any receivers that are connected to that signal will be called with information about the signal and its sender.

Here's a basic representation of the signal flow:

```
Event occurs → Signal is sent → Connected receivers are notified → Receivers execute code
```

## Connecting Receivers to Signals

There are two main ways to connect a receiver function to a signal:

### 1. Using the `@receiver` Decorator

The cleaner way to connect a signal to a receiver is using the `@receiver` decorator:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from profiles.models import UserProfile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
        print(f"Profile created for user: {instance.username}")
```

In this example, whenever a User object is saved and `created` is True (meaning it's a new user), a new UserProfile object will be created for that user.

### 2. Using the `connect()` Method

Alternatively, you can use the `connect()` method:

```python
from django.db.models.signals import post_save
from django.contrib.auth.models import User
from profiles.models import UserProfile

def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)
        print(f"Profile created for user: {instance.username}")

post_save.connect(create_user_profile, sender=User)
```

Both approaches achieve the same result, but the decorator approach is generally considered more readable and explicit.

## Signal Parameters

When a signal is sent, it can include various parameters that provide context about the event. All signals include:

1. `sender`: The model class or object that sent the signal
2. `**kwargs`: Additional keyword arguments that may vary by signal type

For example, the `post_save` signal includes these additional parameters:

- `instance`: The actual instance being saved
- `created`: Boolean indicating if this is a new instance
- `raw`: Boolean; True if the model is being loaded directly from a fixture
- `using`: The database alias being used
- `update_fields`: Set of fields to update as passed to Model.save()

## Where to Put Signal Code

It's important to ensure that your signal handling code is imported when Django starts. A common practice is to put signal handlers in a file called `signals.py` within your app, and then import that file in your app's `apps.py`:

```python
# myapp/signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile

@receiver(post_save, sender=User)
def create_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_profile(sender, instance, **kwargs):
    instance.profile.save()
```

Then, in your `apps.py`:

```python
# myapp/apps.py
from django.apps import AppConfig

class MyAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'
    
    def ready(self):
        import myapp.signals  # Import signals
```

Make sure your `__init__.py` file configures the default app config:

```python
# myapp/__init__.py
default_app_config = 'myapp.apps.MyAppConfig'
```

## Creating Custom Signals

While Django provides many built-in signals, you can also create your own custom signals for specific events in your application.

Here's how to define and use a custom signal:

1. Define your signal:

```python
# myapp/signals.py
from django.dispatch import Signal

# Define the signal
payment_completed = Signal()  # The providing_args argument is deprecated in recent versions
```

2. Send the signal when appropriate:

```python
# myapp/views.py
from .signals import payment_completed

def process_payment(request):
    # ... payment processing code ...
    
    if payment_successful:
        # Send our custom signal
        payment_completed.send(
            sender=request.user,
            amount=amount,
            payment_date=payment_date
        )
        
    # ... rest of the view ...
```

3. Connect a receiver to the custom signal:

```python
# myapp/signals.py
from django.dispatch import receiver
from .signals import payment_completed

@receiver(payment_completed)
def handle_payment_completed(sender, amount, payment_date, **kwargs):
    """
    Handle the payment_completed signal
    """
    # Send a confirmation email
    send_payment_confirmation_email(sender, amount, payment_date)
    
    # Update statistics
    update_payment_statistics(amount)
    
    # Log the payment
    log_payment(sender, amount, payment_date)
```

## Real-World Example: Activity Log System

Let's look at a practical example of how signals can be used to implement an activity logging system:

```python
# activitylog/models.py
from django.db import models
from django.contrib.auth.models import User

class ActivityLog(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    action = models.CharField(max_length=255)
    timestamp = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return f"{self.user.username} - {self.action} at {self.timestamp}"
```

```python
# activitylog/signals.py
from django.contrib.auth.signals import user_logged_in, user_logged_out, user_login_failed
from django.db.models.signals import post_save, post_delete
from django.contrib.auth.models import User
from django.dispatch import receiver
from .models import ActivityLog

@receiver(user_logged_in)
def user_logged_in_callback(sender, request, user, **kwargs):
    ActivityLog.objects.create(
        user=user,
        action='logged in'
    )

@receiver(user_logged_out)
def user_logged_out_callback(sender, request, user, **kwargs):
    ActivityLog.objects.create(
        user=user,
        action='logged out'
    )

@receiver(post_save, sender=User)
def user_created_callback(sender, instance, created, **kwargs):
    if created:
        ActivityLog.objects.create(
            user=instance,
            action='account created'
        )
    else:
        ActivityLog.objects.create(
            user=instance,
            action='profile updated'
        )

@receiver(post_delete, sender=User)
def user_deleted_callback(sender, instance, **kwargs):
    # Note: We can't associate this with the user that was deleted
    # since the user no longer exists, but we could log it with an admin user
    admin = User.objects.filter(is_superuser=True).first()
    if admin:
        ActivityLog.objects.create(
            user=admin,
            action=f'user {instance.username} was deleted'
        )
```

Then ensure these signals are loaded in `apps.py`:

```python
# activitylog/apps.py
from django.apps import AppConfig

class ActivityLogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'activitylog'
    
    def ready(self):
        import activitylog.signals
```

With this setup, we've created a comprehensive activity logging system that tracks user logins, logouts, account creation, updates, and deletions - all without modifying the core User model or views!

## Disconnecting Signals

In some cases, especially in testing, you might want to temporarily disconnect a signal:

```python
from django.db.models.signals import post_save
from django.contrib.auth.models import User

# Store the reference to the receiver function
from myapp.signals import create_user_profile

# Disconnect the signal
post_save.disconnect(create_user_profile, sender=User)

# Do something without the signal being triggered

# Reconnect the signal
post_save.connect(create_user_profile, sender=User)
```

## Performance Considerations

While signals are powerful, they come with a performance cost:

1. Each signal dispatch involves finding and calling all registered receivers
2. Signals make the code flow less obvious, which can make debugging harder
3. Too many signals can slow down your application

For critical paths in your application, you might want to use direct function calls instead of signals.

## Summary

Django's signal dispatch system provides a flexible way to decouple components of your application while still allowing them to communicate. Key points to remember:

- Signals follow the observer pattern: senders notify receivers when events occur
- You can connect receivers to signals using the `@receiver` decorator or `connect()` method
- Custom signals can be created for application-specific events
- Signal handlers should be placed in a location where they will be imported at startup
- Signals are powerful but come with a performance cost, so use them wisely

## Additional Resources

- [Django Official Documentation on Signals](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Django Built-in Signals Reference](https://docs.djangoproject.com/en/stable/ref/signals/)

## Exercises

1. Create a custom signal that gets dispatched when a user changes their password, and a receiver that logs this event.

2. Implement a signal-based system that automatically creates a thumbnail whenever an image is uploaded to your model.

3. Use signals to implement a notification system that alerts users when content they're following is updated.

4. Create a custom middleware that uses signals to track how long database queries take during a request and logs slow queries.

5. Implement a system using signals that automatically updates a "last_modified" field on related models when a primary model is updated.

By completing these exercises, you'll gain practical experience with Django's signal dispatch system and be able to apply it effectively in your projects.