---
title: Django Signal Senders
description: Learn how to specify and work with signal senders in Django to control which instances trigger signal handlers.

---

# Django Signal Senders

## Introduction

In the world of Django signals, understanding how to specify and control signal senders is crucial for building responsive, event-driven applications. Signal senders are the objects that emit signals - they're the origin point of the signal. When working with Django signals, you often need to restrict which instances of a model can trigger a particular signal handler, and that's where sender specification comes in.

This tutorial will explain how to work with signal senders in Django, why they're important, and how to use them effectively in real-world applications.

## Understanding Signal Senders

### What is a Signal Sender?

In Django's signal dispatch system, the sender is the class or object that emitted the signal. By default, when you connect a signal handler to a signal, it will be called whenever that signal is sent by any sender. However, you can specify a particular sender to restrict the handler to only respond to signals from that specific source.

Here's the basic pattern for connecting a signal handler with a specific sender:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from myapp.models import MyModel

@receiver(post_save, sender=MyModel)
def my_handler(sender, instance, created, **kwargs):
    # This function will only be called when a MyModel instance is saved
    print(f"Signal received from {sender.__name__}")
    print(f"Instance: {instance}")
```

In this example, `MyModel` is the sender. The handler will only be executed when a `MyModel` instance is saved, not when instances of other models are saved.

## Working with Signal Senders

### Specifying Model Senders

The most common use case for sender specification is to limit a signal handler to a specific model:

```python
from django.db.models.signals import pre_delete
from django.dispatch import receiver
from myapp.models import Article, Comment

@receiver(pre_delete, sender=Article)
def article_deletion_handler(sender, instance, **kwargs):
    print(f"About to delete article: {instance.title}")
    
@receiver(pre_delete, sender=Comment)
def comment_deletion_handler(sender, instance, **kwargs):
    print(f"About to delete comment on: {instance.article.title}")
```

This approach allows you to have different behaviors when different model instances are being deleted.

### Multiple Senders

You can register the same handler for multiple senders by connecting the signal multiple times:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from myapp.models import Article, Comment, User

def activity_logger(sender, instance, created, **kwargs):
    activity_type = "created" if created else "updated"
    print(f"{sender.__name__} was {activity_type}: {instance}")

# Connect the same handler for multiple senders
post_save.connect(activity_logger, sender=Article)
post_save.connect(activity_logger, sender=Comment)
post_save.connect(activity_logger, sender=User)
```

While this approach works, it's often cleaner to use the approach shown in the next section.

### Handling Multiple Senders Elegantly

You can create a more elegant solution for handling multiple senders with a helper function:

```python
from django.db.models.signals import post_save
from myapp.models import Article, Comment, User

def register_activity_logger(senders):
    def activity_logger(sender, instance, created, **kwargs):
        activity_type = "created" if created else "updated"
        print(f"{sender.__name__} was {activity_type}: {instance}")
    
    for sender in senders:
        post_save.connect(activity_logger, sender=sender)

# Register the handler for multiple models at once
register_activity_logger([Article, Comment, User])
```

This approach keeps your signal registration code DRY and maintainable.

## Custom Signal Senders

### Creating Custom Signals with Specific Senders

When creating custom signals, you can also specify a sender when providing signal arguments:

```python
from django.dispatch import Signal, receiver

# Define a custom signal
payment_completed = Signal()

class PaymentProcessor:
    def process_payment(self, amount):
        print(f"Processing payment of ${amount}")
        # After processing is complete
        payment_completed.send(sender=self.__class__, amount=amount)

# Connect to the custom signal with a specific sender
@receiver(payment_completed, sender=PaymentProcessor)
def on_payment_completed(sender, amount, **kwargs):
    print(f"Payment of ${amount} has been completed!")

# Usage
processor = PaymentProcessor()
processor.process_payment(99.99)
```

Output:
```
Processing payment of $99.99
Payment of $99.99 has been completed!
```

### Using Instance as Sender

While less common, you can also use specific instances as senders rather than classes:

```python
from django.dispatch import Signal

notification_sent = Signal()

class NotificationService:
    def __init__(self, name):
        self.name = name
    
    def send_notification(self, message):
        print(f"{self.name} sending: {message}")
        # Use the instance as the sender
        notification_sent.send(sender=self, message=message)

# Create two different notification services
email_service = NotificationService("Email Service")
sms_service = NotificationService("SMS Service")

# Connect a handler to only one specific service instance
def email_notification_handler(sender, message, **kwargs):
    print(f"Email notification logged: {message}")

notification_sent.connect(email_notification_handler, sender=email_service)

# Test both services
email_service.send_notification("Welcome!")
sms_service.send_notification("Hello!")
```

Output:
```
Email Service sending: Welcome!
Email notification logged: Welcome!
SMS Service sending: Hello!
```

Note that the handler is only called for the `email_service` instance.

## Practical Applications

### Form Submission Tracking

Here's a real-world example of using signal senders to track form submissions from different forms:

```python
from django.dispatch import Signal, receiver
from django.contrib.auth.forms import UserCreationForm
from myapp.forms import ContactForm, NewsletterForm

form_submitted = Signal()

class SignalTrackingFormMixin:
    def clean(self):
        cleaned_data = super().clean()
        if not self.errors:
            form_submitted.send(sender=self.__class__, 
                               form_data=cleaned_data)
        return cleaned_data

class TrackableUserCreationForm(SignalTrackingFormMixin, UserCreationForm):
    pass

class TrackableContactForm(SignalTrackingFormMixin, ContactForm):
    pass

class TrackableNewsletterForm(SignalTrackingFormMixin, NewsletterForm):
    pass

# Connect signal handlers for specific forms
@receiver(form_submitted, sender=TrackableUserCreationForm)
def on_signup(sender, form_data, **kwargs):
    print(f"New user registered: {form_data.get('username')}")
    
@receiver(form_submitted, sender=TrackableContactForm)
def on_contact(sender, form_data, **kwargs):
    print(f"Contact form received from: {form_data.get('email')}")
```

### Model Status Change Tracking

Another practical example is tracking status changes for different model types:

```python
from django.db.models.signals import pre_save
from django.dispatch import receiver
from myapp.models import Order, Task, Project

def status_change_tracker(model_class, status_field='status'):
    @receiver(pre_save, sender=model_class)
    def track_status_change(sender, instance, **kwargs):
        if not instance.pk:
            return  # Skip for new instances
        
        old_instance = sender.objects.get(pk=instance.pk)
        old_status = getattr(old_instance, status_field)
        new_status = getattr(instance, status_field)
        
        if old_status != new_status:
            print(f"{sender.__name__} #{instance.pk} status changed: "
                  f"{old_status} â†’ {new_status}")
    
    return track_status_change

# Register the trackers for different models
status_change_tracker(Order)
status_change_tracker(Task)
status_change_tracker(Project)
```

This pattern allows you to reuse the same tracking logic for different model types while still being able to identify which model sent the signal.

## Best Practices for Signal Senders

1. **Be specific with senders**: When possible, specify the sender to avoid unnecessary signal handler executions.

2. **Document your signal connections**: Always document which senders trigger which handlers to make your code more maintainable.

3. **Consider app structure**: Place signal handlers and their connections in a dedicated `signals.py` module within your app.

4. **Avoid circular imports**: Be careful with imports in your signal handlers to prevent circular import errors.

5. **Use dispatch_uid for multiple registrations**: If you're connecting the same handler multiple times with different senders, consider using `dispatch_uid` to prevent duplicate registrations.

```python
from django.db.models.signals import post_save

def my_handler(sender, **kwargs):
    print(f"Signal from {sender.__name__}")

post_save.connect(my_handler, sender=ModelA, dispatch_uid="model_a_save")
post_save.connect(my_handler, sender=ModelB, dispatch_uid="model_b_save")
```

## Summary

Signal senders in Django provide a powerful way to control which instances trigger your signal handlers. By specifying senders, you can:

- Create targeted signal handlers that only respond to specific models
- Implement different behavior for different types of models
- Create elegant patterns for handling similar events across multiple models
- Build custom signals that provide context about their origin

Understanding how to work with signal senders is essential for building Django applications that respond appropriately to different types of events from different sources.

## Additional Resources

- [Django Signals Documentation](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Django Dispatch Module](https://docs.djangoproject.com/en/stable/ref/signals/)

## Exercises

1. Create a system that logs different actions for different model types using a single signal handler.
2. Build a custom signal that can be sent by different services, with handlers that respond only to specific services.
3. Implement a notification system where different types of notifications trigger different handlers.
4. Create a mixin that automatically registers signal handlers for all models that inherit from it.