---
title: Django Model Signals
description: Learn about Django model signals, their types, and how to use them to respond to model lifecycle events in your Django applications.
---

# Django Model Signals

In Django development, you'll often need to execute specific actions in response to certain events in your models' lifecycle. For example, you might want to send an email when a user is created or update related models when a record is updated. This is where Django model signals come into play.

## What are Django Model Signals?

Django model signals are a mechanism that allows specific code to run before or after certain model events occur. Think of them as hooks or callbacks that get triggered at specific points during a model's lifecycle, such as when it's saved, deleted, or updated.

Model signals follow the **observer pattern**, where signal senders notify a set of receivers when certain actions occur.

## Why Use Django Model Signals?

- **Decoupled Code**: Signals allow you to separate concerns and maintain cleaner models.
- **Cross-Cutting Concerns**: Handle operations that affect multiple parts of your application.
- **Event-Driven Architecture**: Build reactive components that respond to data changes.

## Common Model Signals

Django provides several built-in signals for models:

### Pre-save and Post-save Signals

These signals are sent before or after a model's `save()` method is called.

```python
from django.db.models.signals import pre_save, post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    """Create a Profile whenever a new User is created."""
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    """Save the Profile whenever the User is saved."""
    instance.profile.save()
```

In this example, whenever a User model is saved:
1. If it's a newly created user, a corresponding Profile is created.
2. The user's profile is saved alongside the user.

### Pre-delete and Post-delete Signals

These signals are sent before or after a model's `delete()` method is called.

```python
from django.db.models.signals import pre_delete, post_delete
from django.dispatch import receiver
from .models import Document

@receiver(pre_delete, sender=Document)
def delete_document_files(sender, instance, **kwargs):
    """Delete file from filesystem when Document object is deleted."""
    if instance.file:
        try:
            # Delete the file from storage
            instance.file.delete(False)  # False means don't save the model
        except Exception as e:
            print(f"Error deleting file: {e}")
```

This ensures that when a Document object is deleted, the corresponding file in the filesystem is also removed.

### Model Signals Parameters

Most model signal handlers receive these common parameters:

- `sender`: The model class that sent the signal
- `instance`: The actual instance of the model
- `created`: For post_save only; True if a new record was created
- `**kwargs`: Additional keyword arguments

## Connecting Signals in Django

There are two primary ways to connect signals to receivers:

### 1. Using the @receiver Decorator

The decorator approach is clean and recommended:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import BlogPost

@receiver(post_save, sender=BlogPost)
def index_blog_post(sender, instance, created, **kwargs):
    """Send blog post to search indexing service."""
    if created:
        print(f"Indexing new blog post: {instance.title}")
        # Code to send to search indexing service
    else:
        print(f"Updating indexed blog post: {instance.title}")
        # Code to update search index
```

### 2. Using the connect() Method

You can also manually connect signals:

```python
from django.db.models.signals import post_save
from .models import Comment

def notify_moderators(sender, instance, created, **kwargs):
    """Notify moderators about new comments."""
    if created:
        print(f"New comment posted: {instance.content[:30]}...")
        # Send notification to moderators

# Connect the signal
post_save.connect(notify_moderators, sender=Comment)
```

## Practical Example: Automatic Slug Generation

Let's implement a real-world example of using signals to automatically generate a slug for a blog post:

```python
# models.py
from django.db import models
from django.utils.text import slugify

class BlogPost(models.Model):
    title = models.CharField(max_length=100)
    slug = models.SlugField(unique=True, blank=True)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return self.title

# signals.py
from django.db.models.signals import pre_save
from django.dispatch import receiver
from .models import BlogPost

@receiver(pre_save, sender=BlogPost)
def create_blog_slug(sender, instance, **kwargs):
    """Auto-generate slug from title if not provided."""
    if not instance.slug:
        base_slug = slugify(instance.title)
        instance.slug = base_slug
        
        # Ensure slug is unique
        counter = 1
        while BlogPost.objects.filter(slug=instance.slug).exists():
            instance.slug = f"{base_slug}-{counter}"
            counter += 1
```

Now we need to make sure Django knows about our signals. Create an `apps.py` file:

```python
# apps.py
from django.apps import AppConfig

class BlogConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'blog'

    def ready(self):
        import blog.signals  # Import the signals module
```

And ensure this AppConfig is used in your `__init__.py`:

```python
# __init__.py
default_app_config = 'blog.apps.BlogConfig'
```

## Best Practices for Using Model Signals

1. **Keep Signal Handlers Focused**: Each handler should have a single responsibility.

2. **Handle Errors**: Wrap signal code in try-except blocks to prevent exceptions from breaking your application flow.

3. **Avoid Infinite Loops**: Be careful not to create loops where a signal triggers code that triggers the same signal again.

4. **Consider Alternatives**: For simple cases, model methods or overriding save() might be cleaner than signals.

5. **Use Signal Organization**: Keep signals in a dedicated `signals.py` file.

6. **Beware of Import Timing**: Django signals can be tricky with circular imports. Always connect signals in the AppConfig's ready() method.

## When Not to Use Signals

While signals are powerful, they're not always the right choice:

- **Direct Related Updates**: If you're just updating related models, consider using model methods instead.
- **Critical Business Logic**: Core business logic might be better placed in explicit functions rather than signals.
- **Simple Cases**: For very simple cases, overriding the `save()` method might be clearer.

## Example: Signal Alternatives

Instead of using a signal for slug generation, you could also override the save method:

```python
class BlogPost(models.Model):
    title = models.CharField(max_length=100)
    slug = models.SlugField(unique=True, blank=True)
    content = models.TextField()
    
    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.title)
            # Ensure uniqueness
            counter = 1
            while BlogPost.objects.filter(slug=self.slug).exists():
                self.slug = f"{slugify(self.title)}-{counter}"
                counter += 1
        super().save(*args, **kwargs)
```

## Summary

Django model signals provide a powerful way to respond to model lifecycle events. They help you:

1. Keep your code modular and separated
2. Automatically respond to model changes
3. Implement event-driven architectures in your Django applications

By understanding when and how to use signals, you can make your Django applications more reactive and maintainable.

## Additional Resources

- [Django Documentation on Signals](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Django Signal Dispatcher Documentation](https://docs.djangoproject.com/en/stable/ref/signals/)

## Exercises

1. Create a signal that automatically creates a welcome notification when a new user registers.
2. Implement a signal that logs all changes made to a specific model for auditing purposes.
3. Build a signal-based system that sends an email whenever a specific type of model is updated.
4. Create a signal that automatically generates thumbnails when an image is uploaded.

Remember that while signals are powerful, they should be used judiciously as part of a well-designed application architecture.