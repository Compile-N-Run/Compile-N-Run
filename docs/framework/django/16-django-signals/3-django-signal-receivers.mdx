---
title: Django Signal Receivers
description: Learn how to create and connect signal receivers in Django to respond to system events, with practical examples and best practices.

---

# Django Signal Receivers

In the Django web framework, signals provide a way to allow decoupled applications to be notified when certain events occur. Signal receivers are functions that "listen" for these signals and execute code in response. They're crucial for building reactive, event-driven functionality in your Django applications.

## Introduction to Signal Receivers

Signal receivers are simply Python functions that get called when signals are sent. They act as event listeners, allowing your code to react when specific actions occur within Django's operationâ€”like when a model is saved, a request is completed, or a user logs in.

![Django Signal Flow](https://i.imgur.com/JZ2XGvC.png)

A receiver function typically follows this pattern:

```python
def my_receiver_function(sender, **kwargs):
    # Code to execute when the signal is received
    pass
```

The `sender` parameter represents the class that sent the signal, while `**kwargs` captures any additional information passed with the signal.

## Connecting Receivers to Signals

There are two main ways to connect a receiver function to a signal:

### 1. Using the `@receiver` Decorator

This is the most common and readable approach:

```python
from django.dispatch import receiver
from django.db.models.signals import post_save
from myapp.models import MyModel

@receiver(post_save, sender=MyModel)
def handle_model_save(sender, instance, created, **kwargs):
    if created:
        print(f"New instance of {sender.__name__} created: {instance}")
    else:
        print(f"{sender.__name__} instance updated: {instance}")
```

### 2. Using the `connect()` Method

You can also connect receivers programmatically:

```python
from django.db.models.signals import post_save
from myapp.models import MyModel

def handle_model_save(sender, instance, created, **kwargs):
    if created:
        print(f"New instance of {sender.__name__} created: {instance}")
    else:
        print(f"{sender.__name__} instance updated: {instance}")

post_save.connect(handle_model_save, sender=MyModel)
```

## Signal Parameters

Different signals pass different parameters to their receivers. However, most signals will include these common parameters:

1. `sender`: The class that sent the signal
2. `**kwargs`: Additional keyword arguments that vary by signal type

For example, model signals typically include:
- `instance`: The actual instance being saved/deleted
- `created`: Boolean indicating if this is a new instance (for `post_save`)

## Working with Signal Receivers: Step By Step

Let's create a complete example to demonstrate signal receivers in action:

### Step 1: Define Your Model

```python
# models.py
from django.db import models
from django.contrib.auth.models import User

class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    bio = models.TextField(blank=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return f"{self.user.username}'s profile"
```

### Step 2: Create a Signal Receiver

Let's create a receiver that automatically creates a Profile when a new User is created:

```python
# signals.py
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.auth.models import User
from .models import Profile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)
        print(f"Profile created for {instance.username}")

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    instance.profile.save()
    print(f"Profile updated for {instance.username}")
```

### Step 3: Register Your Signals

Django needs to know about your signals. The best practice is to use the `AppConfig` to import and register them:

```python
# apps.py
from django.apps import AppConfig

class MyAppConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'
    
    def ready(self):
        import myapp.signals  # Import the signals module
```

Make sure your app's `__init__.py` includes:

```python
# __init__.py
default_app_config = 'myapp.apps.MyAppConfig'
```

### Step 4: Testing It Out

Now when a user is created, the signal receiver will automatically create and save a profile:

```python
# Example usage in Python shell or a view
from django.contrib.auth.models import User

# Create a new user
user = User.objects.create_user(username="testuser", 
                                email="test@example.com", 
                                password="testpass123")

# The profile is automatically created via signals
print(f"User created: {user.username}")
print(f"Profile exists: {hasattr(user, 'profile')}")
print(f"Profile bio: {user.profile.bio}")
```

Output:
```
Profile created for testuser
Profile updated for testuser
User created: testuser
Profile exists: True
Profile bio: 
```

## Real-world Applications

Signal receivers have many practical applications in Django development:

### 1. Audit Trails and Logging

```python
@receiver(post_save)
def log_model_changes(sender, instance, created, **kwargs):
    # Ignore certain models
    if sender.__name__ in ['Session', 'LogEntry']:
        return
    
    if created:
        action = "Created"
    else:
        action = "Updated"
    
    with open('audit_log.txt', 'a') as log:
        log.write(f"{action} {sender.__name__} ID:{instance.id} at {timezone.now()}\n")
```

### 2. Cache Invalidation

```python
@receiver(post_save, sender=BlogPost)
def invalidate_blog_cache(sender, instance, **kwargs):
    cache.delete(f'blog_post_{instance.id}')
    cache.delete('blog_post_list')
    print(f"Cache invalidated for {instance.title}")
```

### 3. Sending Notifications

```python
@receiver(post_save, sender=Comment)
def notify_post_author(sender, instance, created, **kwargs):
    if created:
        subject = "New comment on your post"
        message = f"Someone commented on your post: {instance.post.title}"
        from_email = "noreply@example.com"
        recipient = instance.post.author.email
        
        send_mail(subject, message, from_email, [recipient])
        print(f"Notification sent to {recipient}")
```

### 4. Creating Related Objects

```python
@receiver(post_save, sender=Order)
def create_invoice(sender, instance, created, **kwargs):
    if created:
        Invoice.objects.create(
            order=instance,
            amount=instance.total,
            due_date=timezone.now() + timedelta(days=30)
        )
        print(f"Invoice created for Order #{instance.id}")
```

## Best Practices for Signal Receivers

1. **Keep receivers lightweight**: Signal handlers should be quick to execute to avoid slowing down operations.

2. **Prevent infinite loops**: Be careful when modifying the same model that triggered the signal:

```python
@receiver(post_save, sender=MyModel)
def handle_save(sender, instance, **kwargs):
    # BAD: Will trigger the signal again!
    instance.some_field = "updated"
    instance.save()
    
    # BETTER: Use update which doesn't trigger signals
    sender.objects.filter(pk=instance.pk).update(some_field="updated")
```

3. **Handle exceptions properly**:

```python
@receiver(post_save, sender=Product)
def update_stats(sender, instance, **kwargs):
    try:
        # Complex operation that might fail
        Statistics.objects.update_product_counts()
    except Exception as e:
        logger.error(f"Failed to update statistics: {e}")
        # Don't re-raise the exception to prevent disrupting the save operation
```

4. **Organize signals in a dedicated module**: Keep all your signals in a `signals.py` file for better organization.

5. **Consider performance implications**: Too many signal receivers can slow down common operations like saving models.

## Disconnecting Signal Receivers

In some cases, you might need to temporarily disable a signal receiver:

```python
from django.db.models.signals import post_save
from myapp.models import MyModel
from myapp.signals import my_handler

# Disconnect a specific handler
post_save.disconnect(my_handler, sender=MyModel)

# Do operations without the signal being triggered
MyModel.objects.create(name="No signals")

# Reconnect the handler
post_save.connect(my_handler, sender=MyModel)
```

## Summary

Signal receivers are powerful tools in Django that allow your application to respond to events without tightly coupling components. They're especially useful for:

- Creating related objects automatically
- Keeping data in sync across different parts of your application
- Implementing audit trails and logging
- Triggering notifications and communications
- Managing caches

Remember that while signals offer great flexibility, they can also make code flow harder to follow if overused. Signal receivers should be considered for cross-cutting concerns that would otherwise require duplicating code across multiple views or models.

## Additional Resources

- [Django Official Documentation on Signals](https://docs.djangoproject.com/en/stable/topics/signals/)
- [Django Built-in Signals Reference](https://docs.djangoproject.com/en/stable/ref/signals/)
- [Django Extensions](https://github.com/django-extensions/django-extensions) - Contains useful signal mixins

## Exercises

1. Create a signal receiver that automatically generates a slug field for a blog post model when it's saved
2. Implement a logging system that records all changes to a specific model
3. Build a notification system that sends emails when comments are posted
4. Create a receiver that generates a thumbnail when an image is uploaded
5. Implement a signal-based cache invalidation strategy for a complex data model

By mastering signal receivers, you'll be able to create more reactive and maintainable Django applications that can respond elegantly to changes throughout your system.