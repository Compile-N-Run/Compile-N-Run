---
title: Django Middleware Settings
description: Learn how to configure and customize Django middleware, including built-in middleware settings, creating custom middleware, and best practices for optimizing your middleware stack.

---

# Django Middleware Settings

Middleware is a powerful feature in Django that processes requests and responses globally before they reach their final destination. Understanding how to configure middleware settings is essential for controlling request/response flow, implementing security features, and customizing Django's behavior for your applications.

## Introduction to Django Middleware Settings

Django middleware components sit between the web server and your Django application, processing each request and response. Properly configuring middleware settings allows you to:

- Apply security measures across your entire application
- Modify requests and responses globally
- Track user sessions
- Handle authentication
- Implement cross-cutting concerns like logging and request timing

## Configuring the Middleware Stack

The middleware stack in Django is configured through the `MIDDLEWARE` setting in your `settings.py` file. This setting contains an ordered list of middleware classes that Django will apply to each request and response.

```python
# settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

:::tip
The order of middleware in the list matters! Middleware is processed in order for requests (top to bottom) and in reverse order for responses (bottom to top).
:::

## Understanding the Default Middleware Stack

Django's default middleware stack provides essential functionality. Let's examine each component:

### 1. SecurityMiddleware

```python
'django.middleware.security.SecurityMiddleware'
```

This middleware implements several security enhancements:

- `SECURE_SSL_REDIRECT`: Redirects all non-HTTPS requests to HTTPS
- `SECURE_HSTS_SECONDS`: Adds HTTP Strict Transport Security headers
- `SECURE_CONTENT_TYPE_NOSNIFF`: Prevents browsers from MIME-sniffing responses

Example configuration:

```python
# settings.py
SECURE_SSL_REDIRECT = True
SECURE_HSTS_SECONDS = 31536000  # 1 year
SECURE_CONTENT_TYPE_NOSNIFF = True
```

### 2. SessionMiddleware

```python
'django.contrib.sessions.middleware.SessionMiddleware'
```

This middleware enables session support. You can configure various session settings:

```python
# settings.py
SESSION_COOKIE_AGE = 1209600  # 2 weeks, in seconds
SESSION_COOKIE_SECURE = True  # Only send cookie over HTTPS
SESSION_EXPIRE_AT_BROWSER_CLOSE = False
```

### 3. CommonMiddleware

```python
'django.middleware.common.CommonMiddleware'
```

This middleware handles URL-related tasks:

- `APPEND_SLASH`: Automatically appends slashes to URLs
- `PREPEND_WWW`: Prepends "www." to domain names
- `DISALLOWED_USER_AGENTS`: Blocks specified user agents

Example:

```python
# settings.py
APPEND_SLASH = True
PREPEND_WWW = False
```

### 4. CsrfViewMiddleware

```python
'django.middleware.csrf.CsrfViewMiddleware'
```

Provides Cross-Site Request Forgery protection. You can configure:

```python
# settings.py
CSRF_COOKIE_SECURE = True  # Only send over HTTPS
CSRF_USE_SESSIONS = False  # Store CSRF token in cookie (not session)
CSRF_COOKIE_HTTPONLY = False  # Allow JavaScript to access CSRF cookie
```

### 5. AuthenticationMiddleware

```python
'django.contrib.auth.middleware.AuthenticationMiddleware'
```

Associates users with requests using sessions. This middleware doesn't have specific settings but enables the `request.user` attribute.

### 6. MessageMiddleware

```python
'django.contrib.messages.middleware.MessageMiddleware'
```

Enables the messaging framework. You can configure message storage:

```python
# settings.py
MESSAGE_STORAGE = 'django.contrib.messages.storage.cookie.CookieStorage'
```

### 7. XFrameOptionsMiddleware

```python
'django.middleware.clickjacking.XFrameOptionsMiddleware'
```

Prevents clickjacking attacks by adding the X-Frame-Options header. Settings include:

```python
# settings.py
X_FRAME_OPTIONS = 'DENY'  # Options: 'DENY', 'SAMEORIGIN', or 'ALLOW-FROM uri'
```

## Adding Custom Middleware

To add your custom middleware to the stack:

1. Create your middleware class
2. Add it to the `MIDDLEWARE` setting

Let's create a simple request timing middleware:

```python
# myapp/middleware.py
import time

class RequestTimingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Code executed before the view
        start_time = time.time()
        
        response = self.get_response(request)
        
        # Code executed after the view
        duration = time.time() - start_time
        response['X-Request-Duration'] = f"{duration:.2f}s"
        
        return response
```

Then add it to your middleware stack:

```python
# settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # Other default middleware
    'myapp.middleware.RequestTimingMiddleware',  # Our custom middleware
]
```

## Middleware Order Matters

The order of middleware in the `MIDDLEWARE` setting is crucial:

- Request processing: Django processes middleware from top to bottom
- Response processing: Django processes middleware from bottom to top

For example, if you place your authentication middleware after session middleware, you'll have access to session data when authenticating users.

## Practical Example: Creating a Site Maintenance Mode

Let's create a middleware that shows a maintenance page when enabled:

```python
# maintenance_middleware.py
from django.conf import settings
from django.http import HttpResponse
from django.template.loader import render_to_string

class MaintenanceMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Check if maintenance mode is enabled
        if getattr(settings, 'MAINTENANCE_MODE', False):
            # Check if user is staff (optional bypass)
            if not (request.user.is_authenticated and request.user.is_staff):
                content = render_to_string('maintenance.html')
                return HttpResponse(content, status=503)
        return self.get_response(request)
```

Add it to your settings:

```python
# settings.py
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'myapp.middleware.MaintenanceMiddleware',  # Add early in the stack
    # Other middleware...
]

# Toggle maintenance mode
MAINTENANCE_MODE = False  # Set to True when needed
```

Create a `maintenance.html` template:

```html
<!-- templates/maintenance.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Site Maintenance</title>
    <style>
        body { text-align: center; padding: 150px; }
        h1 { font-size: 40px; }
        body { font: 20px Helvetica, sans-serif; color: #333; }
    </style>
</head>
<body>
    <h1>We'll be back soon!</h1>
    <p>We're currently performing maintenance on our site. Please check back later.</p>
</body>
</html>
```

Now you can toggle maintenance mode by changing the `MAINTENANCE_MODE` setting.

## Conditionally Applying Middleware

Sometimes you want middleware to run only for specific paths. Let's create a middleware that applies only to certain URL patterns:

```python
# selective_middleware.py
import re
from django.conf import settings

class SelectiveMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        # Compile URL patterns that this middleware should apply to
        self.patterns = [re.compile(pattern) for pattern in 
                        getattr(settings, 'SELECTIVE_MIDDLEWARE_URLS', [])]
        
    def __call__(self, request):
        path = request.path_info
        
        # Check if the path matches any patterns
        if any(pattern.match(path) for pattern in self.patterns):
            # Apply middleware logic
            print(f"Applying selective middleware to {path}")
        
        return self.get_response(request)
```

Configure it in settings:

```python
# settings.py
MIDDLEWARE = [
    # Other middleware...
    'myapp.middleware.SelectiveMiddleware',
]

# URL patterns to apply the middleware to
SELECTIVE_MIDDLEWARE_URLS = [
    r'^/api/.*',  # Apply to all API requests
    r'^/admin/.*',  # Apply to admin pages
]
```

## Performance Considerations

Middleware runs on every request, so performance is critical:

1. **Keep middleware efficient**: Don't perform heavy operations in middleware
2. **Minimize middleware**: Only include what you need
3. **Order wisely**: Place commonly short-circuiting middleware early in the stack
4. **Cache expensive operations**: If middleware performs expensive operations, cache results when possible

Example of caching in middleware:

```python
# cached_middleware.py
from django.core.cache import cache
from django.conf import settings

class CachedInfoMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Try to get expensive info from cache
        info = cache.get('expensive_info')
        if info is None:
            # Not in cache, calculate it
            info = self._calculate_expensive_info()
            cache.set('expensive_info', info, 3600)  # Cache for 1 hour
        
        # Attach to request for use in views
        request.expensive_info = info
        
        return self.get_response(request)
    
    def _calculate_expensive_info(self):
        # Simulate expensive operation
        return {'calculated_at': datetime.datetime.now().isoformat()}
```

## Django Debug Toolbar Middleware

When developing Django applications, the Django Debug Toolbar is invaluable. It's implemented as middleware:

```python
# settings.py (for development only)
if DEBUG:
    INSTALLED_APPS += ['debug_toolbar']
    MIDDLEWARE += ['debug_toolbar.middleware.DebugToolbarMiddleware']
    INTERNAL_IPS = ['127.0.0.1']
```

:::caution
Always ensure the Debug Toolbar is only enabled in development environments, not in production!
:::

## Summary

Django middleware settings provide a powerful way to globally process requests and responses in your application. Key points to remember:

- The `MIDDLEWARE` setting defines the middleware stack
- Middleware order is critical - requests flow top to bottom, responses flow bottom to top
- Django's built-in middleware provides essential security and functionality
- Custom middleware allows you to implement cross-cutting concerns
- Middleware performance is important since it runs on every request

By effectively configuring your middleware settings, you can enhance security, add custom functionality, and optimize the performance of your Django application.

## Additional Resources

1. [Django Official Documentation on Middleware](https://docs.djangoproject.com/en/stable/topics/http/middleware/)
2. [Django Security Middleware Documentation](https://docs.djangoproject.com/en/stable/ref/middleware/#module-django.middleware.security)
3. [Writing Custom Middleware in Django](https://docs.djangoproject.com/en/stable/topics/http/middleware/#writing-your-own-middleware)

## Exercises

1. Create a middleware that logs all requests to a specific file
2. Implement a rate-limiting middleware that restricts users to a maximum number of requests per minute
3. Create a middleware that adds custom headers to all API responses
4. Develop a middleware that tracks and displays the database query count for each request (hint: look into Django's connection.queries)
5. Modify the maintenance middleware to exempt certain paths, like API endpoints that need to remain available