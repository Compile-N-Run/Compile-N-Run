---
title: Django Middleware Order
description: Learn about Django middleware execution order, how to control it, and best practices for arranging middleware in your Django applications.

---

# Django Middleware Order

When building Django applications, understanding how middleware functions and the order in which it executes is crucial for creating secure, performant web applications. In this guide, we'll explore the importance of middleware order and how to control it effectively.

## Introduction to Middleware Order

Django middleware is a framework of hooks into Django's request/response processing. It's a light, low-level plugin system for globally altering Django's input or output. Each middleware component performs a specific function in the request-response cycle.

The **order** of middleware matters significantly because:

1. Each middleware can process the request before passing it to the next middleware
2. The response flows back through middleware in reverse order
3. Some middleware depends on other middleware being processed first

## How Django Processes Middleware

Django processes middleware in a specific way:

1. When a request comes in, Django applies middleware in the order specified in `MIDDLEWARE`
2. The request passes through each middleware from top to bottom
3. The view function is called
4. The response passes back through each middleware in reverse order (bottom to top)

This two-pass system (request phase and response phase) gives each middleware two opportunities to process data.

```
Request path:
Browser → Middleware 1 → Middleware 2 → Middleware 3 → View

Response path:
View → Middleware 3 → Middleware 2 → Middleware 1 → Browser
```

## Configuring Middleware Order

Middleware is configured in your Django project's `settings.py` file using the `MIDDLEWARE` setting:

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    # Your custom middleware here
]
```

The order in this list determines the sequence in which middleware is processed. The first middleware listed is the first to process the request and the last to process the response.

## Default Middleware Order and Reasoning

Django's default ordering exists for specific reasons:

1. **SecurityMiddleware** comes first to handle security headers and checks before anything else
2. **SessionMiddleware** and **CsrfViewMiddleware** need to be early in the process to establish session and CSRF protection
3. **AuthenticationMiddleware** depends on session middleware, so it comes after
4. **MessageMiddleware** depends on session and authentication, placing it after those

Let's examine why this ordering matters with a simple example.

## Practical Example: Understanding Dependencies

Consider what would happen if we placed `AuthenticationMiddleware` before `SessionMiddleware`:

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    # INCORRECT ORDER ❌
    'django.contrib.auth.middleware.AuthenticationMiddleware',  
    'django.contrib.sessions.middleware.SessionMiddleware',
    # ... other middleware
]
```

This order would cause problems because `AuthenticationMiddleware` depends on the session being available (which is set up by `SessionMiddleware`). The result might be that users appear logged out or authentication failures occur.

## Example: Creating Custom Middleware with Order in Mind

Let's create a simple logging middleware that demonstrates order awareness:

```python
# In a file named middleware.py
class RequestTimeMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Code executed before view (and before other middleware)
        import time
        request.start_time = time.time()
        
        # Pass control to the next middleware or view
        response = self.get_response(request)
        
        # Code executed after view (and after other middleware)
        duration = time.time() - request.start_time
        print(f"Request to {request.path} took {duration:.2f}s")
        
        return response
```

To use this middleware and ensure it captures the full request-response cycle, add it as the first item in your `MIDDLEWARE` setting:

```python
MIDDLEWARE = [
    'myapp.middleware.RequestTimeMiddleware',  # Our custom middleware first
    'django.middleware.security.SecurityMiddleware',
    # ... other middleware
]
```

This way, `RequestTimeMiddleware` will be the first to see the request and the last to see the response, giving an accurate timing of the entire process.

## Real-World Example: API Rate Limiting

Rate limiting is a common feature that depends on middleware order. Let's create a simple rate limiting middleware:

```python
# In middleware.py
from django.http import HttpResponse
from django.core.cache import cache

class RateLimitMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Skip rate limiting for some paths
        if request.path.startswith('/admin/'):
            return self.get_response(request)
            
        # Get client IP
        ip = request.META.get('REMOTE_ADDR')
        key = f"ratelimit:{ip}"
        
        # Check if this IP has exceeded rate limits
        requests = cache.get(key, 0)
        
        if requests > 100:  # More than 100 requests
            return HttpResponse("Rate limit exceeded. Please try again later.", status=429)
            
        # Increment the request count
        cache.set(key, requests + 1, 60)  # 60 second window
        
        # Continue processing the request
        return self.get_response(request)
```

For this middleware to work correctly, you'd want it early in the middleware stack, but after essentials like security:

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'myapp.middleware.RateLimitMiddleware',  # Early, but after security
    # ... other middleware
]
```

This ensures security checks happen first, then rate limiting, before spending resources on session handling, authentication, etc.

## Common Order-Based Issues

Here are some common problems that arise from incorrect middleware ordering:

1. **Authentication failures**: If `AuthenticationMiddleware` comes before `SessionMiddleware`
2. **CSRF verification issues**: If `CsrfViewMiddleware` comes after middleware that modifies forms or POST data
3. **Caching bypassed**: If caching middleware comes after middleware that modifies responses
4. **Performance tracking inaccuracies**: If timing middleware isn't placed first/last

## Best Practices for Ordering Middleware

Here are some guidelines to follow when ordering your middleware:

1. **Keep Django's default ordering** for built-in middleware whenever possible
2. **Place security-related middleware early** in the request cycle
3. **Consider dependencies** - if Middleware B depends on something set by Middleware A, then A should come before B
4. **Place broadly-applicable middleware first** and more specific middleware later
5. **Performance-measuring middleware** should typically be first on the list to capture the entire process
6. **Test thoroughly** after changing middleware order to ensure everything works as expected

## Debugging Middleware Order Issues

If you suspect middleware order issues, try these approaches:

1. Add debug print statements to your middleware's `__call__` method to see execution order
2. Use Django Debug Toolbar to inspect request/response cycle
3. Create a simple middleware that logs the order:

```python
class DebugMiddlewareOrderMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        # Log when middleware is initialized
        print(f"Initializing: {self.__class__.__name__}")
        
    def __call__(self, request):
        # Log when request passes through
        print(f"Request passing through: {self.__class__.__name__}")
        response = self.get_response(request)
        # Log when response passes through
        print(f"Response passing through: {self.__class__.__name__}")
        return response
```

## Summary

The order of middleware in Django applications is critical for proper functioning:

- Middleware executes in the order specified in the `MIDDLEWARE` setting
- Requests flow from top to bottom, responses flow from bottom to top
- Dependencies between middleware components dictate their relative positions
- Security middleware generally comes first, followed by session, authentication, etc.
- Custom middleware should be placed with careful consideration of what it needs to function

Understanding and properly configuring middleware order helps ensure your Django application is secure, performs well, and functions correctly.

## Additional Resources

- [Django's Official Documentation on Middleware](https://docs.djangoproject.com/en/stable/topics/http/middleware/)
- [Django's Built-in Middleware Reference](https://docs.djangoproject.com/en/stable/ref/middleware/)
- [Writing Custom Middleware](https://docs.djangoproject.com/en/stable/topics/http/middleware/#writing-your-own-middleware)

## Exercises

1. Reorder the default Django middleware in a test project and observe what breaks
2. Create a custom middleware that logs which view handled each request
3. Implement a middleware that adds a custom header to responses and experiment with different positions in the middleware stack
4. Create middleware that times different segments of the request processing and determine the optimal ordering
5. Build a middleware that requires authentication for specific URL patterns and place it in the proper position