---
title: Django Full-Text Search
description: Learn how to implement powerful full-text search capabilities in your Django applications

---

# Django Full-Text Search

## Introduction

When building web applications, providing users with a robust search functionality is often a critical feature. While simple queries using Django's `filter()` with `contains` or `icontains` lookups might work for basic use cases, they lack the sophistication needed for efficient and relevant text searching across large datasets.

Full-text search solves this problem by providing advanced text searching capabilities that go beyond simple pattern matching. Django supports full-text search functionality through its ORM, allowing you to implement powerful search features in your applications.

In this tutorial, you'll learn:
- What full-text search is and why it's important
- How to implement basic full-text search in Django
- Advanced full-text search techniques
- Optimization tips and best practices

## What is Full-Text Search?

Full-text search allows users to search for documents or records that contain specific words or phrases. Unlike standard SQL queries that look for exact matches or simple patterns, full-text search engines:

1. **Pre-process text** - normalizing words through stemming, lemmatization, and removing stop words
2. **Index content** - creating specialized data structures for efficient searching
3. **Rank results** - returning matches based on relevance

Django's full-text search capabilities are built on top of the database backend's full-text search features. PostgreSQL, in particular, offers robust full-text search functionality that Django can leverage.

## Setting Up Your Environment

For this tutorial, we'll use PostgreSQL as our database backend since it has excellent full-text search capabilities that Django integrates with well.

First, ensure you have Django and the PostgreSQL adapter installed:

```bash
pip install django psycopg2-binary
```

Make sure your Django project is configured to use PostgreSQL:

```python
# settings.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```

## Creating a Model

Let's create a simple blog model to demonstrate full-text search:

```python
# blog/models.py
from django.db import models

class BlogPost(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.CharField(max_length=100)
    published_date = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.title
```

After creating your model, make migrations and migrate:

```bash
python manage.py makemigrations
python manage.py migrate
```

## Basic Full-Text Search in Django

Django provides several lookup types for full-text search with PostgreSQL:

- `search`: For basic full-text search
- `trigram_similar`: For similarity searches based on trigrams
- `unaccent`: For searches ignoring accents

Let's look at a simple example of using the `search` lookup:

```python
from django.contrib.postgres.search import SearchVector
from .models import BlogPost

# Basic search across multiple fields
results = BlogPost.objects.annotate(
    search=SearchVector('title', 'content'),
).filter(search='django')
```

This will search for the word "django" in both the title and content fields of all blog posts.

## Search Vectors and Search Queries

For more advanced searching, Django provides the `SearchVector` and `SearchQuery` classes:

```python
from django.contrib.postgres.search import SearchVector, SearchQuery

# Create a search vector and query
vector = SearchVector('title', 'content')
query = SearchQuery('django')

# Perform the search
results = BlogPost.objects.annotate(search=vector).filter(search=query)

# Print the results
for post in results:
    print(f"{post.title}: {post.content[:50]}...")
```

**Output:**
```
Django Full-Text Search: Learn how to implement powerful full-text search...
Getting Started with Django: Django is a high-level Python web framework...
```

## Ranking Search Results

To make search results more useful, you'll want to rank them by relevance. Django provides the `SearchRank` class for this purpose:

```python
from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank

vector = SearchVector('title', 'content')
query = SearchQuery('django')

# Annotate with search rank
results = BlogPost.objects.annotate(
    search=vector,
    rank=SearchRank(vector, query)
).filter(search=query).order_by('-rank')

# Display ranked results
for post in results:
    print(f"Rank: {post.rank}, Title: {post.title}")
```

**Output:**
```
Rank: 0.6079271, Title: Django Full-Text Search
Rank: 0.438571, Title: Getting Started with Django
Rank: 0.1273, Title: Web Development Frameworks
```

## Weighting Fields

Some fields may be more important than others in your search. For instance, a match in the title might be more relevant than a match in the content. You can weight fields accordingly:

```python
from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank

vector = SearchVector('title', weight='A') + SearchVector('content', weight='B')
query = SearchQuery('django')

results = BlogPost.objects.annotate(
    rank=SearchRank(vector, query)
).filter(rank__gt=0).order_by('-rank')
```

The weights are assigned as follows:
- A: 1.0
- B: 0.4
- C: 0.2
- D: 0.1

## Using Stemming and Stop Words

Stemming reduces words to their root form, so variations like "running," "ran," and "runs" all match a search for "run." In PostgreSQL, this is controlled by language configurations.

```python
from django.contrib.postgres.search import SearchVector, SearchQuery

vector = SearchVector('title', 'content', config='english')
query = SearchQuery('running', config='english')

results = BlogPost.objects.annotate(search=vector).filter(search=query)
```

This search will also match records containing "run," "runs," etc.

## Trigram Similarity Search

For fuzzy matching or handling typos, you can use trigram similarity searches:

```python
from django.contrib.postgres.search import TrigramSimilarity

results = BlogPost.objects.annotate(
    similarity=TrigramSimilarity('title', 'djnago'),  # Intentional typo
).filter(similarity__gt=0.3).order_by('-similarity')
```

This will find blog posts with titles similar to "djnago" (a misspelling of "django").

## Real-World Example: Building a Search View

Let's create a complete example of a search view for our blog:

```python
# views.py
from django.contrib.postgres.search import SearchVector, SearchQuery, SearchRank
from django.views.generic import ListView
from .models import BlogPost

class SearchBlogView(ListView):
    model = BlogPost
    template_name = 'blog/search_results.html'
    context_object_name = 'results'
    paginate_by = 10
    
    def get_queryset(self):
        query = self.request.GET.get('q', '')
        if query:
            search_vector = SearchVector('title', weight='A') + SearchVector('content', weight='B')
            search_query = SearchQuery(query)
            return BlogPost.objects.annotate(
                rank=SearchRank(search_vector, search_query)
            ).filter(rank__gt=0).order_by('-rank')
        return BlogPost.objects.none()
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['query'] = self.request.GET.get('q', '')
        return context
```

```python
# urls.py
from django.urls import path
from .views import SearchBlogView

urlpatterns = [
    # Other URL patterns
    path('search/', SearchBlogView.as_view(), name='blog_search'),
]
```

Let's create a simple template for displaying search results:

```html
<!-- templates/blog/search_results.html -->
{% extends "base.html" %}

{% block content %}
<h1>Search Results</h1>
<div class="search-form">
    <form method="get" action="{% url 'blog_search' %}">
        <input type="text" name="q" value="{{ query }}" placeholder="Search blog...">
        <button type="submit">Search</button>
    </form>
</div>

<div class="results">
    <p>Found {{ paginator.count }} result{{ paginator.count|pluralize }} for "{{ query }}"</p>
    
    {% if results %}
        {% for post in results %}
        <article>
            <h2>{{ post.title }}</h2>
            <p>{{ post.content|truncatewords:50 }}</p>
            <p>By {{ post.author }} on {{ post.published_date|date:"F j, Y" }}</p>
        </article>
        {% endfor %}
    {% else %}
        <p>No results found.</p>
    {% endif %}
</div>

<!-- Pagination -->
{% if is_paginated %}
<nav>
    <ul class="pagination">
        {% if page_obj.has_previous %}
            <li><a href="?q={{ query }}&page={{ page_obj.previous_page_number }}">Previous</a></li>
        {% endif %}
        
        {% for num in page_obj.paginator.page_range %}
            <li {% if page_obj.number == num %}class="active"{% endif %}>
                <a href="?q={{ query }}&page={{ num }}">{{ num }}</a>
            </li>
        {% endfor %}
        
        {% if page_obj.has_next %}
            <li><a href="?q={{ query }}&page={{ page_obj.next_page_number }}">Next</a></li>
        {% endif %}
    </ul>
</nav>
{% endif %}
{% endblock %}
```

## Performance Optimization

Full-text search can be resource-intensive, especially on large datasets. Here are some optimization tips:

### 1. Create a Search Index

For PostgreSQL, you can create a GIN (Generalized Inverted Index) index to speed up full-text searches:

```python
# migrations/0002_add_search_index.py
from django.db import migrations

class Migration(migrations.Migration):
    dependencies = [
        ('blog', '0001_initial'),
    ]

    operations = [
        migrations.RunSQL(
            sql='''
            CREATE INDEX blogpost_search_idx
            ON blog_blogpost
            USING gin((to_tsvector('english', title) || to_tsvector('english', content)));
            ''',
            reverse_sql='DROP INDEX IF EXISTS blogpost_search_idx',
        ),
    ]
```

### 2. Use a Search Document

For complex models, pre-compute a search document field to avoid calculating vectors at query time:

```python
# models.py
from django.contrib.postgres.search import SearchVectorField
from django.contrib.postgres.indexes import GinIndex

class BlogPost(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.CharField(max_length=100)
    published_date = models.DateTimeField(auto_now_add=True)
    search_document = SearchVectorField(null=True)
    
    class Meta:
        indexes = [
            GinIndex(fields=['search_document'])
        ]
```

Then update the search document field with a signal or periodic task:

```python
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.contrib.postgres.search import SearchVector

@receiver(post_save, sender=BlogPost)
def update_search_vector(sender, instance, **kwargs):
    BlogPost.objects.filter(pk=instance.pk).update(
        search_document=SearchVector('title', weight='A') + SearchVector('content', weight='B')
    )
```

## Extending with Elasticsearch or Other Search Engines

While Django's built-in full-text search capabilities are powerful, for more advanced use cases or larger datasets, you might want to consider using dedicated search engines like Elasticsearch, Solr, or Whoosh.

Django integrates well with these tools through packages like:
- `django-elasticsearch-dsl`
- `django-haystack`

Here's a brief example of setting up Elasticsearch with Django (note that this requires additional setup):

```python
# Install required packages
# pip install elasticsearch django-elasticsearch-dsl

# settings.py
INSTALLED_APPS = [
    # ...
    'django_elasticsearch_dsl',
]

ELASTICSEARCH_DSL = {
    'default': {
        'hosts': 'localhost:9200'
    },
}

# documents.py
from django_elasticsearch_dsl import Document, fields
from django_elasticsearch_dsl.registries import registry
from .models import BlogPost

@registry.register_document
class BlogPostDocument(Document):
    class Index:
        name = 'blog_posts'
        settings = {
            'number_of_shards': 1,
            'number_of_replicas': 0
        }

    title = fields.TextField(
        attr='title',
        fields={
            'raw': fields.KeywordField(),
            'suggest': fields.CompletionField(),
        }
    )
    content = fields.TextField(attr='content')
    author = fields.TextField(attr='author')
    published_date = fields.DateField(attr='published_date')

    class Django:
        model = BlogPost
        fields = [
            'id',
        ]
```

## Summary

In this tutorial, you've learned:

1. What full-text search is and its advantages over simple lookups
2. How to implement basic full-text search in Django with PostgreSQL
3. Advanced techniques like ranking, weighting, and stemming
4. Performance optimization strategies
5. Integration with external search engines

Full-text search is a powerful tool that can significantly enhance the user experience of your Django applications by providing fast, relevant search results. Starting with Django's built-in capabilities provides a solid foundation, which you can later extend with specialized search engines as your application grows.

## Additional Resources

- [Django PostgreSQL Full Text Search Documentation](https://docs.djangoproject.com/en/stable/ref/contrib/postgres/search/)
- [PostgreSQL Full Text Search Documentation](https://www.postgresql.org/docs/current/textsearch.html)
- [Django Haystack Documentation](https://django-haystack.readthedocs.io/)
- [Elasticsearch Python Client](https://elasticsearch-py.readthedocs.io/)

## Exercises

1. Implement a simple blog application with full-text search using Django's built-in capabilities.
2. Add highlighting of search terms in the search results.
3. Implement an autocomplete feature using trigram similarity.
4. Create a custom ranking algorithm that also considers the post's publication date.
5. Benchmark the performance of your search implementation with different index configurations.

By mastering full-text search in Django, you'll be able to build more user-friendly applications that help users find exactly what they're looking for.