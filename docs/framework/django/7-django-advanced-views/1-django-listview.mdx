---
title: Django ListView
description: Learn how to use Django's ListView class-based view to display lists of objects with minimal code

---

# Django ListView

## Introduction

When building web applications, displaying lists of objects is one of the most common requirements. Whether it's a blog listing posts, an e-commerce site showing products, or a social media platform displaying user profiles, presenting collections of data is fundamental.

Django's `ListView` is a powerful class-based view that handles this common task efficiently. It takes care of fetching objects from the database, paginating them if needed, and rendering them to a template with very little code. In this tutorial, we'll explore how to use Django's `ListView` to create elegant list displays for your data.

## What is a ListView?

`ListView` is a generic class-based view provided by Django that displays a list of objects. It inherits from Django's `MultipleObjectTemplateResponseMixin` and `BaseListView` classes, providing a complete solution for displaying lists of model instances.

The basic workflow of a `ListView` is:

1. Fetch data from a model you specify
2. Paginate the data (if configured)
3. Pass the data to a template
4. Render the template with the data

The best part? Most of this happens automatically once you set up the view correctly.

## Basic Usage

Let's start with a simple example. Imagine we have a blog application with a `Post` model:

```python
# blog/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    pub_date = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.title
```

To create a view that lists all blog posts, we can use `ListView` like this:

```python
# blog/views.py
from django.views.generic import ListView
from .models import Post

class PostListView(ListView):
    model = Post
```

That's it! With just two lines of code (excluding imports), we've created a view that will:
- Query all `Post` objects from the database
- Pass them to a template
- Render the template with the posts

By default, the ListView will use a template named `<app_name>/<model_name>_list.html`. In our case, that would be `blog/post_list.html`. Let's create that template:

```html
<!-- blog/templates/blog/post_list.html -->
<h1>All Blog Posts</h1>

<ul>
  {% for post in object_list %}
    <li>
      <h2>{{ post.title }}</h2>
      <p>Published on {{ post.pub_date|date:"F j, Y" }}</p>
      <p>{{ post.content|truncatewords:30 }}</p>
    </li>
  {% empty %}
    <li>No posts yet.</li>
  {% endfor %}
</ul>
```

Finally, we need to add a URL for our view:

```python
# blog/urls.py
from django.urls import path
from .views import PostListView

urlpatterns = [
    path('posts/', PostListView.as_view(), name='post_list'),
]
```

Now when you navigate to `/posts/` in your browser, you'll see a list of all your blog posts.

## Customizing ListView

While the basic setup is incredibly simple, Django's `ListView` offers many customization options:

### Context Object Name

By default, `ListView` passes the list of objects to the template as `object_list`. You can specify a more meaningful name using the `context_object_name` attribute:

```python
class PostListView(ListView):
    model = Post
    context_object_name = 'posts'
```

Now in your template, you can use:

```html
{% for post in posts %}
  <!-- ... -->
{% endfor %}
```

### Custom Template

You can specify a custom template using the `template_name` attribute:

```python
class PostListView(ListView):
    model = Post
    template_name = 'blog/all_posts.html'
```

### Filtering Objects

Often, you'll want to display only a subset of objects rather than all of them. The `queryset` attribute lets you do just that:

```python
class PublishedPostListView(ListView):
    model = Post
    queryset = Post.objects.filter(status='published').order_by('-pub_date')
```

Alternatively, you can override the `get_queryset` method for more complex filtering:

```python
class CategoryPostListView(ListView):
    model = Post
    
    def get_queryset(self):
        category = self.kwargs['category']
        return Post.objects.filter(categories__name=category)
```

### Pagination

One of the most powerful features of `ListView` is built-in pagination. To enable it, just set the `paginate_by` attribute:

```python
class PostListView(ListView):
    model = Post
    paginate_by = 10  # Display 10 posts per page
```

In your template, you can now navigate between pages:

```html
<div class="pagination">
  <span class="step-links">
    {% if page_obj.has_previous %}
      <a href="?page=1">&laquo; first</a>
      <a href="?page={{ page_obj.previous_page_number }}">previous</a>
    {% endif %}

    <span class="current">
      Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}.
    </span>

    {% if page_obj.has_next %}
      <a href="?page={{ page_obj.next_page_number }}">next</a>
      <a href="?page={{ page_obj.paginator.num_pages }}">last &raquo;</a>
    {% endif %}
  </span>
</div>
```

### Adding Extra Context

Sometimes, you need to pass additional data to the template. You can override the `get_context_data` method:

```python
class PostListView(ListView):
    model = Post
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        return context
```

## Real-World Example

Let's build a more complete example of a product listing for an e-commerce site:

```python
# models.py
from django.db import models

class Category(models.Model):
    name = models.CharField(max_length=100)
    slug = models.SlugField(unique=True)
    
    def __str__(self):
        return self.name
        
class Product(models.Model):
    name = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    image = models.ImageField(upload_to='products/', blank=True)
    in_stock = models.BooleanField(default=True)
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='products')
    created = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name
```

```python
# views.py
from django.views.generic import ListView
from .models import Product, Category

class ProductListView(ListView):
    model = Product
    context_object_name = 'products'
    template_name = 'shop/product_list.html'
    paginate_by = 12
    
    def get_queryset(self):
        queryset = Product.objects.filter(in_stock=True)
        
        # Filter by category if provided in URL
        category_slug = self.kwargs.get('category_slug')
        if category_slug:
            queryset = queryset.filter(category__slug=category_slug)
            
        # Handle search query
        q = self.request.GET.get('q')
        if q:
            queryset = queryset.filter(name__icontains=q)
            
        return queryset.order_by('name')
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        
        # Add current category to context if we're filtering by category
        category_slug = self.kwargs.get('category_slug')
        if category_slug:
            context['current_category'] = Category.objects.get(slug=category_slug)
            
        return context
```

```python
# urls.py
from django.urls import path
from .views import ProductListView

urlpatterns = [
    path('products/', ProductListView.as_view(), name='product_list'),
    path('category/<slug:category_slug>/', ProductListView.as_view(), name='category_product_list'),
]
```

```html
<!-- shop/templates/shop/product_list.html -->
{% extends "base.html" %}

{% block content %}
<div class="shop-container">
  <div class="sidebar">
    <h3>Categories</h3>
    <ul>
      <li {% if not current_category %}class="active"{% endif %}>
        <a href="{% url 'product_list' %}">All Products</a>
      </li>
      {% for category in categories %}
        <li {% if current_category.slug == category.slug %}class="active"{% endif %}>
          <a href="{% url 'category_product_list' category.slug %}">{{ category.name }}</a>
        </li>
      {% endfor %}
    </ul>
    
    <form method="get" class="search-form">
      <input type="text" name="q" placeholder="Search products..." value="{{ request.GET.q }}">
      <button type="submit">Search</button>
    </form>
  </div>
  
  <div class="products-grid">
    <h1>
      {% if current_category %}
        {{ current_category.name }}
      {% else %}
        All Products
      {% endif %}
      {% if request.GET.q %}
        - Search results for "{{ request.GET.q }}"
      {% endif %}
    </h1>
    
    {% if products %}
      <div class="products">
        {% for product in products %}
          <div class="product-card">
            {% if product.image %}
              <img src="{{ product.image.url }}" alt="{{ product.name }}">
            {% endif %}
            <h3>{{ product.name }}</h3>
            <p class="price">${{ product.price }}</p>
            <a href="{% url 'product_detail' product.slug %}" class="btn">View Details</a>
          </div>
        {% endfor %}
      </div>
      
      {% include "shop/pagination.html" with page_obj=page_obj %}
    {% else %}
      <p>No products found.</p>
    {% endif %}
  </div>
</div>
{% endblock %}
```

This example shows how powerful `ListView` can be in a real application:
- It filters products based on category (from URL) and search query
- It adds categories to the context for the sidebar
- It includes pagination
- It provides appropriate messaging when no products are found

## Common Patterns and Best Practices

### 1. Request the ListView with Filters

You can use query parameters to filter results:

```python
class ProductListView(ListView):
    model = Product
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # Get filter parameters from request.GET
        min_price = self.request.GET.get('min_price')
        max_price = self.request.GET.get('max_price')
        
        if min_price:
            queryset = queryset.filter(price__gte=min_price)
        if max_price:
            queryset = queryset.filter(price__lte=max_price)
            
        return queryset
```

### 2. Use Class-Based View Mixins

Django's mixin system allows you to add functionality to your views:

```python
from django.contrib.auth.mixins import LoginRequiredMixin

class PrivatePostListView(LoginRequiredMixin, ListView):
    model = Post
    login_url = '/login/'  # Redirect to login page if user is not authenticated
```

### 3. Override get_template_names for Dynamic Templates

You can dynamically choose templates based on context:

```python
class FlexibleListView(ListView):
    model = Product
    
    def get_template_names(self):
        view_type = self.request.GET.get('view', 'grid')
        
        if view_type == 'list':
            return ['shop/product_list_view.html']
        else:
            return ['shop/product_grid_view.html']
```

## Summary

Django's `ListView` is an incredibly powerful and flexible tool for displaying collections of objects in your web application. With minimal code, you can create sophisticated listings that include:

- Object filtering and ordering
- Pagination
- Search functionality
- Category filtering
- Custom templates
- Additional context data

The beauty of class-based views like `ListView` is that they handle the repetitive tasks for you, letting you focus on the unique aspects of your application. As you become more comfortable with Django's generic views, you'll find yourself writing less code while building more powerful applications.

## Additional Resources

- [Django's Official Documentation on ListView](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-display/#django.views.generic.list.ListView)
- [Django's Class-Based Views Guide](https://docs.djangoproject.com/en/stable/topics/class-based-views/)
- [Django Pagination Documentation](https://docs.djangoproject.com/en/stable/topics/pagination/)

## Practice Exercises

1. Create a `ListView` for a music library that shows albums grouped by artist.
2. Implement a `ListView` with filter controls that allow users to filter a product list by multiple criteria (price range, category, rating, etc.).
3. Build a blog `ListView` that shows featured posts at the top and regular posts below, all within the same view.
4. Create a `ListView` that allows toggling between different display modes (grid/list/compact) using different templates.
5. Implement a `ListView` with AJAX pagination where clicking "Load More" fetches the next page of results without a full page reload.

Happy coding!