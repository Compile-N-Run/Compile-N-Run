---
title: Django Filter Views
description: Learn how to implement filtering functionality in Django views to allow users to search and filter data based on different criteria

---

# Django Filter Views

In web applications, users often need to search, sort, and filter data to find exactly what they're looking for. Django provides powerful mechanisms for implementing filtering functionality in your views, allowing users to dynamically narrow down query results based on various criteria.

## Introduction to Django Filtering

Filtering in Django refers to the process of narrowing down queryset results based on specific parameters. For example, in an e-commerce site, users might want to filter products by price range, category, or rating. In a blog, users might filter posts by date, author, or tags.

Django offers several approaches to implement filtering:

1. **Manual filtering**: Using query parameters and conditional logic
2. **Class-based views with mixins**: Extending Django's built-in views
3. **django-filter library**: A third-party package that simplifies complex filtering

Let's explore each of these approaches in detail.

## Basic Manual Filtering

The simplest way to implement filtering is by manually extracting query parameters and modifying your queryset accordingly.

### Example: Simple Product Filter

Imagine you have a product listing and want to allow filtering by category:

```python
# views.py
from django.shortcuts import render
from .models import Product

def product_list(request):
    products = Product.objects.all()
    
    # Get the category filter from query parameters
    category = request.GET.get('category')
    
    # Apply the filter if provided
    if category:
        products = products.filter(category=category)
    
    return render(request, 'products/product_list.html', {
        'products': products,
        'category': category,
    })
```

In your template, you might have a simple form that submits the filter:

```html
<!-- product_list.html -->
<form method="get">
    <label for="category">Filter by category:</label>
    <select name="category" id="category">
        <option value="">All categories</option>
        <option value="electronics" {% if category == 'electronics' %}selected{% endif %}>Electronics</option>
        <option value="books" {% if category == 'books' %}selected{% endif %}>Books</option>
        <option value="clothing" {% if category == 'clothing' %}selected{% endif %}>Clothing</option>
    </select>
    <button type="submit">Filter</button>
</form>

<!-- Display filtered products -->
<ul>
    {% for product in products %}
        <li>{{ product.name }} - {{ product.category }} - ${{ product.price }}</li>
    {% empty %}
        <li>No products found matching your criteria.</li>
    {% endfor %}
</ul>
```

### Multiple Filters

You can extend this approach to handle multiple filters:

```python
def product_list(request):
    products = Product.objects.all()
    
    # Get filter parameters
    category = request.GET.get('category')
    min_price = request.GET.get('min_price')
    max_price = request.GET.get('max_price')
    
    # Apply filters if provided
    if category:
        products = products.filter(category=category)
    
    if min_price:
        products = products.filter(price__gte=float(min_price))
    
    if max_price:
        products = products.filter(price__lte=float(max_price))
    
    return render(request, 'products/product_list.html', {
        'products': products,
        'category': category,
        'min_price': min_price,
        'max_price': max_price,
    })
```

While this approach works, it can quickly become unwieldy as the number of filters increases.

## Using Class-Based Views for Filtering

Class-based views (CBVs) offer a more structured approach to filtering. You can take advantage of methods like `get_queryset()` to apply filters.

```python
from django.views.generic import ListView
from .models import Product

class ProductListView(ListView):
    model = Product
    template_name = 'products/product_list.html'
    context_object_name = 'products'
    
    def get_queryset(self):
        queryset = super().get_queryset()
        
        # Apply filters from query parameters
        category = self.request.GET.get('category')
        min_price = self.request.GET.get('min_price')
        max_price = self.request.GET.get('max_price')
        
        if category:
            queryset = queryset.filter(category=category)
        
        if min_price:
            queryset = queryset.filter(price__gte=float(min_price))
        
        if max_price:
            queryset = queryset.filter(price__lte=float(max_price))
        
        return queryset
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Pass the current filter values to the template
        context['category'] = self.request.GET.get('category', '')
        context['min_price'] = self.request.GET.get('min_price', '')
        context['max_price'] = self.request.GET.get('max_price', '')
        return context
```

## The django-filter Library

For more complex filtering scenarios, the `django-filter` library provides a robust solution. It's especially useful when you need to:

- Apply multiple filters across related models
- Support different filter types (exact, contains, greater than, etc.)
- Implement complex search forms

### Installation and Setup

First, install the library:

```bash
pip install django-filter
```

Add it to your installed apps:

```python
# settings.py
INSTALLED_APPS = [
    # ...
    'django_filters',
    # ...
]
```

### Creating a FilterSet

A `FilterSet` is similar to a Django Form - it defines the fields you want to filter on and how they should be filtered:

```python
# filters.py
import django_filters
from .models import Product

class ProductFilter(django_filters.FilterSet):
    name = django_filters.CharFilter(lookup_expr='icontains', label='Product Name')
    category = django_filters.ChoiceFilter(choices=Product.CATEGORY_CHOICES)
    min_price = django_filters.NumberFilter(field_name='price', lookup_expr='gte', label='Min Price')
    max_price = django_filters.NumberFilter(field_name='price', lookup_expr='lte', label='Max Price')
    
    class Meta:
        model = Product
        fields = ['name', 'category', 'min_price', 'max_price']
```

### Using the FilterSet in a View

You can use the FilterSet with a function-based view:

```python
# views.py
from django.shortcuts import render
from .models import Product
from .filters import ProductFilter

def product_list(request):
    products = Product.objects.all()
    product_filter = ProductFilter(request.GET, queryset=products)
    
    return render(request, 'products/product_list.html', {
        'filter': product_filter,
    })
```

Or with a class-based view:

```python
# views.py
from django_filters.views import FilterView
from .models import Product
from .filters import ProductFilter

class ProductListView(FilterView):
    model = Product
    template_name = 'products/product_list.html'
    filterset_class = ProductFilter
    paginate_by = 10  # Enable pagination
```

### In the Template

To display the filter form and filtered results:

```html
<!-- product_list.html -->
<form method="get">
    {{ filter.form.as_p }}
    <button type="submit">Filter</button>
</form>

<h2>Products</h2>
<ul>
    {% for product in filter.qs %}
        <li>{{ product.name }} - {{ product.category }} - ${{ product.price }}</li>
    {% empty %}
        <li>No products found matching your criteria.</li>
    {% endfor %}
</ul>
```

## Advanced Filtering Techniques

### Custom Filter Fields

The `django-filter` library allows you to create custom filter fields for specific needs:

```python
class ProductFilter(django_filters.FilterSet):
    # Custom price range filter
    price_range = django_filters.ChoiceFilter(
        choices=[
            ('budget', 'Budget (Under $20)'),
            ('mid', 'Mid-range ($20-$100)'),
            ('premium', 'Premium (Over $100)'),
        ],
        method='filter_price_range',
        label='Price Range',
    )
    
    def filter_price_range(self, queryset, name, value):
        if value == 'budget':
            return queryset.filter(price__lt=20)
        elif value == 'mid':
            return queryset.filter(price__gte=20, price__lte=100)
        elif value == 'premium':
            return queryset.filter(price__gt=100)
        return queryset
```

### Date-based Filtering

For filtering by dates, `django-filter` provides specialized fields:

```python
class PostFilter(django_filters.FilterSet):
    start_date = django_filters.DateFilter(field_name='published_date', lookup_expr='gte')
    end_date = django_filters.DateFilter(field_name='published_date', lookup_expr='lte')
    
    class Meta:
        model = BlogPost
        fields = ['author', 'category', 'start_date', 'end_date']
```

### Filtering Related Models

You can filter based on related models using double underscores, just like in Django querysets:

```python
class OrderFilter(django_filters.FilterSet):
    customer_name = django_filters.CharFilter(field_name='customer__name', lookup_expr='icontains')
    product_category = django_filters.CharFilter(field_name='items__product__category', lookup_expr='exact')
    
    class Meta:
        model = Order
        fields = ['status', 'customer_name', 'product_category']
```

## Real-World Example: Product Catalog with Filters

Let's create a complete example of a product catalog with filtering:

1. First, let's define our models:

```python
# models.py
from django.db import models

class Category(models.Model):
    name = models.CharField(max_length=100)
    
    def __str__(self):
        return self.name

class Product(models.Model):
    name = models.CharField(max_length=200)
    category = models.ForeignKey(Category, on_delete=models.CASCADE, related_name='products')
    price = models.DecimalField(max_digits=10, decimal_places=2)
    description = models.TextField()
    in_stock = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.name
```

2. Create the filter class:

```python
# filters.py
import django_filters
from .models import Product, Category

class ProductFilter(django_filters.FilterSet):
    name = django_filters.CharFilter(lookup_expr='icontains', label='Product Name')
    min_price = django_filters.NumberFilter(field_name='price', lookup_expr='gte', label='Min Price')
    max_price = django_filters.NumberFilter(field_name='price', lookup_expr='lte', label='Max Price')
    category = django_filters.ModelChoiceFilter(queryset=Category.objects.all())
    in_stock = django_filters.BooleanFilter()
    
    class Meta:
        model = Product
        fields = ['name', 'category', 'min_price', 'max_price', 'in_stock']
```

3. Create the view:

```python
# views.py
from django_filters.views import FilterView
from .models import Product
from .filters import ProductFilter

class ProductListView(FilterView):
    model = Product
    template_name = 'products/product_list.html'
    filterset_class = ProductFilter
    paginate_by = 12  # Show 12 products per page
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['total_products'] = self.object_list.count()
        return context
```

4. Configure the URL:

```python
# urls.py
from django.urls import path
from .views import ProductListView

urlpatterns = [
    path('products/', ProductListView.as_view(), name='product_list'),
]
```

5. Create the template:

```html
<!-- product_list.html -->
{% extends "base.html" %}

{% block content %}
<div class="container">
    <div class="row">
        <!-- Sidebar with filters -->
        <div class="col-md-3">
            <h3>Filter Products</h3>
            <form method="get">
                {{ filter.form.as_p }}
                <button type="submit" class="btn btn-primary">Apply Filters</button>
                <a href="{% url 'product_list' %}" class="btn btn-secondary">Clear Filters</a>
            </form>
        </div>
        
        <!-- Product grid -->
        <div class="col-md-9">
            <h1>Products</h1>
            <p>Found {{ total_products }} products matching your criteria</p>
            
            <div class="row row-cols-1 row-cols-md-3">
                {% for product in filter.qs %}
                    <div class="col mb-4">
                        <div class="card h-100">
                            <div class="card-body">
                                <h5 class="card-title">{{ product.name }}</h5>
                                <h6 class="card-subtitle mb-2 text-muted">{{ product.category.name }}</h6>
                                <p class="card-text">${{ product.price }}</p>
                                <p class="card-text">{{ product.description|truncatewords:15 }}</p>
                                {% if product.in_stock %}
                                    <span class="badge bg-success">In Stock</span>
                                {% else %}
                                    <span class="badge bg-danger">Out of Stock</span>
                                {% endif %}
                            </div>
                        </div>
                    </div>
                {% empty %}
                    <div class="col-12">
                        <div class="alert alert-info">
                            No products found matching your criteria.
                        </div>
                    </div>
                {% endfor %}
            </div>
            
            <!-- Pagination -->
            {% if is_paginated %}
            <nav aria-label="Page navigation">
                <ul class="pagination">
                    {% if page_obj.has_previous %}
                        <li class="page-item">
                            <a class="page-link" href="?{% if request.GET.urlencode %}{{ request.GET.urlencode }}&{% endif %}page={{ page_obj.previous_page_number }}">Previous</a>
                        </li>
                    {% endif %}
                    
                    {% for num in page_obj.paginator.page_range %}
                        <li class="page-item {% if num == page_obj.number %}active{% endif %}">
                            <a class="page-link" href="?{% if request.GET.urlencode %}{{ request.GET.urlencode }}&{% endif %}page={{ num }}">{{ num }}</a>
                        </li>
                    {% endfor %}
                    
                    {% if page_obj.has_next %}
                        <li class="page-item">
                            <a class="page-link" href="?{% if request.GET.urlencode %}{{ request.GET.urlencode }}&{% endif %}page={{ page_obj.next_page_number }}">Next</a>
                        </li>
                    {% endif %}
                </ul>
            </nav>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}
```

This example demonstrates a complete implementation of a product catalog with filtering, including:

- Multiple filter types (text search, numeric range, boolean, dropdown)
- Pagination
- Responsive grid layout
- Filter form with apply and clear buttons
- Result count display

## Summary

Django Filter Views provide powerful tools to help users find exactly what they're looking for in your application:

1. **Basic manual filtering** is suitable for simple applications with few filter options
2. **Class-based views** offer a cleaner, more organized approach to filtering
3. **The django-filter library** simplifies complex filtering scenarios and provides a consistent API

When implementing filtering in your Django applications, consider:

- The complexity of your filtering needs
- The user experience and interface for applying filters
- Performance implications for large datasets
- Whether to combine filtering with other features like pagination and sorting

By implementing effective filtering in your Django views, you empower your users to efficiently navigate and search through large datasets, improving the overall usability of your application.

## Additional Resources and Exercises

### Resources
- [Django Filter Documentation](https://django-filter.readthedocs.io/)
- [Django QuerySet Reference](https://docs.djangoproject.com/en/stable/ref/models/querysets/)
- [Django Class-Based Views](https://docs.djangoproject.com/en/stable/topics/class-based-views/)

### Exercises

1. **Basic Filter**: Create a blog application with posts that can be filtered by category and date range.

2. **Advanced Filter**: Extend the product catalog example to include filters for related models (e.g., filter products by manufacturer country).

3. **Filter Form Styling**: Improve the UX of a filter form by implementing collapsible sections and range sliders for numeric filters.

4. **Filter Performance**: Implement database-level optimizations (indexes, select_related/prefetch_related) to improve the performance of filtered queries on a large dataset.

5. **Custom Filter**: Create a custom filter field that enables geographical filtering (e.g., "find products within X miles of a zip code").