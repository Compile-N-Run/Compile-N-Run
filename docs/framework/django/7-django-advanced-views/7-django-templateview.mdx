---
title: Django TemplateView
description: Learn how to use Django's TemplateView class-based view to simplify rendering templates with context data, customizing behavior, and implementing real-world applications.

---

# Django TemplateView

In Django's ecosystem of class-based views (CBVs), `TemplateView` stands out as one of the most straightforward yet powerful options for rendering templates. If you're making the transition from function-based views to class-based views, understanding `TemplateView` is an excellent starting point.

## What is TemplateView?

`TemplateView` is a class-based view that renders a template with a context. It's part of Django's generic views system and is designed for cases where you simply need to render a template with some context data. Unlike function-based views where you need to manually load a template, render it with a context, and return an HTTP response, `TemplateView` handles all of this for you.

The basic flow of a `TemplateView` is:

1. Receive an HTTP request
2. Process any context data
3. Render a template with the context
4. Return the rendered template as an HTTP response

## Basic Usage of TemplateView

Let's start with a simple example of using `TemplateView`:

```python
# views.py
from django.views.generic import TemplateView

class HomePageView(TemplateView):
    template_name = "home.html"
```

In your URLconf (urls.py):

```python
# urls.py
from django.urls import path
from .views import HomePageView

urlpatterns = [
    path('', HomePageView.as_view(), name='home'),
]
```

Then in your template:

```html
<!-- templates/home.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Home Page</title>
</head>
<body>
    <h1>Welcome to the Home Page</h1>
</body>
</html>
```

This simple implementation will render the `home.html` template when a user visits the root URL of your site.

## Adding Context Data

One of the primary advantages of `TemplateView` is the ease with which you can add context data to your template. There are two main ways to do this:

### 1. Using get_context_data()

```python
from django.views.generic import TemplateView

class AboutPageView(TemplateView):
    template_name = "about.html"
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = "About Us"
        context['team_members'] = [
            {'name': 'Alice', 'role': 'Developer'},
            {'name': 'Bob', 'role': 'Designer'},
            {'name': 'Charlie', 'role': 'Project Manager'}
        ]
        return context
```

In the template, you can now access these context variables:

```html
<!-- templates/about.html -->
<!DOCTYPE html>
<html>
<head>
    <title>{{ title }}</title>
</head>
<body>
    <h1>{{ title }}</h1>
    
    <h2>Our Team:</h2>
    <ul>
        {% for member in team_members %}
            <li>{{ member.name }} - {{ member.role }}</li>
        {% endfor %}
    </ul>
</body>
</html>
```

### 2. Using extra_context attribute

For simpler cases, you can use the `extra_context` attribute to provide context data:

```python
from django.views.generic import TemplateView

class ContactPageView(TemplateView):
    template_name = "contact.html"
    extra_context = {
        'title': 'Contact Us',
        'email': 'contact@example.com',
        'phone': '+1 (555) 123-4567'
    }
```

However, note that `extra_context` is best suited for static data, as its values are evaluated only once when the server starts.

## Handling GET and POST Requests

While `TemplateView` is primarily designed for GET requests, you can override its methods to handle POST requests as well:

```python
from django.views.generic import TemplateView
from django.http import HttpResponseRedirect
from django.urls import reverse

class FeedbackView(TemplateView):
    template_name = "feedback.html"
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['message'] = "We value your feedback!"
        return context
    
    def post(self, request, *args, **kwargs):
        # Process the form data
        feedback = request.POST.get('feedback', '')
        # Save feedback to database or send email...
        
        # Redirect to a thank you page
        return HttpResponseRedirect(reverse('feedback_thank_you'))
```

With the corresponding template:

```html
<!-- templates/feedback.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Feedback</title>
</head>
<body>
    <h1>Feedback</h1>
    <p>{{ message }}</p>
    
    <form method="post">
        {% csrf_token %}
        <textarea name="feedback" rows="5" cols="40" placeholder="Your feedback here..."></textarea>
        <br>
        <button type="submit">Submit</button>
    </form>
</body>
</html>
```

## Advanced Usage: Multiple Templates Based on Conditions

You can dynamically select which template to render based on certain conditions:

```python
from django.views.generic import TemplateView

class DashboardView(TemplateView):
    
    def get_template_names(self):
        if self.request.user.is_superuser:
            return ["dashboard/admin.html"]
        elif self.request.user.is_staff:
            return ["dashboard/staff.html"]
        else:
            return ["dashboard/user.html"]
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        user = self.request.user
        context['username'] = user.username
        
        if user.is_superuser:
            context['access_level'] = "Admin"
        elif user.is_staff:
            context['access_level'] = "Staff"
        else:
            context['access_level'] = "User"
        
        return context
```

## Real-World Example: Company Landing Page

Let's implement a more complex example of a company's landing page with multiple sections:

```python
from django.views.generic import TemplateView
from .models import Testimonial, Feature, TeamMember

class LandingPageView(TemplateView):
    template_name = "landing_page.html"
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        # Fetch data from database
        context['testimonials'] = Testimonial.objects.filter(is_active=True)[:3]
        context['features'] = Feature.objects.all()
        context['team_members'] = TeamMember.objects.filter(show_on_landing=True)
        
        # Analytics data
        context['users_count'] = 10000
        context['countries_count'] = 50
        context['satisfaction_rate'] = 98
        
        return context
```

Then in your landing page template:

```html
<!-- templates/landing_page.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Welcome to Our Company</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Our Amazing Product</h1>
        <p>Solving problems for businesses worldwide</p>
    </header>
    
    <section id="features">
        <h2>Key Features</h2>
        <div class="features-grid">
            {% for feature in features %}
                <div class="feature-card">
                    <h3>{{ feature.title }}</h3>
                    <p>{{ feature.description }}</p>
                    {% if feature.icon %}
                        <img src="{{ feature.icon.url }}" alt="{{ feature.title }}">
                    {% endif %}
                </div>
            {% endfor %}
        </div>
    </section>
    
    <section id="testimonials">
        <h2>What Our Customers Say</h2>
        <div class="testimonials-slider">
            {% for testimonial in testimonials %}
                <div class="testimonial">
                    <blockquote>{{ testimonial.content }}</blockquote>
                    <p class="author">â€” {{ testimonial.author }}, {{ testimonial.company }}</p>
                </div>
            {% endfor %}
        </div>
    </section>
    
    <section id="analytics">
        <h2>Our Impact</h2>
        <div class="stats">
            <div class="stat">
                <h3>{{ users_count }}+</h3>
                <p>Happy Users</p>
            </div>
            <div class="stat">
                <h3>{{ countries_count }}</h3>
                <p>Countries</p>
            </div>
            <div class="stat">
                <h3>{{ satisfaction_rate }}%</h3>
                <p>Satisfaction Rate</p>
            </div>
        </div>
    </section>
    
    <section id="team">
        <h2>Our Team</h2>
        <div class="team-grid">
            {% for member in team_members %}
                <div class="team-member">
                    {% if member.photo %}
                        <img src="{{ member.photo.url }}" alt="{{ member.name }}">
                    {% endif %}
                    <h3>{{ member.name }}</h3>
                    <p>{{ member.position }}</p>
                </div>
            {% endfor %}
        </div>
    </section>
    
    <footer>
        <p>&copy; {% now "Y" %} Our Company. All rights reserved.</p>
    </footer>
</body>
</html>
```

## Performance Considerations

When using `TemplateView` with database queries, be mindful of the following:

1. **Query Optimization**: If you're fetching data from the database, optimize your queries to avoid N+1 query problems by using `select_related()` and `prefetch_related()`.

```python
# Optimize queries in get_context_data
def get_context_data(self, **kwargs):
    context = super().get_context_data(**kwargs)
    
    # Efficient querying with prefetch_related
    context['articles'] = Article.objects.prefetch_related('author', 'categories').all()
    
    return context
```

2. **Caching**: For templates that don't change frequently, consider using Django's caching framework:

```python
from django.views.decorators.cache import cache_page
from django.utils.decorators import method_decorator

@method_decorator(cache_page(60 * 15))  # Cache for 15 minutes
class StatsView(TemplateView):
    template_name = "stats.html"
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        # Expensive database computations here
        return context
```

## Summary

Django's `TemplateView` is a powerful tool that simplifies the process of rendering templates with context data. Its key advantages include:

- Simple implementation for basic template rendering
- Flexible context handling with `get_context_data()` method
- Ability to override methods like `get` and `post` for custom behavior
- Support for dynamic template selection

By understanding and leveraging `TemplateView`, you can write cleaner, more maintainable code for your Django applications, especially for pages that primarily display information without complex forms or data processing.

## Exercises

1. Create a `TemplateView` that displays different content based on the time of day (morning, afternoon, evening).
2. Implement a `TemplateView` for a FAQ page that fetches questions and answers from a database model.
3. Extend a `TemplateView` to handle a simple contact form submission without using Django forms.
4. Create a dashboard `TemplateView` that displays different statistics based on user permissions.
5. Implement a `TemplateView` that uses context processors to provide additional context data.

## Additional Resources

- [Django Documentation on TemplateView](https://docs.djangoproject.com/en/stable/ref/class-based-views/base/#templateview)
- [Django Class-Based Views Guide](https://docs.djangoproject.com/en/stable/topics/class-based-views/)
- [Django Templates Documentation](https://docs.djangoproject.com/en/stable/topics/templates/)
- [Class-Based Views - Classy Django](https://ccbv.co.uk/projects/Django/latest/django.views.generic.base/TemplateView/)

Understanding `TemplateView` is your first step toward mastering Django's class-based views ecosystem, which includes more specialized views like `ListView`, `DetailView`, and `FormView` that we'll explore in future tutorials.