---
title: Django CreateView
description: Learn how to use Django's powerful CreateView class-based view to handle form creation and data submission in your web applications.

---

# Django CreateView

In Django web development, handling form submissions and creating new database records is a common task. Django's `CreateView` is a powerful class-based view that simplifies this process by handling form display, validation, and object creation with minimal code. This tutorial will guide you through using `CreateView` to build efficient and maintainable form handling in your Django applications.

## What is CreateView?

`CreateView` is a class-based view in Django that specializes in displaying a form to the user, processing the submitted data, and creating a new instance of a model. It inherits from Django's `FormView` and adds model-specific functionality.

The main benefits of using `CreateView` include:

- **Reduced boilerplate code**: You don't need to manually handle form validation and saving
- **Consistent patterns**: Follows Django's conventions for form processing 
- **Built-in features**: Includes success redirects, template selection, and more

## Basic Syntax and Usage

Let's start with a basic example. Imagine you have a blog application with a `Post` model and want to create a view for adding new posts.

First, let's define our model:

```python
# models.py
from django.db import models
from django.urls import reverse

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.title
        
    def get_absolute_url(self):
        return reverse('post-detail', kwargs={'pk': self.pk})
```

Now, let's create a `CreateView` for this model:

```python
# views.py
from django.views.generic.edit import CreateView
from django.urls import reverse_lazy
from .models import Post

class PostCreateView(CreateView):
    model = Post
    fields = ['title', 'content']
    # Optional: Specify a template
    template_name = 'blog/post_form.html'
    # Optional: Specify where to redirect after successful form submission
    success_url = reverse_lazy('post-list')
```

The corresponding URL pattern:

```python
# urls.py
from django.urls import path
from .views import PostCreateView

urlpatterns = [
    path('post/new/', PostCreateView.as_view(), name='post-new'),
    # other URL patterns...
]
```

Finally, let's create a simple template:

```html
<!-- templates/blog/post_form.html -->
{% extends "base.html" %}

{% block content %}
<h1>Create New Post</h1>
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Create</button>
</form>
{% endblock %}
```

With just these few code snippets, you've created a complete feature to add new blog posts!

## How CreateView Works Behind the Scenes

When a user accesses a `CreateView`, the following process occurs:

1. **GET request**: The view creates an instance of the form and renders the template.
2. **POST request**: The view:
   - Creates a form instance with the submitted data
   - Validates the form
   - If valid, saves the new object and redirects to the success URL
   - If invalid, re-renders the form with error messages

Here's a diagram representing this flow:

```
User Request -> GET? -> (Yes) -> Display Empty Form
                |
                v
              (No/POST)
                |
                v
           Validate Form -> Invalid -> Display Form with Errors
                |
                v
              Valid
                |
                v
          Save Object -> Redirect to Success URL
```

## Customizing CreateView

While the basic implementation is simple, `CreateView` can be extensively customized to meet complex requirements.

### Specifying Fields

You can specify which fields should be included in the form using the `fields` attribute. There are two ways to do this:

```python
# Option 1: List specific fields
class PostCreateView(CreateView):
    model = Post
    fields = ['title', 'content']  # Only include these fields

# Option 2: Include all fields
class PostCreateView(CreateView):
    model = Post
    fields = '__all__'  # Include all model fields
```

### Using a Custom Form

For more control over your form's behavior, you can use a custom form class:

```python
# forms.py
from django import forms
from .models import Post

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ['title', 'content']
        
    def clean_title(self):
        title = self.cleaned_data['title']
        if 'Django' not in title:
            raise forms.ValidationError("Post must be about Django")
        return title

# views.py
from .forms import PostForm

class PostCreateView(CreateView):
    model = Post
    form_class = PostForm
    template_name = 'blog/post_form.html'
```

### Overriding Methods

You can override various methods to customize behavior:

```python
class PostCreateView(CreateView):
    model = Post
    fields = ['title', 'content']
    
    def form_valid(self, form):
        # The form is valid, modify the object here
        form.instance.author = self.request.user  # Set the author to current user
        return super().form_valid(form)
    
    def form_invalid(self, form):
        # The form is invalid, add custom error handling
        return super().form_invalid(form)
    
    def get_success_url(self):
        # Dynamic success URL 
        return reverse('post-detail', kwargs={'pk': self.object.pk})
    
    def get_initial(self):
        # Provide initial data for the form
        return {'title': 'My new Django post'}
```

### Success URLs and Messages

You can specify where to redirect after a successful form submission:

```python
from django.contrib import messages

class PostCreateView(CreateView):
    model = Post
    fields = ['title', 'content']
    success_url = reverse_lazy('post-list')
    
    def form_valid(self, form):
        messages.success(self.request, "Post created successfully!")
        return super().form_valid(form)
```

## Real-World Example: A Complete Blog Post Creation System

Let's build a more complete example that incorporates multiple concepts:

```python
# models.py
from django.db import models
from django.urls import reverse
from django.contrib.auth.models import User

class Category(models.Model):
    name = models.CharField(max_length=100)
    
    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    published = models.BooleanField(default=False)
    
    def __str__(self):
        return self.title
        
    def get_absolute_url(self):
        return reverse('post-detail', kwargs={'pk': self.pk})

# forms.py
from django import forms
from .models import Post, Category

class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ['title', 'content', 'category', 'published']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control'}),
            'content': forms.Textarea(attrs={'class': 'form-control'}),
            'category': forms.Select(attrs={'class': 'form-control'}),
        }
        
# views.py
from django.views.generic.edit import CreateView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse_lazy
from django.contrib import messages
from .models import Post
from .forms import PostForm

class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post
    form_class = PostForm
    template_name = 'blog/post_form.html'
    
    def form_valid(self, form):
        # Set the author automatically to the current user
        form.instance.author = self.request.user
        messages.success(self.request, "Your post has been created!")
        return super().form_valid(form)
    
    def get_context_data(self, **kwargs):
        # Add extra context if needed
        context = super().get_context_data(**kwargs)
        context['page_title'] = 'Create New Blog Post'
        return context
```

The corresponding template:

```html
<!-- templates/blog/post_form.html -->
{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <h1>{{ page_title }}</h1>
    
    {% if messages %}
    <div class="messages">
        {% for message in messages %}
        <div class="alert alert-{{ message.tags }}">
            {{ message }}
        </div>
        {% endfor %}
    </div>
    {% endif %}
    
    <form method="post" class="mt-3">
        {% csrf_token %}
        
        <div class="form-group">
            <label for="{{ form.title.id_for_label }}">Title:</label>
            {{ form.title }}
            {{ form.title.errors }}
        </div>
        
        <div class="form-group mt-3">
            <label for="{{ form.content.id_for_label }}">Content:</label>
            {{ form.content }}
            {{ form.content.errors }}
        </div>
        
        <div class="form-group mt-3">
            <label for="{{ form.category.id_for_label }}">Category:</label>
            {{ form.category }}
            {{ form.category.errors }}
        </div>
        
        <div class="form-check mt-3">
            {{ form.published }}
            <label class="form-check-label" for="{{ form.published.id_for_label }}">
                Publish immediately
            </label>
        </div>
        
        <button type="submit" class="btn btn-primary mt-3">Create Post</button>
    </form>
</div>
{% endblock %}
```

This example includes:

1. A form with custom widgets and styling
2. User authentication via the `LoginRequiredMixin`
3. Automatic author assignment
4. Success messages
5. Additional context data for the template

## Best Practices for Using CreateView

When working with `CreateView`, keep these best practices in mind:

1. **Use LoginRequiredMixin** for views that should only be accessible to authenticated users.
2. **Override form_valid()** to perform additional actions after successful validation.
3. **Implement get_absolute_url()** in your models for easier redirection after successful form submission.
4. **Use custom forms** for complex validation and field customization.
5. **Add success messages** to provide feedback to users.
6. **Be explicit with fields** rather than using `fields = '__all__'` to prevent security issues.

## Common Patterns and Solutions

### File Uploads

To handle file uploads in your `CreateView`:

```python
# models.py
class Post(models.Model):
    # ... other fields
    image = models.ImageField(upload_to='blog_images/', blank=True)

# templates/blog/post_form.html
<form method="post" enctype="multipart/form-data">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Create</button>
</form>

# views.py
class PostCreateView(CreateView):
    model = Post
    fields = ['title', 'content', 'image']
    # ... other attributes and methods
```

### Initial Values

To provide initial values for your form:

```python
class PostCreateView(CreateView):
    model = Post
    fields = ['title', 'content', 'category']
    
    def get_initial(self):
        initial = super().get_initial()
        initial['category'] = self.request.GET.get('category', None)
        return initial
```

### Form Field Ordering

To change the order of fields in your form:

```python
# forms.py
class PostForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ['title', 'category', 'content', 'published']
```

## Summary

Django's `CreateView` is a powerful tool that simplifies the process of creating new objects in your application. By leveraging this class-based view:

- You save time by avoiding repetitive form processing code
- You gain a consistent pattern for handling form submissions
- You have clear extension points for customizing behavior

The view handles the entire life cycle of form rendering, validation, and object creation, making your code more maintainable and easier to understand.

## Additional Resources

- [Django Official Documentation on CreateView](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-editing/#createview)
- [Django Forms Documentation](https://docs.djangoproject.com/en/stable/topics/forms/)
- [Class-Based Views Guide](https://ccbv.co.uk/projects/Django/latest/django.views.generic.edit/CreateView/)

## Practice Exercises

1. Create a simple contact form using `CreateView` that sends an email when submitted.
2. Build a multi-step form using `CreateView` and session storage.
3. Implement file uploads with validation in a `CreateView`.
4. Create a view that allows users to create a profile after registration.
5. Build a comment system for a blog using `CreateView` with proper user permissions.

By mastering Django's `CreateView`, you'll be able to implement form handling efficiently and follow Django's "don't repeat yourself" principle throughout your projects.