---
title: Django Function-Based Views
description: Learn how to create and use function-based views in Django for handling HTTP requests and generating HTTP responses.

---

# Django Function-Based Views

## Introduction

Function-based views (FBVs) are one of the primary ways to handle HTTP requests in Django. They're simply Python functions that take a web request and return a web response. This approach is straightforward, making it an excellent starting point for beginners.

In this tutorial, we'll explore how to create function-based views in Django, understand their structure, and implement them in real-world scenarios.

## What are Function-Based Views?

At their core, Django views are responsible for:
1. Receiving an HTTP request
2. Processing that request (often interacting with the database)
3. Returning an HTTP response

A function-based view is just a regular Python function that takes at least one argument, `request` (an instance of `HttpRequest`), and returns an instance of `HttpResponse`.

## Basic Structure of a Function-Based View

Here's the simplest function-based view you can create:

```python
from django.http import HttpResponse

def hello_world(request):
    return HttpResponse("Hello, World!")
```

This view receives a request and returns a response with the text "Hello, World!". 

## Creating Your First Function-Based View

Let's create a simple project to demonstrate function-based views. We'll assume you have Django installed and have set up a project named `myproject` with an app called `myapp`.

### Step 1: Define the View

In `myapp/views.py`:

```python
from django.http import HttpResponse

def home_page(request):
    return HttpResponse("<h1>Welcome to My Django Site</h1>")

def about_page(request):
    return HttpResponse("<h1>About Us</h1><p>This is a simple Django website.</p>")
```

### Step 2: Map URLs to Views

Create a file called `urls.py` in your app directory if it doesn't exist already:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home_page, name='home'),
    path('about/', views.about_page, name='about'),
]
```

### Step 3: Include App URLs in Project URLs

Make sure your project's `urls.py` includes your app's URLs:

```python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),
]
```

Now if you run your Django server and visit the homepage, you'll see "Welcome to My Django Site", and if you visit `/about/`, you'll see the about page content.

## Handling Different HTTP Methods

Function-based views can handle different HTTP methods (GET, POST, etc.) using conditional statements:

```python
from django.http import HttpResponse

def contact_form(request):
    if request.method == 'POST':
        # Process the form submission
        name = request.POST.get('name', '')
        email = request.POST.get('email', '')
        message = request.POST.get('message', '')
        
        # In a real app, you might save this to a database or send an email
        return HttpResponse(f"Thank you, {name}! We received your message.")
    else:
        # Display the empty form
        form_html = """
        <h1>Contact Us</h1>
        <form method="post">
            <input type="text" name="name" placeholder="Your Name"><br>
            <input type="email" name="email" placeholder="Your Email"><br>
            <textarea name="message" placeholder="Your Message"></textarea><br>
            <button type="submit">Send</button>
        </form>
        """
        return HttpResponse(form_html)
```

Don't forget to add this view to your URL patterns.

### CSRF Protection

In a real Django application, you'll need to include CSRF protection for your forms. Django simplifies this with the `csrf_exempt` decorator for testing or the `{% csrf_token %}` template tag in templates.

## Working with Templates

Rather than returning HTML directly in our views, it's better to use Django's template system:

```python
from django.shortcuts import render

def product_page(request):
    # Data that we want to display in the template
    product = {
        'name': 'Django T-shirt',
        'price': 19.99,
        'description': 'Show your Django love with this cool t-shirt!',
        'in_stock': True
    }
    
    # Render the template with the data
    return render(request, 'myapp/product.html', {'product': product})
```

Then create a template file at `myapp/templates/myapp/product.html`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>{{ product.name }}</title>
</head>
<body>
    <h1>{{ product.name }}</h1>
    <p>Price: ${{ product.price }}</p>
    <p>{{ product.description }}</p>
    
    {% if product.in_stock %}
        <button>Add to Cart</button>
    {% else %}
        <p>Out of stock</p>
    {% endif %}
</body>
</html>
```

## Working with Models

Function-based views often interact with Django models to access or modify data:

```python
from django.shortcuts import render, get_object_or_404, redirect
from .models import BlogPost
from .forms import BlogPostForm

def blog_list(request):
    # Get all blog posts
    posts = BlogPost.objects.all().order_by('-created_at')
    return render(request, 'myapp/blog_list.html', {'posts': posts})

def blog_detail(request, post_id):
    # Get a specific blog post or return a 404 error
    post = get_object_or_404(BlogPost, id=post_id)
    return render(request, 'myapp/blog_detail.html', {'post': post})

def blog_create(request):
    if request.method == 'POST':
        form = BlogPostForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('blog_list')
    else:
        form = BlogPostForm()
    return render(request, 'myapp/blog_form.html', {'form': form})
```

To make this work, you'd need to:
1. Create the `BlogPost` model
2. Create a `BlogPostForm` using Django's forms framework
3. Create the mentioned templates
4. Define appropriate URL patterns

## Decorators with Function-Based Views

Django provides decorators to add functionality to views:

### 1. Login Required

```python
from django.contrib.auth.decorators import login_required

@login_required
def profile(request):
    # This view will only be accessible to logged-in users
    return render(request, 'myapp/profile.html')
```

### 2. Permission Required

```python
from django.contrib.auth.decorators import permission_required

@permission_required('myapp.can_publish')
def publish_article(request):
    # This view requires the user to have the 'can_publish' permission
    # Logic to publish an article
    return redirect('article_list')
```

### 3. Require HTTP Methods

```python
from django.views.decorators.http import require_http_methods

@require_http_methods(["GET", "POST"])
def my_view(request):
    # This view only accepts GET and POST requests
    if request.method == 'POST':
        # Process form
        pass
    else:
        # Display form
        pass
    return HttpResponse("OK")
```

## Real-World Example: A Simple Blog Application

Let's put everything together in a more complete example. We'll build simple views for a blog application:

### Models (models.py)

```python
from django.db import models
from django.contrib.auth.models import User

class BlogPost(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    def __str__(self):
        return self.title
```

### Forms (forms.py)

```python
from django import forms
from .models import BlogPost

class BlogPostForm(forms.ModelForm):
    class Meta:
        model = BlogPost
        fields = ['title', 'content']
```

### Views (views.py)

```python
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from .models import BlogPost
from .forms import BlogPostForm

def blog_list(request):
    posts = BlogPost.objects.all().order_by('-created_at')
    return render(request, 'blog/list.html', {'posts': posts})

def blog_detail(request, post_id):
    post = get_object_or_404(BlogPost, id=post_id)
    return render(request, 'blog/detail.html', {'post': post})

@login_required
def blog_create(request):
    if request.method == 'POST':
        form = BlogPostForm(request.POST)
        if form.is_valid():
            post = form.save(commit=False)
            post.author = request.user
            post.save()
            return redirect('blog_detail', post_id=post.id)
    else:
        form = BlogPostForm()
    return render(request, 'blog/form.html', {'form': form, 'action': 'Create'})

@login_required
def blog_edit(request, post_id):
    post = get_object_or_404(BlogPost, id=post_id)
    
    # Only allow the author to edit the post
    if post.author != request.user:
        return redirect('blog_detail', post_id=post.id)
        
    if request.method == 'POST':
        form = BlogPostForm(request.POST, instance=post)
        if form.is_valid():
            form.save()
            return redirect('blog_detail', post_id=post.id)
    else:
        form = BlogPostForm(instance=post)
    return render(request, 'blog/form.html', {'form': form, 'action': 'Edit'})

@login_required
def blog_delete(request, post_id):
    post = get_object_or_404(BlogPost, id=post_id)
    
    # Only allow the author to delete the post
    if post.author != request.user:
        return redirect('blog_detail', post_id=post.id)
        
    if request.method == 'POST':
        post.delete()
        return redirect('blog_list')
    return render(request, 'blog/confirm_delete.html', {'post': post})
```

### URLs (urls.py)

```python
from django.urls import path
from . import views

urlpatterns = [
    path('blog/', views.blog_list, name='blog_list'),
    path('blog/<int:post_id>/', views.blog_detail, name='blog_detail'),
    path('blog/new/', views.blog_create, name='blog_create'),
    path('blog/<int:post_id>/edit/', views.blog_edit, name='blog_edit'),
    path('blog/<int:post_id>/delete/', views.blog_delete, name='blog_delete'),
]
```

## Advantages of Function-Based Views

1. **Simplicity**: FBVs are straightforward Python functions, making them easy to understand for beginners.
2. **Flexibility**: You can use regular Python constructs like conditionals and loops directly.
3. **Decorators**: Python decorators work naturally with functions.
4. **Focused**: Each view typically handles one specific task.

## When to Use Function-Based Views

Function-based views are ideal when:
- You're building simple views with straightforward logic
- You're learning Django and want to understand the basics
- You need a quick, one-off view for a specific purpose
- You're working on a small application where the added complexity of class-based views isn't necessary

## Summary

Function-based views are a fundamental part of Django that allow you to process HTTP requests and return responses. In this tutorial, we've covered:

- The basic structure of a function-based view
- How to map URLs to views
- Handling different HTTP methods
- Working with templates and models
- Using decorators to add functionality
- Building a complete blog application example

Function-based views are a great starting point for Django beginners. As your applications grow in complexity, you might want to explore class-based views, which we'll cover in another tutorial.

## Further Resources and Exercises

### Resources
- [Django Documentation on Views](https://docs.djangoproject.com/en/stable/topics/http/views/)
- [Django Documentation on URL Dispatcher](https://docs.djangoproject.com/en/stable/topics/http/urls/)
- [Django Forms Documentation](https://docs.djangoproject.com/en/stable/topics/forms/)

### Exercises

1. **Basic View Exercise**: Create a function-based view that displays the current date and time.
2. **Form Handling Exercise**: Create a contact form view that validates input and sends an email.
3. **CRUD Exercise**: Extend the blog application to include categories and tags for blog posts.
4. **API Exercise**: Create a function-based view that returns JSON data instead of HTML.
5. **Authentication Exercise**: Create a user profile view that allows users to update their information.

By completing these exercises, you'll gain practical experience with function-based views and deepen your understanding of Django's request-response cycle.