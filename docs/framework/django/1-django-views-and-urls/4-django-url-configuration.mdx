---
title: Django URL Configuration
description: Learn how to configure URLs in Django applications, route user requests to appropriate views, and understand Django's URL patterns and parameters.

---

# Django URL Configuration

## Introduction

URL configuration is a fundamental concept in Django web development. It defines how your web application responds to specific URL patterns from users. Think of it as a map that guides incoming web requests to the appropriate view functions in your application.

In this tutorial, we'll explore Django's URL routing system, understand how to define URL patterns, and learn how to connect URLs to views. By the end, you'll be able to create clean, organized URL structures for your Django projects.

## Django URL Basics

### What is a URLconf?

In Django, URL configurations (URLconfs) are Python modules that map URL patterns to view functions. When a user makes a request to your Django site, the system searches through your defined URL patterns to find a match and execute the corresponding view.

The main URLconf file in a Django project is typically located at `yourproject/urls.py`.

### The `urls.py` Structure

Let's examine the basic structure of a `urls.py` file:

```python
from django.urls import path
from django.contrib import admin
from . import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('hello/', views.hello_world),
    path('', views.homepage),
]
```

In this example:
- `path('admin/', admin.site.urls)` directs requests to `/admin/` to Django's built-in admin interface
- `path('hello/', views.hello_world)` maps `/hello/` to a view function called `hello_world`
- `path('', views.homepage)` maps the root URL (`/`) to the `homepage` view

## Creating URL Patterns

### Basic Path Syntax

The `path()` function is the primary tool for defining URL patterns. Its basic syntax is:

```python
path(route, view, kwargs=None, name=None)
```

Where:
- `route` is a string containing a URL pattern
- `view` is the view function to call when the pattern matches
- `kwargs` is an optional dictionary of arguments to pass to the view
- `name` is an optional name for the URL pattern (useful for URL reversing)

### URL Parameters

URLs often need to capture values from the URL itself. For example, a blog application might have URLs like `/blog/2023/01/15/` to show posts from a specific date.

Django allows you to capture these values using angle brackets:

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('blog/<int:year>/<int:month>/<int:day>/', views.blog_post_day),
    path('user/<str:username>/', views.user_profile),
]
```

Then in your view functions:

```python
# views.py
def blog_post_day(request, year, month, day):
    # The parameters year, month, and day are automatically 
    # passed to the view based on the URL
    return render(request, 'blog/day.html', {
        'year': year,
        'month': month,
        'day': day
    })

def user_profile(request, username):
    # username parameter is extracted from the URL
    return render(request, 'users/profile.html', {'username': username})
```

### Path Converters

Django provides several path converters for different data types:

- `str`: Matches any non-empty string, excluding the path separator (`/`). This is the default.
- `int`: Matches positive integers.
- `slug`: Matches slug strings (ASCII letters, numbers, hyphens, or underscores).
- `uuid`: Matches formatted UUID strings.
- `path`: Matches any non-empty string, including the path separator (`/`).

Example:

```python
urlpatterns = [
    # Only matches if year is a four-digit number
    path('articles/<int:year>/', views.year_archive),
    
    # Matches a slug format (e.g., "my-awesome-post")
    path('posts/<slug:post_slug>/', views.post_detail),
    
    # Matches any path, including slashes
    path('documents/<path:document_path>/', views.document_viewer),
]
```

## Organizing URLs with Include

For larger projects, placing all URL patterns in a single file becomes unwieldy. Django provides the `include()` function to split your URLconf into multiple files:

```python
# project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls')),
    path('users/', include('users.urls')),
]
```

Then in each app:

```python
# blog/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.blog_index, name='blog_index'),
    path('post/<slug:slug>/', views.blog_post, name='blog_post'),
]
```

This approach keeps your URL structure organized and modular, making it easier to maintain as your project grows.

## URL Naming and Reversing

### Named URLs

Django allows you to name your URL patterns, which is useful for referring to them elsewhere in your code:

```python
path('blog/', views.blog, name='blog_home'),
path('blog/post/<int:post_id>/', views.post_detail, name='blog_post_detail'),
```

### Reverse URL Resolution

Instead of hardcoding URLs in your templates or views, you can use Django's URL reversing system:

In Python code:

```python
from django.urls import reverse

def some_view(request):
    # Construct a URL for the blog post with ID 123
    url = reverse('blog_post_detail', args=[123])
    # url would be "/blog/post/123/"
    # ...
```

In templates:

```html
<a href="{% url 'blog_home' %}">Blog Home</a>
<a href="{% url 'blog_post_detail' post_id=123 %}">View Post 123</a>
```

This method has several advantages:
- URLs are defined in one place only
- If you change the URL pattern, all references update automatically
- It's easier to maintain consistency across your project

## Practical Example: Building a Blog URL Structure

Let's create a complete URL configuration for a simple blog application:

```python
# blog/urls.py
from django.urls import path
from . import views

app_name = 'blog'  # This creates a URL namespace

urlpatterns = [
    # Home page: example.com/blog/
    path('', views.index, name='index'),
    
    # Post list by category: example.com/blog/category/django/
    path('category/<slug:category_slug>/', views.category, name='category'),
    
    # Post detail: example.com/blog/2023/01/my-first-post/
    path('<int:year>/<int:month>/<slug:post_slug>/', 
         views.post_detail, 
         name='post_detail'),
    
    # Archive: example.com/blog/archive/2023/
    path('archive/<int:year>/', views.year_archive, name='year_archive'),
    
    # Archive: example.com/blog/archive/2023/01/
    path('archive/<int:year>/<int:month>/', 
         views.month_archive, 
         name='month_archive'),
]
```

Let's create the corresponding views:

```python
# blog/views.py
from django.shortcuts import render, get_object_or_404
from .models import Post, Category

def index(request):
    posts = Post.objects.all().order_by('-pub_date')[:10]
    return render(request, 'blog/index.html', {'posts': posts})

def category(request, category_slug):
    category = get_object_or_404(Category, slug=category_slug)
    posts = Post.objects.filter(categories=category)
    return render(request, 'blog/category.html', {
        'category': category,
        'posts': posts
    })

def post_detail(request, year, month, post_slug):
    post = get_object_or_404(Post, 
                            pub_date__year=year,
                            pub_date__month=month,
                            slug=post_slug)
    return render(request, 'blog/post_detail.html', {'post': post})

def year_archive(request, year):
    posts = Post.objects.filter(pub_date__year=year)
    return render(request, 'blog/archive.html', {
        'year': year,
        'posts': posts
    })

def month_archive(request, year, month):
    posts = Post.objects.filter(
        pub_date__year=year,
        pub_date__month=month
    )
    return render(request, 'blog/archive.html', {
        'year': year,
        'month': month,
        'posts': posts
    })
```

Now let's use URL reversing in a template:

```html
<!-- blog/templates/blog/index.html -->
<h1>Latest Blog Posts</h1>

<ul>
{% for post in posts %}
    <li>
        <a href="{% url 'blog:post_detail' year=post.pub_date.year month=post.pub_date.month post_slug=post.slug %}">
            {{ post.title }}
        </a>
        - Posted in:
        {% for category in post.categories.all %}
            <a href="{% url 'blog:category' category_slug=category.slug %}">
                {{ category.name }}
            </a>
            {% if not forloop.last %}, {% endif %}
        {% endfor %}
    </li>
{% endfor %}
</ul>

<h2>Archives</h2>
<ul>
    <li><a href="{% url 'blog:year_archive' year=2023 %}">2023</a></li>
    <li><a href="{% url 'blog:year_archive' year=2022 %}">2022</a></li>
</ul>
```

This example demonstrates a practical URL structure with:
- Hierarchical organization
- URL parameters for dynamic content
- URL namespacing with `app_name`
- URL reversing in templates

## Advanced URL Patterns

### Regular Expression Routes

For more complex URL matching, Django provides `re_path()` which uses regular expressions:

```python
from django.urls import path, re_path
from . import views

urlpatterns = [
    # Match hexadecimal numbers
    re_path(r'^article/(?P<article_id>[0-9a-f]{8})/$', views.article_detail),
    
    # Match dates in format: YYYY-MM-DD
    re_path(r'^archive/(?P<date>\d{4}-\d{2}-\d{2})/$', views.archive_day),
]
```

### Default View Arguments

You can provide default values for view arguments using the `kwargs` parameter:

```python
from django.urls import path
from . import views

urlpatterns = [
    # The archive view will receive year=2023 even if not in the URL
    path('archive/', views.archive, kwargs={'year': 2023}),
]
```

## Summary

In this tutorial, we've covered Django's URL configuration system:

- Creating URL patterns with `path()`
- Capturing URL parameters with path converters
- Organizing URLs with `include()`
- Using URL naming and reversing
- Building practical URL structures for real applications
- Using advanced URL techniques with regular expressions and default arguments

URL configuration is a crucial part of any Django project. Well-designed URLs make your application more user-friendly and easier to maintain. Remember to keep your URLs clean, logical, and descriptive of the resources they point to.

## Exercises

1. Create a URL configuration for a books application with URLs for:
   - Listing all books (`/books/`)
   - Book details by ID (`/books/42/`)
   - Filtering books by author (`/books/author/tolkien/`)

2. Refactor an existing URL structure to use named URLs and URL reversing.

3. Implement URL configurations for a multi-level category system (categories can have subcategories).

## Additional Resources

- [Django Official Documentation on URL Dispatcher](https://docs.djangoproject.com/en/stable/topics/http/urls/)
- [Django URL Patterns Best Practices](https://docs.djangoproject.com/en/stable/intro/tutorial03/)
- [Regular Expressions in Python](https://docs.python.org/3/library/re.html)

Happy coding with Django URL configurations!