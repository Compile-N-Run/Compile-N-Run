---
title: Django URL Patterns
description: Learn how to define and manage URL patterns in Django to map user requests to appropriate view functions

---

# Django URL Patterns

## Introduction

In a Django web application, URL patterns serve as the routing mechanism that maps user requests to appropriate view functions. When a user navigates to a specific URL in your application, Django's URL dispatcher uses these patterns to determine which view function should handle the request.

Understanding URL patterns is crucial for building well-structured Django applications, as they form the backbone of how users interact with your site. In this article, we'll explore how to define URL patterns in Django, their syntax, and best practices for organizing them.

## Django's URL Dispatcher

At the heart of Django's URL handling is the URL dispatcher, which matches the requested URL against defined patterns and directs the request to the appropriate view function.

### How URL Resolution Works

When a user makes a request to your Django application:

1. Django determines the root URLconf module based on the `ROOT_URLCONF` setting
2. Django loads the module and looks for the variable `urlpatterns`
3. Django runs through each URL pattern until it finds one that matches the requested URL
4. Once a match is found, Django calls the associated view function

## Basic URL Pattern Syntax

Django's URL patterns are defined using the `path()` function in your project's `urls.py` files.

### The `path()` Function

The basic syntax for the `path()` function is:

```python
path(route, view, kwargs=None, name=None)
```

Where:
- `route` is a string that contains a URL pattern
- `view` is the view function that will be called when the pattern matches
- `kwargs` (optional) is a dictionary of additional arguments to pass to the view
- `name` (optional) is a name for this URL pattern for reverse URL matching

Let's see a simple example:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('articles/', views.article_list, name='article_list'),
    path('articles/<int:year>/', views.article_year_archive, name='article_year_archive'),
    path('articles/<int:year>/<int:month>/', views.article_month_archive, name='article_month_archive'),
]
```

In this example, we've defined three URL patterns:
- `articles/` maps to the `article_list` view
- `articles/<int:year>/` maps to the `article_year_archive` view, passing the year as an integer parameter
- `articles/<int:year>/<int:month>/` maps to the `article_month_archive` view, passing both year and month as integer parameters

## Path Converters

Django provides several path converters that can be used to capture parts of the URL and convert them to appropriate Python types before passing them to the view:

| Converter | Description | Example |
|-----------|-------------|---------|
| `str` | Matches any non-empty string, excluding `/` | `<str:username>` |
| `int` | Matches zero or positive integers | `<int:id>` |
| `slug` | Matches slug strings (letters, numbers, hyphens, underscores) | `<slug:title>` |
| `uuid` | Matches formatted UUID strings | `<uuid:id>` |
| `path` | Matches any non-empty string, including `/` | `<path:file_path>` |

Here's how you might use them:

```python
from django.urls import path
from . import views

urlpatterns = [
    path('users/<str:username>/', views.user_profile, name='user_profile'),
    path('articles/<int:article_id>/', views.article_detail, name='article_detail'),
    path('blog/<slug:post_slug>/', views.blog_post, name='blog_post'),
    path('documents/<path:document_path>/', views.serve_document, name='serve_document'),
]
```

And here's how the corresponding view functions might look:

```python
def user_profile(request, username):
    # username will be a string
    return render(request, 'profiles/user.html', {'username': username})

def article_detail(request, article_id):
    # article_id will be an integer
    article = get_object_or_404(Article, id=article_id)
    return render(request, 'articles/detail.html', {'article': article})

def blog_post(request, post_slug):
    # post_slug will be a string containing only letters, numbers, hyphens, and underscores
    post = get_object_or_404(Post, slug=post_slug)
    return render(request, 'blog/post.html', {'post': post})

def serve_document(request, document_path):
    # document_path can contain slashes
    return serve_file(document_path)
```

## Regular Expression URLs

For more complex URL patterns, Django provides the `re_path()` function which allows you to use regular expressions:

```python
from django.urls import path, re_path
from . import views

urlpatterns = [
    path('articles/', views.article_list, name='article_list'),
    re_path(r'^articles/(?P<year>[0-9]{4})/$', views.article_year_archive, name='article_year_archive'),
]
```

In this example, the regular expression `^articles/(?P<year>[0-9]{4})/$` will match URLs like `articles/2023/` and pass `2023` as the `year` parameter to the view function.

## Including Other URLconfs

As your application grows, you'll want to organize your URL patterns across multiple apps. Django's `include()` function helps with this:

```python
from django.urls import include, path

urlpatterns = [
    path('blog/', include('blog.urls')),
    path('products/', include('products.urls')),
]
```

This allows you to modularize your URL patterns by app. For example, in your `blog` app, you might have:

```python
# blog/urls.py
from django.urls import path
from . import views

app_name = 'blog'  # This creates a namespace

urlpatterns = [
    path('', views.post_list, name='post_list'),
    path('<int:post_id>/', views.post_detail, name='post_detail'),
    path('category/<str:category>/', views.category_posts, name='category_posts'),
]
```

Now you can access these URLs as `/blog/`, `/blog/42/`, and `/blog/category/django/`.

## URL Namespaces and Reverse URL Lookup

Django provides a way to uniquely identify a URL pattern through namespaces and names. This is particularly useful for reverse URL lookup (getting the URL from the view name).

### URL Namespaces

In the previous example, we used `app_name = 'blog'` to create a namespace for the blog app's URLs. This helps avoid name conflicts between different apps.

### Reverse URL Lookup

To get the URL for a specific view, you can use the `reverse()` function or the `url` template tag:

```python
from django.urls import reverse

# In a view function
def some_view(request):
    url = reverse('blog:post_detail', args=[42])
    # url will be '/blog/42/'
    return HttpResponseRedirect(url)
```

In a template:

```html
<a href="{% url 'blog:post_detail' post.id %}">{{ post.title }}</a>
```

## Practical Example: Building a Blog URL Structure

Let's put it all together with a more complete example of a blog application URL structure:

```python
# mysite/urls.py (main project URLs)
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('blog/', include('blog.urls', namespace='blog')),
    path('accounts/', include('accounts.urls')),
]
```

```python
# blog/urls.py (blog app URLs)
from django.urls import path
from . import views

app_name = 'blog'

urlpatterns = [
    # List views
    path('', views.post_list, name='post_list'),
    path('category/<slug:category_slug>/', views.category_posts, name='category_posts'),
    path('tag/<slug:tag_slug>/', views.tag_posts, name='tag_posts'),
    
    # Detail views
    path('post/<int:year>/<int:month>/<slug:post_slug>/', views.post_detail, name='post_detail'),
    path('author/<str:username>/', views.author_posts, name='author_posts'),
    
    # Create, update, delete
    path('post/create/', views.post_create, name='post_create'),
    path('post/<int:post_id>/edit/', views.post_edit, name='post_edit'),
    path('post/<int:post_id>/delete/', views.post_delete, name='post_delete'),
    
    # API
    path('api/posts/', views.api_post_list, name='api_post_list'),
    path('api/posts/<int:post_id>/', views.api_post_detail, name='api_post_detail'),
]
```

Now let's implement one of these view functions to see how URL parameters are used:

```python
def post_detail(request, year, month, post_slug):
    """Display a single blog post."""
    try:
        post = Post.objects.get(
            pub_date__year=year,
            pub_date__month=month,
            slug=post_slug,
            status='published'
        )
    except Post.DoesNotExist:
        raise Http404("Post does not exist")
        
    return render(
        request,
        'blog/post_detail.html',
        {'post': post}
    )
```

In a template, you could link to this post with:

```html
<a href="{% url 'blog:post_detail' post.pub_date.year post.pub_date.month post.slug %}">
    {{ post.title }}
</a>
```

## Best Practices for Django URL Patterns

1. **Use namespaces**: Always use app namespaces to avoid URL name collisions
2. **Give meaningful names**: Choose descriptive names for your URL patterns
3. **Keep URLs user-friendly**: Design URLs that are easy to read and remember
4. **Follow REST principles**: For APIs, structure URLs around resources
5. **Use path converters**: Prefer path converters over regular expressions when possible
6. **Organize by app**: Keep URL patterns modular by organizing them by app
7. **Use trailing slashes consistently**: Django adds trailing slashes by default

## Summary

Django URL patterns are a powerful system for mapping URLs to view functions in your web application. They allow you to create clean, user-friendly URLs and organize your application's navigation structure.

In this article, we've covered:
- The basics of URL patterns and how the URL dispatcher works
- How to define URL patterns using `path()` and `re_path()`
- Path converters for different types of URL parameters
- Including other URLconfs to modularize your application
- URL namespaces and reverse URL lookup
- A practical example of building a blog URL structure
- Best practices for designing URL patterns

By mastering URL patterns, you'll be able to create well-structured Django applications with intuitive navigation systems.

## Additional Resources

- [Official Django URL dispatcher documentation](https://docs.djangoproject.com/en/stable/topics/http/urls/)
- [Django URL patterns cheat sheet](https://github.com/django/django/blob/main/django/urls/converters.py)
- [RESTful API design principles](https://restfulapi.net/)

## Exercises

1. Create a URL pattern for an e-commerce site with categories, products, and user accounts
2. Implement a view function that takes multiple URL parameters and renders them in a template
3. Practice using reverse URL lookup in both views and templates
4. Convert a set of regular expression URL patterns to use path converters instead
5. Create a URL structure for a personal portfolio site with projects and blog sections