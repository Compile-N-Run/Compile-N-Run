---
title: Django Select Related
description: Learn how to optimize Django database queries using select_related to reduce the number of queries and improve performance in your web applications.

---

# Django Select Related

## Introduction

When building web applications with Django, you'll often find yourself working with related models. For example, you might have a `Blog` model related to an `Author` model. When you display blog posts on your website, you'll need to access the author's information for each post. 

Without optimization, this can lead to a problem known as the "N+1 query problem" - where Django executes one query to get all blog posts and then an additional query for each post to get its author. This means that if you display 10 blog posts, you'll make 11 database queries!

Django provides a powerful tool to solve this issue: `select_related()`. This method allows you to retrieve related objects in a single database query, significantly improving your application's performance.

## Understanding `select_related()`

`select_related()` is a QuerySet method that returns a new QuerySet containing related objects pre-filled. It works by performing a SQL JOIN and including the fields of the related object in the SELECT statement.

### Basic Syntax

```python
Model.objects.select_related('related_field').all()
```

The `select_related()` method accepts the names of foreign key relationships to follow. You can follow relationships as deep as you want by using double underscores.

```python
Model.objects.select_related('related_field__further_related_field').all()
```

## When to Use `select_related()`

Use `select_related()` when:

1. You know you'll need to access a related object
2. The related field is a `ForeignKey` or `OneToOneField` relation
3. You want to reduce the number of database queries

## Basic Example

Let's start with a simple example to illustrate the problem and solution. 

Consider these models:

```python
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)
    bio = models.TextField()
    
    def __str__(self):
        return self.name

class Blog(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    published_date = models.DateTimeField(auto_now_add=True)
    
    def __str__(self):
        return self.title
```

### The N+1 Query Problem

Here's what happens without `select_related()`:

```python
# This gets all blogs with one query
blogs = Blog.objects.all()

# But now for each blog, we access the author - this causes N additional queries
for blog in blogs:
    print(f"{blog.title} by {blog.author.name}")
```

You can check the number of queries using Django Debug Toolbar or by analyzing the SQL queries:

```python
from django.db import connection

blogs = Blog.objects.all()
for blog in blogs:
    print(f"{blog.title} by {blog.author.name}")
    
print(f"Number of queries: {len(connection.queries)}")
# If you have 10 blogs, this will print "Number of queries: 11"
```

### Solution with `select_related()`

Now let's optimize this with `select_related()`:

```python
# This gets all blogs AND their authors with a single query
blogs = Blog.objects.select_related('author').all()

# Now these accesses don't generate additional queries!
for blog in blogs:
    print(f"{blog.title} by {blog.author.name}")

print(f"Number of queries: {len(connection.queries)}")
# This will print "Number of queries: 1"
```

## Following Multiple Relationships

You can follow multiple relationships in a single `select_related()` call:

```python
# Assuming we have Category and Editor models related to Blog
blogs = Blog.objects.select_related('author', 'category', 'editor').all()
```

## Following Deep Relationships

You can follow relationships as deep as needed using double underscores:

```python
from django.db import models

class Country(models.Model):
    name = models.CharField(max_length=100)
    
class City(models.Model):
    name = models.CharField(max_length=100)
    country = models.ForeignKey(Country, on_delete=models.CASCADE)
    
class Author(models.Model):
    name = models.CharField(max_length=100)
    city = models.ForeignKey(City, on_delete=models.CASCADE)
    
class Blog(models.Model):
    title = models.CharField(max_length=200)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
```

To efficiently access an author's country:

```python
# Without select_related (3 queries)
blog = Blog.objects.first()
country_name = blog.author.city.country.name

# With select_related (1 query)
blog = Blog.objects.select_related('author__city__country').first()
country_name = blog.author.city.country.name
```

## Real-World Example: A Blog Application

Let's look at a more comprehensive example in the context of a blog application view:

```python
# Without optimization
def blog_list(request):
    blogs = Blog.objects.all().order_by('-published_date')[:10]
    return render(request, 'blog/list.html', {'blogs': blogs})
```

The corresponding template might look like:

```html
{% for blog in blogs %}
  <article>
    <h2>{{ blog.title }}</h2>
    <p>By {{ blog.author.name }} from {{ blog.author.city.name }}, {{ blog.author.city.country.name }}</p>
    <!-- Each access to author, city, and country triggers a new database query! -->
    <div>{{ blog.content }}</div>
  </article>
{% endfor %}
```

Optimized version:

```python
# With optimization
def blog_list(request):
    blogs = Blog.objects.select_related('author__city__country').order_by('-published_date')[:10]
    return render(request, 'blog/list.html', {'blogs': blogs})
```

Now the template can access all those related fields without triggering additional database queries!

## Performance Comparison

Let's compare the performance with and without `select_related()`:

```python
import time
from django.db import reset_queries, connection

# Function to measure query execution time and count
def measure_queries(func):
    reset_queries()
    start_time = time.time()
    result = func()
    end_time = time.time()
    query_count = len(connection.queries)
    execution_time = end_time - start_time
    return result, query_count, execution_time

# Without select_related
def get_blogs_unoptimized():
    blogs = list(Blog.objects.all()[:100])
    # Force evaluation of author name to trigger queries
    authors = [blog.author.name for blog in blogs]
    return blogs

# With select_related
def get_blogs_optimized():
    blogs = list(Blog.objects.select_related('author')[:100])
    # This won't trigger additional queries
    authors = [blog.author.name for blog in blogs]
    return blogs

# Run the comparison
unoptimized_result = measure_queries(get_blogs_unoptimized)
optimized_result = measure_queries(get_blogs_optimized)

print(f"Unoptimized: {unoptimized_result[1]} queries in {unoptimized_result[2]:.4f} seconds")
print(f"Optimized: {optimized_result[1]} queries in {optimized_result[2]:.4f} seconds")
```

This would output something like:

```
Unoptimized: 101 queries in 0.3520 seconds
Optimized: 1 query in 0.0124 seconds
```

## When Not to Use `select_related()`

While powerful, `select_related()` is not always the right choice:

1. **For ManyToMany fields**: Use `prefetch_related()` instead (we'll cover this in another lesson)
2. **When you don't need the related data**: If you don't access the related fields, using `select_related()` adds unnecessary overhead
3. **When JOINs would retrieve too much data**: Very deep or complex relationships might result in large result sets

## Best Practices

1. **Use Django Debug Toolbar**: It helps identify query problems in your views
2. **Be selective**: Only include the relationships you'll actually use
3. **Consider caching**: For very complex queries, consider caching the results
4. **Test performance**: Measure the impact of your optimizations, especially on large datasets

## Summary

`select_related()` is a powerful optimization tool in Django that helps you reduce the number of database queries by fetching related objects in a single query using SQL JOINs. It's especially useful for `ForeignKey` and `OneToOneField` relationships.

By using `select_related()` appropriately, you can significantly improve your Django application's performance and responsiveness, particularly when dealing with related models.

Remember the key points:
- Use it when you know you'll access related models in your code
- It works with forward `ForeignKey` and `OneToOneField` relationships
- You can follow deep relationships using double underscores
- For `ManyToManyField` relationships, use `prefetch_related()` instead

## Additional Resources

- [Django Documentation on select_related()](https://docs.djangoproject.com/en/stable/ref/models/querysets/#select-related)
- [Django QuerySet Optimization](https://docs.djangoproject.com/en/stable/topics/db/optimization/)
- [Django Debug Toolbar](https://github.com/jazzband/django-debug-toolbar) for query debugging

## Exercises

1. Create a simple Django application with at least three related models (e.g., Country → City → Location → Event) and experiment with different `select_related()` queries.
2. Profile the performance difference between queries with and without `select_related()`.
3. Identify and optimize N+1 query issues in an existing Django project.
4. Try combining `select_related()` with other QuerySet methods like `filter()`, `exclude()`, and `order_by()`.
5. Compare the SQL queries generated by Django with and without `select_related()` using `connection.queries` or Django Debug Toolbar.