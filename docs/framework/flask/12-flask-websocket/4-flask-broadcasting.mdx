---
title: Flask Broadcasting
description: Learn how to implement WebSocket broadcasting in Flask to send messages to multiple clients simultaneously

---

# Flask Broadcasting

## Introduction

Broadcasting is a powerful WebSocket feature that allows you to send messages to multiple connected clients simultaneously. Unlike traditional one-to-one communication, broadcasting enables one-to-many communication patterns, making it perfect for applications like chat rooms, live notifications, real-time dashboards, and multiplayer games.

In this tutorial, we'll explore how to implement broadcasting in Flask using Flask-SocketIO, a popular extension that brings WebSocket capabilities to Flask applications. By the end, you'll understand how to efficiently send real-time updates to groups of connected users.

## Prerequisites

Before diving into broadcasting, make sure you have:

1. Basic knowledge of Flask
2. Flask-SocketIO installed: `pip install flask-socketio`
3. Understanding of basic WebSocket concepts

## Understanding Broadcasting

Broadcasting allows a server to push the same message to multiple connected clients without having to send individual messages to each one. This is particularly useful when:

- You need to update many users about a change (like a new chat message)
- You want to synchronize state across multiple clients
- You need to send periodic updates to all connected clients

In Flask-SocketIO, broadcasting can be done at different scopes:
- To all connected clients
- To specific rooms (groups of clients)
- To all clients except the sender

## Setting Up a Basic Flask-SocketIO Application

First, let's set up a basic Flask application with Flask-SocketIO:

```python
from flask import Flask, render_template
from flask_socketio import SocketIO, emit, join_room, leave_room

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
socketio = SocketIO(app, cors_allowed_origins="*")

@app.route('/')
def index():
    return render_template('index.html')

if __name__ == '__main__':
    socketio.run(app, debug=True)
```

Create a simple HTML template (`templates/index.html`):

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flask-SocketIO Broadcasting Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script type="text/javascript">
        const socket = io();
        
        socket.on('connect', function() {
            console.log('Connected to SocketIO server');
        });
        
        socket.on('broadcast_message', function(data) {
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML += '<p>' + data.message + '</p>';
        });
        
        function sendMessage() {
            const message = document.getElementById('message').value;
            socket.emit('send_message', {message: message});
            document.getElementById('message').value = '';
            return false;
        }
    </script>
</head>
<body>
    <h1>Flask-SocketIO Broadcasting Demo</h1>
    <form onsubmit="return sendMessage();">
        <input type="text" id="message" placeholder="Enter a message">
        <input type="submit" value="Send">
    </form>
    <div id="messages"></div>
</body>
</html>
```

## Broadcasting to All Clients

Let's implement our first broadcasting example - sending a message to all connected clients:

```python
@socketio.on('send_message')
def handle_message(data):
    # Broadcast to all clients
    emit('broadcast_message', data, broadcast=True)
    print(f"Message broadcast to all clients: {data['message']}")
```

The key parameter here is `broadcast=True`, which tells Flask-SocketIO to send the message to all connected clients, including the sender.

### How It Works:

1. A client sends a message using the 'send_message' event
2. The server receives it and calls `handle_message()`
3. The server broadcasts this message to all connected clients via the 'broadcast_message' event
4. Each client's JavaScript receives the message and displays it

## Broadcasting to All Except the Sender

Often, you want to broadcast to everyone except the client who sent the message:

```python
@socketio.on('send_message')
def handle_message(data):
    # Include sender's information
    data['sender'] = request.sid  # Socket ID of the sender
    
    # Broadcast to all clients except the sender
    emit('broadcast_message', data, broadcast=True, include_self=False)
    
    # Send a confirmation just to the sender
    emit('message_sent', {'status': 'Message sent to all other users'})
```

The `include_self=False` parameter ensures that the message is sent to everyone except the sender.

## Working with Rooms

Rooms allow you to organize clients into groups for more targeted broadcasting. This is perfect for chat rooms, game lobbies, or user-specific notifications.

### Joining and Leaving Rooms

```python
@socketio.on('join')
def on_join(data):
    username = data['username']
    room = data['room']
    
    # Add the client to the room
    join_room(room)
    
    # Notify everyone in the room that someone joined
    emit('status', {'msg': f'{username} has joined the room'}, room=room)

@socketio.on('leave')
def on_leave(data):
    username = data['username']
    room = data['room']
    
    # Remove the client from the room
    leave_room(room)
    
    # Notify everyone in the room that someone left
    emit('status', {'msg': f'{username} has left the room'}, room=room)
```

### Broadcasting to Specific Rooms

Now we can send messages to specific rooms:

```python
@socketio.on('send_room_message')
def handle_room_message(data):
    room = data['room']
    message = data['message']
    username = data['username']
    
    # Broadcast the message to everyone in the room
    emit('room_message', 
         {'msg': message, 'username': username}, 
         room=room)
```

## Real-world Example: A Simple Chat Application

Let's put everything together with a more comprehensive chat application example:

Server-side (`app.py`):

```python
from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit, join_room, leave_room

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key'
socketio = SocketIO(app, cors_allowed_origins="*")

# Store active rooms
rooms = {}

@app.route('/')
def index():
    return render_template('chat.html')

@socketio.on('connect')
def handle_connect():
    print(f"Client connected: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    print(f"Client disconnected: {request.sid}")

@socketio.on('join_room')
def handle_join_room(data):
    username = data['username']
    room = data['room']
    
    join_room(room)
    
    # Initialize room if it doesn't exist
    if room not in rooms:
        rooms[room] = {'members': 0, 'messages': []}
    
    rooms[room]['members'] += 1
    
    # Broadcast to others
    emit('user_joined', 
         {'username': username, 'room': room, 'count': rooms[room]['members']},
         room=room,
         include_self=False)
    
    # Send room history to the new user
    emit('room_history', {'messages': rooms[room]['messages']})

@socketio.on('leave_room')
def handle_leave_room(data):
    username = data['username']
    room = data['room']
    
    leave_room(room)
    
    if room in rooms:
        rooms[room]['members'] -= 1
        
        # Clean up empty rooms
        if rooms[room]['members'] <= 0:
            del rooms[room]
        else:
            # Notify remaining users
            emit('user_left', 
                 {'username': username, 'count': rooms[room]['members']},
                 room=room)

@socketio.on('chat_message')
def handle_chat_message(data):
    room = data['room']
    username = data['username']
    message = data['message']
    timestamp = data['timestamp']
    
    # Store message in room history
    message_data = {
        'username': username,
        'message': message,
        'timestamp': timestamp
    }
    
    if room in rooms:
        # Limit history to last 50 messages
        rooms[room]['messages'].append(message_data)
        if len(rooms[room]['messages']) > 50:
            rooms[room]['messages'] = rooms[room]['messages'][-50:]
    
    # Broadcast to everyone in the room
    emit('chat_message', message_data, room=room)

if __name__ == '__main__':
    socketio.run(app, debug=True, host='0.0.0.0')
```

Client-side (`templates/chat.html`):

```html
<!DOCTYPE html>
<html>
<head>
    <title>Flask SocketIO Chat</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        #chat-container {
            width: 800px;
            margin: 0 auto;
        }
        #messages {
            height: 400px;
            border: 1px solid #ccc;
            overflow-y: scroll;
            margin-bottom: 10px;
            padding: 10px;
        }
        .message {
            margin-bottom: 5px;
        }
        .system-message {
            color: #888;
            font-style: italic;
        }
        .user-info {
            display: none;
        }
    </style>
</head>
<body>
    <div id="chat-container">
        <h1>Flask SocketIO Chat</h1>
        
        <div class="user-info" id="login-form">
            <h2>Join a Chat Room</h2>
            <input type="text" id="username" placeholder="Your username">
            <input type="text" id="room" placeholder="Room name">
            <button onclick="joinRoom()">Join</button>
        </div>
        
        <div class="user-info" id="chat-interface">
            <h2>Chat Room: <span id="room-display"></span> (<span id="member-count">0</span> users)</h2>
            <div id="messages"></div>
            <input type="text" id="message" placeholder="Type a message...">
            <button onclick="sendMessage()">Send</button>
            <button onclick="leaveRoom()">Leave Room</button>
        </div>
    </div>

    <script type="text/javascript">
        let currentUsername = '';
        let currentRoom = '';
        const socket = io();
        
        // Show the login form initially
        document.getElementById('login-form').style.display = 'block';
        
        socket.on('connect', function() {
            console.log('Connected to server');
        });
        
        function joinRoom() {
            currentUsername = document.getElementById('username').value.trim();
            currentRoom = document.getElementById('room').value.trim();
            
            if (currentUsername && currentRoom) {
                // Join the room
                socket.emit('join_room', {
                    username: currentUsername,
                    room: currentRoom
                });
                
                // Update UI
                document.getElementById('login-form').style.display = 'none';
                document.getElementById('chat-interface').style.display = 'block';
                document.getElementById('room-display').textContent = currentRoom;
                document.getElementById('member-count').textContent = '1';
            }
        }
        
        function leaveRoom() {
            if (currentUsername && currentRoom) {
                socket.emit('leave_room', {
                    username: currentUsername,
                    room: currentRoom
                });
                
                // Reset UI
                document.getElementById('login-form').style.display = 'block';
                document.getElementById('chat-interface').style.display = 'none';
                document.getElementById('messages').innerHTML = '';
                currentUsername = '';
                currentRoom = '';
            }
        }
        
        function sendMessage() {
            const messageInput = document.getElementById('message');
            const message = messageInput.value.trim();
            
            if (message) {
                socket.emit('chat_message', {
                    username: currentUsername,
                    room: currentRoom,
                    message: message,
                    timestamp: new Date().toISOString()
                });
                
                messageInput.value = '';
            }
        }
        
        // Set up event listeners for Enter key
        document.getElementById('message').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') sendMessage();
        });
        
        document.getElementById('username').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') document.getElementById('room').focus();
        });
        
        document.getElementById('room').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') joinRoom();
        });
        
        // Handle incoming messages
        socket.on('chat_message', function(data) {
            addMessage(`<strong>${data.username}:</strong> ${data.message}`);
        });
        
        socket.on('user_joined', function(data) {
            document.getElementById('member-count').textContent = data.count;
            addSystemMessage(`${data.username} has joined the room`);
        });
        
        socket.on('user_left', function(data) {
            document.getElementById('member-count').textContent = data.count;
            addSystemMessage(`${data.username} has left the room`);
        });
        
        socket.on('room_history', function(data) {
            // Clear existing messages
            const messagesDiv = document.getElementById('messages');
            messagesDiv.innerHTML = '';
            
            // Add all history messages
            data.messages.forEach(msg => {
                addMessage(`<strong>${msg.username}:</strong> ${msg.message}`);
            });
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        });
        
        function addMessage(html) {
            const messagesDiv = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = 'message';
            messageElement.innerHTML = html;
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        function addSystemMessage(text) {
            const messagesDiv = document.getElementById('messages');
            const messageElement = document.createElement('div');
            messageElement.className = 'message system-message';
            messageElement.textContent = text;
            messagesDiv.appendChild(messageElement);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
    </script>
</body>
</html>
```

## Advanced Broadcasting Techniques

### Namespaces

For larger applications, you can organize your WebSocket connections using namespaces. Each namespace can handle different parts of your application:

```python
# Create namespaces
chat_ns = socketio.namespace('/chat')
notifications_ns = socketio.namespace('/notifications')

@chat_ns.on('message')
def handle_chat_message(data):
    emit('new_message', data, namespace='/chat', broadcast=True)

@notifications_ns.on('system_event')
def handle_system_event(data):
    emit('system_notification', data, namespace='/notifications', broadcast=True)
```

Clients would connect to these specific namespaces:

```javascript
// Client-side
const chatSocket = io('/chat');
const notificationsSocket = io('/notifications');
```

### Dynamic Rooms

You can create rooms dynamically based on user attributes like user IDs:

```python
@socketio.on('connect')
def handle_connect():
    user_id = get_user_id_from_session()  # Your auth logic here
    
    if user_id:
        # Add user to their personal room
        join_room(f'user_{user_id}')
        
        # Add user to rooms based on permissions/groups
        user_groups = get_user_groups(user_id)  # Your logic
        for group in user_groups:
            join_room(f'group_{group}')
```

Now you can send targeted notifications:

```python
def notify_user(user_id, message):
    emit('notification', message, room=f'user_{user_id}', namespace='/')

def notify_group(group_id, message):
    emit('group_notification', message, room=f'group_{group_id}', namespace='/')
```

## Performance Considerations

When implementing broadcasting in Flask-SocketIO, keep these performance tips in mind:

1. **Message Size**: Keep broadcast messages small to reduce network traffic and processing time.

2. **Rate Limiting**: Implement rate limiting to prevent abuse and server overload.

```python
from flask_limiter import Limiter

limiter = Limiter(app)

@socketio.on('send_message')
@limiter.limit("10 per minute")  # Example rate limit
def handle_message(data):
    emit('broadcast_message', data, broadcast=True)
```

3. **Scaling**: For production applications with many simultaneous connections, consider:
   - Using Redis as the message broker
   - Implementing a load balancer
   - Employing multiple worker processes

```python
# Using Redis for message queue
socketio = SocketIO(app, message_queue='redis://')
```

## Summary

Broadcasting in Flask with WebSockets allows you to build powerful real-time applications that can send messages to multiple clients simultaneously. In this tutorial, we've covered:

- Basic broadcasting to all connected clients
- Broadcasting to specific rooms
- Creating and managing rooms for targeted communications
- A complete chat application example
- Advanced techniques like namespaces and dynamic rooms
- Performance considerations for production applications

With these tools, you can build a wide range of real-time applications including chat systems, collaborative editors, real-time dashboards, multiplayer games, and more.

## Exercises

1. Modify the chat example to include private messaging between users
2. Implement a typing indicator that shows when someone is typing in a room
3. Add a feature that shows which users are currently online in each room
4. Create a real-time dashboard that broadcasts updates to all connected clients
5. Implement a notification system that sends different types of notifications to different groups of users

## Additional Resources

- [Flask-SocketIO Documentation](https://flask-socketio.readthedocs.io/)
- [Socket.IO Official Documentation](https://socket.io/docs/)
- [Scaling Flask-SocketIO with Redis](https://flask-socketio.readthedocs.io/en/latest/deployment.html)
- [Real-Time Web Applications with Flask](https://blog.miguelgrinberg.com/post/easy-websockets-with-flask-and-gevent)

Happy coding with Flask WebSockets!