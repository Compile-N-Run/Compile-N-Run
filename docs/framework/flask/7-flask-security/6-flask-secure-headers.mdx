---
title: Flask Secure Headers
description: Learn how to implement and configure secure HTTP headers in Flask applications to enhance security and protect against common web vulnerabilities.

---

# Flask Secure Headers

## Introduction

When building web applications with Flask, security should always be a top priority. One crucial aspect of web security that is often overlooked is the proper configuration of HTTP response headers. Secure headers help protect your application against various attacks such as Cross-Site Scripting (XSS), clickjacking, and man-in-the-middle attacks.

In this tutorial, we'll explore how to implement secure headers in Flask applications. We'll cover what HTTP security headers are, why they matter, and how to configure them properly in your Flask app.

## What Are HTTP Security Headers?

HTTP security headers are special HTTP response headers that your server sends to browsers to increase the security of your website. These headers instruct browsers to behave in specific ways when processing the content of your website, adding an extra layer of defense against common web vulnerabilities.

Some of the most important security headers include:

- **Content-Security-Policy (CSP)**: Controls resources the browser is allowed to load
- **Strict-Transport-Security (HSTS)**: Forces secure (HTTPS) connections
- **X-Content-Type-Options**: Prevents MIME type sniffing
- **X-Frame-Options**: Prevents clickjacking attacks
- **X-XSS-Protection**: Helps prevent cross-site scripting attacks

## Implementing Secure Headers in Flask

Let's look at different approaches to implement secure headers in your Flask application.

### Approach 1: Manual Implementation

The most straightforward approach is to manually set headers in your Flask application responses.

```python
from flask import Flask, Response

app = Flask(__name__)

@app.after_request
def add_security_headers(response):
    # Prevents MIME type sniffing
    response.headers['X-Content-Type-Options'] = 'nosniff'
    
    # Prevents clickjacking attacks
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    
    # Helps prevent XSS attacks
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    # Forces HTTPS connections
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
    
    # Content security policy
    response.headers['Content-Security-Policy'] = "default-src 'self'"
    
    return response

@app.route('/')
def hello_world():
    return 'Hello, secure world!'

if __name__ == '__main__':
    app.run(debug=True)
```

When you run this application and make a request to it, the server's response will include these security headers:

```
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
X-XSS-Protection: 1; mode=block
Strict-Transport-Security: max-age=31536000; includeSubDomains
Content-Security-Policy: default-src 'self'
```

### Approach 2: Using Flask-Talisman

A more robust solution is to use the Flask-Talisman extension, which provides a comprehensive set of security features including HTTPS enforcement and secure headers configuration.

First, install Flask-Talisman:

```bash
pip install flask-talisman
```

Then, implement it in your Flask application:

```python
from flask import Flask
from flask_talisman import Talisman

app = Flask(__name__)

# Basic Talisman setup
Talisman(app)

# Or with custom configurations
"""
Talisman(app,
         content_security_policy={
             'default-src': '\'self\'',
             'script-src': '\'self\' \'unsafe-inline\'',
             'style-src': '\'self\' \'unsafe-inline\'',
         },
         frame_options='SAMEORIGIN')
"""

@app.route('/')
def hello_world():
    return 'Hello, secure world!'

if __name__ == '__main__':
    app.run(debug=True)
```

### Approach 3: Using Flask-Security-Headers

Another option is to use the Flask-Security-Headers extension specifically designed for header management:

```bash
pip install flask-security-headers
```

Implementation example:

```python
from flask import Flask
from flask_security_headers import SecurityHeaders

app = Flask(__name__)

# Configure security headers
sh = SecurityHeaders()
sh.update_header('X-Content-Type-Options', 'nosniff')
sh.update_header('X-Frame-Options', 'SAMEORIGIN')
sh.update_header('X-XSS-Protection', '1; mode=block')
sh.update_header('Strict-Transport-Security', 'max-age=31536000; includeSubDomains')

# Initialize with Flask app
sh.init_app(app)

@app.route('/')
def hello_world():
    return 'Hello, secure world!'

if __name__ == '__main__':
    app.run(debug=True)
```

## Detailed Look at Important Security Headers

Let's examine each important security header in more detail:

### Content-Security-Policy (CSP)

CSP is one of the most powerful security headers. It helps prevent XSS attacks by controlling what resources can be loaded by the page.

```python
# Basic CSP that only allows resources from the same origin
response.headers['Content-Security-Policy'] = "default-src 'self'"

# More complex CSP allowing specific sources
csp = "default-src 'self'; " \
      "script-src 'self' https://code.jquery.com; " \
      "img-src 'self' https://imgur.com; " \
      "style-src 'self' https://fonts.googleapis.com; " \
      "font-src 'self' https://fonts.gstatic.com"
response.headers['Content-Security-Policy'] = csp
```

### HTTP Strict Transport Security (HSTS)

HSTS forces browsers to use HTTPS, protecting against protocol downgrade attacks and cookie hijacking.

```python
# Enable HSTS with a one-year duration
response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
```

### X-Content-Type-Options

This header prevents browsers from MIME-sniffing a response away from the declared content type, which helps avoid MIME-confusion attacks.

```python
response.headers['X-Content-Type-Options'] = 'nosniff'
```

### X-Frame-Options

X-Frame-Options protects your website against clickjacking attacks by controlling whether the browser should render the page in a frame.

```python
# Prevent framing from different origin
response.headers['X-Frame-Options'] = 'SAMEORIGIN'

# Prevent all framing
# response.headers['X-Frame-Options'] = 'DENY'
```

### X-XSS-Protection

This header enables the browser's built-in XSS protection.

```python
response.headers['X-XSS-Protection'] = '1; mode=block'
```

## Real-World Example: Secure Flask Blog Application

Let's create a simple but secure blog application that implements proper security headers:

```python
from flask import Flask, render_template, request, redirect, url_for, session
from flask_talisman import Talisman

app = Flask(__name__)
app.secret_key = 'your-secret-key-here'  # In production, use a secure random key

# Configure CSP to allow what our blog needs
csp = {
    'default-src': '\'self\'',
    'img-src': ['\'self\'', 'https://secure-images.cdn.com'],
    'script-src': ['\'self\'', '\'unsafe-inline\''],  # Unsafe-inline only if absolutely needed
    'style-src': ['\'self\'', '\'unsafe-inline\'', 'https://fonts.googleapis.com'],
    'font-src': ['\'self\'', 'https://fonts.gstatic.com']
}

# Initialize Talisman with our CSP
Talisman(app,
         content_security_policy=csp,
         content_security_policy_nonce_in=['script-src'],
         force_https=True,
         strict_transport_security=True,
         strict_transport_security_max_age=31536000,
         frame_options='SAMEORIGIN')

# Mock blog data
blog_posts = [
    {'id': 1, 'title': 'Introduction to Flask', 'content': 'Flask is a micro web framework...'},
    {'id': 2, 'title': 'Flask Security', 'content': 'Security is important in web applications...'}
]

@app.route('/')
def home():
    return render_template('home.html', posts=blog_posts)

@app.route('/post/<int:post_id>')
def post(post_id):
    post = next((p for p in blog_posts if p['id'] == post_id), None)
    if post:
        return render_template('post.html', post=post)
    return 'Post not found', 404

@app.route('/admin')
def admin():
    if session.get('logged_in'):
        return render_template('admin.html')
    return redirect(url_for('login'))

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        # This is a simple example; in production, use proper authentication
        if request.form.get('username') == 'admin' and request.form.get('password') == 'secure_password':
            session['logged_in'] = True
            return redirect(url_for('admin'))
    return render_template('login.html')

if __name__ == '__main__':
    app.run(debug=True)
```

Sample HTML template (`home.html`) that works with the CSP:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Secure Flask Blog</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <h1>Welcome to Our Secure Blog</h1>
    
    <div class="posts">
        {% for post in posts %}
            <div class="post">
                <h2><a href="{{ url_for('post', post_id=post.id) }}">{{ post.title }}</a></h2>
                <p>{{ post.content|truncate(100) }}</p>
            </div>
        {% endfor %}
    </div>

    <script nonce="{{ csp_nonce() }}">
        // With nonce, this inline script is allowed by our CSP
        console.log('Page loaded securely');
    </script>
</body>
</html>
```

## Testing Your Security Headers

After implementing security headers, it's important to test them. You can use online tools such as:

1. [Mozilla Observatory](https://observatory.mozilla.org/)
2. [Security Headers](https://securityheaders.com/)
3. [CSP Evaluator](https://csp-evaluator.withgoogle.com/)

You can also check headers using `curl`:

```bash
curl -I https://your-flask-app.com
```

## Common Issues and Solutions

### Strict CSP Breaking Functionality

If your Content Security Policy is too strict, it might break some website functionality. Look for console errors in the browser and adjust your policy accordingly.

```python
# More permissive CSP that might be necessary for some applications
csp = {
    'default-src': '\'self\'',
    'script-src': ['\'self\'', '\'unsafe-inline\'', '\'unsafe-eval\'', 'https://apis.google.com'],
    'style-src': ['\'self\'', '\'unsafe-inline\''],
    'img-src': ['\'self\'', 'data:', 'https:'],
    'connect-src': ['\'self\'', 'https://api.example.com']
}
```

### HSTS Breaking Local Development

HSTS can cause issues during local development if you're not using HTTPS. Consider disabling it in development:

```python
# Check if in production before applying HSTS
if app.config['ENV'] == 'production':
    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
```

### Third-Party Scripts and CSP

When using third-party services like Google Analytics or embedded content, you'll need to update your CSP accordingly:

```python
csp = {
    'default-src': '\'self\'',
    'script-src': ['\'self\'', 'https://www.google-analytics.com', 'https://www.googletagmanager.com'],
    'img-src': ['\'self\'', 'https://www.google-analytics.com'],
    'connect-src': ['\'self\'', 'https://www.google-analytics.com']
}
```

## Summary

Implementing secure headers in your Flask application is a crucial step in protecting against common web vulnerabilities. We've covered:

- The importance of HTTP security headers
- Different approaches to implement them (manual, Flask-Talisman, Flask-Security-Headers)
- Detailed explanations of key security headers and their configurations
- A real-world example of a secure Flask blog
- Testing methods and common issues with solutions

By properly configuring security headers, you significantly improve your application's security posture and protect your users from various attacks.

## Additional Resources

1. [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)
2. [Flask-Talisman Documentation](https://github.com/GoogleCloudPlatform/flask-talisman)
3. [Content Security Policy Reference](https://content-security-policy.com/)
4. [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)

## Exercises

1. Implement basic security headers in a simple Flask application and test them using the Mozilla Observatory.
2. Create a Flask application with a custom Content Security Policy that allows loading resources from specific third-party domains.
3. Modify the blog example to include a contact form and update the CSP to allow form submissions.
4. Implement a reporting mechanism for CSP violations using the `report-uri` directive.
5. Create a middleware that automatically adds security headers to all responses in a Flask application without using external extensions.