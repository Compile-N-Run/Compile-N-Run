---
title: Flask Context
description: Understanding how Flask handles application and request contexts, their lifecycle, and practical usage in web applications

---

# Flask Context

## Introduction

Flask, a lightweight Python web framework, utilizes the concept of "contexts" to manage application state and request information during a web application's lifecycle. In simple terms, Flask contexts provide a way to make certain objects globally accessible to your application without having to pass them around explicitly.

Understanding Flask contexts is essential for building robust web applications as they provide access to the current application, the active request, and other important information. This guide explores the two main types of contexts in Flask - Application Context and Request Context - and shows how they help in developing organized and maintainable web applications.

## Flask Context Types

Flask provides two types of contexts:

1. **Application Context**: Related to the application's lifecycle
2. **Request Context**: Related to the handling of HTTP requests

Let's explore each context in detail.

## Application Context

The application context keeps track of the application-level data during the application's lifecycle. It's created and destroyed as needed and won't be shared between requests.

### Key Objects in Application Context

- `current_app`: The active Flask application instance
- `g`: A temporary object for storing data during the application context, reset with each request

### When is Application Context Created?

An application context is created in several situations:

- When a Flask application begins handling a request
- When you explicitly push an application context using `app.app_context()`
- When running Flask CLI commands

### Using the Application Context

Here's how you can explicitly work with the application context:

```python
from flask import Flask, current_app, g

app = Flask(__name__)

@app.route('/')
def index():
    # Inside a request, the application context is already available
    app_name = current_app.name
    return f"App name: {app_name}"

# Using application context outside of a request
with app.app_context():
    # Access current_app
    print(current_app.name)  # Output: 'flask.app.Flask'
    
    # Use g to store temporary data
    g.db_connection = "database_connection"
    print(g.db_connection)  # Output: 'database_connection'
```

Application contexts are particularly useful when you need to access your Flask application in code that runs outside of a view function, such as in background jobs, scripts, or during application initialization.

## Request Context

The request context contains information about the current HTTP request. It provides access to request data such as form data, request headers, and the request method.

### Key Objects in Request Context

- `request`: Contains all information about the current HTTP request
- `session`: Dictionary-like object representing the user session

### When is Request Context Created?

A request context is created automatically when Flask starts handling an HTTP request and is destroyed once the response is sent back to the client.

### Using the Request Context

Here's a practical example of working with the request context:

```python
from flask import Flask, request, session

app = Flask(__name__)
app.secret_key = 'your-secret-key'  # Required for using sessions

@app.route('/user', methods=['GET', 'POST'])
def user():
    if request.method == 'POST':
        # Access form data
        username = request.form.get('username')
        
        # Store in session
        session['username'] = username
        return f"Hello, {username}! Your data has been saved."
    
    # For GET requests
    if 'username' in session:
        return f"Welcome back, {session['username']}!"
    else:
        return '''
        <form method="post">
            <label>Username: <input type="text" name="username"></label>
            <input type="submit" value="Submit">
        </form>
        '''

# Manually pushing a request context (less common)
with app.test_request_context('/user', method='POST', data={'username': 'test_user'}):
    print(request.form.get('username'))  # Output: 'test_user'
```

The `test_request_context()` method is primarily used for testing, allowing you to create a request context outside of an actual HTTP request.

## Context Locals

Flask uses "context locals" to make objects like `current_app`, `g`, `request`, and `session` act like global variables while still being thread-safe. This works through a mechanism called "thread local storage," which ensures that each thread sees its own version of these objects.

These context locals are imported directly from the Flask module:

```python
from flask import current_app, g, request, session
```

## Practical Example: Database Connection with Context

Here's a practical example showing how to manage database connections using Flask contexts:

```python
import sqlite3
from flask import Flask, g, current_app

app = Flask(__name__)

# Configuration
app.config['DATABASE'] = 'example.db'

def get_db():
    """Connect to the database and return a connection object"""
    if 'db' not in g:
        g.db = sqlite3.connect(current_app.config['DATABASE'])
        g.db.row_factory = sqlite3.Row
    return g.db

@app.teardown_appcontext
def close_db(error):
    """Close the database connection at the end of the request"""
    db = g.pop('db', None)
    if db is not None:
        db.close()

@app.route('/users')
def list_users():
    db = get_db()
    users = db.execute('SELECT * FROM users').fetchall()
    return {'users': [dict(user) for user in users]}
```

In this example:
1. We define a `get_db()` function that creates a database connection if one doesn't exist yet and stores it in `g`
2. The `teardown_appcontext` decorator registers a function that runs when the application context ends
3. When the application context ends, we close any open database connections

This pattern ensures that database connections are opened when needed and properly closed after each request, preventing resource leaks.

## Context Nesting and Lifetime

Contexts in Flask follow a stack-like behavior, meaning they can be nested:

```
Request Context â†’ Application Context
```

When you enter a request context, Flask automatically pushes an application context if one doesn't exist yet. When the request context ends, its corresponding application context is popped as well.

## Common Issues with Contexts

### Working Outside of Application Context

One common error is attempting to access `current_app` outside of an application context:

```python
from flask import Flask, current_app

app = Flask(__name__)

# This will fail
print(current_app.name)  # RuntimeError: Working outside of application context

# This works
with app.app_context():
    print(current_app.name)  # Output: 'flask.app.Flask'
```

### Working Outside of Request Context

Similarly, trying to access `request` outside of a request context will fail:

```python
from flask import Flask, request

app = Flask(__name__)

# This will fail
print(request.method)  # RuntimeError: Working outside of request context

# This works
with app.test_request_context('/'):
    print(request.method)  # Output: 'GET'
```

## Summary

Flask contexts provide a clean way to access important objects throughout your application without explicitly passing them around. The two main contexts are:

- **Application Context**: Provides access to `current_app` and `g`
- **Request Context**: Provides access to `request` and `session`

Understanding how these contexts work helps you write more organized and maintainable Flask applications, especially when working with database connections, configuration, and handling HTTP requests.

## Additional Resources

- [Flask Documentation on Contexts](https://flask.palletsprojects.com/en/2.3.x/appcontext/)
- [The Request Context](https://flask.palletsprojects.com/en/2.3.x/reqcontext/)
- [Flask API Documentation](https://flask.palletsprojects.com/en/2.3.x/api/)

## Exercises

1. Create a simple Flask application that uses `g` to count the number of times each route has been accessed during the application's lifetime.
   
2. Write a Flask application with a background task that needs access to the application's configuration. Make sure to properly handle the application context.
   
3. Implement a middleware that logs information about each request by accessing the request context.