---
title: Flask URL Variables
description: Learn how to capture dynamic values from URLs in Flask applications using URL variables and create flexible routing systems

---

# Flask URL Variables

When building web applications, you often need to handle dynamic content based on user input or database information. Flask URL variables provide an elegant way to capture values directly from the URL path, allowing you to create flexible and dynamic routes in your application.

## Introduction to URL Variables

URL variables (also called route parameters or dynamic routing) are components of a URL that can change while still being handled by the same route function. Instead of creating separate routes for similar pages, you can define a single route with variable parts.

For example, instead of creating individual routes for each user profile:
```python
@app.route('/user/john')
@app.route('/user/mary')
@app.route('/user/alex')
```

You can define a single route with a variable:
```python
@app.route('/user/<username>')
```

This approach creates cleaner code and allows for a more scalable application structure.

## Basic Syntax for URL Variables

In Flask, URL variables are defined by enclosing a variable name in angle brackets `<>` within the route pattern:

```python
from flask import Flask

app = Flask(__name__)

@app.route('/user/<username>')
def show_user_profile(username):
    return f'User: {username}'

if __name__ == '__main__':
    app.run(debug=True)
```

When you run this application and navigate to `http://localhost:5000/user/john`, you'll see:

```
User: john
```

The string "john" is captured from the URL and passed to the view function as the `username` parameter.

## Variable Types

By default, Flask treats URL variables as strings, but you can specify different types to automatically convert the variable to that type and apply validation:

```python
from flask import Flask

app = Flask(__name__)

# String variable (default)
@app.route('/blog/<post_title>')
def show_blog_post(post_title):
    return f'Blog Post: {post_title}'

# Integer variable
@app.route('/product/<int:product_id>')
def show_product(product_id):
    return f'Product ID: {product_id}, Type: {type(product_id).__name__}'

# Float variable
@app.route('/price/<float:amount>')
def show_price(amount):
    return f'Price: ${amount:.2f}, Type: {type(amount).__name__}'

# Path variable (includes slashes)
@app.route('/file/<path:file_path>')
def show_file(file_path):
    return f'File path: {file_path}'

if __name__ == '__main__':
    app.run(debug=True)
```

Available converters include:
- `string` (default): accepts any text without a slash
- `int`: accepts positive integers
- `float`: accepts positive floating-point values
- `path`: like string but also accepts slashes
- `uuid`: accepts UUID strings

### Example Outputs

If you navigate to:
- `http://localhost:5000/product/42` → `Product ID: 42, Type: int`
- `http://localhost:5000/price/19.99` → `Price: $19.99, Type: float`
- `http://localhost:5000/file/documents/reports/annual.pdf` → `File path: documents/reports/annual.pdf`

## Multiple URL Variables

You can define multiple URL variables within a single route:

```python
from flask import Flask

app = Flask(__name__)

@app.route('/user/<username>/post/<int:post_id>')
def show_user_post(username, post_id):
    return f'Post {post_id} by {username}'

if __name__ == '__main__':
    app.run(debug=True)
```

Navigating to `http://localhost:5000/user/john/post/42` would display:
```
Post 42 by john
```

## Practical Example: Building a Simple Blog

Let's create a more realistic example for a basic blog application that uses URL variables to display different categories and posts:

```python
from flask import Flask, render_template

app = Flask(__name__)

# Sample blog data
blog_posts = {
    'technology': [
        {'id': 1, 'title': 'Getting Started with Flask', 'content': 'Flask is a micro web framework...'},
        {'id': 2, 'title': 'Python Tips and Tricks', 'content': 'Here are some useful Python tips...'}
    ],
    'travel': [
        {'id': 1, 'title': 'Exploring Paris', 'content': 'Paris is known as the city of lights...'},
        {'id': 2, 'title': 'Tokyo Adventures', 'content': 'Tokyo is a vibrant metropolis...'}
    ]
}

@app.route('/')
def home():
    return render_template('home.html', categories=blog_posts.keys())

@app.route('/category/<category>')
def category(category):
    if category in blog_posts:
        posts = blog_posts[category]
        return render_template('category.html', category=category, posts=posts)
    return f"Category '{category}' not found", 404

@app.route('/category/<category>/post/<int:post_id>')
def post(category, post_id):
    if category in blog_posts:
        for post in blog_posts[category]:
            if post['id'] == post_id:
                return render_template('post.html', category=category, post=post)
    return f"Post not found", 404

if __name__ == '__main__':
    app.run(debug=True)
```

To make this work, you would need to create the following templates:

`home.html`:
```html
<!DOCTYPE html>
<html>
<head>
    <title>My Blog</title>
</head>
<body>
    <h1>Welcome to My Blog</h1>
    <h2>Categories:</h2>
    <ul>
        {% for category in categories %}
            <li><a href="/category/{{ category }}">{{ category|capitalize }}</a></li>
        {% endfor %}
    </ul>
</body>
</html>
```

`category.html`:
```html
<!DOCTYPE html>
<html>
<head>
    <title>{{ category|capitalize }} - My Blog</title>
</head>
<body>
    <h1>{{ category|capitalize }} Posts</h1>
    <ul>
        {% for post in posts %}
            <li>
                <a href="/category/{{ category }}/post/{{ post.id }}">{{ post.title }}</a>
            </li>
        {% endfor %}
    </ul>
    <p><a href="/">Back to Home</a></p>
</body>
</html>
```

`post.html`:
```html
<!DOCTYPE html>
<html>
<head>
    <title>{{ post.title }} - My Blog</title>
</head>
<body>
    <h1>{{ post.title }}</h1>
    <p>{{ post.content }}</p>
    <p><a href="/category/{{ category }}">Back to {{ category|capitalize }}</a></p>
    <p><a href="/">Back to Home</a></p>
</body>
</html>
```

## URL Building with Variables

When creating links in your application, it's better to use Flask's `url_for()` function instead of hardcoding URLs. This makes your application more maintainable and handles URL variable replacement automatically:

```python
from flask import Flask, url_for, redirect

app = Flask(__name__)

@app.route('/user/<username>')
def user_profile(username):
    return f'User: {username}'

@app.route('/redirect_to_user/<username>')
def redirect_to_user(username):
    return redirect(url_for('user_profile', username=username))

# Example of url_for usage
@app.route('/')
def index():
    # Create a link to John's profile
    john_url = url_for('user_profile', username='john')
    return f'<a href="{john_url}">View John\'s profile</a>'

if __name__ == '__main__':
    app.run(debug=True)
```

The `url_for()` function takes the name of the view function as its first argument and any URL variable values as keyword arguments.

## Handling Variable Errors

When using typed URL variables, Flask automatically returns a 404 error if the value can't be converted to the specified type. For example:
- Accessing `/product/abc` when the route is `@app.route('/product/<int:product_id>')` would result in a 404 error because "abc" is not a valid integer.

For more customized error handling, you can use try-except blocks in your view functions:

```python
@app.route('/user/<int:user_id>')
def show_user(user_id):
    try:
        # Assume get_user returns a user or raises UserNotFound
        user = get_user(user_id)
        return render_template('user.html', user=user)
    except UserNotFound:
        return render_template('user_not_found.html', user_id=user_id), 404
```

## Summary

Flask URL variables provide a powerful and elegant way to handle dynamic content in your web applications. They allow you to:

1. Create flexible routes that can handle various inputs
2. Automatically convert URL parts to appropriate Python types
3. Build more maintainable applications with cleaner route structures
4. Create RESTful APIs and resource-oriented URLs

By mastering URL variables, you can create more dynamic and user-friendly Flask applications that efficiently handle different types of content and user interactions.

## Exercises

1. Create a Flask application that shows different products based on a product ID URL variable.
2. Build a simple calculator that takes two numbers and an operation (add, subtract, multiply, divide) as URL variables and returns the result.
3. Create a mock blog system where posts can be filtered by year, month, and day using multiple URL variables.
4. Implement a user management system with routes for viewing, editing, and deleting users with appropriate URL variables.

## Additional Resources

- [Flask Documentation on Variable Rules](https://flask.palletsprojects.com/en/2.2.x/quickstart/#variable-rules)
- [Flask URL Building](https://flask.palletsprojects.com/en/2.2.x/quickstart/#url-building)
- [RESTful API Design Principles](https://restfulapi.net/)
- [Flask Mega-Tutorial: Web Forms](https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iii-web-forms)

Now you have a solid understanding of how to use URL variables in Flask to create dynamic and flexible routing for your web applications!