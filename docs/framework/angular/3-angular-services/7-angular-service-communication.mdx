---
title: Angular Service Communication
description: Learn how to establish communication between components using Angular services, a fundamental pattern for sharing data and functionality across your application

---

# Angular Service Communication

## Introduction

In Angular applications, components are designed to be isolated and focus on specific UI concerns. However, real-world applications often require components to share data and communicate with each other. While parent-child communication can be achieved using `@Input()` and `@Output()` decorators, communication between unrelated components needs a different approach.

This is where **Angular services** shine as communication channels. Services act as centralized data stores and provide methods that components can use to share information, regardless of their position in the component hierarchy.

In this tutorial, we'll learn how to implement effective component communication using Angular services, which is one of the most important and commonly used patterns in Angular development.

## Prerequisites

Before diving in, you should be familiar with:
- Basic Angular concepts
- Component structure
- Dependency injection
- Observable basics (helpful but not required)

## Understanding Service-Based Communication

Angular services provide an elegant solution for component communication through these key mechanisms:

1. **Data sharing**: Services can store shared data that any component can access
2. **Method invocation**: Components can call service methods to trigger actions in other components
3. **Event broadcasting**: Services can emit events that any component can listen to

Let's explore each of these approaches with practical examples.

## Setting Up a Communication Service

First, let's create a basic communication service:

```typescript
// message.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class MessageService {
  // Private behavior subject that holds the current message
  private messageSource = new BehaviorSubject<string>('Default message');
  
  // Exposed as an observable that components can subscribe to
  currentMessage = this.messageSource.asObservable();

  // Method to update the message
  changeMessage(message: string) {
    this.messageSource.next(message);
  }
}
```

This service uses RxJS `BehaviorSubject` to maintain and share a message across components. Let's break down how it works:

- `BehaviorSubject` is a special type of Observable that requires an initial value and always emits its current value to new subscribers
- `currentMessage` is the public Observable that components will subscribe to
- `changeMessage()` is the method components will call to update the message value

## Component Communication Example

Now, let's create two components that will communicate using our service:

```typescript
// sender.component.ts
import { Component } from '@angular/core';
import { MessageService } from '../services/message.service';

@Component({
  selector: 'app-sender',
  template: `
    <h2>Sender Component</h2>
    <input #messageInput placeholder="Type a message">
    <button (click)="sendMessage(messageInput.value)">Send Message</button>
  `
})
export class SenderComponent {
  constructor(private messageService: MessageService) {}

  sendMessage(message: string) {
    this.messageService.changeMessage(message);
  }
}
```

```typescript
// receiver.component.ts
import { Component, OnInit, OnDestroy } from '@angular/core';
import { MessageService } from '../services/message.service';
import { Subscription } from 'rxjs';

@Component({
  selector: 'app-receiver',
  template: `
    <h2>Receiver Component</h2>
    <div class="message-box">
      <p>Message from sender: <strong>{{ message }}</strong></p>
    </div>
  `,
  styles: [`
    .message-box {
      padding: 10px;
      border: 1px solid #ccc;
      background-color: #f8f8f8;
    }
  `]
})
export class ReceiverComponent implements OnInit, OnDestroy {
  message: string = '';
  private subscription: Subscription;

  constructor(private messageService: MessageService) {}

  ngOnInit() {
    this.subscription = this.messageService.currentMessage.subscribe(
      message => this.message = message
    );
  }

  ngOnDestroy() {
    // Always unsubscribe to prevent memory leaks
    this.subscription.unsubscribe();
  }
}
```

In this example:

1. The `SenderComponent` injects the `MessageService` and calls its `changeMessage()` method when the button is clicked
2. The `ReceiverComponent` subscribes to the service's `currentMessage` Observable to receive updates
3. When the user types a message and clicks "Send Message", the receiver component automatically displays the new message

This creates a communication channel between components that don't have a direct relationship in the component hierarchy.

## Advanced Service Communication Techniques

### 1. Using Event Emitters for Multiple Subscribers

Sometimes you need to broadcast events to multiple components. Let's enhance our service:

```typescript
// enhanced-message.service.ts
import { Injectable, EventEmitter } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

export interface Message {
  text: string;
  sender: string;
  timestamp: Date;
}

@Injectable({
  providedIn: 'root'
})
export class EnhancedMessageService {
  // For simple string messages
  private messageSource = new BehaviorSubject<string>('Default message');
  currentMessage = this.messageSource.asObservable();
  
  // For complex message objects
  private messagesSource = new BehaviorSubject<Message[]>([]);
  messages = this.messagesSource.asObservable();
  
  // Event emitter for notification events
  newMessageNotification = new EventEmitter<Message>();

  // Update the simple message
  changeMessage(message: string) {
    this.messageSource.next(message);
  }

  // Add a new complex message
  addMessage(text: string, sender: string) {
    const message: Message = {
      text,
      sender,
      timestamp: new Date()
    };
    
    // Get current messages, add new one
    const currentMessages = this.messagesSource.getValue();
    this.messagesSource.next([...currentMessages, message]);
    
    // Notify subscribers about new message
    this.newMessageNotification.emit(message);
  }

  // Clear all messages
  clearMessages() {
    this.messagesSource.next([]);
  }
}
```

This enhanced service demonstrates:
- Using `BehaviorSubject` to maintain a list of messages
- Using `EventEmitter` to notify components about specific events
- Supporting both simple string and complex object data types

### 2. State Management with Services

For more complex applications, services can manage state:

```typescript
// user.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';

export interface User {
  id: number;
  name: string;
  email: string;
  isAuthenticated: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class UserService {
  private initialState: User = {
    id: 0,
    name: '',
    email: '',
    isAuthenticated: false
  };

  private userSubject = new BehaviorSubject<User>(this.initialState);
  user$ = this.userSubject.asObservable();

  login(email: string, password: string) {
    // In real app, this would make an API call
    // Simulating successful login
    setTimeout(() => {
      const user: User = {
        id: 1,
        name: 'John Doe',
        email: email,
        isAuthenticated: true
      };
      this.userSubject.next(user);
    }, 1000);
  }

  logout() {
    this.userSubject.next(this.initialState);
  }

  updateProfile(name: string) {
    const currentUser = this.userSubject.getValue();
    this.userSubject.next({
      ...currentUser,
      name
    });
  }

  get currentUser(): User {
    return this.userSubject.getValue();
  }
}
```

A component could then use this service:

```typescript
// header.component.ts
import { Component, OnInit } from '@angular/core';
import { UserService, User } from '../services/user.service';
import { Observable } from 'rxjs';

@Component({
  selector: 'app-header',
  template: `
    <header>
      <h1>My App</h1>
      <div *ngIf="(user$ | async) as user">
        <span *ngIf="user.isAuthenticated">
          Welcome, {{ user.name }}!
          <button (click)="logout()">Logout</button>
        </span>
        <button *ngIf="!user.isAuthenticated" (click)="login()">Login</button>
      </div>
    </header>
  `
})
export class HeaderComponent implements OnInit {
  user$: Observable<User>;

  constructor(private userService: UserService) {}

  ngOnInit() {
    this.user$ = this.userService.user$;
  }

  login() {
    this.userService.login('john@example.com', 'password');
  }

  logout() {
    this.userService.logout();
  }
}
```

## Real-World Example: Shopping Cart Service

Let's build a practical example of a shopping cart service that multiple components might use:

```typescript
// cart.service.ts
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Product {
  id: number;
  name: string;
  price: number;
}

export interface CartItem {
  product: Product;
  quantity: number;
}

@Injectable({
  providedIn: 'root'
})
export class CartService {
  private cartItems = new BehaviorSubject<CartItem[]>([]);
  
  // Observable for components to subscribe to
  cart$ = this.cartItems.asObservable();
  
  // Derived observable for cart total
  cartTotal$ = this.cart$.pipe(
    map(items => items.reduce((total, item) => 
      total + (item.product.price * item.quantity), 0))
  );
  
  // Derived observable for item count
  itemCount$ = this.cart$.pipe(
    map(items => items.reduce((count, item) => count + item.quantity, 0))
  );

  addToCart(product: Product, quantity: number = 1) {
    const currentItems = this.cartItems.getValue();
    const existingItem = currentItems.find(item => item.product.id === product.id);
    
    let updatedItems: CartItem[];
    
    if (existingItem) {
      // Update quantity of existing item
      updatedItems = currentItems.map(item => 
        item.product.id === product.id 
          ? { ...item, quantity: item.quantity + quantity }
          : item
      );
    } else {
      // Add new item
      updatedItems = [...currentItems, { product, quantity }];
    }
    
    this.cartItems.next(updatedItems);
  }

  removeFromCart(productId: number) {
    const currentItems = this.cartItems.getValue();
    const updatedItems = currentItems.filter(item => item.product.id !== productId);
    this.cartItems.next(updatedItems);
  }

  updateQuantity(productId: number, quantity: number) {
    const currentItems = this.cartItems.getValue();
    const updatedItems = currentItems.map(item => 
      item.product.id === productId 
        ? { ...item, quantity: quantity } 
        : item
    );
    this.cartItems.next(updatedItems);
  }

  clearCart() {
    this.cartItems.next([]);
  }
}
```

Usage in product and cart components:

```typescript
// product-list.component.ts
import { Component } from '@angular/core';
import { CartService, Product } from '../services/cart.service';

@Component({
  selector: 'app-product-list',
  template: `
    <div class="products">
      <div class="product" *ngFor="let product of products">
        <h3>{{ product.name }}</h3>
        <p>${{ product.price.toFixed(2) }}</p>
        <button (click)="addToCart(product)">Add to Cart</button>
      </div>
    </div>
  `
})
export class ProductListComponent {
  products: Product[] = [
    { id: 1, name: 'Laptop', price: 999.99 },
    { id: 2, name: 'Smartphone', price: 699.99 },
    { id: 3, name: 'Headphones', price: 149.99 }
  ];

  constructor(private cartService: CartService) {}

  addToCart(product: Product) {
    this.cartService.addToCart(product);
  }
}
```

```typescript
// cart-widget.component.ts
import { Component, OnInit } from '@angular/core';
import { Observable } from 'rxjs';
import { CartService, CartItem } from '../services/cart.service';

@Component({
  selector: 'app-cart-widget',
  template: `
    <div class="cart-widget">
      <h2>Your Cart ({{ itemCount$ | async }} items)</h2>
      <ul>
        <li *ngFor="let item of cart$ | async">
          {{ item.product.name }} - ${{ item.product.price.toFixed(2) }} x {{ item.quantity }}
          <button (click)="updateQuantity(item, item.quantity + 1)">+</button>
          <button (click)="updateQuantity(item, item.quantity - 1)" [disabled]="item.quantity <= 1">-</button>
          <button (click)="removeItem(item)">Remove</button>
        </li>
      </ul>
      <div class="cart-total">
        Total: ${{ cartTotal$ | async | number:'1.2-2' }}
      </div>
      <button (click)="clearCart()">Clear Cart</button>
    </div>
  `
})
export class CartWidgetComponent implements OnInit {
  cart$: Observable<CartItem[]>;
  cartTotal$: Observable<number>;
  itemCount$: Observable<number>;

  constructor(private cartService: CartService) {}

  ngOnInit() {
    this.cart$ = this.cartService.cart$;
    this.cartTotal$ = this.cartService.cartTotal$;
    this.itemCount$ = this.cartService.itemCount$;
  }

  updateQuantity(item: CartItem, newQuantity: number) {
    if (newQuantity < 1) return;
    this.cartService.updateQuantity(item.product.id, newQuantity);
  }

  removeItem(item: CartItem) {
    this.cartService.removeFromCart(item.product.id);
  }

  clearCart() {
    this.cartService.clearCart();
  }
}
```

This real-world example demonstrates:
1. Using a service as a centralized state store
2. Derived state through RxJS operators
3. Multiple components interacting with the same service
4. Complex operations like adding, removing, and updating items

## Best Practices for Service Communication

1. **Use RxJS appropriately**: 
   - Use `BehaviorSubject` when you need an initial value and want to cache the latest value
   - Use `Subject` when you don't need an initial value
   - Use `ReplaySubject` when you need to cache multiple values

2. **Always unsubscribe**:
   ```typescript
   ngOnDestroy() {
     this.subscription.unsubscribe();
   }
   ```
   Or use the async pipe in templates when possible:
   ```html
   <div>{{ data$ | async }}</div>
   ```

3. **Keep services focused**: Each service should have a single responsibility

4. **Use proper state management patterns** for complex applications (consider NgRx or other state management libraries)

5. **Document your services** with comments to make them maintainable

## Common Pitfalls to Avoid

1. **Memory leaks**: Forgetting to unsubscribe from observables
2. **Circular dependencies**: Services depending on each other in a loop
3. **Over-engineering**: Creating too many services for simple applications
4. **Under-utilizing observables**: Not taking advantage of RxJS operators for data transformations

## Summary

Angular services provide a powerful mechanism for component communication that helps maintain clean, decoupled code. The key patterns we've covered include:

- Using services as data stores with observables
- Broadcasting events through services
- Managing application state with services
- Creating derived state with RxJS operators

By leveraging these patterns, you can build maintainable Angular applications where components can communicate effectively without tight coupling.

## Additional Resources

- [Angular Official Documentation on Services](https://angular.io/guide/architecture-services)
- [RxJS Documentation](https://rxjs.dev/guide/overview)
- [Angular University: Communication Between Components Using @Output, EventEmitter, and @Input](https://blog.angular-university.io/angular-components-communication/)

## Exercises

1. Create a notification service that allows any component to add notifications and displays them in a notification component
2. Implement a theme service that allows users to toggle between light and dark theme
3. Build a user preferences service that saves user settings to localStorage and loads them when the app starts
4. Enhance the cart service to persist the cart data between page refreshes using localStorage
5. Create a data synchronization service that simulates sending cart updates to a backend API

By completing these exercises, you'll gain practical experience in implementing various service communication patterns in Angular applications.