---
title: Angular Template Expressions
description: Learn how to use expressions in Angular templates to bind data and execute logic within your HTML templates.

---

# Angular Template Expressions

## Introduction

Angular template expressions are JavaScript-like code snippets that Angular evaluates within templates. These expressions appear within double curly braces `{{ }}` for interpolation or within quotes for property, event, or attribute bindings. Template expressions are the foundation of Angular's powerful data-binding system, allowing you to build dynamic and responsive user interfaces.

In this guide, you'll learn how template expressions work, their syntax restrictions, and best practices for using them effectively in your Angular applications.

## Understanding Template Expressions

Template expressions allow you to access component properties and methods directly from your HTML templates. Angular evaluates these expressions and automatically updates the DOM when the underlying data changes.

### Basic Syntax

The most common way to use template expressions is through interpolation using the double curly braces syntax:

```html
<p>Hello, {{ username }}!</p>
<div>The sum of 1 + 1 is {{ 1 + 1 }}</div>
<span>Today is {{ getCurrentDate() }}</span>
```

When Angular renders this template, it evaluates each expression and replaces it with the resulting value:

- `{{ username }}` gets replaced with the value of the `username` property from your component
- `{{ 1 + 1 }}` gets replaced with `2`
- `{{ getCurrentDate() }}` gets replaced with the result of calling the `getCurrentDate()` method from your component

## Template Expression Limitations

While template expressions look like JavaScript, they have several important restrictions:

1. **No assignments**: You cannot use assignments (`=`, `+=`, `-=`, etc.)
2. **No `new` operator**: You cannot create new objects with `new`
3. **No chaining expressions** with `;` or `,`
4. **No increment/decrement operators**: `++` and `--` are not allowed
5. **No bitwise operators**: `|`, `&`, etc. are not supported
6. **Limited control flow statements**: No `if/else`, `for` loops, etc.

These restrictions help ensure that expressions remain simple and focused on data binding, rather than executing complex logic in your templates.

## Contexts in Template Expressions

Angular evaluates template expressions against a specific context. By default, this is the component instance. This means expressions have access to:

1. Properties and methods of the component
2. Properties and methods of template-specific contexts (like `*ngFor` loop variables)
3. Template reference variables

### Example with Component Context

Let's see a complete example showing how template expressions access component properties:

```typescript
// user-greeting.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-user-greeting',
  template: `
    <h2>Hello, {{ username }}!</h2>
    <p>You have {{ messageCount }} unread messages.</p>
    <p>Your subscription {{ isSubscriptionActive ? 'is active' : 'has expired' }}.</p>
    <button (click)="incrementMessages()">Add message</button>
  `
})
export class UserGreetingComponent {
  username = 'Maria';
  messageCount = 5;
  isSubscriptionActive = true;
  
  incrementMessages() {
    this.messageCount++;
  }
}
```

In this example:
- `{{ username }}` and `{{ messageCount }}` access component properties
- `{{ isSubscriptionActive ? 'is active' : 'has expired' }}` uses a ternary expression
- The button click event uses a method from the component

## Common Uses of Template Expressions

### 1. String Interpolation

The most common use of template expressions is displaying text:

```html
<h1>Welcome to {{ appName }}</h1>
<p>{{ user.firstName }} {{ user.lastName }}</p>
```

### 2. Property Binding

Template expressions are used in property bindings with the `[]` syntax:

```html
<img [src]="product.imageUrl">
<button [disabled]="isLoading">Save</button>
```

### 3. Attribute Binding

For HTML attributes that don't have corresponding DOM properties:

```html
<div [attr.aria-label]="description">
  <!-- content -->
</div>
```

### 4. Class and Style Bindings

Control CSS classes and styles dynamically:

```html
<div [class.active]="isActive">This div is conditionally active</div>
<span [style.color]="isError ? 'red' : 'green'">Status message</span>
```

### 5. Event Binding

Template expressions are used to respond to events:

```html
<button (click)="addToCart(product)">Add to Cart</button>
<input (keyup)="updateSearch($event.target.value)">
```

## Expression Operators

Angular templates support many JavaScript operators:

### 1. Arithmetic Operators

```html
<div>Total: {{ quantity * price }}</div>
<div>Discount: {{ price - (price * discount / 100) }}</div>
```

### 2. Comparison Operators

```html
<div *ngIf="user.age >= 18">Content for adults</div>
```

### 3. Logical Operators

```html
<div *ngIf="isLoggedIn && hasPermission">
  You have access to this content
</div>
<button [disabled]="isLoading || hasErrors">Submit</button>
```

### 4. String Concatenation

```html
<p>Welcome, {{ user.firstName + ' ' + user.lastName }}!</p>
```

### 5. Ternary Operator

```html
<div>Status: {{ isActive ? 'Active' : 'Inactive' }}</div>
```

## Pipe Expressions

Angular pipes transform data for display and can be used within template expressions:

```html
<p>Today is {{ currentDate | date: 'fullDate' }}</p>
<div>Amount: {{ price | currency: 'USD' }}</div>
<p>{{ longText | slice:0:100 }}...</p>
```

## Real-world Example: Product Listing

Let's look at a more comprehensive example showing template expressions in action:

```typescript
// product-list.component.ts
import { Component } from '@angular/core';

interface Product {
  id: number;
  name: string;
  price: number;
  discountPercentage: number;
  inStock: boolean;
}

@Component({
  selector: 'app-product-list',
  template: `
    <div class="product-list">
      <div 
        *ngFor="let product of products" 
        class="product-card"
        [class.out-of-stock]="!product.inStock">
        
        <h3>{{ product.name }}</h3>
        
        <div class="price-section">
          <span *ngIf="product.discountPercentage > 0" class="original-price">
            {{ product.price | currency }}
          </span>
          <span class="current-price" [class.discounted]="product.discountPercentage > 0">
            {{ calculateFinalPrice(product) | currency }}
          </span>
          <span *ngIf="product.discountPercentage > 0" class="discount-badge">
            {{ product.discountPercentage }}% off
          </span>
        </div>
        
        <div class="stock-status" [style.color]="product.inStock ? 'green' : 'red'">
          {{ product.inStock ? 'In Stock' : 'Out of Stock' }}
        </div>
        
        <button 
          (click)="addToCart(product)"
          [disabled]="!product.inStock">
          Add to Cart
        </button>
      </div>
    </div>
  `
})
export class ProductListComponent {
  products: Product[] = [
    { id: 1, name: 'Smartphone', price: 699.99, discountPercentage: 10, inStock: true },
    { id: 2, name: 'Laptop', price: 1299.99, discountPercentage: 0, inStock: true },
    { id: 3, name: 'Headphones', price: 199.99, discountPercentage: 15, inStock: false }
  ];
  
  calculateFinalPrice(product: Product): number {
    if (product.discountPercentage > 0) {
      return product.price * (1 - product.discountPercentage / 100);
    }
    return product.price;
  }
  
  addToCart(product: Product): void {
    if (product.inStock) {
      console.log(`Added ${product.name} to cart!`);
      // Implementation for adding to cart
    }
  }
}
```

In this example, we have a product listing that uses various template expressions:

1. Interpolation with `{{ product.name }}` and `{{ product.discountPercentage }}`
2. Method calls like `{{ calculateFinalPrice(product) | currency }}`
3. Property binding with `[class.out-of-stock]="!product.inStock"`
4. Style binding with `[style.color]="product.inStock ? 'green' : 'red'"`
5. Event binding with `(click)="addToCart(product)"`
6. Conditional logic with ternary expressions like `{{ product.inStock ? 'In Stock' : 'Out of Stock' }}`

## Best Practices

1. **Keep expressions simple** - Complex logic should be in the component, not the template
2. **Avoid side effects** - Expressions shouldn't change any state
3. **Be wary of null values** - Use safe navigation operator (`?.`) or `*ngIf` to handle potential null values
4. **Cache complex calculations** - For expensive operations, compute the value in the component
5. **Use pure pipes** - They're more efficient as they only recalculate when inputs change

## Common Mistakes and Their Solutions

### Mistake 1: Complex Logic in Templates

❌ Bad:
```html
<div>{{ user.firstName + ' ' + (user.middleName ? user.middleName + ' ' : '') + user.lastName }}</div>
```

✅ Better:
```typescript
// In component
getFullName(): string {
  return this.user.firstName + ' ' + 
    (this.user.middleName ? this.user.middleName + ' ' : '') + 
    this.user.lastName;
}
```

```html
<!-- In template -->
<div>{{ getFullName() }}</div>
```

### Mistake 2: Not Handling Null Values

❌ Bad:
```html
<div>{{ user.address.street }}</div> <!-- Could throw error if address is null -->
```

✅ Better:
```html
<div>{{ user?.address?.street }}</div>
<!-- or -->
<div *ngIf="user && user.address">{{ user.address.street }}</div>
```

### Mistake 3: Method Calls in Templates

❌ Bad (if `calculateTotal()` is computationally expensive):
```html
<div *ngFor="let item of cartItems">
  <!-- calculateTotal() called on every change detection cycle -->
  <span>{{ calculateTotal() | currency }}</span>
</div>
```

✅ Better:
```typescript
// In component
ngOnInit() {
  this.total = this.calculateTotal();
}

updateCart() {
  // called whenever cart changes
  this.total = this.calculateTotal();
}
```

```html
<!-- In template -->
<span>{{ total | currency }}</span>
```

## Summary

Angular template expressions are a powerful feature that allows you to create dynamic templates that respond to changes in your component data. They provide a clean way to bind data, handle events, and conditionally display content.

Key points to remember:
- Template expressions appear in interpolation with `{{ }}` or in property/event bindings
- They have access to component properties and methods
- They have some syntax restrictions compared to regular JavaScript
- Keep expressions simple and move complex logic to component methods
- Use operators like the safe navigation operator (`?.`) to handle potential null values

By mastering template expressions, you can build more interactive and dynamic Angular applications with cleaner, more maintainable code.

## Additional Resources

- [Official Angular Documentation on Template Expressions](https://angular.io/guide/template-syntax#template-expressions)
- [Angular Template Syntax Guide](https://angular.io/guide/template-syntax)
- [Angular Template Expression Operators](https://angular.io/guide/template-expression-operators)

## Exercises

1. Create a shopping cart component that displays items, quantities, and calculates totals using template expressions.
2. Build a form that uses template expressions to show validation messages based on user input.
3. Implement a dashboard component that uses expressions to conditionally style elements based on data values (like showing numbers in red if negative).
4. Enhance the product listing example to include a search filter and sorting options using template expressions.