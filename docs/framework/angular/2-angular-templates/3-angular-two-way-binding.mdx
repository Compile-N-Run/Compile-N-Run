---
title: Angular Two-way Binding
description: Learn how to implement two-way data binding in Angular using ngModel and the banana-in-a-box syntax to synchronize data between components and templates.

---

# Angular Two-way Binding

## Introduction

Two-way binding is one of Angular's most powerful features that creates a connection between your component's data and your HTML template. Unlike one-way binding which only flows data in a single direction, two-way binding enables data to flow in both directions - from your component to the view and from the view back to the component when user events occur.

This synchronization happens automatically, allowing you to build interactive forms and UI elements that respond immediately to user input without writing extensive event handling code.

## Prerequisites

Before diving into two-way binding, you should be familiar with:

- Basic Angular concepts
- Component architecture
- Property binding (one-way binding from component to view)
- Event binding (one-way binding from view to component)

## Understanding Two-way Binding

Two-way binding in Angular is essentially a combination of:

1. **Property binding** `[property]="data"` - sending data from component to view
2. **Event binding** `(event)="handler()"` - sending data from view to component

Angular provides a special syntax called "banana in a box" `[()]` which combines these two bindings into one convenient expression.

## The Banana-in-a-Box Syntax

The banana-in-a-box syntax `[(ngModel)]` is the most common way to implement two-way binding in Angular:

```html
<input [(ngModel)]="username">
```

This is equivalent to writing:

```html
<input [ngModel]="username" (ngModelChange)="username = $event">
```

The first part `[ngModel]="username"` binds the username property of your component to the input value, while the second part `(ngModelChange)="username = $event"` updates the username property when the input value changes.

## Setting Up ngModel

To use `ngModel`, you'll need to import the `FormsModule` from `@angular/forms`:

```typescript
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule  // Add FormsModule here
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## Basic Two-way Binding Example

Let's create a simple example that demonstrates two-way binding with an input field:

```typescript
// app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  username: string = 'Guest';
}
```

```html
<!-- app.component.html -->
<div class="container">
  <h2>Two-way Binding Example</h2>
  
  <div class="form-group">
    <label>Enter your name: </label>
    <input [(ngModel)]="username" class="form-control">
  </div>
  
  <div class="output">
    <p>Hello, {{username}}!</p>
  </div>
</div>
```

In this example:
1. We initialize `username` with the value "Guest"
2. The input field is bound to the `username` property using `[(ngModel)]`
3. When you type in the input field, the `username` property updates automatically
4. The greeting displayed below updates in real-time as you type

## Two-way Binding with Different Form Elements

Two-way binding works with various form elements:

### Checkbox Example

```typescript
// component
export class CheckboxComponent {
  isSubscribed: boolean = false;
}
```

```html
<div class="form-group">
  <label>
    <input type="checkbox" [(ngModel)]="isSubscribed"> Subscribe to newsletter
  </label>
  <p *ngIf="isSubscribed">Thank you for subscribing!</p>
</div>
```

### Select Dropdown Example

```typescript
// component
export class SelectComponent {
  selectedCountry: string = 'USA';
  countries: string[] = ['USA', 'Canada', 'UK', 'Australia', 'Japan'];
}
```

```html
<div class="form-group">
  <label>Select your country:</label>
  <select [(ngModel)]="selectedCountry">
    <option *ngFor="let country of countries" [value]="country">
      {{country}}
    </option>
  </select>
  <p>You selected: {{selectedCountry}}</p>
</div>
```

### Radio Button Example

```typescript
// component
export class RadioComponent {
  favoriteColor: string = 'red';
}
```

```html
<div class="form-group">
  <p>Choose your favorite color:</p>
  
  <label>
    <input type="radio" [(ngModel)]="favoriteColor" name="color" value="red"> Red
  </label>
  
  <label>
    <input type="radio" [(ngModel)]="favoriteColor" name="color" value="green"> Green
  </label>
  
  <label>
    <input type="radio" [(ngModel)]="favoriteColor" name="color" value="blue"> Blue
  </label>
  
  <p>Your favorite color is: {{favoriteColor}}</p>
</div>
```

## Creating Custom Two-way Binding

You can also create your own custom two-way binding for your components. This is useful when you want to create reusable components that follow the same pattern.

Let's create a custom counter component with two-way binding:

```typescript
// counter.component.ts
import { Component, Input, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-counter',
  template: `
    <div class="counter">
      <button (click)="decrement()">-</button>
      <span>{{ count }}</span>
      <button (click)="increment()">+</button>
    </div>
  `,
  styles: [`
    .counter {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    button {
      width: 30px;
      height: 30px;
    }
  `]
})
export class CounterComponent {
  @Input() count: number = 0;
  @Output() countChange = new EventEmitter<number>();

  increment() {
    this.count++;
    this.countChange.emit(this.count);
  }

  decrement() {
    this.count--;
    this.countChange.emit(this.count);
  }
}
```

To use this component with two-way binding:

```html
<!-- app.component.html -->
<div class="container">
  <h2>Custom Two-way Binding</h2>
  <app-counter [(count)]="counterValue"></app-counter>
  <p>Current count: {{counterValue}}</p>
</div>
```

```typescript
// app.component.ts
export class AppComponent {
  counterValue: number = 5;
}
```

For custom two-way binding to work:
1. Create an `@Input()` property (e.g., `count`)
2. Create an `@Output()` property with the same name plus "Change" suffix (e.g., `countChange`)
3. Emit events from the `@Output()` property whenever the value changes

## Real-world Example: User Registration Form

Let's build a more comprehensive example - a user registration form that validates input and provides feedback:

```typescript
// register.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
  styleUrls: ['./register.component.css']
})
export class RegisterComponent {
  user = {
    name: '',
    email: '',
    password: '',
    confirmPassword: '',
    acceptTerms: false
  };

  submitted = false;

  get passwordsMatch(): boolean {
    return this.user.password === this.user.confirmPassword;
  }

  get formValid(): boolean {
    return (
      this.user.name.length > 0 &&
      this.user.email.includes('@') &&
      this.user.password.length >= 8 &&
      this.passwordsMatch &&
      this.user.acceptTerms
    );
  }

  onSubmit() {
    this.submitted = true;
    if (this.formValid) {
      // Form is valid, submit to server
      console.log('Form submitted:', this.user);
    }
  }
}
```

```html
<!-- register.component.html -->
<div class="registration-form">
  <h2>Create an Account</h2>

  <div class="form-group">
    <label for="name">Full Name</label>
    <input 
      id="name"
      type="text" 
      [(ngModel)]="user.name" 
      required
      [class.is-invalid]="submitted && user.name.length === 0">
    <div *ngIf="submitted && user.name.length === 0" class="error-message">
      Name is required
    </div>
  </div>

  <div class="form-group">
    <label for="email">Email</label>
    <input 
      id="email"
      type="email" 
      [(ngModel)]="user.email" 
      required
      [class.is-invalid]="submitted && !user.email.includes('@')">
    <div *ngIf="submitted && !user.email.includes('@')" class="error-message">
      Please enter a valid email
    </div>
  </div>

  <div class="form-group">
    <label for="password">Password</label>
    <input 
      id="password"
      type="password" 
      [(ngModel)]="user.password" 
      required
      [class.is-invalid]="submitted && user.password.length < 8">
    <div *ngIf="submitted && user.password.length < 8" class="error-message">
      Password must be at least 8 characters
    </div>
  </div>

  <div class="form-group">
    <label for="confirmPassword">Confirm Password</label>
    <input 
      id="confirmPassword"
      type="password" 
      [(ngModel)]="user.confirmPassword" 
      required
      [class.is-invalid]="submitted && !passwordsMatch">
    <div *ngIf="submitted && !passwordsMatch" class="error-message">
      Passwords don't match
    </div>
  </div>

  <div class="form-group checkbox">
    <label>
      <input 
        type="checkbox" 
        [(ngModel)]="user.acceptTerms"
        [class.is-invalid]="submitted && !user.acceptTerms">
      I accept the terms and conditions
    </label>
    <div *ngIf="submitted && !user.acceptTerms" class="error-message">
      You must accept the terms
    </div>
  </div>

  <button 
    type="submit"
    (click)="onSubmit()"
    [disabled]="submitted && !formValid">
    Register
  </button>

  <div *ngIf="submitted && formValid" class="success-message">
    Registration successful!
  </div>
</div>
```

This registration form example showcases several key aspects of two-way binding:
1. Multiple form controls all bound to properties of a user object
2. Real-time validation that updates as the user types
3. Form submission that respects the validation state
4. Conditional display of error messages

## Common Pitfalls and Best Practices

### Immutable Objects

When using two-way binding with objects, be careful with nested properties. Angular's change detection might not detect changes to nested properties if you modify them directly:

```typescript
// This might not update the view properly
this.user.address.street = "New Street";
```

Instead, create a new object:

```typescript
// This will ensure proper updates
this.user = { 
  ...this.user, 
  address: { 
    ...this.user.address, 
    street: "New Street" 
  } 
};
```

### Performance Considerations

Two-way binding is convenient but can impact performance when overused, especially on frequently updated values or large forms. For high-performance requirements:

1. Consider using Reactive Forms instead of template-driven forms with ngModel
2. Break complex forms into smaller components
3. Implement OnPush change detection strategy for better performance

### Testing Two-way Binding

When testing components that use two-way binding, you'll need to:

1. Import FormsModule in your TestBed configuration
2. Trigger input events to simulate user interaction
3. Check that both the view and the component model are updated correctly

```typescript
// Example test for a component with two-way binding
it('should update component property when input changes', () => {
  const input = fixture.debugElement.query(By.css('input')).nativeElement;
  input.value = 'New Value';
  input.dispatchEvent(new Event('input'));
  
  expect(component.username).toBe('New Value');
});
```

## Summary

Two-way binding is a powerful feature in Angular that simplifies the synchronization of data between your component and template. By using the `[(ngModel)]` syntax, you can create interactive forms and UI elements without writing extensive code to handle data flow in both directions.

Key points to remember:

1. Two-way binding combines property binding `[]` and event binding `()`
2. Import `FormsModule` to use `ngModel`
3. The "banana in a box" syntax `[(ngModel)]` is shorthand for `[ngModel]` and `(ngModelChange)`
4. You can create custom two-way binding by pairing an `@Input()` with an `@Output()` that has the "Change" suffix
5. Use two-way binding with various form elements like inputs, checkboxes, select dropdowns, and radio buttons

## Additional Resources

- [Angular Forms Guide](https://angular.io/guide/forms-overview)
- [NgModel API Documentation](https://angular.io/api/forms/NgModel)
- [Angular Custom Two-way Binding](https://angular.io/guide/two-way-binding)

## Exercises

1. Create a form that collects user preferences (name, theme color, notification settings) and displays them in real-time
2. Build a tip calculator that uses two-way binding to update the tip amount as the bill total changes
3. Implement a custom rating component with two-way binding that allows users to rate from 1-5 stars
4. Create a complex form with validation that checks email format, password strength, and field matching
5. Modify the user registration example to include additional fields like address and phone number