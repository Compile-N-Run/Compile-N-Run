---
title: Angular Memory Management
description: Learn how to effectively manage memory in Angular applications to prevent memory leaks and optimize performance.

---

# Angular Memory Management

## Introduction

Memory management is a critical aspect of developing performant Angular applications. Poor memory management can lead to memory leaks, which gradually consume browser memory and degrade application performance over time. In this tutorial, we'll explore how Angular manages memory, common causes of memory leaks, and best practices to avoid them.

Memory leaks occur when your application allocates memory but fails to release it when no longer needed. In browser applications, this means objects remain in memory even when they're no longer useful, causing increased memory consumption and potentially crashing the application.

## Understanding Memory Management in Angular

Angular is built with memory management in mind, providing automatic cleanup mechanisms via its change detection system. However, certain programming patterns can bypass these mechanisms and cause memory leaks.

### The Angular Lifecycle

Angular components have lifecycle hooks that provide opportunities for cleanup:

```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-example',
  template: '<div>Memory Management Example</div>'
})
export class ExampleComponent implements OnInit, OnDestroy {
  ngOnInit() {
    // Initialize resources
    console.log('Component initialized');
  }

  ngOnDestroy() {
    // Clean up resources
    console.log('Component destroyed - resources cleaned up');
  }
}
```

When this component is removed from the DOM, Angular calls `ngOnDestroy`, giving you an opportunity to clean up resources.

## Common Causes of Memory Leaks in Angular

### 1. Unsubscribed Observables

One of the most common causes of memory leaks in Angular applications is forgetting to unsubscribe from Observables:

```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { interval, Subscription } from 'rxjs';

@Component({
  selector: 'app-timer',
  template: '<div>Time elapsed: {{ counter }} seconds</div>'
})
export class TimerComponent implements OnInit, OnDestroy {
  counter = 0;
  private timerSubscription: Subscription;

  ngOnInit() {
    // This creates a memory leak if not unsubscribed!
    this.timerSubscription = interval(1000).subscribe(() => {
      this.counter++;
      console.log(this.counter);
    });
  }

  // Missing ngOnDestroy would cause a memory leak
}
```

Even after the component is destroyed, the subscription would continue running and consuming memory. Here's the correct way:

```typescript
ngOnDestroy() {
  // Proper cleanup
  if (this.timerSubscription) {
    this.timerSubscription.unsubscribe();
    console.log('Timer subscription unsubscribed');
  }
}
```

### 2. Event Listeners Not Removed

DOM event listeners attached in Angular components can cause memory leaks if not properly removed:

```typescript
import { Component, OnInit, OnDestroy, ElementRef } from '@angular/core';

@Component({
  selector: 'app-scroll-tracker',
  template: '<div>Scroll position tracking component</div>'
})
export class ScrollTrackerComponent implements OnInit, OnDestroy {
  private scrollHandler: any;

  constructor(private el: ElementRef) {}

  ngOnInit() {
    this.scrollHandler = () => console.log('Window scrolled');
    window.addEventListener('scroll', this.scrollHandler);
  }

  ngOnDestroy() {
    // Clean up the event listener
    window.removeEventListener('scroll', this.scrollHandler);
    console.log('Scroll event listener removed');
  }
}
```

### 3. References to DOM Elements

Holding references to DOM elements can prevent garbage collection:

```typescript
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-dom-reference',
  template: '<div #myElement>DOM reference example</div>'
})
export class DomReferenceComponent implements OnInit {
  private elements: HTMLElement[] = [];

  ngOnInit() {
    // BAD: Storing references without cleanup
    this.elements.push(document.querySelector('#some-element'));
  }
  
  // Missing cleanup code
}
```

## Best Practices for Memory Management

### 1. Use the Async Pipe

The async pipe automatically subscribes and unsubscribes from Observables:

```typescript
import { Component } from '@angular/core';
import { interval } from 'rxjs';
import { map } from 'rxjs/operators';

@Component({
  selector: 'app-async-example',
  template: `<div>
    Counter: {{ counter$ | async }}
  </div>`
})
export class AsyncExampleComponent {
  counter$ = interval(1000).pipe(map((val) => val + 1));
}
```

No manual subscription management needed - Angular handles it automatically!

### 2. Use takeUntil Pattern for Multiple Observables

For components with multiple subscriptions, the takeUntil pattern is efficient:

```typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { interval, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Component({
  selector: 'app-multiple-streams',
  template: '<div>Managing multiple streams example</div>'
})
export class MultipleStreamsComponent implements OnInit, OnDestroy {
  private destroy$ = new Subject<void>();
  data: any;
  counter = 0;

  constructor(private http: HttpClient) {}

  ngOnInit() {
    // First subscription
    this.http.get('https://api.example.com/data')
      .pipe(takeUntil(this.destroy$))
      .subscribe(response => {
        this.data = response;
      });

    // Second subscription
    interval(1000)
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.counter++;
      });
  }

  ngOnDestroy() {
    // One line cleans up all subscriptions
    this.destroy$.next();
    this.destroy$.complete();
    console.log('All subscriptions cleaned up');
  }
}
```

### 3. Implement OnDestroy for all Components with Resources

Make it a habit to implement OnDestroy for components that manage any kind of resource:

```typescript
import { Component, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-best-practice',
  template: '<div>Always implement OnDestroy</div>'
})
export class BestPracticeComponent implements OnDestroy {
  // Component logic...

  ngOnDestroy() {
    // Cleanup code here
    console.log('Component resources cleaned up');
  }
}
```

## Detecting Memory Leaks

Modern browsers provide tools to help identify memory leaks:

### Using Chrome DevTools

1. Open Chrome DevTools (F12)
2. Go to the Memory tab
3. Take a heap snapshot
4. Perform actions in your app
5. Take another snapshot
6. Compare snapshots to find retained objects

Here's how to detect memory leaks in practice:

1. Navigate to your component
2. Take a heap snapshot
3. Navigate away from the component (should be destroyed)
4. Take another heap snapshot
5. Look for instances of your component that should have been garbage collected

## Real-World Example: Memory-Safe Modal Service

Let's build a memory-safe modal service that properly cleans up resources:

```typescript
// modal.service.ts
import { Injectable, ComponentRef, ApplicationRef, ComponentFactoryResolver, Injector } from '@angular/core';
import { Subject } from 'rxjs';
import { ModalComponent } from './modal.component';

@Injectable({
  providedIn: 'root'
})
export class ModalService {
  private modalComponentRef: ComponentRef<ModalComponent> | null = null;
  private modalClosed = new Subject<void>();
  
  modalClosed$ = this.modalClosed.asObservable();

  constructor(
    private componentFactoryResolver: ComponentFactoryResolver,
    private appRef: ApplicationRef,
    private injector: Injector
  ) {}

  open(content: string): void {
    // Create component
    const componentFactory = this.componentFactoryResolver.resolveComponentFactory(ModalComponent);
    this.modalComponentRef = componentFactory.create(this.injector);
    
    // Set input properties
    this.modalComponentRef.instance.content = content;
    this.modalComponentRef.instance.close.subscribe(() => this.close());
    
    // Attach to app
    this.appRef.attachView(this.modalComponentRef.hostView);
    document.body.appendChild(this.modalComponentRef.location.nativeElement);
  }

  close(): void {
    if (this.modalComponentRef) {
      // Proper cleanup
      this.appRef.detachView(this.modalComponentRef.hostView);
      this.modalComponentRef.destroy();
      this.modalComponentRef = null;
      this.modalClosed.next();
      console.log('Modal component properly destroyed');
    }
  }
}
```

```typescript
// modal.component.ts
import { Component, Input, Output, EventEmitter, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-modal',
  template: `
    <div class="modal">
      <div class="modal-content">
        <span class="close" (click)="onClose()">&times;</span>
        <p>{{ content }}</p>
      </div>
    </div>
  `,
  styles: [`
    .modal {
      position: fixed; 
      z-index: 1000;
      left: 0; 
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.4);
    }
    .modal-content {
      background-color: white;
      margin: 15% auto;
      padding: 20px;
      width: 70%;
    }
    .close {
      float: right;
      cursor: pointer;
    }
  `]
})
export class ModalComponent implements OnDestroy {
  @Input() content: string;
  @Output() close = new EventEmitter<void>();

  onClose(): void {
    this.close.emit();
  }

  ngOnDestroy(): void {
    console.log('Modal component ngOnDestroy called');
  }
}
```

Using the modal service:

```typescript
// app.component.ts
import { Component } from '@angular/core';
import { ModalService } from './modal.service';

@Component({
  selector: 'app-root',
  template: `
    <button (click)="openModal()">Open Modal</button>
  `
})
export class AppComponent {
  constructor(private modalService: ModalService) {}

  openModal(): void {
    this.modalService.open('This is a memory-safe modal!');
  }
}
```

## Memory Profiling with @angular/core/debug

Angular provides debugging tools to help identify memory issues:

```typescript
import { Component, NgZone } from '@angular/core';
import { ChangeDetectionPerfRecord, enableDebugTools } from '@angular/platform-browser';

@Component({
  selector: 'app-profiling',
  template: '<div>Profiling example</div>'
})
export class ProfilingComponent {
  constructor(ngZone: NgZone) {
    // Access Angular's profiling features
    ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        // Example of recording performance
        const record: ChangeDetectionPerfRecord = {
          msPerTick: 0,
          numTicks: 0
        };
        console.log('Performance record:', record);
      }, 3000);
    });
  }
}
```

## Summary

Proper memory management is crucial for building high-performing Angular applications. Let's recap the key points:

1. Always unsubscribe from Observables in the ngOnDestroy lifecycle hook
2. Use the async pipe when possible to automatically manage subscriptions
3. Implement the takeUntil pattern for components with multiple subscriptions
4. Remember to remove event listeners and clear references to DOM elements
5. Implement ngOnDestroy for all components that manage resources
6. Regularly test your application for memory leaks using browser dev tools

By following these best practices, you can avoid memory leaks and ensure your Angular applications remain performant even after extended use.

## Additional Resources

- [Angular Official Documentation on Change Detection](https://angular.io/guide/change-detection)
- [RxJS Documentation on Subscription Management](https://rxjs.dev/guide/subscription)
- [Chrome DevTools Memory Panel](https://developers.google.com/web/tools/chrome-devtools/memory-problems)

## Exercises

1. Create a component that uses the interval Observable and demonstrates proper subscription cleanup.
2. Implement the takeUntil pattern in a component with at least three different Observable subscriptions.
3. Use Chrome DevTools to profile an Angular application and identify memory usage patterns.
4. Create a service that manages browser resources (like WebSockets or localStorage) with proper cleanup.
5. Refactor an existing component that has potential memory leaks, implementing proper cleanup procedures.