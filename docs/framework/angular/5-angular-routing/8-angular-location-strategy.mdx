---
title: Angular Location Strategy
description: Learn about Angular's Location Strategy, how to implement PathLocationStrategy and HashLocationStrategy, and when to use each approach in your Angular applications.

---

# Angular Location Strategy

## Introduction

When building single-page applications (SPAs) with Angular, handling browser URLs and navigation is a crucial aspect of creating a seamless user experience. Angular's Location Strategy provides a way to manage how URLs are represented in the browser's address bar and how the application responds to navigation events.

In this guide, we'll explore Angular's Location Strategy, understand the different types available, and learn when to use each approach. This knowledge is essential for creating robust routing systems in your Angular applications.

## What is Location Strategy?

Location Strategy in Angular is an abstraction that determines how your application tracks and represents URL changes. It provides a consistent API for Angular's router to work with different URL styles without having to change the application logic.

Angular provides two main Location Strategy implementations:

1. **PathLocationStrategy (default)**: Uses the HTML5 History API
2. **HashLocationStrategy**: Uses hash-based URLs

Let's explore each of these strategies in detail.

## PathLocationStrategy (Default)

PathLocationStrategy is Angular's default location strategy. It leverages the HTML5 History API to manipulate the browser URL without causing a full page reload.

### How it works

With PathLocationStrategy, URLs in your application look like regular URLs:

```
https://example.com/users
https://example.com/users/profile
```

### Implementation

Angular uses PathLocationStrategy by default, so you don't need to explicitly configure it. However, if you want to be explicit, you can configure it in your app module:

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { LocationStrategy, PathLocationStrategy } from '@angular/common';
import { AppComponent } from './app.component';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    BrowserModule,
    RouterModule.forRoot([
      // Your routes here
    ])
  ],
  declarations: [AppComponent],
  providers: [
    { provide: LocationStrategy, useClass: PathLocationStrategy }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### Server Configuration Requirements

When using PathLocationStrategy, server-side configuration is necessary. Since all URLs are handled by your client-side Angular application, the server needs to be configured to return the index.html file for all routes that don't match actual files.

For example, in an Apache server, you might use a `.htaccess` file with:

```
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule>
```

For an Express.js server:

```javascript
const express = require('express');
const path = require('path');
const app = express();

// Serve static files
app.use(express.static(__dirname + '/dist/your-app-name'));

// Send all requests to index.html
app.get('/*', function(req, res) {
  res.sendFile(path.join(__dirname + '/dist/your-app-name/index.html'));
});

// Start the app
app.listen(process.env.PORT || 8080);
```

## HashLocationStrategy

HashLocationStrategy uses the hash fragment (`#`) part of the URL to store the application's location state. This is an older approach but still useful in certain scenarios.

### How it works

With HashLocationStrategy, URLs in your application include a hash symbol:

```
https://example.com/#/users
https://example.com/#/users/profile
```

The part after the hash (`#`) is never sent to the server, making this strategy useful when you don't have control over server routing.

### Implementation

To use HashLocationStrategy in your Angular application, configure it in your app module:

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { LocationStrategy, HashLocationStrategy } from '@angular/common';
import { AppComponent } from './app.component';
import { RouterModule } from '@angular/router';

@NgModule({
  imports: [
    BrowserModule,
    RouterModule.forRoot([
      // Your routes here
    ])
  ],
  declarations: [AppComponent],
  providers: [
    { provide: LocationStrategy, useClass: HashLocationStrategy }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

Alternatively, you can configure it when setting up your routes:

```typescript
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [
  // Your routes here
];

@NgModule({
  imports: [
    RouterModule.forRoot(routes, { useHash: true })
  ],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

### Advantages of HashLocationStrategy

1. **No server configuration needed**: Since the hash part of the URL is not sent to the server, you don't need special server configuration.
2. **Works on older browsers**: Compatible with browsers that don't support HTML5 History API.
3. **Works with static file servers**: Perfect for applications hosted on static file servers like GitHub Pages.

## Choosing the Right Strategy

### Use PathLocationStrategy when:

- You have control over server configuration
- You want cleaner, more user-friendly URLs
- SEO is important for your application
- You're targeting modern browsers

### Use HashLocationStrategy when:

- You don't have control over the server configuration
- Your application is hosted on a static file server
- You need to support very old browsers
- You want a simpler deployment process without server-side routing configuration

## Practical Example: Configuring Both Strategies

Let's create a complete example showing how to configure your application to use either strategy based on an environment variable:

First, create an environment configuration:

```typescript
// environments/environment.ts
export const environment = {
  production: false,
  useHashStrategy: false
};

// environments/environment.prod.ts
export const environment = {
  production: true,
  useHashStrategy: true  // Using hash strategy for production
};
```

Then, configure your app module to use the appropriate strategy:

```typescript
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { LocationStrategy, PathLocationStrategy, HashLocationStrategy } from '@angular/common';
import { AppComponent } from './app.component';
import { RouterModule } from '@angular/router';
import { environment } from '../environments/environment';

@NgModule({
  imports: [
    BrowserModule,
    RouterModule.forRoot([
      // Your routes here
    ], { useHash: environment.useHashStrategy })
  ],
  declarations: [AppComponent],
  providers: [
    {
      provide: LocationStrategy,
      useClass: environment.useHashStrategy ? HashLocationStrategy : PathLocationStrategy
    }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

## Working with Location Strategy APIs

Angular provides the `Location` service that abstracts away the differences between location strategies. This allows you to work with URLs in a consistent way regardless of the strategy used:

```typescript
import { Component } from '@angular/core';
import { Location } from '@angular/common';

@Component({
  selector: 'app-navigation',
  template: `
    <button (click)="goBack()">Go Back</button>
    <button (click)="navigateTo('/dashboard')">Dashboard</button>
  `
})
export class NavigationComponent {
  constructor(private location: Location) { }

  goBack(): void {
    this.location.back();
  }

  navigateTo(path: string): void {
    this.location.go(path);
  }
}
```

## Summary

Angular's Location Strategy is a powerful abstraction that allows you to control how URLs are represented and processed in your single-page application. The two main strategies are:

- **PathLocationStrategy**: Uses clean URLs and the HTML5 History API but requires server configuration.
- **HashLocationStrategy**: Uses hash-based URLs that don't require server configuration but are less SEO-friendly.

Understanding the differences between these strategies and knowing when to use each one is essential for creating effective routing solutions in your Angular applications.

## Additional Resources

- [Angular Router Documentation](https://angular.io/guide/router)
- [Angular Location Service Documentation](https://angular.io/api/common/Location)
- [HTML5 History API MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/History_API)

## Exercises

1. Configure an Angular application to use HashLocationStrategy and test navigation between multiple routes.
2. Configure the same application to use PathLocationStrategy and compare the URL appearance.
3. Create a simple Express.js server that correctly handles PathLocationStrategy for an Angular app.
4. Build a service that detects whether the browser supports HTML5 History API and dynamically selects the appropriate Location Strategy.
5. Implement a debug component that displays the current URL representation according to the active location strategy.