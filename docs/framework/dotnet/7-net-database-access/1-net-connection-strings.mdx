---
title: ".NET Connection Strings"
description: "Learn how to configure and use connection strings in .NET applications to connect to various database systems"

---

# .NET Connection Strings

## Introduction

Connection strings are fundamental components in database programming with .NET. They serve as the configuration information that allows your application to connect to a specific database. Think of a connection string as an address and authentication credentials combined into one standardized text format that tells your application exactly how to reach and communicate with a database.

In this tutorial, we'll explore how connection strings work in .NET applications, the different formats they can take, and how to implement them securely for various database systems.

## What is a Connection String?

A connection string is a text string that includes the information necessary to establish a connection to a database. This information typically includes:

- The database server name or address
- Authentication credentials (username and password)
- The specific database name
- Additional connection parameters like timeout values, encryption settings, etc.

Connection strings are used by .NET's data providers to establish a connection to a specific database management system (DBMS) like SQL Server, MySQL, PostgreSQL, or Oracle.

## Basic Structure of Connection Strings

While the exact format varies by database provider, most connection strings follow a similar pattern of key-value pairs:

```
Provider=value;Server=value;Database=value;User ID=value;Password=value;
```

Let's break down the most common components:

| Component | Description |
|-----------|-------------|
| Provider | The name of the database provider |
| Server/Data Source | The name or address of the database server |
| Database/Initial Catalog | The name of the specific database to connect to |
| User ID | Username for database authentication |
| Password | Password for database authentication |
| Integrated Security | Whether to use Windows Authentication |
| Connection Timeout | Time (in seconds) to wait for a connection before timing out |

## Connection Strings for Common Database Systems

### SQL Server Connection Strings

SQL Server is Microsoft's relational database management system and has tight integration with .NET.

#### SQL Server Authentication Example

```csharp
// Connection string using SQL Server Authentication
string connectionString = "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;";

// Creating a connection using the connection string
using (SqlConnection connection = new SqlConnection(connectionString))
{
    try
    {
        connection.Open();
        Console.WriteLine("Connection to SQL Server successful!");
        // Database operations would go here
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
    }
}
```

#### Windows Authentication Example

```csharp
// Connection string using Windows Authentication
string connectionString = "Server=myServerAddress;Database=myDataBase;Integrated Security=True;";

// Creating a connection using the connection string
using (SqlConnection connection = new SqlConnection(connectionString))
{
    try
    {
        connection.Open();
        Console.WriteLine("Connection to SQL Server successful!");
        // Database operations would go here
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
    }
}
```

### MySQL Connection Strings

To connect to MySQL databases, you'll need to install the MySQL data provider (MySql.Data NuGet package).

```csharp
// First, add the MySQL package reference:
// Install-Package MySql.Data

// MySQL connection string
string connectionString = "Server=myServerAddress;Database=myDataBase;Uid=myUsername;Pwd=myPassword;";

// Creating a MySQL connection
using (MySqlConnection connection = new MySqlConnection(connectionString))
{
    try
    {
        connection.Open();
        Console.WriteLine("Connection to MySQL successful!");
        // Database operations would go here
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
    }
}
```

### SQLite Connection Strings

SQLite is a lightweight, file-based database system popular for mobile and desktop applications.

```csharp
// First, add the SQLite package reference:
// Install-Package System.Data.SQLite

// SQLite connection string
string connectionString = "Data Source=myDatabase.sqlite;Version=3;";

// Creating a SQLite connection
using (SQLiteConnection connection = new SQLiteConnection(connectionString))
{
    try
    {
        connection.Open();
        Console.WriteLine("Connection to SQLite successful!");
        // Database operations would go here
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
    }
}
```

### PostgreSQL Connection Strings

For PostgreSQL connections, you'll need the Npgsql provider.

```csharp
// First, add the Npgsql package reference:
// Install-Package Npgsql

// PostgreSQL connection string
string connectionString = "Host=myServerAddress;Username=myUsername;Password=myPassword;Database=myDataBase";

// Creating a PostgreSQL connection
using (NpgsqlConnection connection = new NpgsqlConnection(connectionString))
{
    try
    {
        connection.Open();
        Console.WriteLine("Connection to PostgreSQL successful!");
        // Database operations would go here
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error: {ex.Message}");
    }
}
```

## Managing Connection Strings in Configuration Files

It's a best practice to store connection strings in configuration files rather than hardcoding them in your application. This makes your application more flexible and secure.

### In .NET Framework (App.config or Web.config)

```xml
<configuration>
  <connectionStrings>
    <add name="MyDbConnection" 
         connectionString="Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"
         providerName="System.Data.SqlClient" />
  </connectionStrings>
</configuration>
```

To use the connection string from the configuration:

```csharp
string connectionString = ConfigurationManager.ConnectionStrings["MyDbConnection"].ConnectionString;
```

### In .NET Core / .NET 5+ (appsettings.json)

```json
{
  "ConnectionStrings": {
    "MyDbConnection": "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"
  }
}
```

To use the connection string:

```csharp
// In your Startup.cs or Program.cs
var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json")
    .Build();

string connectionString = configuration.GetConnectionString("MyDbConnection");
```

Or if you're using dependency injection:

```csharp
// In a controller or service
public class MyService
{
    private readonly string _connectionString;

    public MyService(IConfiguration configuration)
    {
        _connectionString = configuration.GetConnectionString("MyDbConnection");
    }
}
```

## Connection String Security

Connection strings often contain sensitive information like usernames and passwords. Here are some best practices for securing them:

### 1. Use Environment-Specific Configuration

Use different configuration files for development, testing, and production environments.

### 2. Encrypt Sensitive Parts

For .NET Framework applications, you can encrypt sections of your configuration file:

```csharp
// To encrypt connectionStrings section
aspnet_regiis -pe "connectionStrings" -app "/MyApplication"

// To decrypt connectionStrings section
aspnet_regiis -pd "connectionStrings" -app "/MyApplication"
```

### 3. Use Secret Managers

In .NET Core and above, use the Secret Manager for development:

```bash
dotnet user-secrets set "ConnectionStrings:MyDbConnection" "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;"
```

### 4. Use Environment Variables

Environment variables are a secure way to store connection strings in production:

```csharp
var connectionString = Environment.GetEnvironmentVariable("DB_CONNECTION_STRING");
```

### 5. Use Azure Key Vault or Similar Services

For production applications, consider storing sensitive information in Azure Key Vault.

## Connection String Builders

.NET provides builder classes to create connection strings programmatically, which can help prevent syntax errors:

```csharp
// For SQL Server
var builder = new SqlConnectionStringBuilder
{
    DataSource = "myServerAddress",
    InitialCatalog = "myDataBase",
    UserID = "myUsername",
    Password = "myPassword",
    IntegratedSecurity = false,
    ConnectTimeout = 30
};

string connectionString = builder.ConnectionString;
```

## Practical Example: Creating a Database Utility Class

Let's create a simple database utility class that uses a connection string to execute SQL queries:

```csharp
public class DatabaseUtility
{
    private readonly string _connectionString;

    public DatabaseUtility(string connectionString)
    {
        _connectionString = connectionString;
    }

    public async Task<DataTable> ExecuteQueryAsync(string query, Dictionary<string, object> parameters = null)
    {
        using (SqlConnection connection = new SqlConnection(_connectionString))
        {
            await connection.OpenAsync();
            
            SqlCommand command = new SqlCommand(query, connection);
            
            // Add parameters if provided
            if (parameters != null)
            {
                foreach (var param in parameters)
                {
                    command.Parameters.AddWithValue(param.Key, param.Value ?? DBNull.Value);
                }
            }
            
            // Create data adapter and fill dataset
            DataTable table = new DataTable();
            using (SqlDataAdapter adapter = new SqlDataAdapter(command))
            {
                adapter.Fill(table);
            }
            
            return table;
        }
    }

    public async Task<int> ExecuteNonQueryAsync(string query, Dictionary<string, object> parameters = null)
    {
        using (SqlConnection connection = new SqlConnection(_connectionString))
        {
            await connection.OpenAsync();
            
            SqlCommand command = new SqlCommand(query, connection);
            
            // Add parameters if provided
            if (parameters != null)
            {
                foreach (var param in parameters)
                {
                    command.Parameters.AddWithValue(param.Key, param.Value ?? DBNull.Value);
                }
            }
            
            return await command.ExecuteNonQueryAsync();
        }
    }
}
```

### Using the Database Utility Class

```csharp
// Get connection string from configuration
string connectionString = configuration.GetConnectionString("MyDbConnection");

// Create the database utility
DatabaseUtility dbUtil = new DatabaseUtility(connectionString);

// Execute a query with parameters
var parameters = new Dictionary<string, object>
{
    { "@CustomerId", 123 }
};

DataTable results = await dbUtil.ExecuteQueryAsync(
    "SELECT * FROM Customers WHERE CustomerId = @CustomerId", 
    parameters
);

// Display results
foreach (DataRow row in results.Rows)
{
    Console.WriteLine($"Name: {row["Name"]}, Email: {row["Email"]}");
}

// Execute a non-query (insert, update, delete)
int rowsAffected = await dbUtil.ExecuteNonQueryAsync(
    "UPDATE Customers SET LastLogin = GETDATE() WHERE CustomerId = @CustomerId",
    parameters
);

Console.WriteLine($"Rows updated: {rowsAffected}");
```

## Connection Pooling

Connection pooling is a technique used to improve performance by reusing database connections instead of creating new ones for every database operation. Most .NET data providers enable connection pooling by default.

### Controlling Connection Pooling

You can control connection pooling behavior through connection string parameters:

```csharp
// SQL Server connection string with pooling settings
string connectionString = "Server=myServerAddress;Database=myDataBase;" +
    "User Id=myUsername;Password=myPassword;" +
    "Pooling=true;Min Pool Size=5;Max Pool Size=100;";
```

Common pooling parameters include:

- `Pooling`: Enable or disable connection pooling (default: true)
- `Min Pool Size`: Minimum number of connections to keep in the pool
- `Max Pool Size`: Maximum number of connections allowed in the pool
- `Connection Lifetime`: Maximum lifetime of a connection in seconds
- `Connection Timeout`: Time to wait when trying to establish a connection

## Summary

Connection strings are essential for database connectivity in .NET applications. In this tutorial, we've covered:

- The basic structure and components of connection strings
- How to create connection strings for different database systems
- Best practices for storing and securing connection strings
- Using connection string builders for type-safe construction
- Managing connections in configuration files
- Creating reusable database utilities
- Understanding connection pooling

By properly managing your connection strings, you'll build more secure, maintainable, and efficient database applications.

## Additional Resources

- [Microsoft Docs: Connection Strings](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/connection-strings)
- [ConnectionStrings.com](https://www.connectionstrings.com/) - A reference for connection string formats for various database systems
- [Security Best Practices for Connection Strings](https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/connection-string-builders)

## Exercises

1. Create a console application that connects to a SQL Server database using both Windows authentication and SQL Server authentication.
2. Build a simple application that reads connection strings from a configuration file and displays data from a table.
3. Create a database utility class that implements connection pooling and measures the performance difference with and without pooling.
4. Practice securing connection strings by implementing Azure Key Vault in a small web application.