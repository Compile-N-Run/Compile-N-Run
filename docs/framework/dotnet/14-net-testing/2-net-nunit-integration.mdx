---
title: ".NET NUnit Integration"
description: "Learn how to integrate and use NUnit with .NET applications for effective unit testing"

---

# .NET NUnit Integration

## Introduction

NUnit is one of the most popular unit testing frameworks for .NET applications. It provides a comprehensive set of tools and features to write, execute, and manage your tests effectively. Whether you're practicing test-driven development (TDD) or simply want to ensure your code works as expected, integrating NUnit with your .NET projects can significantly improve your development workflow.

In this tutorial, we'll explore how to set up NUnit in a .NET project, write basic tests, use various assertion methods, and understand best practices for creating maintainable test suites. By the end, you'll have a solid foundation to start implementing unit tests in your own applications.

## What is NUnit?

NUnit is an open-source unit testing framework for .NET applications. Originally ported from JUnit, NUnit has evolved significantly to take advantage of .NET features, making it a powerful tool for developers. Some key features include:

- Easy to read and write test syntax
- Rich set of assertions for various testing scenarios
- Support for parameterized tests
- Test runners for visual feedback
- Integration with IDE's like Visual Studio and JetBrains Rider
- Support for parallel test execution

## Setting Up NUnit in Your Project

Let's start by setting up NUnit in a new .NET project.

### Step 1: Create a New Project

First, create a new .NET project or use an existing one. For this tutorial, we'll create a simple class library and a separate test project.

```bash
dotnet new classlib -n MyLibrary
dotnet new nunit -n MyLibrary.Tests
```

### Step 2: Add Project Reference

Next, add a reference from the test project to the main project:

```bash
cd MyLibrary.Tests
dotnet add reference ../MyLibrary/MyLibrary.csproj
```

### Step 3: Install NUnit Packages

The NUnit template already includes the necessary packages, but if you're adding NUnit to an existing project, you'll need to add these packages:

```bash
dotnet add package NUnit
dotnet add package NUnit3TestAdapter
dotnet add package Microsoft.NET.Test.Sdk
```

## Writing Your First NUnit Test

Let's create a simple calculator class in our main project and then write tests for it.

### Calculator Class

Create a new file called `Calculator.cs` in the `MyLibrary` project:

```csharp
namespace MyLibrary
{
    public class Calculator
    {
        public int Add(int a, int b)
        {
            return a + b;
        }
        
        public int Subtract(int a, int b)
        {
            return a - b;
        }
        
        public int Multiply(int a, int b)
        {
            return a * b;
        }
        
        public double Divide(int a, int b)
        {
            if (b == 0)
                throw new DivideByZeroException("Cannot divide by zero");
                
            return (double)a / b;
        }
    }
}
```

### Test Class

Now, let's create a test class in the `MyLibrary.Tests` project. Create a file called `CalculatorTests.cs`:

```csharp
using NUnit.Framework;
using MyLibrary;

namespace MyLibrary.Tests
{
    [TestFixture]
    public class CalculatorTests
    {
        private Calculator _calculator;
        
        [SetUp]
        public void Setup()
        {
            _calculator = new Calculator();
        }
        
        [Test]
        public void Add_TwoPositiveNumbers_ReturnsCorrectSum()
        {
            // Arrange
            int a = 5;
            int b = 7;
            
            // Act
            int result = _calculator.Add(a, b);
            
            // Assert
            Assert.That(result, Is.EqualTo(12));
        }
        
        [Test]
        public void Subtract_TwoPositiveNumbers_ReturnsCorrectDifference()
        {
            // Arrange
            int a = 10;
            int b = 3;
            
            // Act
            int result = _calculator.Subtract(a, b);
            
            // Assert
            Assert.That(result, Is.EqualTo(7));
        }
    }
}
```

### Running the Tests

To run the tests, use the following command:

```bash
cd MyLibrary.Tests
dotnet test
```

You should see output indicating that your tests have passed:

```
Starting test execution, please wait...
A total of 2 test files matched the specified pattern.

Passed!  - Failed:     0, Passed:     2, Skipped:     0, Total:     2, Duration: < 1 ms
```

## Understanding NUnit Attributes

NUnit uses attributes to mark classes and methods that should be treated as tests. Let's explore some key attributes:

### `[TestFixture]`

Applied to a class to indicate it contains test methods.

### `[Test]`

Applied to methods that contain test logic.

### `[SetUp]` and `[TearDown]`

`[SetUp]` methods run before each test, and `[TearDown]` methods run after each test. They're useful for preparing and cleaning up test environments.

### `[OneTimeSetUp]` and `[OneTimeTearDown]`

These methods run once before and after all tests in a fixture, respectively.

Let's extend our test class to include these attributes:

```csharp
using NUnit.Framework;
using MyLibrary;

namespace MyLibrary.Tests
{
    [TestFixture]
    public class CalculatorTests
    {
        private Calculator _calculator;
        
        [OneTimeSetUp]
        public void OneTimeSetup()
        {
            // Code that runs once before all tests
            TestContext.WriteLine("Starting all calculator tests...");
        }
        
        [SetUp]
        public void Setup()
        {
            // Code that runs before each test
            _calculator = new Calculator();
        }
        
        [Test]
        public void Add_TwoPositiveNumbers_ReturnsCorrectSum()
        {
            // Test implementation
            int result = _calculator.Add(5, 7);
            Assert.That(result, Is.EqualTo(12));
        }
        
        [TearDown]
        public void TearDown()
        {
            // Code that runs after each test
            // For example, cleaning up resources
        }
        
        [OneTimeTearDown]
        public void OneTimeTearDown()
        {
            // Code that runs once after all tests
            TestContext.WriteLine("Completed all calculator tests.");
        }
    }
}
```

## Advanced Assertions

NUnit provides a rich set of assertion methods. Here are some common ones:

```csharp
[Test]
public void DemonstrateAssertions()
{
    // Equality
    Assert.That(5 + 5, Is.EqualTo(10));
    
    // Comparison
    Assert.That(5, Is.LessThan(10));
    Assert.That(10, Is.GreaterThan(5));
    
    // Type checking
    Assert.That("test", Is.InstanceOf<string>());
    
    // Collections
    var list = new List<int> { 1, 2, 3 };
    Assert.That(list, Has.Count.EqualTo(3));
    Assert.That(list, Contains.Item(2));
    Assert.That(list, Is.Ordered);
    
    // String assertions
    Assert.That("Hello World", Does.Contain("World"));
    Assert.That("Hello World", Does.StartWith("Hello"));
    
    // Exceptions
    Assert.That(() => { throw new ArgumentException(); }, 
                Throws.TypeOf<ArgumentException>());
}
```

## Parameterized Tests

Instead of writing multiple similar tests, you can use parameterized tests:

```csharp
[TestCase(1, 1, 2)]
[TestCase(5, 3, 8)]
[TestCase(-5, 5, 0)]
[TestCase(0, 0, 0)]
public void Add_VariousInputs_ReturnsCorrectSum(int a, int b, int expectedResult)
{
    int result = _calculator.Add(a, b);
    Assert.That(result, Is.EqualTo(expectedResult));
}

[Test]
public void Divide_DivideByZero_ThrowsException()
{
    // Testing exception throwing
    Assert.That(() => _calculator.Divide(5, 0), 
                Throws.TypeOf<DivideByZeroException>());
}
```

## Testing Async Methods

NUnit also supports testing asynchronous methods:

```csharp
// In your main project
public class AsyncCalculator
{
    public async Task<int> AddAsync(int a, int b)
    {
        await Task.Delay(100); // Simulate async operation
        return a + b;
    }
}

// In your test project
[Test]
public async Task AddAsync_TwoNumbers_ReturnsCorrectSum()
{
    var asyncCalculator = new AsyncCalculator();
    int result = await asyncCalculator.AddAsync(5, 7);
    Assert.That(result, Is.EqualTo(12));
}
```

## Real-World Example: Testing a User Service

Let's create a more complex example that might reflect a real-world scenario. We'll create a simple user service with basic CRUD operations and test it.

### User Service Implementation

```csharp
// In MyLibrary project
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public bool IsActive { get; set; }
}

public interface IUserRepository
{
    User GetById(int id);
    void Save(User user);
    void Delete(int id);
    IEnumerable<User> GetAllUsers();
}

public class UserService
{
    private readonly IUserRepository _repository;
    
    public UserService(IUserRepository repository)
    {
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
    }
    
    public User GetUser(int id)
    {
        if (id <= 0)
            throw new ArgumentException("User ID must be positive", nameof(id));
            
        return _repository.GetById(id);
    }
    
    public void AddUser(User user)
    {
        if (user == null)
            throw new ArgumentNullException(nameof(user));
            
        if (string.IsNullOrWhiteSpace(user.Name))
            throw new ArgumentException("User name is required", nameof(user));
            
        if (string.IsNullOrWhiteSpace(user.Email))
            throw new ArgumentException("User email is required", nameof(user));
            
        _repository.Save(user);
    }
    
    public IEnumerable<User> GetActiveUsers()
    {
        return _repository.GetAllUsers().Where(u => u.IsActive);
    }
}
```

### Mock Repository and Tests

We'll use Moq to mock the repository for testing. First, add the Moq package to your test project:

```bash
dotnet add package Moq
```

Then write test classes:

```csharp
using NUnit.Framework;
using MyLibrary;
using Moq;
using System.Collections.Generic;
using System.Linq;

namespace MyLibrary.Tests
{
    [TestFixture]
    public class UserServiceTests
    {
        private Mock<IUserRepository> _mockRepository;
        private UserService _userService;
        
        [SetUp]
        public void Setup()
        {
            _mockRepository = new Mock<IUserRepository>();
            _userService = new UserService(_mockRepository.Object);
        }
        
        [Test]
        public void GetUser_ValidId_ReturnsUser()
        {
            // Arrange
            int userId = 1;
            var user = new User { Id = userId, Name = "John", Email = "john@example.com", IsActive = true };
            _mockRepository.Setup(repo => repo.GetById(userId)).Returns(user);
            
            // Act
            var result = _userService.GetUser(userId);
            
            // Assert
            Assert.That(result, Is.Not.Null);
            Assert.That(result.Id, Is.EqualTo(userId));
            Assert.That(result.Name, Is.EqualTo("John"));
        }
        
        [Test]
        public void GetUser_InvalidId_ThrowsException()
        {
            // Act & Assert
            Assert.That(() => _userService.GetUser(0), Throws.ArgumentException);
        }
        
        [Test]
        public void AddUser_ValidUser_CallsRepositorySave()
        {
            // Arrange
            var user = new User { Name = "Alice", Email = "alice@example.com" };
            
            // Act
            _userService.AddUser(user);
            
            // Assert
            _mockRepository.Verify(repo => repo.Save(user), Times.Once);
        }
        
        [Test]
        public void GetActiveUsers_ReturnsOnlyActiveUsers()
        {
            // Arrange
            var users = new List<User>
            {
                new User { Id = 1, Name = "Active1", IsActive = true },
                new User { Id = 2, Name = "Inactive", IsActive = false },
                new User { Id = 3, Name = "Active2", IsActive = true }
            };
            
            _mockRepository.Setup(repo => repo.GetAllUsers()).Returns(users);
            
            // Act
            var activeUsers = _userService.GetActiveUsers().ToList();
            
            // Assert
            Assert.That(activeUsers, Has.Count.EqualTo(2));
            Assert.That(activeUsers.All(u => u.IsActive), Is.True);
        }
    }
}
```

## Best Practices for NUnit Testing

1. **Naming Convention**: Use clear, descriptive test names. A common pattern is `MethodName_Scenario_ExpectedResult`.

2. **Arrange-Act-Assert Pattern**: Structure your tests using the AAA pattern:
   - Arrange: Set up the test environment
   - Act: Execute the code being tested
   - Assert: Verify the results

3. **One Assert per Test**: Generally, focus each test on one logical assertion. This makes tests clearer and easier to debug.

4. **Use Test Categories**: Use the `[Category]` attribute to organize tests into groups:

    ```csharp
    [Test]
    [Category("Integration")]
    public void SomeIntegrationTest() { /* ... */ }
    ```

5. **Test Independence**: Each test should be able to run independently of others. Avoid dependencies between tests.

6. **Use SetUp and TearDown**: For common initialization and cleanup code.

7. **Testing Exceptions**:

    ```csharp
    [Test]
    public void Divide_WhenDivisorIsZero_ThrowsDivideByZeroException()
    {
        Assert.That(() => _calculator.Divide(10, 0), Throws.TypeOf<DivideByZeroException>());
    }
    ```

## Summary

In this tutorial, we've covered the essentials of integrating NUnit with your .NET applications:

- Setting up NUnit in a .NET project
- Writing basic and parameterized tests
- Understanding NUnit attributes
- Using various assertion methods
- Testing asynchronous code
- Mocking dependencies for effective unit testing
- Best practices for writing maintainable tests

NUnit is a powerful framework that will help you build more reliable and robust applications by ensuring your code behaves as expected. As you practice writing tests, you'll develop a better understanding of how to design testable code and how to write effective tests that catch issues early.

## Additional Resources

1. [Official NUnit Documentation](https://docs.nunit.org/)
2. [NUnit GitHub Repository](https://github.com/nunit/nunit)
3. [The Art of Unit Testing](https://www.manning.com/books/the-art-of-unit-testing-third-edition) by Roy Osherove
4. [Test Driven Development: By Example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530) by Kent Beck

## Exercises

To reinforce your understanding, try these exercises:

1. Create a `StringUtility` class with methods for common string operations (e.g., reversing strings, counting words), and write comprehensive tests for it.

2. Implement a `ShoppingCart` class with methods to add items, remove items, and calculate total. Write tests that verify the behavior.

3. Create a simple bank account class that prevents overdrafts and has deposit/withdrawal functionality. Write tests for different scenarios, including edge cases.

4. Practice TDD by writing tests first, then implementing the code to make them pass for a simple calculator that supports addition, subtraction, multiplication, division, and square roots.

Happy testing!