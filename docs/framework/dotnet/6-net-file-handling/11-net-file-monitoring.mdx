---
title: ".NET File Monitoring"
description: "Learn how to monitor file system changes in .NET applications using FileSystemWatcher class to detect creation, modification, deletion, and renaming of files and directories."

---

# .NET File Monitoring

In modern applications, monitoring the file system for changes is a common requirement. Whether you're building a backup utility, a file synchronization tool, or simply need to respond to file modifications in real-time, .NET provides powerful tools for monitoring file system changes. This guide introduces you to file monitoring in .NET, focusing primarily on the `FileSystemWatcher` class.

## Introduction to File Monitoring

File monitoring is the process of detecting changes to files and directories on a file system. These changes include:

- Creation of new files or directories
- Modification of existing files
- Deletion of files or directories
- Renaming of files or directories

.NET's `FileSystemWatcher` class provides a straightforward way to monitor these changes and respond accordingly through event-driven programming.

## The FileSystemWatcher Class

The `FileSystemWatcher` class resides in the `System.IO` namespace and allows you to listen for file system change notifications. It raises events when files or directories in the specified path change.

### Basic Properties

- `Path`: The directory to monitor.
- `Filter`: The type of files to monitor (e.g., "*.txt" for text files).
- `IncludeSubdirectories`: Whether to monitor subdirectories within the specified path.
- `NotifyFilter`: The type of changes to watch for (e.g., file name, directory name, size, last write time, etc.).
- `EnableRaisingEvents`: When set to `true`, the watcher starts monitoring; when `false`, it stops.

### Key Events

- `Created`: Triggered when a file or directory is created.
- `Changed`: Triggered when a file or directory changes.
- `Deleted`: Triggered when a file or directory is deleted.
- `Renamed`: Triggered when a file or directory is renamed.
- `Error`: Triggered when an error occurs during monitoring.

## Basic File Monitoring Example

Let's start with a simple example that monitors a directory for any changes:

```csharp
using System;
using System.IO;
using System.Threading;

class Program
{
    static void Main()
    {
        // Create a new FileSystemWatcher instance
        using (FileSystemWatcher watcher = new FileSystemWatcher())
        {
            // Set the directory to monitor
            watcher.Path = @"C:\MonitoringTest";
            
            // Watch for changes in LastWrite time, FileName, DirectoryName
            watcher.NotifyFilter = NotifyFilters.LastWrite 
                                 | NotifyFilters.FileName 
                                 | NotifyFilters.DirectoryName;
            
            // Watch all files
            watcher.Filter = "*.*";
            
            // Add event handlers
            watcher.Changed += OnChanged;
            watcher.Created += OnCreated;
            watcher.Deleted += OnDeleted;
            watcher.Renamed += OnRenamed;
            watcher.Error += OnError;
            
            // Start monitoring
            watcher.EnableRaisingEvents = true;
            
            Console.WriteLine("Monitoring directory: " + watcher.Path);
            Console.WriteLine("Press 'q' to quit.");
            
            // Keep the program running until 'q' is pressed
            while (Console.Read() != 'q') ;
        }
    }
    
    private static void OnChanged(object sender, FileSystemEventArgs e)
    {
        Console.WriteLine($"Changed: {e.FullPath}");
    }
    
    private static void OnCreated(object sender, FileSystemEventArgs e)
    {
        Console.WriteLine($"Created: {e.FullPath}");
    }
    
    private static void OnDeleted(object sender, FileSystemEventArgs e)
    {
        Console.WriteLine($"Deleted: {e.FullPath}");
    }
    
    private static void OnRenamed(object sender, RenamedEventArgs e)
    {
        Console.WriteLine($"Renamed: {e.OldFullPath} to {e.FullPath}");
    }
    
    private static void OnError(object sender, ErrorEventArgs e)
    {
        Console.WriteLine($"Error: {e.GetException().Message}");
    }
}
```

### Example Output

If you run this program and modify files in the monitored directory, you might see output like:

```
Monitoring directory: C:\MonitoringTest
Press 'q' to quit.
Created: C:\MonitoringTest\newfile.txt
Changed: C:\MonitoringTest\newfile.txt
Renamed: C:\MonitoringTest\newfile.txt to C:\MonitoringTest\renamed.txt
Deleted: C:\MonitoringTest\renamed.txt
```

## Handling Common Scenarios

### Monitoring Multiple File Types

To monitor specific file types, adjust the `Filter` property:

```csharp
// Monitor only text files
watcher.Filter = "*.txt";

// To monitor multiple file types, you'll need multiple watchers
FileSystemWatcher imageWatcher = new FileSystemWatcher
{
    Path = @"C:\MonitoringTest",
    Filter = "*.jpg",
    EnableRaisingEvents = true
};
imageWatcher.Changed += OnChanged;
```

### Monitoring Subdirectories

To include subdirectories in your monitoring, set the `IncludeSubdirectories` property to `true`:

```csharp
watcher.IncludeSubdirectories = true;
```

### Buffering Events

Sometimes, multiple events might be raised for a single logical operation. For instance, when a large file is written, multiple `Changed` events could be triggered. To handle this, you can implement a buffering strategy:

```csharp
using System;
using System.IO;
using System.Threading;
using System.Collections.Concurrent;

class Program
{
    // Dictionary to track the last processed time for each file
    private static ConcurrentDictionary<string, DateTime> _lastProcessed = 
        new ConcurrentDictionary<string, DateTime>();
    
    // Buffer time in milliseconds
    private const int BufferTime = 500;
    
    static void Main()
    {
        // Same setup as before...
    }
    
    private static void OnChanged(object sender, FileSystemEventArgs e)
    {
        // Get the current time
        DateTime now = DateTime.Now;
        
        // Check if we've recently processed this file
        if (_lastProcessed.TryGetValue(e.FullPath, out DateTime lastTime))
        {
            if ((now - lastTime).TotalMilliseconds < BufferTime)
            {
                // Skip this event, it's too soon after the last one
                return;
            }
        }
        
        // Update the last processed time
        _lastProcessed[e.FullPath] = now;
        
        // Process the file change
        Console.WriteLine($"Changed: {e.FullPath} at {now}");
    }
    
    // Other event handlers...
}
```

## Real-World Application Examples

### Auto-Backup Tool

```csharp
using System;
using System.IO;

class AutoBackupTool
{
    private readonly string _sourceDirectory;
    private readonly string _backupDirectory;
    private readonly FileSystemWatcher _watcher;
    
    public AutoBackupTool(string sourceDir, string backupDir)
    {
        _sourceDirectory = sourceDir;
        _backupDirectory = backupDir;
        
        // Ensure backup directory exists
        Directory.CreateDirectory(_backupDirectory);
        
        _watcher = new FileSystemWatcher
        {
            Path = _sourceDirectory,
            NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName,
            Filter = "*.*",
            IncludeSubdirectories = true,
            EnableRaisingEvents = true
        };
        
        _watcher.Changed += OnFileChanged;
        _watcher.Created += OnFileChanged;
        
        Console.WriteLine($"Monitoring {_sourceDirectory} for changes...");
        Console.WriteLine($"Backups will be saved to {_backupDirectory}");
    }
    
    private void OnFileChanged(object sender, FileSystemEventArgs e)
    {
        try
        {
            // Only process files, not directories
            if (File.Exists(e.FullPath))
            {
                // Create relative path for backup
                string relativePath = e.FullPath.Substring(_sourceDirectory.Length + 1);
                string backupPath = Path.Combine(_backupDirectory, relativePath);
                
                // Create directory structure if it doesn't exist
                string backupDir = Path.GetDirectoryName(backupPath);
                if (!Directory.Exists(backupDir))
                {
                    Directory.CreateDirectory(backupDir);
                }
                
                // Create backup with timestamp
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string backupFilename = $"{Path.GetFileNameWithoutExtension(backupPath)}_{timestamp}{Path.GetExtension(backupPath)}";
                string fullBackupPath = Path.Combine(backupDir, backupFilename);
                
                // Copy the file
                File.Copy(e.FullPath, fullBackupPath, true);
                
                Console.WriteLine($"Backed up: {e.Name} to {fullBackupPath}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Backup failed: {ex.Message}");
        }
    }
}

class Program
{
    static void Main()
    {
        var backupTool = new AutoBackupTool(@"C:\WorkDirectory", @"C:\Backups");
        Console.WriteLine("Press 'q' to quit.");
        while (Console.Read() != 'q') ;
    }
}
```

### Log File Monitor

```csharp
using System;
using System.IO;
using System.Text;
using System.Threading;

class LogMonitor
{
    private readonly string _logFilePath;
    private readonly FileSystemWatcher _watcher;
    private long _lastReadPosition = 0;
    
    public LogMonitor(string logFilePath)
    {
        _logFilePath = logFilePath;
        string directoryPath = Path.GetDirectoryName(logFilePath);
        string fileName = Path.GetFileName(logFilePath);
        
        _watcher = new FileSystemWatcher
        {
            Path = directoryPath,
            Filter = fileName,
            NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size,
            EnableRaisingEvents = true
        };
        
        _watcher.Changed += OnLogFileChanged;
        
        // Get initial file size
        if (File.Exists(_logFilePath))
        {
            var fileInfo = new FileInfo(_logFilePath);
            _lastReadPosition = fileInfo.Length;
        }
        
        Console.WriteLine($"Monitoring log file: {_logFilePath}");
    }
    
    private void OnLogFileChanged(object sender, FileSystemEventArgs e)
    {
        // Give the file a moment to be released by the writing process
        Thread.Sleep(100);
        
        try
        {
            using (FileStream fs = new FileStream(_logFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                if (fs.Length > _lastReadPosition)
                {
                    // Seek to where we last read
                    fs.Seek(_lastReadPosition, SeekOrigin.Begin);
                    
                    // Read the new content
                    byte[] buffer = new byte[fs.Length - _lastReadPosition];
                    fs.Read(buffer, 0, buffer.Length);
                    
                    // Convert to string and display
                    string newContent = Encoding.UTF8.GetString(buffer);
                    Console.WriteLine("New log entries:");
                    Console.WriteLine(newContent);
                    
                    // Update position
                    _lastReadPosition = fs.Length;
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading log file: {ex.Message}");
        }
    }
}

class Program
{
    static void Main()
    {
        var logMonitor = new LogMonitor(@"C:\Logs\application.log");
        Console.WriteLine("Press 'q' to quit.");
        while (Console.Read() != 'q') ;
    }
}
```

## Best Practices and Considerations

### Performance Implications

File monitoring can consume system resources, especially when watching large directories with frequent changes. Consider these practices:

1. **Be Specific**: Use filters to limit which files you're monitoring.
2. **Avoid Recursive Monitoring** when possible, especially on large directory trees.
3. **Buffer Your Events**: As shown earlier, implement buffering for high-frequency change events.
4. **Dispose Properly**: Always dispose of your `FileSystemWatcher` objects when done.

### Limitations

The `FileSystemWatcher` has some inherent limitations:

1. **Event Buffering**: The internal buffer of `FileSystemWatcher` can overflow if too many changes occur rapidly, leading to missed events.
2. **Network Directories**: Monitoring network directories can be unreliable and may miss events.
3. **File Content**: It doesn't tell you what changed inside a file, only that the file changed.
4. **Moving Files**: It doesn't directly detect when files are moved between directories; instead, you'll see delete and create events.

### Error Handling

Always handle the `Error` event to catch and respond to any issues that occur during monitoring:

```csharp
watcher.Error += (sender, e) =>
{
    Exception ex = e.GetException();
    if (ex is InternalBufferOverflowException)
    {
        Console.WriteLine("Error: File system watcher internal buffer overflow");
    }
    else
    {
        Console.WriteLine($"Error: {ex.Message}");
    }
};
```

## Summary

.NET's file monitoring capabilities through the `FileSystemWatcher` class provide a powerful way to detect and respond to file system changes in real-time. This functionality is essential for applications that need to synchronize files, create backups, monitor logs, or react to user-generated content.

In this guide, we covered:

- The basics of the `FileSystemWatcher` class
- How to set up monitoring for different types of file changes
- Handling common scenarios like monitoring specific file types and subdirectories
- Implementing buffering strategies for high-frequency events
- Real-world applications like auto-backup tools and log file monitors
- Best practices and limitations to consider

With these tools and techniques, you're well-equipped to implement effective file monitoring in your .NET applications.

## Additional Resources

- [Microsoft Documentation on FileSystemWatcher](https://docs.microsoft.com/en-us/dotnet/api/system.io.filesystemwatcher)
- [Handling File System Events in .NET](https://docs.microsoft.com/en-us/dotnet/standard/io/how-to-monitor-file-system-events)

## Exercises

1. Create a simple application that monitors a directory and logs all changes to a CSV file with timestamps.
2. Modify the auto-backup example to keep only the last five backups of each file, deleting older versions.
3. Build a "hot reload" application that monitors a configuration file and automatically reloads settings when the file changes.
4. Implement a file synchronization tool that keeps two directories in sync by monitoring changes in the source directory.
5. Create a file monitoring service that sends email notifications when critical files are modified.