---
title: ".NET File Serialization"
description: "Learn how to serialize and deserialize objects in .NET to save and restore data from files in various formats like JSON, XML, and binary."

---

# .NET File Serialization

## Introduction

Serialization is a fundamental process in application development that allows you to convert objects into a format that can be easily stored, transmitted, or reconstructed later. In .NET, serialization enables you to save the state of an object to a file and restore it when needed, facilitating data persistence between application sessions.

This tutorial covers the essentials of file serialization in .NET, demonstrating how to serialize and deserialize objects using various formats like JSON, XML, and binary. By the end, you'll understand how to implement serialization in your .NET applications to efficiently store and retrieve data.

## Understanding Serialization and Deserialization

**Serialization** is the process of converting an object into a stream of bytes or a text-based format that can be:
- Saved to a file
- Stored in a database
- Transmitted over a network

**Deserialization** is the reverse process, reconstructing the object from the serialized data.

### Why Use Serialization?

- **Data Persistence**: Save application state between sessions
- **Data Transfer**: Send objects over networks or between processes
- **Caching**: Store complex objects for faster retrieval
- **Deep Copying**: Create complete copies of objects with all their dependencies

## Serialization Formats in .NET

.NET supports multiple serialization formats, each with its own advantages:

| Format | Advantages | Best For |
|--------|------------|----------|
| JSON | Human-readable, widely supported, compact | Web APIs, configuration files |
| XML | Human-readable, strongly typed, schema support | Complex data structures, interoperability |
| Binary | Compact size, faster performance | Internal storage, performance-critical scenarios |

## JSON Serialization

JSON (JavaScript Object Notation) is a lightweight, human-readable format widely used for data exchange. In modern .NET applications, `System.Text.Json` is the recommended library for JSON serialization.

### Basic JSON Serialization Example

First, let's create a class that we'll serialize:

```csharp
using System;
using System.IO;
using System.Text.Json;

public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string EmailAddress { get; set; }
}
```

Now, let's serialize a `Person` object to a JSON file:

```csharp
public static void SerializePersonToJson()
{
    // Create a person object
    var person = new Person 
    { 
        Name = "John Doe", 
        Age = 30, 
        EmailAddress = "john@example.com" 
    };

    // Set up serialization options (optional)
    var options = new JsonSerializerOptions
    {
        WriteIndented = true // For pretty-printing
    };

    // Serialize to JSON string
    string jsonString = JsonSerializer.Serialize(person, options);

    // Write to file
    File.WriteAllText("person.json", jsonString);
    
    Console.WriteLine("Person serialized to JSON file successfully!");
    Console.WriteLine($"File content:\n{jsonString}");
}
```

**Output:**
```
Person serialized to JSON file successfully!
File content:
{
  "Name": "John Doe",
  "Age": 30,
  "EmailAddress": "john@example.com"
}
```

### Deserializing from JSON

To read the object back from the JSON file:

```csharp
public static void DeserializePersonFromJson()
{
    // Read JSON from file
    string jsonString = File.ReadAllText("person.json");
    
    // Deserialize to Person object
    Person person = JsonSerializer.Deserialize<Person>(jsonString);
    
    // Use the deserialized object
    Console.WriteLine($"Deserialized Person: {person.Name}, {person.Age}, {person.EmailAddress}");
}
```

**Output:**
```
Deserialized Person: John Doe, 30, john@example.com
```

## XML Serialization

XML serialization uses the `System.Xml.Serialization` namespace and provides more control over the structure of serialized data.

### Basic XML Serialization Example

First, let's create a class with XML serialization attributes:

```csharp
using System;
using System.IO;
using System.Xml.Serialization;

[Serializable]
public class Product
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    [XmlElement("ProductCategory")]
    public string Category { get; set; }
}
```

Now, let's serialize a `Product` object to an XML file:

```csharp
public static void SerializeProductToXml()
{
    // Create a product object
    var product = new Product 
    { 
        Name = "Laptop", 
        Price = 1299.99m, 
        Category = "Electronics" 
    };

    // Create XML serializer for the Product type
    XmlSerializer serializer = new XmlSerializer(typeof(Product));
    
    // Create a file stream to write to
    using (FileStream fs = new FileStream("product.xml", FileMode.Create))
    {
        // Serialize the product to XML
        serializer.Serialize(fs, product);
    }
    
    // Display the serialized XML content
    string xmlContent = File.ReadAllText("product.xml");
    Console.WriteLine("Product serialized to XML file successfully!");
    Console.WriteLine($"File content:\n{xmlContent}");
}
```

**Output:**
```
Product serialized to XML file successfully!
File content:
<?xml version="1.0"?>
<Product xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Name>Laptop</Name>
  <Price>1299.99</Price>
  <ProductCategory>Electronics</ProductCategory>
</Product>
```

### Deserializing from XML

To read the object back from the XML file:

```csharp
public static void DeserializeProductFromXml()
{
    // Create XML serializer for the Product type
    XmlSerializer serializer = new XmlSerializer(typeof(Product));
    
    // Create a file stream to read from
    using (FileStream fs = new FileStream("product.xml", FileMode.Open))
    {
        // Deserialize the XML to a Product object
        Product product = (Product)serializer.Deserialize(fs);
        
        // Use the deserialized object
        Console.WriteLine($"Deserialized Product: {product.Name}, ${product.Price}, Category: {product.Category}");
    }
}
```

**Output:**
```
Deserialized Product: Laptop, $1299.99, Category: Electronics
```

## Binary Serialization

Binary serialization is the most efficient in terms of size and performance but produces non-human-readable files. In modern .NET applications, the `BinaryFormatter` is generally avoided for security reasons, but we'll show a simple example using it.

:::caution
Note that `BinaryFormatter` is marked as not secure for untrusted data in .NET Core and .NET 5+. For production applications, consider alternatives like Protocol Buffers (protobuf) or MessagePack.
:::

### Binary Serialization Example

```csharp
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

[Serializable] // Required for binary serialization
public class GameState
{
    public string PlayerName { get; set; }
    public int Score { get; set; }
    public DateTime LastPlayed { get; set; }
}
```

Now, let's serialize a `GameState` object to a binary file:

```csharp
public static void SerializeGameStateToBinary()
{
#pragma warning disable SYSLIB0011 // Type or member is obsolete
    // Create a game state object
    var gameState = new GameState 
    { 
        PlayerName = "Player1", 
        Score = 12500, 
        LastPlayed = DateTime.Now 
    };

    // Create a binary formatter
    BinaryFormatter formatter = new BinaryFormatter();
    
    // Create a file stream to write to
    using (FileStream fs = new FileStream("gamestate.bin", FileMode.Create))
    {
        // Serialize the game state to binary format
        formatter.Serialize(fs, gameState);
    }
    
    Console.WriteLine("Game state serialized to binary file successfully!");
    Console.WriteLine("File size: " + new FileInfo("gamestate.bin").Length + " bytes");
#pragma warning restore SYSLIB0011 // Type or member is obsolete
}
```

### Deserializing from Binary

```csharp
public static void DeserializeGameStateFromBinary()
{
#pragma warning disable SYSLIB0011 // Type or member is obsolete
    // Create a binary formatter
    BinaryFormatter formatter = new BinaryFormatter();
    
    // Create a file stream to read from
    using (FileStream fs = new FileStream("gamestate.bin", FileMode.Open))
    {
        // Deserialize the binary data to a GameState object
        GameState gameState = (GameState)formatter.Deserialize(fs);
        
        // Use the deserialized object
        Console.WriteLine($"Deserialized Game State: Player: {gameState.PlayerName}, Score: {gameState.Score}, Last Played: {gameState.LastPlayed}");
    }
#pragma warning restore SYSLIB0011 // Type or member is obsolete
}
```

## Real-World Applications

### 1. Application Settings

A common use for serialization is saving user settings or application configuration:

```csharp
public class ApplicationSettings
{
    public bool DarkModeEnabled { get; set; }
    public string DefaultFilePath { get; set; }
    public int AutoSaveIntervalMinutes { get; set; }
    public List<string> RecentFiles { get; set; }
    
    // Save settings to file
    public void SaveSettings(string filePath)
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        string jsonString = JsonSerializer.Serialize(this, options);
        File.WriteAllText(filePath, jsonString);
    }
    
    // Load settings from file
    public static ApplicationSettings LoadSettings(string filePath)
    {
        if (File.Exists(filePath))
        {
            string jsonString = File.ReadAllText(filePath);
            return JsonSerializer.Deserialize<ApplicationSettings>(jsonString);
        }
        
        // Return default settings if file doesn't exist
        return new ApplicationSettings
        {
            DarkModeEnabled = false,
            DefaultFilePath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments),
            AutoSaveIntervalMinutes = 5,
            RecentFiles = new List<string>()
        };
    }
}
```

Usage example:

```csharp
// Create default settings
var settings = new ApplicationSettings
{
    DarkModeEnabled = true,
    DefaultFilePath = @"C:\Projects",
    AutoSaveIntervalMinutes = 10,
    RecentFiles = new List<string> { "file1.txt", "file2.txt" }
};

// Save settings
settings.SaveSettings("appsettings.json");
Console.WriteLine("Settings saved!");

// Load settings later
var loadedSettings = ApplicationSettings.LoadSettings("appsettings.json");
Console.WriteLine($"Loaded settings: Dark mode: {loadedSettings.DarkModeEnabled}, Auto-save: {loadedSettings.AutoSaveIntervalMinutes} minutes");
```

### 2. Data Caching

Another practical application is caching data that takes a long time to generate:

```csharp
public class DataCache<T>
{
    private readonly string _cacheFilePath;
    private readonly Func<T> _dataGenerator;
    private readonly TimeSpan _cacheExpiration;
    
    public DataCache(string cacheFilePath, Func<T> dataGenerator, TimeSpan cacheExpiration)
    {
        _cacheFilePath = cacheFilePath;
        _dataGenerator = dataGenerator;
        _cacheExpiration = cacheExpiration;
    }
    
    [Serializable]
    private class CacheEntry
    {
        public T Data { get; set; }
        public DateTime CreatedAt { get; set; }
    }
    
    public T GetData()
    {
        // Check if cache exists and is valid
        if (File.Exists(_cacheFilePath))
        {
            string jsonString = File.ReadAllText(_cacheFilePath);
            CacheEntry entry = JsonSerializer.Deserialize<CacheEntry>(jsonString);
            
            // Check if cache is still valid
            if (DateTime.Now - entry.CreatedAt < _cacheExpiration)
            {
                Console.WriteLine("Returning cached data");
                return entry.Data;
            }
        }
        
        // Generate new data
        Console.WriteLine("Generating fresh data");
        T freshData = _dataGenerator();
        
        // Cache the data
        CacheEntry newEntry = new CacheEntry
        {
            Data = freshData,
            CreatedAt = DateTime.Now
        };
        
        string newJson = JsonSerializer.Serialize(newEntry);
        File.WriteAllText(_cacheFilePath, newJson);
        
        return freshData;
    }
}
```

Usage example:

```csharp
// Create a data cache for a list of products with 1-hour expiration
var productCache = new DataCache<List<string>>(
    "products_cache.json",
    () => {
        // This would be an expensive operation in real-world scenarios
        Console.WriteLine("Performing expensive data operation...");
        System.Threading.Thread.Sleep(2000); // Simulate delay
        return new List<string> { "Product A", "Product B", "Product C" };
    },
    TimeSpan.FromHours(1)
);

// First call will generate and cache data
var products = productCache.GetData();
foreach (var product in products)
{
    Console.WriteLine($"- {product}");
}

// Second call should use cached data
var cachedProducts = productCache.GetData();
```

## Best Practices for Serialization

1. **Security Considerations**:
   - Validate all deserialized data before using it
   - Avoid using `BinaryFormatter` for data from untrusted sources
   - Consider using safer libraries like MessagePack or protobuf for binary serialization

2. **Performance Optimization**:
   - Choose the appropriate serialization format for your needs
   - Reuse serializer instances where possible
   - For large files, consider streaming serialization

3. **Data Structure Design**:
   - Use the `[Serializable]` attribute for binary serialization
   - Include default constructors for serializable classes
   - Consider marking sensitive fields as `[NonSerialized]` or `[JsonIgnore]`

4. **Error Handling**:
   - Implement proper exception handling around serialization operations
   - Include version information to handle changes to class structure

## Summary

In this tutorial, you've learned the fundamentals of file serialization in .NET:

- Different serialization formats (JSON, XML, binary) and their trade-offs
- How to serialize objects to files and deserialize them back
- Real-world applications of serialization, including application settings and data caching
- Best practices for secure and efficient serialization

Serialization is a powerful mechanism to maintain state in your applications and transfer data between systems. By choosing the right serialization format and implementing proper error handling, you can create robust and efficient data persistence in your .NET applications.

## Exercises

1. Create a simple note-taking application that serializes notes to JSON files.
2. Implement a class library that can serialize a collection of custom objects to both XML and JSON formats.
3. Build a configuration system that allows users to save and load preferences with different serialization formats.
4. Implement a versioning system that can handle deserialization of different versions of the same class.
5. Create a data export/import feature that can convert between CSV, JSON, and XML formats.

## Additional Resources

- [System.Text.Json Documentation](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-overview)
- [XML Serialization in .NET](https://docs.microsoft.com/en-us/dotnet/standard/serialization/xml-serialization)
- [Binary Serialization in .NET](https://docs.microsoft.com/en-us/dotnet/standard/serialization/binary-serialization)
- [MessagePack for .NET](https://github.com/neuecc/MessagePack-CSharp)
- [Protobuf-net](https://github.com/protobuf-net/protobuf-net)