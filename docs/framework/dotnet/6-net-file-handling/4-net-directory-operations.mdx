---
title: .NET Directory Operations
description: A comprehensive guide to working with directories in .NET, including creating, deleting, moving, and getting information about directories.

---

# .NET Directory Operations

## Introduction

When developing applications, managing files and directories is a common requirement. Whether you're building a file manager, a data processing application, or simply need to organize output files, understanding how to work with directories in .NET is essential.

.NET provides robust tools for directory operations through classes in the `System.IO` namespace, primarily the `Directory` and `DirectoryInfo` classes. These classes allow you to create, delete, move directories, and gather information about existing directories in your file system.

In this tutorial, we'll explore the various directory operations available in .NET and how to use them effectively in your applications.

## Understanding Directory Classes in .NET

.NET provides two primary classes for working with directories:

1. **Directory**: A static class that provides basic directory operations without the need to instantiate an object.
2. **DirectoryInfo**: An instance-based class that provides more detailed control and information about directories.

Let's examine when to use each approach:

```csharp
// Using the static Directory class
Directory.CreateDirectory("MyFolder");

// Using the instance-based DirectoryInfo class
DirectoryInfo dirInfo = new DirectoryInfo("MyFolder");
dirInfo.Create();
```

The main difference is that `DirectoryInfo` objects maintain state and provide more properties, while the `Directory` class methods are generally simpler to use for one-off operations.

## Creating Directories

### Basic Directory Creation

Creating a directory is one of the most fundamental operations:

```csharp
using System;
using System.IO;

// Create a single directory in the current location
Directory.CreateDirectory("NewFolder");
Console.WriteLine("Directory created successfully!");

// Create a directory with a full path
Directory.CreateDirectory(@"C:\Temp\MyApplication\Data");
Console.WriteLine("Directory with full path created!");

// Create nested directories (all parent directories are created automatically)
Directory.CreateDirectory(@"ParentFolder\ChildFolder\GrandchildFolder");
Console.WriteLine("Nested directories created!");
```

### Using DirectoryInfo for Creation

The `DirectoryInfo` class provides an object-oriented approach:

```csharp
using System;
using System.IO;

// Create a directory using DirectoryInfo
DirectoryInfo dirInfo = new DirectoryInfo("ProjectFiles");
dirInfo.Create();
Console.WriteLine($"Directory created: {dirInfo.FullName}");

// Create subdirectory using DirectoryInfo
DirectoryInfo subDir = dirInfo.CreateSubdirectory("Assets");
Console.WriteLine($"Subdirectory created: {subDir.FullName}");
```

## Checking if a Directory Exists

Before performing operations, it's often necessary to check if a directory exists:

```csharp
using System;
using System.IO;

string directoryPath = @"C:\Projects\MyApp";

if (Directory.Exists(directoryPath))
{
    Console.WriteLine($"The directory '{directoryPath}' exists!");
}
else
{
    Console.WriteLine($"The directory '{directoryPath}' does not exist.");
    
    // Create it if needed
    Directory.CreateDirectory(directoryPath);
    Console.WriteLine("Directory has been created.");
}
```

With `DirectoryInfo`:

```csharp
using System;
using System.IO;

DirectoryInfo dirInfo = new DirectoryInfo(@"C:\Projects\MyApp");
if (dirInfo.Exists)
{
    Console.WriteLine($"The directory '{dirInfo.FullName}' exists!");
}
else
{
    Console.WriteLine($"The directory '{dirInfo.FullName}' does not exist.");
    dirInfo.Create();
    Console.WriteLine("Directory has been created.");
}
```

## Getting Directory Information

### Basic Information with Directory Class

```csharp
using System;
using System.IO;

string directoryPath = @"C:\Projects";

// Get creation time
DateTime creationTime = Directory.GetCreationTime(directoryPath);
Console.WriteLine($"Directory was created on: {creationTime}");

// Get last access time
DateTime lastAccessTime = Directory.GetLastAccessTime(directoryPath);
Console.WriteLine($"Directory was last accessed on: {lastAccessTime}");

// Get last write time
DateTime lastWriteTime = Directory.GetLastWriteTime(directoryPath);
Console.WriteLine($"Directory was last modified on: {lastWriteTime}");

// Get parent directory
string parent = Directory.GetParent(directoryPath).FullName;
Console.WriteLine($"Parent directory: {parent}");

// Get current directory
string currentDir = Directory.GetCurrentDirectory();
Console.WriteLine($"Current directory: {currentDir}");
```

### Detailed Information with DirectoryInfo

```csharp
using System;
using System.IO;

DirectoryInfo dirInfo = new DirectoryInfo(@"C:\Projects");

Console.WriteLine($"Full path: {dirInfo.FullName}");
Console.WriteLine($"Name: {dirInfo.Name}");
Console.WriteLine($"Parent: {dirInfo.Parent?.FullName ?? "None"}");
Console.WriteLine($"Root: {dirInfo.Root}");
Console.WriteLine($"Creation Time: {dirInfo.CreationTime}");
Console.WriteLine($"Last Access Time: {dirInfo.LastAccessTime}");
Console.WriteLine($"Last Write Time: {dirInfo.LastWriteTime}");
Console.WriteLine($"Attributes: {dirInfo.Attributes}");
```

## Listing Files and Subdirectories

### Listing with Directory Class

```csharp
using System;
using System.IO;

string directoryPath = @"C:\Projects";

// Get all files in the directory
string[] files = Directory.GetFiles(directoryPath);
Console.WriteLine("Files:");
foreach (string file in files)
{
    Console.WriteLine($" - {Path.GetFileName(file)}");
}

// Get all subdirectories in the directory
string[] directories = Directory.GetDirectories(directoryPath);
Console.WriteLine("\nSubdirectories:");
foreach (string directory in directories)
{
    Console.WriteLine($" - {Path.GetFileName(directory)}");
}

// Get files with specific extension
string[] txtFiles = Directory.GetFiles(directoryPath, "*.txt");
Console.WriteLine("\nText files only:");
foreach (string txtFile in txtFiles)
{
    Console.WriteLine($" - {Path.GetFileName(txtFile)}");
}

// Search recursively in all subdirectories
string[] allFiles = Directory.GetFiles(directoryPath, "*.*", SearchOption.AllDirectories);
Console.WriteLine($"\nTotal files (including subdirectories): {allFiles.Length}");
```

### Listing with DirectoryInfo

```csharp
using System;
using System.IO;

DirectoryInfo dirInfo = new DirectoryInfo(@"C:\Projects");

// Get files
FileInfo[] files = dirInfo.GetFiles();
Console.WriteLine("Files:");
foreach (FileInfo file in files)
{
    Console.WriteLine($" - {file.Name} ({file.Length} bytes)");
}

// Get directories
DirectoryInfo[] subDirs = dirInfo.GetDirectories();
Console.WriteLine("\nSubdirectories:");
foreach (DirectoryInfo subDir in subDirs)
{
    Console.WriteLine($" - {subDir.Name} (Created: {subDir.CreationTime})");
}

// Get specific file types
FileInfo[] jpgFiles = dirInfo.GetFiles("*.jpg", SearchOption.AllDirectories);
Console.WriteLine($"\nFound {jpgFiles.Length} JPG files in all subdirectories.");
```

## Moving and Copying Directories

### Moving Directories

```csharp
using System;
using System.IO;

try
{
    // Move a directory and its contents
    string sourcePath = @"C:\Temp\SourceFolder";
    string targetPath = @"D:\Backup\TargetFolder";
    
    // Ensure source exists and target doesn't
    if (Directory.Exists(sourcePath) && !Directory.Exists(targetPath))
    {
        Directory.Move(sourcePath, targetPath);
        Console.WriteLine($"Directory moved from {sourcePath} to {targetPath}");
    }
    else
    {
        Console.WriteLine("Cannot move: Source doesn't exist or target already exists.");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"An error occurred: {ex.Message}");
}
```

### Copying Directories

.NET doesn't provide a direct method to copy directories, so we need to create our own method:

```csharp
using System;
using System.IO;

// Custom method to copy a directory and its contents
static void CopyDirectory(string sourceDir, string destinationDir, bool recursive)
{
    // Get information about the source directory
    var dir = new DirectoryInfo(sourceDir);
    
    // Check if the source directory exists
    if (!dir.Exists)
        throw new DirectoryNotFoundException($"Source directory not found: {dir.FullName}");
    
    // Cache directories before we start copying
    DirectoryInfo[] dirs = dir.GetDirectories();
    
    // Create the destination directory
    Directory.CreateDirectory(destinationDir);
    
    // Get the files in the source directory and copy to the destination directory
    foreach (FileInfo file in dir.GetFiles())
    {
        string targetFilePath = Path.Combine(destinationDir, file.Name);
        file.CopyTo(targetFilePath);
        Console.WriteLine($"Copied {file.Name}");
    }
    
    // If recursive and there are directories, copy those too
    if (recursive)
    {
        foreach (DirectoryInfo subDir in dirs)
        {
            string newDestinationDir = Path.Combine(destinationDir, subDir.Name);
            CopyDirectory(subDir.FullName, newDestinationDir, true);
        }
    }
}

// Usage example
try
{
    string sourceDir = @"C:\Projects\MyApp";
    string destinationDir = @"D:\Backup\MyApp_Copy";
    
    CopyDirectory(sourceDir, destinationDir, true);
    Console.WriteLine("Directory copied successfully!");
}
catch (Exception ex)
{
    Console.WriteLine($"Error copying directory: {ex.Message}");
}
```

## Deleting Directories

### Deleting with Directory Class

```csharp
using System;
using System.IO;

try
{
    string pathToDelete = @"C:\Temp\OldFiles";
    
    // Delete empty directory
    Directory.Delete(pathToDelete); 
    Console.WriteLine("Empty directory deleted!");
    
    // Delete directory with contents
    Directory.Delete(pathToDelete, true);
    Console.WriteLine("Directory and all its contents deleted!");
}
catch (IOException ex)
{
    Console.WriteLine($"Error: {ex.Message}");
    // This may occur if files are in use or the directory is not empty
}
catch (UnauthorizedAccessException ex)
{
    Console.WriteLine($"Access denied: {ex.Message}");
    // This may occur if you don't have proper permissions
}
```

### Deleting with DirectoryInfo

```csharp
using System;
using System.IO;

try
{
    DirectoryInfo dirInfo = new DirectoryInfo(@"C:\Temp\OldFiles");
    
    if (dirInfo.Exists)
    {
        // Delete the directory and all its contents
        dirInfo.Delete(true);
        Console.WriteLine("Directory deleted successfully!");
    }
    else
    {
        Console.WriteLine("Directory does not exist.");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"Error deleting directory: {ex.Message}");
}
```

## Directory Attributes and Properties

You can access and modify directory attributes:

```csharp
using System;
using System.IO;

string dirPath = @"C:\Projects\SecretProject";
DirectoryInfo dirInfo = new DirectoryInfo(dirPath);

// Get attributes
FileAttributes attributes = dirInfo.Attributes;
Console.WriteLine($"Current attributes: {attributes}");

// Check if directory has a specific attribute
bool isHidden = (attributes & FileAttributes.Hidden) == FileAttributes.Hidden;
Console.WriteLine($"Is hidden: {isHidden}");

// Set directory as hidden
if (!isHidden)
{
    dirInfo.Attributes |= FileAttributes.Hidden;
    Console.WriteLine("Directory is now hidden.");
}

// Remove hidden attribute
dirInfo.Attributes &= ~FileAttributes.Hidden;
Console.WriteLine("Hidden attribute removed.");

// Make directory read-only
dirInfo.Attributes |= FileAttributes.ReadOnly;
Console.WriteLine("Directory is now read-only.");
```

## Real-World Examples

### Example 1: Project Backup Utility

A simple utility to back up a project directory:

```csharp
using System;
using System.IO;

public class ProjectBackupUtility
{
    public static void BackupProject(string projectPath, string backupRoot)
    {
        try
        {
            // Create timestamp for unique backup folder
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss");
            string projectName = new DirectoryInfo(projectPath).Name;
            string backupPath = Path.Combine(backupRoot, $"{projectName}_Backup_{timestamp}");
            
            // Create backup directory
            Directory.CreateDirectory(backupPath);
            
            // Copy all files and subdirectories
            CopyDirectory(projectPath, backupPath, true);
            
            Console.WriteLine($"Backup created successfully at: {backupPath}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Backup failed: {ex.Message}");
        }
    }
    
    // Our CopyDirectory method from earlier examples
    private static void CopyDirectory(string sourceDir, string destinationDir, bool recursive)
    {
        // Implementation from previous examples
        var dir = new DirectoryInfo(sourceDir);
        
        if (!dir.Exists)
            throw new DirectoryNotFoundException($"Source directory not found: {dir.FullName}");
        
        DirectoryInfo[] dirs = dir.GetDirectories();
        Directory.CreateDirectory(destinationDir);
        
        foreach (FileInfo file in dir.GetFiles())
        {
            string targetFilePath = Path.Combine(destinationDir, file.Name);
            file.CopyTo(targetFilePath);
        }
        
        if (recursive)
        {
            foreach (DirectoryInfo subDir in dirs)
            {
                string newDestinationDir = Path.Combine(destinationDir, subDir.Name);
                CopyDirectory(subDir.FullName, newDestinationDir, true);
            }
        }
    }
}

// Example usage
class Program
{
    static void Main(string[] args)
    {
        string projectPath = @"C:\Projects\MyApplication";
        string backupFolder = @"D:\Backups";
        
        ProjectBackupUtility.BackupProject(projectPath, backupFolder);
    }
}
```

### Example 2: Directory Cleanup Utility

A utility to clean up old files from a directory:

```csharp
using System;
using System.IO;

public class DirectoryCleanupUtility
{
    public static void CleanupOldFiles(string directoryPath, int daysOld)
    {
        try
        {
            DirectoryInfo directory = new DirectoryInfo(directoryPath);
            if (!directory.Exists)
            {
                Console.WriteLine($"Directory does not exist: {directoryPath}");
                return;
            }
            
            DateTime cutoffDate = DateTime.Now.AddDays(-daysOld);
            int filesDeleted = 0;
            long bytesFreed = 0;
            
            // Process files in the current directory
            foreach (FileInfo file in directory.GetFiles())
            {
                if (file.LastWriteTime < cutoffDate)
                {
                    bytesFreed += file.Length;
                    file.Delete();
                    filesDeleted++;
                    Console.WriteLine($"Deleted file: {file.Name}");
                }
            }
            
            // Process subdirectories (and optionally remove empty ones)
            foreach (DirectoryInfo subDir in directory.GetDirectories())
            {
                // Recursively clean up subdirectories
                CleanupOldFiles(subDir.FullName, daysOld);
                
                // Check if directory is empty and delete it
                if (subDir.GetFiles().Length == 0 && subDir.GetDirectories().Length == 0)
                {
                    subDir.Delete();
                    Console.WriteLine($"Removed empty directory: {subDir.Name}");
                }
            }
            
            Console.WriteLine($"Cleanup completed! Deleted {filesDeleted} files and freed {bytesFreed / 1024} KB of space.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error during cleanup: {ex.Message}");
        }
    }
}

// Example usage
class Program
{
    static void Main(string[] args)
    {
        string tempDir = @"C:\Temp";
        int olderThanDays = 30;
        
        Console.WriteLine($"Cleaning up files older than {olderThanDays} days in {tempDir}");
        DirectoryCleanupUtility.CleanupOldFiles(tempDir, olderThanDays);
    }
}
```

## Error Handling in Directory Operations

When working with directories, many things can go wrong. Here's how to handle common exceptions:

```csharp
using System;
using System.IO;
using System.Security;

try
{
    string path = @"C:\SomeDirectory\SubDirectory";
    
    // Attempt to create a directory
    Directory.CreateDirectory(path);
    
    // Attempt to delete a directory
    Directory.Delete(path, true);
}
catch (UnauthorizedAccessException ex)
{
    Console.WriteLine($"Access denied: {ex.Message}");
    Console.WriteLine("Make sure you have the necessary permissions to access this location.");
}
catch (PathTooLongException ex)
{
    Console.WriteLine($"Path too long: {ex.Message}");
    Console.WriteLine("The path exceeds the system-defined maximum length.");
}
catch (DirectoryNotFoundException ex)
{
    Console.WriteLine($"Directory not found: {ex.Message}");
    Console.WriteLine("The specified directory does not exist.");
}
catch (IOException ex)
{
    Console.WriteLine($"IO error: {ex.Message}");
    Console.WriteLine("There was an error accessing the file system.");
}
catch (SecurityException ex)
{
    Console.WriteLine($"Security error: {ex.Message}");
    Console.WriteLine("You don't have the required permission.");
}
catch (Exception ex)
{
    Console.WriteLine($"Unexpected error: {ex.Message}");
}
```

## Best Practices for Directory Operations

1. **Always check if a directory exists before performing operations** to avoid unnecessary exceptions.

2. **Use try-catch blocks** to handle potential exceptions gracefully.

3. **Be cautious with recursive operations**, especially deletion, as they can have significant impacts.

4. **Use `Path.Combine()` to build paths** instead of string concatenation to ensure proper path formatting.

5. **Consider using `DirectoryInfo` for multiple operations** on the same directory to avoid repeated path parsing.

6. **Use asynchronous operations** for large file operations to maintain application responsiveness.

7. **Be careful with permissions** - not all users may have access to all directories.

8. **Handle relative paths carefully** - they are relative to the current directory, which may not be what you expect.

## Summary

Directory operations are a fundamental part of many .NET applications. In this guide, we covered:

- Creating, checking, and deleting directories
- Getting information about directories
- Listing files and subdirectories
- Moving and copying directories
- Working with directory attributes
- Real-world examples of directory operations
- Proper error handling techniques
- Best practices for working with directories

The `System.IO` namespace provides a powerful set of tools for working with directories. By understanding these tools and following best practices, you can build robust applications that effectively manage file system resources.

## Additional Resources

- [Microsoft Documentation: Directory Class](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory)
- [Microsoft Documentation: DirectoryInfo Class](https://docs.microsoft.com/en-us/dotnet/api/system.io.directoryinfo)
- [Microsoft Documentation: Path Class](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)

## Exercises

1. Create a console application that lists all directories and files in a specified path, with proper indentation to show the hierarchy.

2. Build a utility that synchronizes two directories (similar to a simple backup tool).

3. Create a program that monitors a directory for changes and logs any new, modified, or deleted files.

4. Build a directory size calculator that computes the total size of a directory and all its subdirectories.

5. Create a utility that organizes files in a directory based on their extension or creation date.