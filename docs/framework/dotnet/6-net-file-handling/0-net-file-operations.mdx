---
title: .NET File Operations
description: Learn how to perform common file operations like creating, reading, writing, and deleting files in .NET applications

---

# .NET File Operations

## Introduction

File operations are fundamental to many applications, allowing you to read data from external sources, save information persistently, and manage content on the file system. .NET provides a robust set of classes to perform various file operations, making it straightforward to work with files in your applications.

In this tutorial, we'll explore common file operations in .NET, including:

- Checking if a file exists
- Creating new files
- Reading from files
- Writing to files
- Deleting files
- Moving and copying files
- Getting file information

By the end of this tutorial, you'll have a solid understanding of how to manipulate files in your .NET applications.

## Key Classes for File Operations

Before diving into specific operations, let's familiarize ourselves with the main classes used for file operations in .NET:

- **`File`**: A static class that provides methods for creating, copying, deleting, moving, and opening files.
- **`FileInfo`**: An instance-based alternative to the `File` class that provides similar functionality.
- **`Directory`** and **`DirectoryInfo`**: Classes for working with directories (folders).
- **`Path`**: A utility class for working with file and directory paths.

These classes are found in the `System.IO` namespace, so you'll need to include this namespace in your code:

```csharp
using System.IO;
```

## Checking If a File Exists

One of the most basic file operations is checking whether a file exists. The `File` class provides a simple way to do this:

```csharp
string filePath = "example.txt";
bool fileExists = File.Exists(filePath);

Console.WriteLine($"Does the file exist? {fileExists}");
```

**Output**:
```
Does the file exist? False
```

This is useful before attempting to read from a file or when you want to avoid overwriting existing files.

## Creating a New File

There are several ways to create a new file in .NET:

### Using the File.Create Method

```csharp
string filePath = "newfile.txt";
using (FileStream fs = File.Create(filePath))
{
    // File is created and stream is open for writing
    byte[] info = new UTF8Encoding(true).GetBytes("This is some text in the file.");
    fs.Write(info, 0, info.Length);
}
Console.WriteLine($"File created at: {filePath}");
```

### Using StreamWriter

```csharp
string filePath = "anotherfile.txt";
using (StreamWriter writer = new StreamWriter(filePath))
{
    writer.WriteLine("This is the first line.");
    writer.WriteLine("This is the second line.");
}
Console.WriteLine($"File created at: {filePath}");
```

## Reading From a File

Reading from files can be done in several ways, depending on your needs:

### Reading All Text at Once

```csharp
string filePath = "example.txt";

// First create a file with some content
using (StreamWriter writer = new StreamWriter(filePath))
{
    writer.WriteLine("Line 1: Hello, world!");
    writer.WriteLine("Line 2: Welcome to file operations in .NET");
    writer.WriteLine("Line 3: This is the last line.");
}

// Read all the text from the file
string content = File.ReadAllText(filePath);
Console.WriteLine("File content (all at once):");
Console.WriteLine(content);
```

**Output**:
```
File content (all at once):
Line 1: Hello, world!
Line 2: Welcome to file operations in .NET
Line 3: This is the last line.
```

### Reading Line by Line

```csharp
string[] lines = File.ReadAllLines(filePath);
Console.WriteLine("\nFile content (line by line):");
foreach (string line in lines)
{
    Console.WriteLine($"  > {line}");
}
```

**Output**:
```
File content (line by line):
  > Line 1: Hello, world!
  > Line 2: Welcome to file operations in .NET
  > Line 3: This is the last line.
```

### Reading with StreamReader

For more control, especially with large files, use `StreamReader`:

```csharp
Console.WriteLine("\nReading with StreamReader:");
using (StreamReader reader = new StreamReader(filePath))
{
    string line;
    while ((line = reader.ReadLine()) != null)
    {
        Console.WriteLine($"  > {line}");
    }
}
```

**Output**:
```
Reading with StreamReader:
  > Line 1: Hello, world!
  > Line 2: Welcome to file operations in .NET
  > Line 3: This is the last line.
```

## Writing to a File

Writing to files can be done in several ways:

### Write All Text at Once

```csharp
string filePath = "output.txt";
string content = "This content will replace everything in the file.\nThis is a second line.";

File.WriteAllText(filePath, content);
Console.WriteLine($"Content written to {filePath}");
```

### Write Multiple Lines at Once

```csharp
string[] lines = {
    "First line for the array write",
    "Second line for the array write",
    "Third line for the array write"
};

File.WriteAllLines("multiline.txt", lines);
Console.WriteLine("Multiple lines written to multiline.txt");
```

### Append to an Existing File

```csharp
string filePath = "log.txt";

// Create the file if it doesn't exist
if (!File.Exists(filePath))
{
    File.WriteAllText(filePath, "Log file created on " + DateTime.Now.ToString() + "\n");
}

// Append text to the file
File.AppendAllText(filePath, $"Log entry at {DateTime.Now}: System started\n");
Console.WriteLine($"Appended to {filePath}");
```

## Deleting a File

Deleting a file is straightforward:

```csharp
string fileToDelete = "tempfile.txt";

// First create the file
File.WriteAllText(fileToDelete, "This file will be deleted");

Console.WriteLine($"Does '{fileToDelete}' exist before deletion? {File.Exists(fileToDelete)}");

// Delete the file
File.Delete(fileToDelete);

Console.WriteLine($"Does '{fileToDelete}' exist after deletion? {File.Exists(fileToDelete)}");
```

**Output**:
```
Does 'tempfile.txt' exist before deletion? True
Does 'tempfile.txt' exist after deletion? False
```

For safety, it's often a good idea to check if a file exists before attempting to delete it:

```csharp
string nonExistentFile = "nonexistent.txt";
if (File.Exists(nonExistentFile))
{
    File.Delete(nonExistentFile);
    Console.WriteLine($"Deleted {nonExistentFile}");
}
else
{
    Console.WriteLine($"The file {nonExistentFile} doesn't exist");
}
```

**Output**:
```
The file nonexistent.txt doesn't exist
```

## Moving and Copying Files

.NET makes it easy to move and copy files:

### Copying a File

```csharp
string originalFile = "original.txt";
string copyFile = "copy.txt";

// Create the original file
File.WriteAllText(originalFile, "This is the original file content");

// Copy the file
File.Copy(originalFile, copyFile);

Console.WriteLine($"Original file content: {File.ReadAllText(originalFile)}");
Console.WriteLine($"Copied file content: {File.ReadAllText(copyFile)}");
```

**Output**:
```
Original file content: This is the original file content
Copied file content: This is the original file content
```

To overwrite an existing destination file, specify `true` for the `overwrite` parameter:

```csharp
File.WriteAllText(copyFile, "This content will be overwritten");
File.Copy(originalFile, copyFile, true); // Overwrite the existing file
```

### Moving a File

Moving a file is similar to copying, but it removes the source file:

```csharp
string sourceFile = "source.txt";
string destinationFile = "moved.txt";

// Create the source file
File.WriteAllText(sourceFile, "This file will be moved");

// Move the file
File.Move(sourceFile, destinationFile);

Console.WriteLine($"Does source file still exist? {File.Exists(sourceFile)}");
Console.WriteLine($"Destination file content: {File.ReadAllText(destinationFile)}");
```

**Output**:
```
Does source file still exist? False
Destination file content: This file will be moved
```

## Getting File Information

The `FileInfo` class provides information about a specific file:

```csharp
string infoFilePath = "info_example.txt";

// Create and write to the file
File.WriteAllText(infoFilePath, "This is a sample file for getting information");

// Get file information
FileInfo fileInfo = new FileInfo(infoFilePath);

Console.WriteLine($"File name: {fileInfo.Name}");
Console.WriteLine($"Full path: {fileInfo.FullName}");
Console.WriteLine($"Directory: {fileInfo.DirectoryName}");
Console.WriteLine($"Size: {fileInfo.Length} bytes");
Console.WriteLine($"Creation time: {fileInfo.CreationTime}");
Console.WriteLine($"Last access time: {fileInfo.LastAccessTime}");
Console.WriteLine($"Last write time: {fileInfo.LastWriteTime}");
Console.WriteLine($"Is read-only: {fileInfo.IsReadOnly}");
```

**Output**:
```
File name: info_example.txt
Full path: C:\path\to\info_example.txt
Directory: C:\path\to
Size: 47 bytes
Creation time: 5/10/2023 10:15:30 AM
Last access time: 5/10/2023 10:15:30 AM
Last write time: 5/10/2023 10:15:30 AM
Is read-only: False
```

## Working with File Paths

The `Path` class provides utilities for working with file and directory paths:

```csharp
string filePath = @"C:\Users\Username\Documents\example.txt";

Console.WriteLine($"File name: {Path.GetFileName(filePath)}");
Console.WriteLine($"File name without extension: {Path.GetFileNameWithoutExtension(filePath)}");
Console.WriteLine($"File extension: {Path.GetExtension(filePath)}");
Console.WriteLine($"Directory name: {Path.GetDirectoryName(filePath)}");

// Combine paths safely
string directory = @"C:\Users\Username\Documents";
string fileName = "example.txt";
string combinedPath = Path.Combine(directory, fileName);
Console.WriteLine($"Combined path: {combinedPath}");

// Get temporary file name
string tempFilePath = Path.GetTempFileName();
Console.WriteLine($"Temporary file: {tempFilePath}");
```

**Output**:
```
File name: example.txt
File name without extension: example
File extension: .txt
Directory name: C:\Users\Username\Documents
Combined path: C:\Users\Username\Documents\example.txt
Temporary file: C:\Users\Username\AppData\Local\Temp\tmp1A2B.tmp
```

## Real-world Example: Simple Log File

Let's create a practical example of a simple logging system:

```csharp
public class SimpleLogger
{
    private readonly string _logFilePath;

    public SimpleLogger(string logFilePath)
    {
        _logFilePath = logFilePath;
        
        // Ensure the directory exists
        string directory = Path.GetDirectoryName(_logFilePath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
    }

    public void Log(string message)
    {
        try
        {
            string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
            
            // Append to the log file
            File.AppendAllText(_logFilePath, logEntry + Environment.NewLine);
        }
        catch (Exception ex)
        {
            // In a real application, you might want to handle this differently
            Console.WriteLine($"Error writing to log file: {ex.Message}");
        }
    }

    public string[] ReadLastNEntries(int n)
    {
        try
        {
            if (!File.Exists(_logFilePath))
                return new string[0];

            string[] allLines = File.ReadAllLines(_logFilePath);
            return allLines.Length <= n 
                ? allLines 
                : allLines.Skip(allLines.Length - n).ToArray();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading log file: {ex.Message}");
            return new string[0];
        }
    }
}

// Using the logger
string logPath = "application.log";
SimpleLogger logger = new SimpleLogger(logPath);

logger.Log("Application started");
logger.Log("User logged in: john_doe");
logger.Log("Processing file: data.csv");
logger.Log("User performed action: export data");
logger.Log("Application shutdown");

// Read back the last 3 log entries
Console.WriteLine("Last 3 log entries:");
string[] lastEntries = logger.ReadLastNEntries(3);
foreach (string entry in lastEntries)
{
    Console.WriteLine($"  {entry}");
}
```

**Output**:
```
Last 3 log entries:
  2023-05-10 14:23:45 - Processing file: data.csv
  2023-05-10 14:23:45 - User performed action: export data
  2023-05-10 14:23:45 - Application shutdown
```

## Best Practices for File Operations

1. **Always use exception handling** when performing file operations, as they can fail for many reasons (file locked, insufficient permissions, disk full, etc.).

2. **Dispose of resources properly** by using `using` statements or calling `Dispose()` explicitly to ensure files are properly closed.

3. **Check file existence** before performing operations that depend on a file being present.

4. **Use Path.Combine()** instead of concatenating paths manually to ensure proper path formatting.

5. **Be mindful of file paths and security**:
   - Be careful with user-provided paths to prevent access to unauthorized files
   - Consider using relative paths when appropriate
   - Use `Path.GetFullPath()` to resolve relative paths

6. **Consider performance implications**:
   - For large files, read/write in chunks instead of all at once
   - Choose the appropriate method based on the size of the data
   - Use buffered operations for better performance

7. **Handle concurrency** by considering file locking and simultaneous access scenarios.

## Summary

In this tutorial, we've covered the fundamental file operations in .NET:

- Checking if a file exists
- Creating new files
- Reading from files using various methods
- Writing to files and appending content
- Deleting files
- Moving and copying files
- Getting file information
- Working with file paths

We also built a simple practical application (a logger) that demonstrates how these operations can be combined to create useful functionality in real-world scenarios.

.NET's file handling capabilities are extensive, making it easy to work with files in a variety of ways. By understanding these basic operations, you can build sophisticated applications that efficiently read, write, and manage files.

## Additional Exercises

1. Create a simple text editor that can open, edit, and save text files.

2. Build a file backup utility that copies files from one directory to another, only copying files that have changed.

3. Create a CSV file parser that reads data from a CSV file and converts it to a list of objects.

4. Implement a file watcher that monitors a directory and logs when files are created, modified, or deleted.

5. Build a configuration system that reads and writes application settings to a JSON file.

## Further Resources

- [Microsoft Docs: File and Stream I/O](https://docs.microsoft.com/en-us/dotnet/standard/io/)
- [Microsoft Docs: File Class](https://docs.microsoft.com/en-us/dotnet/api/system.io.file)
- [Microsoft Docs: FileInfo Class](https://docs.microsoft.com/en-us/dotnet/api/system.io.fileinfo)
- [Microsoft Docs: Path Class](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)
- [C# Corner: File Handling in C#](https://www.c-sharpcorner.com/article/file-handling-in-C-Sharp/)