---
title: .NET Progress Reporting
description: Learn how to implement and use progress reporting with asynchronous operations in .NET to provide feedback during long-running tasks

---

# .NET Progress Reporting

When working with asynchronous operations in .NET, especially those that take a considerable amount of time to complete, it's often desirable to provide feedback to users about the operation's progress. This improves user experience by giving them a sense of how much longer they need to wait and confirming that the application is still working rather than frozen.

In this tutorial, we'll explore how to implement progress reporting in .NET asynchronous operations using built-in mechanisms.

## Understanding Progress Reporting in .NET

.NET provides a standardized way to report progress from asynchronous operations through the `IProgress<T>` interface and its common implementation, `Progress<T>`. These types enable you to:

1. Report progress from long-running operations
2. Update UI elements with progress information
3. Provide feedback in a thread-safe manner

The beauty of this approach is that it works seamlessly with the Task-based Asynchronous Pattern (TAP) without requiring manual thread synchronization.

## The `IProgress<T>` Interface

The `IProgress<T>` interface is quite simple, containing just one method:

```csharp
public interface IProgress<in T>
{
    void Report(T value);
}
```

Here, `T` represents the type of progress update you want to report. This could be:
- A simple percentage (`int` or `double`)
- A complex object containing detailed progress information
- Any other type that can represent your progress state

## `Progress<T>` Implementation

While you could implement the `IProgress<T>` interface yourself, .NET provides a default implementation called `Progress<T>` that handles most of the common scenarios, including:

- Thread synchronization
- Callback invocation on the appropriate thread (usually the UI thread)

Here's how to create a `Progress<T>` instance:

```csharp
var progress = new Progress<int>(percentComplete => 
{
    // This action will be executed on the thread that created the Progress object
    progressBar.Value = percentComplete;
    statusLabel.Text = $"Processing: {percentComplete}%";
});
```

## Basic Progress Reporting Example

Let's start with a simple console application example that demonstrates progress reporting:

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.WriteLine("Starting long-running operation...");

        var progress = new Progress<int>(percent =>
        {
            Console.WriteLine($"Progress: {percent}%");
        });

        await ProcessFileAsync(progress);

        Console.WriteLine("Operation completed!");
        Console.ReadKey();
    }

    static async Task ProcessFileAsync(IProgress<int> progress)
    {
        // Simulate processing a large file
        int totalParts = 10;
        
        for (int i = 0; i < totalParts; i++)
        {
            // Do some work
            await Task.Delay(500); // Simulate work being done
            
            // Report progress as a percentage
            int percentComplete = (i + 1) * 100 / totalParts;
            progress?.Report(percentComplete);
        }
    }
}
```

**Output:**
```
Starting long-running operation...
Progress: 10%
Progress: 20%
Progress: 30%
Progress: 40%
Progress: 50%
Progress: 60%
Progress: 70%
Progress: 80%
Progress: 90%
Progress: 100%
Operation completed!
```

## Progress Reporting with Complex Data

Sometimes a simple percentage isn't enough. In such cases, you can create a custom progress class:

```csharp
public class FileProcessingProgress
{
    public int PercentComplete { get; set; }
    public string CurrentFileName { get; set; }
    public int ProcessedFiles { get; set; }
    public int TotalFiles { get; set; }
    public long BytesProcessed { get; set; }
}
```

And then use it with the `IProgress<T>` interface:

```csharp
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.WriteLine("Starting batch file processing...");

        var progress = new Progress<FileProcessingProgress>(p =>
        {
            Console.WriteLine($"Processing file {p.ProcessedFiles} of {p.TotalFiles}: {p.CurrentFileName}");
            Console.WriteLine($"Overall progress: {p.PercentComplete}% ({p.BytesProcessed / 1024} KB processed)");
            Console.WriteLine();
        });

        await ProcessFileBatchAsync(progress);

        Console.WriteLine("Batch processing completed!");
        Console.ReadKey();
    }

    static async Task ProcessFileBatchAsync(IProgress<FileProcessingProgress> progress)
    {
        string[] files = { "document.docx", "image.jpg", "data.csv", "video.mp4" };
        long[] fileSizes = { 5_000, 8_000, 3_000, 15_000 }; // Simulated file sizes in KB
        
        var progressData = new FileProcessingProgress
        {
            TotalFiles = files.Length,
            ProcessedFiles = 0,
            BytesProcessed = 0
        };

        for (int i = 0; i < files.Length; i++)
        {
            progressData.CurrentFileName = files[i];
            progressData.ProcessedFiles = i + 1;
            
            // Simulate processing the file
            int chunks = (int)fileSizes[i] / 1000;
            for (int j = 0; j < chunks; j++)
            {
                await Task.Delay(100); // Simulate processing a chunk

                progressData.BytesProcessed += 1000 * 1024; // 1000KB in bytes
                progressData.PercentComplete = (int)((double)(i * 100 + j * 100 / chunks) / files.Length);
                
                progress?.Report(new FileProcessingProgress
                {
                    PercentComplete = progressData.PercentComplete,
                    CurrentFileName = progressData.CurrentFileName,
                    ProcessedFiles = progressData.ProcessedFiles,
                    TotalFiles = progressData.TotalFiles,
                    BytesProcessed = progressData.BytesProcessed
                });
            }
        }
    }
}
```

## Progress Reporting in a WPF Application

Progress reporting is particularly useful in GUI applications. Here's how you can use it in a WPF application:

```csharp
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
    }

    private async void StartButton_Click(object sender, RoutedEventArgs e)
    {
        StartButton.IsEnabled = false;
        
        // Create a progress object that updates the UI
        var progress = new Progress<int>(percent => 
        {
            ProgressBar.Value = percent;
            StatusLabel.Text = $"Processing: {percent}%";
        });

        try
        {
            // Start the long-running operation with progress reporting
            await ProcessDataAsync(progress);
            StatusLabel.Text = "Processing completed successfully!";
        }
        catch (Exception ex)
        {
            StatusLabel.Text = $"Error: {ex.Message}";
        }
        finally
        {
            StartButton.IsEnabled = true;
        }
    }

    private async Task ProcessDataAsync(IProgress<int> progress)
    {
        // Simulate a long-running task with progress updates
        for (int i = 0; i <= 10; i++)
        {
            await Task.Delay(500); // Simulate work being done
            progress?.Report(i * 10);
        }
    }
}
```

## Progress Reporting with CancellationToken

Often, you'll want to combine progress reporting with the ability to cancel operations. Here's how you can do that:

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.WriteLine("Starting long-running operation...");
        Console.WriteLine("Press 'C' to cancel the operation at any time.");

        using var cts = new CancellationTokenSource();

        // Start a task to monitor for cancellation
        _ = Task.Run(() => 
        {
            while (Console.ReadKey(true).Key != ConsoleKey.C)
            {
                // Wait for 'C' key press
            }
            
            Console.WriteLine("\nCancellation requested!");
            cts.Cancel();
        });

        var progress = new Progress<int>(percent =>
        {
            Console.WriteLine($"Progress: {percent}%");
        });

        try
        {
            await ProcessDataAsync(progress, cts.Token);
            Console.WriteLine("Operation completed successfully!");
        }
        catch (OperationCanceledException)
        {
            Console.WriteLine("Operation was cancelled.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Operation failed: {ex.Message}");
        }

        Console.WriteLine("Press any key to exit.");
        Console.ReadKey();
    }

    static async Task ProcessDataAsync(IProgress<int> progress, CancellationToken cancellationToken)
    {
        int totalSteps = 10;
        
        for (int i = 0; i < totalSteps; i++)
        {
            // Check for cancellation before each significant operation
            cancellationToken.ThrowIfCancellationRequested();
            
            // Simulate work
            await Task.Delay(1000, cancellationToken);
            
            // Report progress
            int percentComplete = (i + 1) * 100 / totalSteps;
            progress?.Report(percentComplete);
        }
    }
}
```

## Best Practices for Progress Reporting

1. **Don't report too frequently**: Reporting progress too often can degrade performance, especially in UI applications. Consider throttling progress updates.

2. **Handle null progress parameters**: Always check if the progress parameter is null before using it.
   ```csharp
   progress?.Report(percentComplete);
   ```

3. **Avoid expensive operations in progress handlers**: The progress callback should be lightweight to avoid blocking the UI thread.

4. **Thread safety**: The `Progress<T>` class handles thread synchronization, but if you implement `IProgress<T>` yourself, ensure thread safety.

5. **Combine with cancellation support**: Long-running operations that report progress should typically also support cancellation.

## Creating a Custom Progress Reporter

Sometimes you might need to implement your own progress reporting mechanism. Here's a custom implementation of `IProgress<T>`:

```csharp
public class ThrottledProgress<T> : IProgress<T>
{
    private readonly Action<T> _handler;
    private readonly int _intervalMs;
    private readonly SynchronizationContext _synchronizationContext;
    private T _latestValue;
    private DateTime _lastReportTime = DateTime.MinValue;

    public ThrottledProgress(Action<T> handler, int intervalMs = 100)
    {
        _handler = handler ?? throw new ArgumentNullException(nameof(handler));
        _intervalMs = intervalMs;
        _synchronizationContext = SynchronizationContext.Current;
    }

    public void Report(T value)
    {
        _latestValue = value;
        var now = DateTime.Now;
        
        // If enough time has passed since the last report, update immediately
        if ((now - _lastReportTime).TotalMilliseconds >= _intervalMs)
        {
            _lastReportTime = now;
            ReportCore(value);
        }
    }

    private void ReportCore(T value)
    {
        if (_synchronizationContext != null)
        {
            _synchronizationContext.Post(_ => _handler(value), null);
        }
        else
        {
            _handler(value);
        }
    }
}
```

This implementation throttles progress updates to avoid overwhelming the UI thread with too many updates.

## Summary

Progress reporting is a valuable technique in asynchronous programming that enhances user experience by providing feedback during long-running operations. In .NET, the `IProgress<T>` interface and `Progress<T>` class offer a standardized way to implement progress reporting that works seamlessly with the Task-based Asynchronous Pattern.

Key points covered:
- Using the `IProgress<T>` interface for progress reporting
- Implementing progress reporting with the `Progress<T>` class
- Reporting both simple percentage values and complex progress data
- Combining progress reporting with cancellation support
- Best practices and custom implementations

With these techniques, you can create responsive applications that keep users informed about the status of long-running operations, greatly improving the overall user experience.

## Additional Resources

- [Microsoft Docs: `IProgress<T>` Interface](https://docs.microsoft.com/en-us/dotnet/api/system.iprogress-1)
- [Microsoft Docs: `Progress<T>` Class](https://docs.microsoft.com/en-us/dotnet/api/system.progress-1)
- [Stephen Cleary's Blog: Progress Reporting](https://blog.stephencleary.com/2012/02/reporting-progress-from-async-tasks.html)

## Exercises

1. Create a console application that simulates downloading multiple files with progress reporting for each file.

2. Implement a WPF or Windows Forms application with a progress bar that shows the status of a simulated database backup operation.

3. Extend the ThrottledProgress example to include a method to force an immediate update regardless of the throttle interval.

4. Create a progress reporting system that tracks both determinate progress (with a known end point) and indeterminate activity (where you know an operation is ongoing but not how much is complete).

5. Implement a file copy utility that reports progress including current transfer speed and estimated time remaining.