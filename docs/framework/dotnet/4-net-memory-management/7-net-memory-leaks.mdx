---
title: ".NET Memory Leaks"
description: "Understanding memory leaks in .NET applications, their causes, detection methods, and effective prevention techniques."

---

# .NET Memory Leaks

## Introduction

Memory leaks in .NET applications occur when allocated memory that is no longer needed isn't released back to the operating system. Despite .NET's automatic garbage collection system, memory leaks can still happen and gradually degrade application performance or even lead to crashes.

In this article, we'll explore what memory leaks are in the context of .NET, how they happen despite having a garbage collector, how to detect them, and most importantly, how to fix and prevent them.

## What is a Memory Leak in .NET?

In traditional unmanaged programming languages like C and C++, memory leaks happen when allocated memory isn't explicitly deallocated. .NET, however, has a garbage collector (GC) that automatically reclaims memory that's no longer in use.

So how can memory leaks still occur in .NET?

A .NET memory leak happens when objects remain referenced even though your application no longer needs them. The garbage collector can only reclaim objects that aren't referenced anymore. If an object is still referenced somewhere in your application, the GC will consider it "alive" and won't collect it.

## Common Causes of Memory Leaks in .NET

### 1. Event Handlers Not Properly Unsubscribed

This is one of the most common causes of memory leaks in .NET applications:

```csharp
public class LeakyClass
{
    public LeakyClass()
    {
        // Subscribing to a static event
        Application.Idle += OnApplicationIdle;
    }

    private void OnApplicationIdle(object sender, EventArgs e)
    {
        // Process idle event
    }

    // Missing: Should have a way to unsubscribe from the event
}
```

In this example, if we create and later discard many instances of `LeakyClass`, they won't be garbage collected because the static `Application.Idle` event still holds references to them.

### 2. Static Collections or References

Static variables remain alive for the duration of the application:

```csharp
public class CacheService
{
    // This collection will never be garbage collected
    private static readonly List<LargeObject> _cache = new List<LargeObject>();
    
    public void AddToCache(LargeObject obj)
    {
        _cache.Add(obj); // Objects are added but never removed
    }
}
```

### 3. Long-lived Objects Referencing Short-lived Objects

```csharp
public class DataProcessor
{
    private List<ProcessingResult> _allResults = new List<ProcessingResult>();
    
    public void ProcessBatch(List<DataItem> items)
    {
        foreach (var item in items)
        {
            var result = ProcessItem(item);
            _allResults.Add(result); // Results keep accumulating
        }
    }
    
    // Missing: Should have a way to clear old results
}
```

### 4. Disposable Objects Not Being Disposed

```csharp
public void ProcessFile(string filename)
{
    // FileStream implements IDisposable and should be disposed
    FileStream fs = new FileStream(filename, FileMode.Open);
    // Read data from file
    // Missing: fs.Dispose() or using statement
}
```

## Detecting Memory Leaks

### Visual Studio Memory Profiler

Visual Studio includes tools to help detect memory leaks:

1. Open your project in Visual Studio
2. Click on Debug > Performance Profiler
3. Select Memory Usage and start profiling
4. Perform actions in your application that might cause memory leaks
5. Take snapshots before and after these actions
6. Compare snapshots to identify objects that aren't being garbage collected

### Using Memory Profilers

Third-party tools like JetBrains dotMemory, ANTS Memory Profiler, and SciTech .NET Memory Profiler can provide more detailed analysis.

### Manual Leak Detection

You can also add basic monitoring to your application:

```csharp
public class MemoryMonitor
{
    public static void LogMemoryUsage(string checkpoint)
    {
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        
        long memory = GC.GetTotalMemory(true);
        Console.WriteLine($"Memory at {checkpoint}: {memory / 1024 / 1024} MB");
    }
}

// Usage
MemoryMonitor.LogMemoryUsage("Before operation");
// Perform operation
MemoryMonitor.LogMemoryUsage("After operation");
```

## Fixing Common Memory Leaks

### 1. Properly Unsubscribe from Events

```csharp
public class NonLeakyClass : IDisposable
{
    public NonLeakyClass()
    {
        Application.Idle += OnApplicationIdle;
    }
    
    private void OnApplicationIdle(object sender, EventArgs e)
    {
        // Process idle event
    }
    
    public void Dispose()
    {
        // Unsubscribe when done
        Application.Idle -= OnApplicationIdle;
    }
}

// Usage:
using (var obj = new NonLeakyClass())
{
    // Use obj here
} // Dispose is automatically called
```

### 2. Use Weak References

When you need to keep a reference that shouldn't prevent garbage collection:

```csharp
public class CacheWithWeakReferences
{
    private Dictionary<string, WeakReference<LargeObject>> _cache = 
        new Dictionary<string, WeakReference<LargeObject>>();
    
    public void Add(string key, LargeObject obj)
    {
        _cache[key] = new WeakReference<LargeObject>(obj);
    }
    
    public bool TryGetValue(string key, out LargeObject obj)
    {
        obj = null;
        if (_cache.TryGetValue(key, out var weakRef))
        {
            return weakRef.TryGetTarget(out obj);
        }
        return false;
    }
}
```

### 3. Implement the IDisposable Pattern

For classes that manage resources:

```csharp
public class ResourceManager : IDisposable
{
    private bool _disposed = false;
    private FileStream _fileStream;
    
    public ResourceManager(string filename)
    {
        _fileStream = new FileStream(filename, FileMode.Open);
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Dispose managed resources
                _fileStream?.Dispose();
            }
            
            // Free unmanaged resources
            _fileStream = null;
            _disposed = true;
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    ~ResourceManager()
    {
        Dispose(false);
    }
}

// Usage:
using (var rm = new ResourceManager("data.txt"))
{
    // Use resource manager
} // Automatically disposed
```

### 4. Use Memory-Efficient Collections

For large or long-lived collections, consider specialized collections:

```csharp
// Instead of keeping large strings in memory
public class LargeStringCache
{
    // ConditionalWeakTable holds weak references to its keys
    private ConditionalWeakTable<object, string> _cache = 
        new ConditionalWeakTable<object, string>();
    
    public void Add(object key, string largeText)
    {
        _cache.Add(key, largeText);
    }
    
    public bool TryGetValue(object key, out string value)
    {
        return _cache.TryGetValue(key, out value);
    }
}
```

## Real-World Example: Web API Service with Memory Leak

Let's examine a realistic example of a web API service with a memory leak and how to fix it:

### Problem Version

```csharp
public class DataService
{
    // Static cache that grows unbounded
    private static readonly Dictionary<string, CustomerData> _customerCache 
        = new Dictionary<string, CustomerData>();
        
    // Event that service subscribes to but never unsubscribes
    public event EventHandler<LogEventArgs> OnLogEvent;
    
    public async Task<CustomerData> GetCustomerAsync(string id)
    {
        if (_customerCache.TryGetValue(id, out var cachedData))
        {
            return cachedData;
        }
        
        // Get customer from database
        CustomerData data = await LoadFromDatabaseAsync(id);
        
        // Cache it forever
        _customerCache[id] = data;
        
        OnLogEvent?.Invoke(this, new LogEventArgs { Message = $"Loaded customer: {id}" });
        
        return data;
    }
    
    private async Task<CustomerData> LoadFromDatabaseAsync(string id)
    {
        // Imagine database access code here
        await Task.Delay(100); // Simulate DB call
        return new CustomerData { Id = id, Name = $"Customer {id}" };
    }
}

// Usage in controller
public class CustomerController : ControllerBase
{
    private static DataService _dataService = new DataService();
    private Logger _logger;
    
    public CustomerController(Logger logger)
    {
        _logger = logger;
        // Subscribe to event but never unsubscribe
        _dataService.OnLogEvent += (s, e) => _logger.Log(e.Message);
    }
    
    [HttpGet("customer/{id}")]
    public async Task<IActionResult> GetCustomer(string id)
    {
        var data = await _dataService.GetCustomerAsync(id);
        return Ok(data);
    }
}
```

### Fixed Version

```csharp
public class ImprovedDataService : IDisposable
{
    // Use a memory-bounded cache
    private readonly MemoryCache _customerCache;
    // Use a non-static field
    private readonly EventHandler<LogEventArgs> _logHandler;
    
    public ImprovedDataService(ILogger logger)
    {
        _customerCache = new MemoryCache(new MemoryCacheOptions {
            SizeLimit = 1000 // Limit cache size
        });
        
        _logHandler = (s, e) => logger.Log(e.Message);
        OnLogEvent += _logHandler; // Store reference to handler
    }
    
    // Event with proper management
    public event EventHandler<LogEventArgs> OnLogEvent;
    
    public async Task<CustomerData> GetCustomerAsync(string id)
    {
        if (_customerCache.TryGetValue(id, out CustomerData cachedData))
        {
            return cachedData;
        }
        
        // Get customer from database
        CustomerData data = await LoadFromDatabaseAsync(id);
        
        // Cache with sliding expiration and size tracking
        var cacheOptions = new MemoryCacheEntryOptions()
            .SetSlidingExpiration(TimeSpan.FromMinutes(10))
            .SetSize(1); // Each entry counts as 1 toward SizeLimit
            
        _customerCache.Set(id, data, cacheOptions);
        
        OnLogEvent?.Invoke(this, new LogEventArgs { Message = $"Loaded customer: {id}" });
        
        return data;
    }
    
    private async Task<CustomerData> LoadFromDatabaseAsync(string id)
    {
        // Database access code here
        await Task.Delay(100);
        return new CustomerData { Id = id, Name = $"Customer {id}" };
    }
    
    public void Dispose()
    {
        // Proper cleanup
        OnLogEvent -= _logHandler;
        _customerCache.Dispose();
    }
}

// Usage in controller
public class ImprovedCustomerController : ControllerBase
{
    private readonly ImprovedDataService _dataService;
    
    public ImprovedCustomerController(ImprovedDataService dataService)
    {
        _dataService = dataService;
        // No need to subscribe/unsubscribe to events here
    }
    
    [HttpGet("customer/{id}")]
    public async Task<IActionResult> GetCustomer(string id)
    {
        var data = await _dataService.GetCustomerAsync(id);
        return Ok(data);
    }
}

// Register as scoped in DI container
services.AddScoped<ImprovedDataService>();
```

### Improvements Made

1. Replaced unbounded static cache with bounded `MemoryCache`
2. Implemented proper `IDisposable` pattern
3. Used proper event handler management
4. Managed service lifetime through dependency injection
5. Added cache entry expiration

## Best Practices for Preventing Memory Leaks

1. **Always unsubscribe from events** when they are no longer needed
2. **Implement and use the `IDisposable` pattern** for all classes that manage resources
3. **Avoid static collections** that grow unbounded
4. **Be careful with captured variables in closures**, especially in long-running operations
5. **Use weak references** when appropriate
6. **Limit the lifetime and size of caches**
7. **Watch for large object retention** in async methods
8. **Use memory profiling tools regularly** during development

## Summary

Memory leaks in .NET occur when objects remain referenced but are no longer needed. Despite .NET's garbage collector, memory leaks can happen through event handlers not being unsubscribed, static collections growing unbounded, improper resource disposal, and capturing variables in closures.

By following best practices, implementing proper resource management, and regularly profiling your application, you can prevent memory leaks and ensure your .NET applications run efficiently and reliably over long periods.

## Additional Resources

- [Microsoft Docs: Cleaning Up Unmanaged Resources](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/unmanaged)
- [Understanding Weak References in .NET](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/weak-references)
- [.NET Memory Management and Garbage Collection](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)

## Exercises

1. Use a memory profiler to analyze a sample application and identify potential memory leaks.
2. Refactor a class that uses events to properly implement the IDisposable pattern.
3. Create a custom cache implementation that uses weak references to prevent memory leaks.
4. Analyze how closures in C# can cause memory leaks and implement a solution to prevent them.
5. Compare the memory usage of an application before and after fixing memory leaks using the MemoryMonitor class from this article.