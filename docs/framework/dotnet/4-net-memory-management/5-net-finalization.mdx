---
title: ".NET Finalization"
description: "Learn about finalization in .NET, how the garbage collector manages object cleanup, and best practices for deterministic resource management."

---

# .NET Finalization

## Introduction

Finalization is an important concept in .NET memory management that provides a safety net for cleaning up unmanaged resources when objects are garbage collected. Unlike managed memory which is automatically handled by the .NET garbage collector, unmanaged resources (like file handles, database connections, or window handles) require explicit cleanup to avoid resource leaks.

In this article, we'll explore how finalization works in .NET, its relationship with the garbage collector, best practices, and how to implement proper cleanup strategies for your objects.

## What is Finalization?

Finalization is a process in .NET that gives objects a "last chance" to clean up unmanaged resources before they're permanently removed from memory. When the garbage collector determines an object is no longer reachable (i.e., it's eligible for collection), it can run the object's finalizer method, if one exists, before reclaiming the memory.

A finalizer (also called a destructor in C#) is a special method that gets called by the garbage collector during the finalization process.

## How to Implement a Finalizer in C#

In C#, you can implement a finalizer using syntax that looks similar to a constructor but with a tilde (`~`) prefix:

```csharp
public class FileWrapper
{
    private IntPtr _fileHandle; // Unmanaged resource
    
    public FileWrapper(string filePath)
    {
        // Open the file and store the handle
        _fileHandle = OpenFile(filePath);
    }
    
    // Finalizer
    ~FileWrapper()
    {
        // Clean up unmanaged resources
        if (_fileHandle != IntPtr.Zero)
        {
            CloseFile(_fileHandle);
            _fileHandle = IntPtr.Zero;
        }
    }
    
    // Simulated methods for demonstration
    private IntPtr OpenFile(string filePath) => IntPtr.Zero;
    private void CloseFile(IntPtr handle) { }
}
```

## The Finalization Process

The .NET finalization process involves several steps:

1. When an object with a finalizer is created, the .NET runtime registers it in a special finalization queue
2. When the object becomes unreachable, the garbage collector marks it for collection
3. If the object has a finalizer, it's moved to a finalization queue (also called F-Reachable queue)
4. A dedicated finalization thread executes the finalizers for objects in this queue
5. After finalization, the object is marked as finalized and becomes eligible for collection in the next garbage collection cycle

## Finalization vs. Deterministic Cleanup

While finalization provides a safety net, it has several limitations:

1. **Non-deterministic timing**: You cannot predict when finalizers will run
2. **Performance overhead**: Objects with finalizers require at least two garbage collection cycles to be fully collected
3. **No guarantee of execution**: In some cases (like application crashes), finalizers may never run

Because of these limitations, .NET provides the `IDisposable` interface for deterministic cleanup:

```csharp
public class FileWrapper : IDisposable
{
    private IntPtr _fileHandle;
    private bool _disposed = false;
    
    public FileWrapper(string filePath)
    {
        _fileHandle = OpenFile(filePath);
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Prevent finalization since we've already cleaned up
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Clean up managed resources
            }
            
            // Clean up unmanaged resources
            if (_fileHandle != IntPtr.Zero)
            {
                CloseFile(_fileHandle);
                _fileHandle = IntPtr.Zero;
            }
            
            _disposed = true;
        }
    }
    
    ~FileWrapper()
    {
        Dispose(false);
    }
    
    // Simulated methods for demonstration
    private IntPtr OpenFile(string filePath) => IntPtr.Zero;
    private void CloseFile(IntPtr handle) { }
}
```

## Generations and Finalization

The .NET garbage collector organizes objects into generations (0, 1, and 2). Objects with finalizers have special handling:

1. Finalizable objects are more expensive to collect
2. They usually live longer than non-finalizable objects
3. They're typically promoted to higher generations before being collected

This can lead to unexpected memory usage patterns if overused.

## The Dispose Pattern

The recommended approach for handling resource cleanup in .NET is the Dispose Pattern, which combines deterministic cleanup via `IDisposable` with a finalizer as a safety net:

```csharp
public class ResourceWrapper : IDisposable
{
    private IntPtr _nativeResource;
    private ManagedResource _managedResource;
    private bool _disposed = false;
    
    public ResourceWrapper()
    {
        _nativeResource = AllocateNativeResource();
        _managedResource = new ManagedResource();
    }
    
    // Public implementation of Dispose pattern
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    // Protected implementation of Dispose pattern
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Free managed resources
                if (_managedResource != null)
                {
                    _managedResource.Dispose();
                    _managedResource = null;
                }
            }
            
            // Free unmanaged resources
            if (_nativeResource != IntPtr.Zero)
            {
                FreeNativeResource(_nativeResource);
                _nativeResource = IntPtr.Zero;
            }
            
            _disposed = true;
        }
    }
    
    // Finalizer
    ~ResourceWrapper()
    {
        Dispose(false);
    }
    
    // Simulated methods and class for demonstration
    private IntPtr AllocateNativeResource() => IntPtr.Zero;
    private void FreeNativeResource(IntPtr handle) { }
    
    private class ManagedResource : IDisposable
    {
        public void Dispose() { }
    }
}
```

## Practical Example: Managing Database Connections

Let's see how finalization and the Dispose pattern work in a real-world scenario with database connections:

```csharp
public class DatabaseManager : IDisposable
{
    private SqlConnection _connection;
    private bool _disposed = false;
    
    public DatabaseManager(string connectionString)
    {
        _connection = new SqlConnection(connectionString);
        _connection.Open();
    }
    
    public void ExecuteQuery(string query)
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(DatabaseManager));
            
        using (SqlCommand command = new SqlCommand(query, _connection))
        {
            using (SqlDataReader reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    // Process results
                }
            }
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                // Clean up managed resources
                if (_connection != null)
                {
                    _connection.Close();
                    _connection.Dispose();
                    _connection = null;
                }
            }
            
            _disposed = true;
        }
    }
    
    ~DatabaseManager()
    {
        Dispose(false);
    }
}
```

Using this class with the `using` statement ensures proper cleanup:

```csharp
public void ProcessData()
{
    using (var dbManager = new DatabaseManager("connection_string_here"))
    {
        dbManager.ExecuteQuery("SELECT * FROM Users");
    } // dbManager.Dispose() is automatically called here
}
```

## Best Practices for Finalization

1. **Use finalizers sparingly**: Only implement them when you need to clean up unmanaged resources
2. **Implement the Dispose pattern**: Combine `IDisposable` with a finalizer as a safety net
3. **Call `GC.SuppressFinalize`**: When `Dispose()` is called, prevent unnecessary finalization
4. **Keep finalizers simple**: Avoid complex operations that might throw exceptions
5. **Don't access other finalizable objects**: They might have already been finalized
6. **Properly handle disposed state**: Check if your object is already disposed before operations
7. **Use `SafeHandle` and `CriticalFinalizerObject`**: For more robust handling of unmanaged resources

## Common Issues with Finalization

### Finalizer Memory Leaks

If finalizers reference other objects, they can inadvertently extend the lifetime of those objects:

```csharp
// Problematic code - can cause memory leaks
public class Logger
{
    // Singleton instance
    public static Logger Instance { get; } = new Logger();
    
    private List<string> _logEntries = new List<string>();
    
    public void Log(string entry)
    {
        _logEntries.Add(entry);
    }
}

public class ResourceUser
{
    private IntPtr _handle;
    
    ~ResourceUser()
    {
        // This keeps Logger.Instance alive until all ResourceUser instances are finalized
        Logger.Instance.Log($"ResourceUser with handle {_handle} was finalized");
        CloseHandle(_handle);
    }
    
    private void CloseHandle(IntPtr handle) { }
}
```

### Finalization Order

The order of finalization is not guaranteed, which can lead to issues if finalizers depend on other objects:

```csharp
public class Parent
{
    private Child _child = new Child();
    
    ~Parent()
    {
        // The Child object might already be finalized
        // Accessing it here could cause problems
        _child.DoSomething(); // Danger!
    }
}

public class Child
{
    public void DoSomething() { }
    
    ~Child()
    {
        // Finalization code
    }
}
```

## Advanced Finalization Topics

### SafeHandle

`SafeHandle` is a better alternative to finalizers for handling unmanaged resources:

```csharp
public class SafeFileHandle : SafeHandle
{
    public SafeFileHandle(IntPtr handle) : base(IntPtr.Zero, true)
    {
        SetHandle(handle);
    }
    
    protected override bool ReleaseHandle()
    {
        // Clean up the unmanaged resource
        if (handle != IntPtr.Zero)
        {
            CloseFile(handle);
            return true;
        }
        return false;
    }
    
    public override bool IsInvalid => handle == IntPtr.Zero;
    
    // Simulated method for demonstration
    private bool CloseFile(IntPtr handle) => true;
}

public class BetterFileWrapper : IDisposable
{
    private SafeFileHandle _handle;
    
    public BetterFileWrapper(string filePath)
    {
        IntPtr rawHandle = OpenFile(filePath);
        _handle = new SafeFileHandle(rawHandle);
    }
    
    public void Dispose()
    {
        _handle?.Dispose();
    }
    
    // Simulated method for demonstration
    private IntPtr OpenFile(string filePath) => IntPtr.Zero;
}
```

### CriticalFinalizerObject

For resources that absolutely must be cleaned up, you can derive from `CriticalFinalizerObject`:

```csharp
public class CriticalResource : CriticalFinalizerObject, IDisposable
{
    private IntPtr _handle;
    private bool _disposed = false;
    
    public CriticalResource()
    {
        _handle = AllocateCriticalResource();
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            // Clean up unmanaged resources
            if (_handle != IntPtr.Zero)
            {
                ReleaseCriticalResource(_handle);
                _handle = IntPtr.Zero;
            }
            
            _disposed = true;
        }
    }
    
    ~CriticalResource()
    {
        Dispose(false);
    }
    
    // Simulated methods for demonstration
    private IntPtr AllocateCriticalResource() => IntPtr.Zero;
    private void ReleaseCriticalResource(IntPtr handle) { }
}
```

## Summary

Finalization in .NET provides a safety mechanism for cleaning up unmanaged resources when deterministic cleanup isn't possible. However, it comes with limitations such as non-deterministic timing and performance overhead.

Key takeaways:

1. Use finalizers only when necessary for unmanaged resource cleanup
2. Implement the Dispose Pattern for deterministic cleanup
3. Use `using` statements or try-finally blocks to ensure `Dispose()` is called
4. Call `GC.SuppressFinalize(this)` in your `Dispose()` method to improve performance
5. Consider using `SafeHandle` and `CriticalFinalizerObject` for robust resource management

Understanding finalization is crucial for writing reliable .NET applications that properly manage resources and avoid memory leaks.

## Additional Resources

- [Microsoft Docs: Cleaning Up Unmanaged Resources](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/unmanaged)
- [Microsoft Docs: Implement a Dispose Method](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose)
- [SafeHandle Class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.safehandle)
- [CriticalFinalizerObject Class](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.constrainedexecution.criticalfinalizerobject)

## Exercises

1. Create a class that manages an unmanaged resource and implements both a finalizer and the `IDisposable` interface.
2. Write code that demonstrates how to use `SafeHandle` to wrap an unmanaged resource.
3. Create a program that measures the performance difference between objects with and without finalizers.
4. Implement a resource pool that properly manages the lifetime of reusable resources.
5. Create a class hierarchy with base and derived classes that properly implement the Dispose pattern.