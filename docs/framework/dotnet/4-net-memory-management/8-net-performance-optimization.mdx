---
title: .NET Performance Optimization
description: Learn essential techniques to optimize performance in .NET applications, from memory management to code execution efficiency.

---

# .NET Performance Optimization

## Introduction

Performance optimization is a critical skill for .NET developers who want to build efficient, responsive, and scalable applications. Even with the modern hardware capabilities and the continuous improvements to the .NET framework, poorly optimized code can still lead to sluggish applications, excessive memory usage, and frustrated users.

In this guide, we'll explore various techniques to optimize .NET applications, focusing particularly on memory management aspects. Whether you're building web applications, desktop software, or mobile apps with .NET MAUI, these optimization principles will help you write more efficient code.

## Why Performance Optimization Matters

Before diving into specific techniques, let's understand why performance optimization is important:

1. **Enhanced User Experience**: Fast applications provide a better user experience
2. **Resource Efficiency**: Optimized code consumes fewer system resources
3. **Cost Savings**: In cloud environments, efficient applications can significantly reduce operational costs
4. **Scalability**: Well-optimized applications can handle more users with the same hardware

## Memory Management Fundamentals

### Understanding the Garbage Collector

The .NET Garbage Collector (GC) manages memory automatically, but understanding how it works can help you write more efficient code.

```csharp
// Objects are allocated on the managed heap
var largeList = new List<string>(10000);

// When objects are no longer referenced, they become eligible for collection
largeList = null; // The original list can now be collected
```

The GC in .NET divides objects into generations (0, 1, and 2) based on their lifetimes. New objects start in generation 0, and if they survive a collection, they're promoted to generation 1, and so on.

### Value Types vs. Reference Types

Understanding the difference between value types and reference types is crucial for memory optimization:

```csharp
// Value types are stored on the stack
int number = 42; // Stored directly on the stack

// Reference types are stored on the heap
string text = "Hello"; // Reference on stack, actual data on heap
```

Value types like `int`, `float`, `struct`, and `enum` are generally more memory-efficient for small data because they avoid heap allocations.

## Memory Optimization Techniques

### Use Object Pooling

Object pooling reduces garbage collection pressure by reusing objects instead of creating new ones:

```csharp
using Microsoft.Extensions.ObjectPool;

public class PoolExample
{
    private readonly ObjectPool<StringBuilder> _stringBuilderPool;
    
    public PoolExample()
    {
        var policy = new DefaultPooledObjectPolicy<StringBuilder>();
        _stringBuilderPool = new DefaultObjectPool<StringBuilder>(policy, 100);
    }
    
    public string BuildString()
    {
        // Get from pool
        StringBuilder sb = _stringBuilderPool.Get();
        try
        {
            sb.Append("Hello, ");
            sb.Append("World!");
            return sb.ToString();
        }
        finally
        {
            // Important: return to pool when done
            sb.Clear(); // Reset the StringBuilder
            _stringBuilderPool.Return(sb);
        }
    }
}
```

### Minimize Allocations in Loops

Avoid unnecessary allocations in loops, especially for high-frequency operations:

```csharp
// Inefficient: creates a new string in each iteration
void ProcessLogsInefficiently(string[] logs)
{
    for (int i = 0; i < logs.Length; i++)
    {
        string processedLog = "Processed: " + logs[i]; // New string allocation
        Console.WriteLine(processedLog);
    }
}

// Optimized: reuses the StringBuilder
void ProcessLogsEfficiently(string[] logs)
{
    StringBuilder sb = new StringBuilder(100);
    for (int i = 0; i < logs.Length; i++)
    {
        sb.Clear();
        sb.Append("Processed: ");
        sb.Append(logs[i]);
        Console.WriteLine(sb.ToString());
    }
}
```

### Use `Span<T>` for Memory-Efficient Operations

`Span<T>` is a powerful feature for working with memory without allocations:

```csharp
// Traditional string operations create allocations
void ProcessStringTraditional(string input)
{
    string first = input.Substring(0, 5); 
    string second = input.Substring(5, 5);
    
    Console.WriteLine($"First: {first}, Second: {second}");
}

// Span-based approach avoids allocations
void ProcessStringWithSpan(string input)
{
    ReadOnlySpan<char> span = input.AsSpan();
    ReadOnlySpan<char> first = span.Slice(0, 5);
    ReadOnlySpan<char> second = span.Slice(5, 5);
    
    Console.WriteLine($"First: {first.ToString()}, Second: {second.ToString()}");
}
```

### Consider Struct Usage for Small Data

For small data structures, consider using structs instead of classes:

```csharp
// As a class (reference type)
public class PointClass
{
    public int X { get; set; }
    public int Y { get; set; }
}

// As a struct (value type) - more memory efficient for small data
public struct PointStruct
{
    public int X { get; set; }
    public int Y { get; set; }
}

void UsePoints()
{
    // 1000 class instances create 1000 heap allocations
    PointClass[] pointClasses = new PointClass[1000];
    for (int i = 0; i < 1000; i++)
    {
        pointClasses[i] = new PointClass { X = i, Y = i };
    }
    
    // 1000 struct instances create just 1 heap allocation (for the array)
    PointStruct[] pointStructs = new PointStruct[1000];
    for (int i = 0; i < 1000; i++)
    {
        pointStructs[i] = new PointStruct { X = i, Y = i };
    }
}
```

## Execution Performance Optimization

### Use Async/Await Properly

Proper use of async/await can significantly improve application responsiveness:

```csharp
// Inefficient use of async/await
public async Task<string> GetDataInefficiently()
{
    // Unnecessarily blocking a thread
    var result = await Task.Run(() => 
    {
        // CPU-bound work that doesn't need to be in Task.Run
        return ProcessData("sample");
    }).ConfigureAwait(false);
    
    return result;
}

// Efficient use of async/await
public async Task<string> GetDataEfficiently()
{
    // Only use Task.Run for CPU-bound operations when needed
    string result = ProcessData("sample"); // Just do the work directly
    
    // For truly I/O-bound operations, use await without Task.Run
    if (result == "needsMoreData")
    {
        result = await FetchFromDatabaseAsync().ConfigureAwait(false);
    }
    
    return result;
}
```

### LINQ Optimization

LINQ is convenient but can sometimes introduce performance overhead:

```csharp
void LinqPerformanceExample(List<int> numbers)
{
    // Less efficient: Creates multiple enumerations and intermediate collections
    var result1 = numbers
        .Where(n => n > 10)
        .Select(n => n * 2)
        .OrderBy(n => n)
        .ToList();
    
    // More efficient: Defers execution and minimizes allocations
    var result2 = numbers
        .Where(n => n > 10)
        .Select(n => n * 2)
        .OrderBy(n => n)
        .ToArray(); // Single allocation for the final result
    
    // Most efficient for this specific case: Do it manually if performance is critical
    List<int> result3 = new List<int>();
    foreach (var number in numbers)
    {
        if (number > 10)
        {
            result3.Add(number * 2);
        }
    }
    result3.Sort();
}
```

### Consider Using ArrayPool for Temporary Arrays

For operations that need temporary arrays, consider using `ArrayPool<T>`:

```csharp
using System.Buffers;

void ProcessLargeDataSet(byte[] sourceData)
{
    // Without ArrayPool - allocates a new 8KB buffer on each call
    void WithoutArrayPool()
    {
        byte[] buffer = new byte[8192]; // 8KB allocation
        // Use buffer for temporary processing
        for (int i = 0; i < buffer.Length; i++)
        {
            buffer[i] = (byte)(sourceData[i % sourceData.Length] * 2);
        }
        ProcessBuffer(buffer);
    }
    
    // With ArrayPool - reuses buffers
    void WithArrayPool()
    {
        byte[] buffer = ArrayPool<byte>.Shared.Rent(8192);
        try
        {
            // Use buffer for temporary processing
            for (int i = 0; i < buffer.Length; i++)
            {
                buffer[i] = (byte)(sourceData[i % sourceData.Length] * 2);
            }
            ProcessBuffer(buffer);
        }
        finally
        {
            // Important: Return the array to the pool when done
            ArrayPool<byte>.Shared.Return(buffer);
        }
    }
}

void ProcessBuffer(byte[] buffer)
{
    // Process the buffer...
}
```

## Practical Performance Optimization Example

Let's look at a practical example of optimizing a method that processes a large list of user records:

```csharp
public class User
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
    public DateTime LastLogin { get; set; }
}

// Original implementation - inefficient
public List<string> GetActiveUserEmailsInefficient(List<User> users)
{
    // This method creates multiple intermediate collections
    return users
        .Where(u => (DateTime.Now - u.LastLogin).TotalDays < 30)
        .OrderBy(u => u.Name)
        .Select(u => u.Email)
        .ToList();
}

// Optimized implementation
public List<string> GetActiveUserEmailsEfficient(List<User> users)
{
    // Pre-allocate capacity for better performance
    List<string> activeEmails = new List<string>(users.Count / 2); // Estimate capacity
    
    DateTime cutoff = DateTime.Now.AddDays(-30);
    
    // Process in one pass without intermediate collections
    foreach (var user in users)
    {
        if (user.LastLogin >= cutoff)
        {
            activeEmails.Add(user.Email);
        }
    }
    
    // Only sort at the end
    activeEmails.Sort();
    
    return activeEmails;
}
```

## Measuring Performance

To effectively optimize your code, you need to measure its performance:

### Using Stopwatch for Simple Profiling

```csharp
using System.Diagnostics;

void MeasurePerformance()
{
    var users = GenerateTestUsers(10000);
    
    Stopwatch sw = Stopwatch.StartNew();
    var result1 = GetActiveUserEmailsInefficient(users);
    sw.Stop();
    Console.WriteLine($"Inefficient method: {sw.ElapsedMilliseconds}ms");
    
    sw.Restart();
    var result2 = GetActiveUserEmailsEfficient(users);
    sw.Stop();
    Console.WriteLine($"Efficient method: {sw.ElapsedMilliseconds}ms");
}

List<User> GenerateTestUsers(int count)
{
    var random = new Random(42);
    var users = new List<User>(count);
    
    for (int i = 0; i < count; i++)
    {
        users.Add(new User
        {
            Id = i,
            Name = $"User{i}",
            Email = $"user{i}@example.com",
            LastLogin = DateTime.Now.AddDays(-random.Next(0, 60))
        });
    }
    
    return users;
}
```

### Using BenchmarkDotNet for Detailed Performance Analysis

For more detailed and reliable performance measurements, consider using BenchmarkDotNet:

```csharp
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Running;

public class UserProcessingBenchmark
{
    private List<User> _users;
    
    [GlobalSetup]
    public void Setup()
    {
        _users = GenerateTestUsers(10000);
    }
    
    [Benchmark]
    public List<string> Inefficient() => GetActiveUserEmailsInefficient(_users);
    
    [Benchmark]
    public List<string> Efficient() => GetActiveUserEmailsEfficient(_users);
}

// In Program.cs
BenchmarkRunner.Run<UserProcessingBenchmark>();
```

## Common Memory Issues to Watch For

### Memory Leaks

Even in a managed environment like .NET, memory leaks can occur:

```csharp
public class MemoryLeakExample
{
    // Potential memory leak: events prevent garbage collection
    public event EventHandler SomeEvent;
    
    // Proper cleanup with event unsubscription
    public void Subscribe(object subscriber)
    {
        SomeEvent += HandleEvent;
    }
    
    public void Unsubscribe(object subscriber)
    {
        // Always unsubscribe from events when done
        SomeEvent -= HandleEvent;
    }
    
    private void HandleEvent(object sender, EventArgs e) { }
}
```

### Large Object Heap (LOH) Issues

Objects larger than 85,000 bytes are allocated on the Large Object Heap, which is collected less frequently:

```csharp
void LargeObjectHeapExample()
{
    // This large array goes on the LOH
    byte[] largeArray = new byte[100_000]; // Over 85KB, goes on LOH
    
    // For temporary large arrays, consider array pooling
    byte[] pooledArray = ArrayPool<byte>.Shared.Rent(100_000);
    try
    {
        // Use pooledArray
    }
    finally
    {
        ArrayPool<byte>.Shared.Return(pooledArray);
    }
}
```

## Summary

Performance optimization in .NET is a broad and deep topic that requires understanding of both the language features and the underlying runtime behavior. In this guide, we've covered:

1. **Memory management fundamentals** in .NET
2. **Techniques to reduce allocations** and minimize garbage collection pressure
3. **Execution optimization** for faster code execution
4. **Practical examples** of refactoring code for better performance
5. **Tools and methods** to measure and analyze performance

Remember that performance optimization should be guided by measurements rather than assumptions. Always profile your application first to identify the true bottlenecks, and focus your optimization efforts where they'll have the most impact.

## Additional Resources

- [Microsoft Docs: Writing High-Performance .NET Code](https://docs.microsoft.com/en-us/dotnet/framework/performance/writing-large-responsive-apps)
- [BenchmarkDotNet](https://benchmarkdotnet.org/) - A powerful .NET library for benchmarking
- [.NET Memory Profiling Tools](https://docs.microsoft.com/en-us/visualstudio/profiling/memory-usage) - Visual Studio's memory profiling tools
- [Pro .NET Memory Management](https://prodotnetmemory.com/) - Book by Konrad Kokosa on .NET memory management

## Exercises

1. **Performance Comparison**: Implement and benchmark two versions of a method that processes a large collection - one using LINQ and another using direct loops.

2. **Memory Profiling**: Use a memory profiling tool to analyze a simple .NET application and identify any unexpected memory allocations.

3. **Object Pooling Implementation**: Create a custom object pool for a resource-intensive class in one of your applications.

4. **`Span<T>` Refactoring**: Take an existing method that does string parsing and refactor it to use `Span<T>` for better performance.

5. **Benchmark Analysis**: Use BenchmarkDotNet to compare the performance of different collection types (List, Array, Dictionary) for your specific use case.