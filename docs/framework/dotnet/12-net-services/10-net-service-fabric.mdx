---
title: .NET Service Fabric
description: Learn about Microsoft's .NET Service Fabric - a distributed systems platform that makes it easy to package, deploy, and manage scalable and reliable microservices.

---

# .NET Service Fabric

## Introduction

Service Fabric is Microsoft's distributed systems platform designed to package, deploy, and manage scalable and reliable microservices. It serves as a middleware platform that bridges the gap between applications and infrastructure, allowing developers to build cloud-native applications without worrying about the complexities of distributed computing.

In today's cloud-first world, applications need to be resilient, scalable, and easily maintainable. .NET Service Fabric provides a comprehensive solution to address these requirements, making it an essential tool in a modern developer's toolkit.

## What is .NET Service Fabric?

Service Fabric is a distributed systems platform that provides several key capabilities:

1. **Orchestration** - Manages deployment, scaling, and lifecycle of microservices
2. **State Management** - Offers reliable state management for stateful services
3. **Failover Management** - Handles service failures and ensures high availability
4. **Health Monitoring** - Provides comprehensive monitoring of application health
5. **Programming Models** - Supports various programming models and frameworks

Service Fabric powers many Microsoft services like Azure SQL Database, Cosmos DB, and Dynamics 365, processing millions of requests with high reliability.

## Core Concepts

### Microservices Architecture

Microservices are small, independent services that work together to form a complete application. Each microservice:

- Has a single responsibility
- Can be developed, deployed, and scaled independently
- Communicates with other services through well-defined APIs

Service Fabric provides the platform to build, deploy, and manage these microservices effectively.

### Service Types in Service Fabric

Service Fabric supports two main types of services:

1. **Stateless Services** - Services that don't maintain persistent state between requests
2. **Stateful Services** - Services that maintain state between requests, with the help of Service Fabric

## Getting Started with Service Fabric

### Prerequisites

To work with Service Fabric, you'll need:

- Visual Studio 2019 or newer
- Service Fabric SDK
- .NET Core 3.1 or newer

### Setting Up the Development Environment

1. Install the Service Fabric SDK from the [official Microsoft website](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started)
2. Install the Service Fabric tools for Visual Studio
3. Set up a local Service Fabric cluster for development and testing

### Creating Your First Service Fabric Application

Let's create a simple stateless service:

1. Open Visual Studio
2. Create a new project and select "Service Fabric Application"
3. Choose "Stateless Service" as the service type
4. Give your service a name (e.g., "HelloWorldService")

Your project structure should look something like this:

```
HelloWorldApplication/
├── HelloWorldService/
│   ├── Program.cs
│   ├── ServiceEventSource.cs
│   ├── HelloWorldService.cs
│   └── PackageRoot/
└── ApplicationPackageRoot/
    └── ApplicationManifest.xml
```

The main service implementation is in `HelloWorldService.cs`:

```csharp
using System;
using System.Collections.Generic;
using System.Fabric;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.ServiceFabric.Services.Communication.Runtime;
using Microsoft.ServiceFabric.Services.Runtime;

namespace HelloWorldService
{
    internal sealed class HelloWorldService : StatelessService
    {
        public HelloWorldService(StatelessServiceContext context)
            : base(context)
        { }

        protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
        {
            return new ServiceInstanceListener[0];
        }

        protected override async Task RunAsync(CancellationToken cancellationToken)
        {
            long iterations = 0;

            while (true)
            {
                cancellationToken.ThrowIfCancellationRequested();

                ServiceEventSource.Current.ServiceMessage(this.Context, 
                    "Hello World: {0}", ++iterations);

                await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
            }
        }
    }
}
```

This service writes a "Hello World" message to the Service Fabric logs every second.

## Adding a Web API to Service Fabric

Let's enhance our service to expose a REST API:

1. Add Microsoft.ServiceFabric.Services.Remoting NuGet package
2. Add Microsoft.AspNetCore packages
3. Update the service implementation:

```csharp
using System;
using System.Collections.Generic;
using System.Fabric;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.ServiceFabric.Services.Communication.AspNetCore;
using Microsoft.ServiceFabric.Services.Communication.Runtime;
using Microsoft.ServiceFabric.Services.Runtime;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;

namespace HelloWorldService
{
    internal sealed class HelloWorldService : StatelessService
    {
        public HelloWorldService(StatelessServiceContext context)
            : base(context)
        { }

        protected override IEnumerable<ServiceInstanceListener> CreateServiceInstanceListeners()
        {
            return new ServiceInstanceListener[]
            {
                new ServiceInstanceListener(serviceContext =>
                    new KestrelCommunicationListener(serviceContext, "ServiceEndpoint", (url, listener) =>
                    {
                        return new WebHostBuilder()
                            .UseKestrel()
                            .ConfigureServices(services => services
                                .AddSingleton<StatelessServiceContext>(serviceContext))
                            .UseContentRoot(Directory.GetCurrentDirectory())
                            .UseStartup<Startup>()
                            .UseServiceFabricIntegration(listener, ServiceFabricIntegrationOptions.None)
                            .UseUrls(url)
                            .Build();
                    }))
            };
        }

        protected override async Task RunAsync(CancellationToken cancellationToken)
        {
            long iterations = 0;

            while (true)
            {
                cancellationToken.ThrowIfCancellationRequested();

                ServiceEventSource.Current.ServiceMessage(this.Context, 
                    "Hello World: {0}", ++iterations);

                await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
            }
        }
    }
}
```

Add a `Startup.cs` file:

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

namespace HelloWorldService
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseRouting();
            app.UseAuthorization();
            
            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
    }
}
```

Add a Controller:

```csharp
using Microsoft.AspNetCore.Mvc;
using System;

namespace HelloWorldService.Controllers
{
    [ApiController]
    [Route("[controller]")]
    public class HelloController : ControllerBase
    {
        [HttpGet]
        public ActionResult<string> Get()
        {
            return $"Hello from Service Fabric! Time: {DateTime.Now}";
        }
    }
}
```

Now, when you deploy this service, you'll have a REST API endpoint at `/hello` that returns a greeting message.

## Creating a Stateful Service

Let's create a simple counter service that maintains state:

```csharp
using System;
using System.Collections.Generic;
using System.Fabric;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.ServiceFabric.Data;
using Microsoft.ServiceFabric.Data.Collections;
using Microsoft.ServiceFabric.Services.Communication.Runtime;
using Microsoft.ServiceFabric.Services.Runtime;

namespace CounterService
{
    internal sealed class CounterService : StatefulService
    {
        public CounterService(StatefulServiceContext context)
            : base(context)
        { }

        protected override IEnumerable<ServiceReplicaListener> CreateServiceReplicaListeners()
        {
            return new ServiceReplicaListener[0];
        }

        protected override async Task RunAsync(CancellationToken cancellationToken)
        {
            var counterDictionary = await this.StateManager
                .GetOrAddAsync<IReliableDictionary<string, long>>("CounterDictionary");

            while (true)
            {
                cancellationToken.ThrowIfCancellationRequested();

                using (var tx = this.StateManager.CreateTransaction())
                {
                    var result = await counterDictionary.TryGetValueAsync(tx, "counter");
                    long currentValue = result.HasValue ? result.Value : 0;
                    
                    await counterDictionary.SetAsync(tx, "counter", currentValue + 1);
                    await tx.CommitAsync();
                    
                    ServiceEventSource.Current.ServiceMessage(this.Context, 
                        "Current Counter Value: {0}", currentValue + 1);
                }

                await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
            }
        }
    }
}
```

This service maintains a counter that increases every second, with the state persisted using Service Fabric's reliable collections.

## Deploying Service Fabric Applications

### Local Deployment

1. Right-click on your Service Fabric application project in Visual Studio
2. Select "Debug" → "Start new instance"
3. Visual Studio will build, package, and deploy your application to the local Service Fabric cluster
4. Open Service Fabric Explorer at `http://localhost:19080` to view your deployed application

### Azure Deployment

To deploy to Azure:

1. Create a Service Fabric cluster in Azure Portal
2. Update your publish profile in Visual Studio
3. Right-click the project and select "Publish"
4. Follow the wizard to deploy to your Azure Service Fabric cluster

## Real-World Example: Order Processing System

Let's design a simplified order processing system using Service Fabric:

1. **Order Service (Stateful)** - Stores order information
2. **Inventory Service (Stateful)** - Maintains product inventory
3. **Payment Service (Stateless)** - Processes payments
4. **Notification Service (Stateless)** - Sends notifications to customers

### Order Service Implementation (Simplified)

```csharp
public class Order
{
    public string OrderId { get; set; }
    public string CustomerId { get; set; }
    public List<OrderItem> Items { get; set; }
    public string Status { get; set; }
}

public class OrderItem
{
    public string ProductId { get; set; }
    public int Quantity { get; set; }
}

// In the OrderService class
protected override async Task RunAsync(CancellationToken cancellationToken)
{
    var ordersDictionary = await this.StateManager
        .GetOrAddAsync<IReliableDictionary<string, Order>>("OrdersDictionary");

    // Process incoming orders
    // ...
}
```

### Service Communication

Services can communicate with each other using:

1. **Service Remoting** - For direct service-to-service communication
2. **RESTful APIs** - Using HTTP endpoints
3. **Service Fabric Reliable Queues** - For asynchronous communication

Example of service remoting:

```csharp
// Define the interface
public interface IInventoryService : IService
{
    Task<bool> CheckInventoryAsync(string productId, int quantity);
    Task UpdateInventoryAsync(string productId, int changeQuantity);
}

// Implement in the inventory service
internal sealed class InventoryService : StatefulService, IInventoryService
{
    // Implementation
    public async Task<bool> CheckInventoryAsync(string productId, int quantity)
    {
        var inventoryDict = await this.StateManager
            .GetOrAddAsync<IReliableDictionary<string, int>>("InventoryDictionary");
        
        using (var tx = this.StateManager.CreateTransaction())
        {
            var result = await inventoryDict.TryGetValueAsync(tx, productId);
            
            if (!result.HasValue || result.Value < quantity)
                return false;
                
            return true;
        }
    }
    
    // Other methods
}

// Call from order service
var inventoryServiceUri = new Uri("fabric:/MyApplication/InventoryService");
var inventoryService = ServiceProxy.Create<IInventoryService>(inventoryServiceUri);

bool isAvailable = await inventoryService.CheckInventoryAsync(productId, quantity);
```

## Service Fabric Best Practices

1. **Design for failure** - Assume services can and will fail
2. **Stateless when possible** - Use stateless services when state isn't required
3. **Partition stateful services** - Distribute state across partitions for scalability
4. **Monitor health** - Use Service Fabric health monitoring
5. **Version your services** - Plan for upgrades with proper versioning
6. **Limit service dependencies** - Minimize dependencies between services
7. **Use reliable collections** - For stateful services, use reliable collections

## Common Challenges and Solutions

| Challenge | Solution |
|-----------|----------|
| Service upgrade failures | Use rolling upgrades with health checks |
| Data partitioning | Create appropriate partitioning scheme based on expected data volume |
| Service discovery | Use the Service Fabric Naming Service |
| Debugging distributed apps | Use Service Fabric diagnostic tools and proper logging |
| Load balancing | Use Service Fabric's built-in load balancing features |

## Summary

.NET Service Fabric is a powerful distributed systems platform that helps developers build and manage microservices-based applications. It provides:

- A reliable platform for deploying microservices
- Built-in state management for stateful services
- Automatic failover and healing
- Comprehensive monitoring and diagnostics
- Multiple programming models

By leveraging Service Fabric, .NET developers can build cloud-native applications that scale efficiently and maintain high availability.

## Additional Resources

- [Official Microsoft Service Fabric Documentation](https://docs.microsoft.com/en-us/azure/service-fabric/)
- [Service Fabric GitHub Repository](https://github.com/microsoft/service-fabric)
- [Service Fabric Programming Models](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-choose-framework)
- [Reliable Services Quick Start](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-quick-start)

## Practice Exercises

1. Create a simple stateless Service Fabric service that exposes a REST API
2. Implement a stateful counter service that persists its state
3. Create a multi-service application with service-to-service communication
4. Deploy a Service Fabric application to a local development cluster
5. Implement health checks for your services to ensure they're working properly

With these exercises, you'll gain hands-on experience with Service Fabric and be well on your way to building robust, scalable microservices applications.