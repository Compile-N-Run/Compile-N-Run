---
title: .NET Publishing Options
description: A comprehensive guide to the various publishing options available for .NET applications, including framework-dependent, self-contained, single-file, and trimmed deployments.

---

# .NET Publishing Options

When it comes to deploying .NET applications, understanding the various publishing options is crucial for ensuring your applications can be distributed and run efficiently. This guide will walk you through the different publishing approaches offered by .NET, their pros and cons, and help you choose the right option for your specific needs.

## Introduction to .NET Publishing

Publishing a .NET application is the process of compiling your code and gathering all necessary files required to deploy and run your application in a target environment. The .NET SDK provides several publishing options, each designed to address different deployment scenarios.

Before diving into the different options, let's understand the basic publishing command:

```bash
dotnet publish -c Release
```

This simple command creates a basic publish output, but .NET offers much more flexibility through various publishing configurations.

## Framework-Dependent Deployment (FDD)

### What is Framework-Dependent Deployment?

Framework-Dependent Deployment is the default publishing option in .NET. In this model, your application relies on a shared version of the .NET runtime that must be installed on the target system.

### How to Create a Framework-Dependent Deployment

```bash
dotnet publish -c Release
```

### Example Project.csproj Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <!-- Framework-dependent is the default, so no additional settings needed -->
  </PropertyGroup>
</Project>
```

### Advantages of Framework-Dependent Deployments

1. **Smaller deployment size**: Your application package includes only your application and its third-party dependencies.
2. **Automatic updates**: When the .NET runtime is updated on the host machine, your application can benefit from bug fixes and performance improvements.
3. **Less disk space usage**: Multiple applications can share the same .NET runtime installation.

### Disadvantages

1. **Runtime dependency**: The target machine must have the correct version of .NET installed.
2. **Version conflicts**: Different applications might require different versions of the .NET runtime.

## Self-Contained Deployment (SCD)

### What is Self-Contained Deployment?

A Self-Contained Deployment includes both your application and the .NET runtime required to run it. This ensures your application can run on a machine that doesn't have the .NET runtime installed.

### How to Create a Self-Contained Deployment

```bash
dotnet publish -c Release --self-contained -r <RID>
```

Where `<RID>` is the Runtime Identifier for your target platform (e.g., `win-x64`, `linux-x64`, `osx-x64`).

### Example Project.csproj Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
  </PropertyGroup>
</Project>
```

### Advantages of Self-Contained Deployments

1. **No runtime dependency**: Your application will run without requiring the .NET runtime to be installed.
2. **Version control**: You control exactly which version of the .NET runtime your application uses.
3. **Simplified deployment**: No need to worry about installing prerequisites on the target machine.

### Disadvantages

1. **Larger deployment size**: The package includes the entire .NET runtime.
2. **Manual updates**: If a security vulnerability is found in the .NET runtime, you need to rebuild and redistribute your application.
3. **Multiple copies**: Each self-contained application has its own copy of the runtime, consuming more disk space.

## Single-File Deployment

### What is Single-File Deployment?

Single-file deployment bundles your application and its dependencies into a single executable file, simplifying distribution and installation.

### How to Create a Single-File Deployment

```bash
dotnet publish -c Release --self-contained -r <RID> -p:PublishSingleFile=true
```

### Example Project.csproj Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>true</PublishSingleFile>
    <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
  </PropertyGroup>
</Project>
```

### How Single-File Deployment Works

When a single-file application starts:

1. The executable extracts its bundled files to a temporary directory
2. The application runs from this temporary location
3. When the application exits, the temporary files are cleaned up

### Advantages of Single-File Deployment

1. **Simplified distribution**: Only one file to manage and distribute.
2. **Clean installation**: No scattered files that users need to keep track of.
3. **Reduced risk of missing files**: All dependencies are bundled together.

### Disadvantages

1. **Startup delay**: Time needed to extract files before execution.
2. **Memory usage**: Temporary files consume disk space while the application runs.
3. **Limited to certain scenarios**: Some advanced scenarios may not work well with single-file deployment.

## Trimmed Deployment

### What is Trimmed Deployment?

Trimming is the process of removing unused code from your application and its dependencies, resulting in a smaller deployment size.

### How to Create a Trimmed Deployment

```bash
dotnet publish -c Release --self-contained -r <RID> -p:PublishTrimmed=true
```

### Example Project.csproj Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishTrimmed>true</PublishTrimmed>
    <TrimMode>link</TrimMode>
  </PropertyGroup>
</Project>
```

### Caution About Trimming

Trimming relies on static analysis to determine which parts of the code are used. However, this analysis has limitations when dealing with:

1. Reflection
2. Dynamic loading
3. Late binding

If your application uses these features, you might need to configure trimming with additional options or directives.

### Advantages of Trimmed Deployment

1. **Smaller size**: Significantly reduced deployment size compared to regular self-contained deployments.
2. **Faster startup**: Less code to load can lead to faster application startup.
3. **Reduced attack surface**: Fewer libraries included means a smaller potential attack surface.

### Disadvantages

1. **Compatibility issues**: Some libraries might not work correctly when trimmed.
2. **Complex configuration**: May require additional configuration to handle reflection and dynamic code.
3. **Debugging challenges**: Troubleshooting issues in trimmed applications can be more difficult.

## Real-World Scenario: Choosing the Right Publishing Option

Let's walk through a practical example of choosing the right publishing option:

### Scenario 1: Enterprise Internal Application

**Requirements:**
- Application runs on corporate machines with standardized environments
- IT department manages .NET runtime installations
- Frequent application updates

**Recommended Option:** Framework-Dependent Deployment (FDD)

**Implementation:**

```bash
dotnet publish -c Release
```

**Explanation:**
Since the IT department can ensure the correct .NET runtime is installed on all machines, using FDD results in smaller deployment packages and easier updates.

### Scenario 2: Consumer Desktop Application

**Requirements:**
- Application distributed to end users with varying system configurations
- Minimal setup experience desired
- Application stability is critical

**Recommended Option:** Self-Contained Single-File Deployment

**Implementation:**

```bash
dotnet publish -c Release --self-contained -r win-x64 -p:PublishSingleFile=true
```

**Explanation:**
End users get a single executable that works without installing the .NET runtime, providing a cleaner installation experience and avoiding version conflicts.

### Scenario 3: Containerized Microservice

**Requirements:**
- Application runs in Docker containers
- Container size should be minimized
- Fast startup is important

**Recommended Option:** Trimmed Self-Contained Deployment

**Implementation:**

```bash
dotnet publish -c Release --self-contained -r linux-musl-x64 -p:PublishTrimmed=true
```

**Example Dockerfile:**

```dockerfile
FROM mcr.microsoft.com/dotnet/runtime-deps:7.0-alpine
WORKDIR /app
COPY bin/Release/net7.0/linux-musl-x64/publish/ .
ENTRYPOINT ["./MyMicroservice"]
```

**Explanation:**
Containers benefit from smaller image sizes and faster startup times. By using a trimmed deployment targeting a minimal Linux distribution, we optimize for both.

## Advanced Publishing Options

### Ready-to-Run (R2R) Compilation

Ready-to-Run compilation pre-compiles assemblies to native code, improving startup performance by reducing the amount of Just-In-Time (JIT) compilation needed at runtime.

```bash
dotnet publish -c Release -r <RID> -p:PublishReadyToRun=true
```

### Example Project.csproj Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net7.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <PublishReadyToRun>true</PublishReadyToRun>
  </PropertyGroup>
</Project>
```

### Invariant Globalization Mode

If your application doesn't need globalization support, you can reduce the size of your deployment by disabling it.

```xml
<PropertyGroup>
  <InvariantGlobalization>true</InvariantGlobalization>
</PropertyGroup>
```

### Compression

For single-file deployments, you can enable compression to further reduce the file size:

```xml
<PropertyGroup>
  <EnableCompressionInSingleFile>true</EnableCompressionInSingleFile>
</PropertyGroup>
```

## Choosing the Right Publishing Option: Decision Matrix

| Factor | FDD | SCD | Single-File | Trimmed |
|--------|-----|-----|-------------|---------|
| Deployment size | Smallest | Large | Large | Medium |
| Runtime dependency | Yes | No | No | No |
| Setup complexity | Higher | Low | Lowest | Low |
| Startup time | Fast | Fast | Slower | Fastest |
| Compatibility | High | High | Medium | Lower |
| Maintenance | Easy | More complex | More complex | Most complex |

## Summary

.NET provides a variety of publishing options to meet different deployment needs:

1. **Framework-Dependent Deployment**: The default option that requires the .NET runtime on the target system. Ideal for controlled environments.

2. **Self-Contained Deployment**: Includes the .NET runtime with your application, making it more portable but larger.

3. **Single-File Deployment**: Bundles everything into a single executable for easy distribution.

4. **Trimmed Deployment**: Reduces size by removing unused code, but requires careful testing.

The best choice depends on your specific requirements regarding deployment size, target environment, maintenance considerations, and user experience.

## Additional Resources

- [Official .NET Publishing Documentation](https://docs.microsoft.com/en-us/dotnet/core/deploying/)
- [Runtime Identifiers Catalog](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog)
- [Trimming Options in .NET](https://docs.microsoft.com/en-us/dotnet/core/deploying/trimming-options)

## Practice Exercise

1. Create a simple console application and publish it using each of the four main publishing options discussed in this guide.
2. Compare the resulting file sizes and folder structures.
3. Test the startup time for each version.
4. Try deploying each version to a clean machine or virtual environment and observe any differences in behavior or requirements.

By practicing these publishing options with your own applications, you'll gain a deeper understanding of when to use each approach for your specific needs.