---
title: .NET Kubernetes Orchestration
description: Learn how to deploy and manage .NET applications using Kubernetes orchestration, including containerization, deployment strategies, and best practices for scaling your applications.

---

# .NET Kubernetes Orchestration

## Introduction

Kubernetes has become the industry standard for container orchestration, providing a robust platform for deploying, scaling, and managing containerized applications. For .NET developers, Kubernetes offers a powerful way to deploy and manage your applications in a cloud-native environment, regardless of whether you're working with .NET Framework or .NET Core/.NET 5+.

In this guide, we'll explore how to orchestrate .NET applications using Kubernetes, starting from the basics and progressing to more advanced deployment scenarios. We'll cover containerization of .NET apps, creating Kubernetes manifests, deployment strategies, and best practices to ensure your applications run reliably at scale.

## Prerequisites

Before diving into Kubernetes orchestration, make sure you have:

- Basic understanding of .NET development
- Docker installed on your machine
- A Kubernetes cluster (local like Minikube or Docker Desktop, or cloud-based)
- kubectl command-line tool installed
- .NET SDK (version 6.0 or later recommended)

## Understanding Kubernetes Concepts for .NET Developers

For .NET developers new to Kubernetes, here are the key concepts you should understand:

- **Pods**: The smallest deployable units in Kubernetes that host your .NET application containers
- **Deployments**: Manage the desired state of your pods (e.g., how many replicas should run)
- **Services**: Allow network access to a set of pods
- **ConfigMaps and Secrets**: Store configuration and sensitive information
- **Ingress**: Manages external access to services in your cluster
- **Namespaces**: Virtual clusters for resource isolation

## Containerizing Your .NET Application

Before orchestrating with Kubernetes, you first need to containerize your .NET application using Docker.

### 1. Create a Simple .NET Web API

Let's start with a simple .NET Web API:

```bash
dotnet new webapi -n KubernetesDemo
cd KubernetesDemo
```

### 2. Create a Dockerfile

Create a `Dockerfile` in the root of your project:

```dockerfile
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build
WORKDIR /app

# Copy csproj and restore dependencies
COPY *.csproj ./
RUN dotnet restore

# Copy the rest of the files and build
COPY . ./
RUN dotnet publish -c Release -o out

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:6.0
WORKDIR /app
COPY --from=build /app/out .
EXPOSE 80
ENTRYPOINT ["dotnet", "KubernetesDemo.dll"]
```

### 3. Build and Test Your Docker Image

```bash
docker build -t kubernetes-demo:1.0 .
docker run -p 8080:80 kubernetes-demo:1.0
```

Now you can access your API at http://localhost:8080/weatherforecast (or whatever your API endpoint is).

## Creating Kubernetes Manifests for .NET Applications

Once your application is containerized, you need to define how Kubernetes should run it. We'll create manifests for deployment, service, and configuration.

### 1. Deployment Manifest

Create a file named `deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubernetes-demo
  labels:
    app: kubernetes-demo
spec:
  replicas: 3
  selector:
    matchLabels:
      app: kubernetes-demo
  template:
    metadata:
      labels:
        app: kubernetes-demo
    spec:
      containers:
      - name: kubernetes-demo
        image: kubernetes-demo:1.0
        ports:
        - containerPort: 80
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        resources:
          limits:
            cpu: "500m"
            memory: "512Mi"
          requests:
            cpu: "200m"
            memory: "256Mi"
```

### 2. Service Manifest

Create a file named `service.yaml`:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: kubernetes-demo
spec:
  selector:
    app: kubernetes-demo
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
```

### 3. ConfigMap for Application Settings

Create a file named `configmap.yaml`:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: kubernetes-demo-config
data:
  appsettings.json: |
    {
      "Logging": {
        "LogLevel": {
          "Default": "Information",
          "Microsoft": "Warning",
          "Microsoft.Hosting.Lifetime": "Information"
        }
      },
      "AllowedHosts": "*",
      "ConnectionStrings": {
        "DefaultConnection": "Your-Connection-String"
      }
    }
```

## Deploying Your .NET Application to Kubernetes

Now let's deploy the application to Kubernetes using the created manifests:

### 1. Push Your Image to a Registry

For a real cluster, you'll need to push your image to a container registry:

```bash
# For Docker Hub
docker tag kubernetes-demo:1.0 yourusername/kubernetes-demo:1.0
docker push yourusername/kubernetes-demo:1.0

# Update the deployment.yaml to use this image:
# image: yourusername/kubernetes-demo:1.0
```

For local testing with Minikube, you can use the local Docker daemon:

```bash
# For Minikube
eval $(minikube docker-env)
docker build -t kubernetes-demo:1.0 .
```

### 2. Apply Kubernetes Manifests

```bash
kubectl apply -f configmap.yaml
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```

### 3. Verify the Deployment

```bash
# Check if pods are running
kubectl get pods

# Check the service
kubectl get services

# For Minikube, access the service
minikube service kubernetes-demo
```

## Advanced .NET Kubernetes Orchestration

Once you have basic deployment working, you can explore more advanced scenarios:

### Implementing Health Checks

ASP.NET Core supports health checks that can be integrated with Kubernetes probes:

1. Add health checks to your .NET application:

```csharp
// In Program.cs
var builder = WebApplication.CreateBuilder(args);

// Add health checks
builder.Services.AddHealthChecks();

var app = builder.Build();

// Configure health check endpoint
app.MapHealthChecks("/health");

app.Run();
```

2. Update your Kubernetes deployment to use these health checks:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kubernetes-demo
spec:
  # ... other configuration
  template:
    spec:
      containers:
      - name: kubernetes-demo
        image: kubernetes-demo:1.0
        ports:
        - containerPort: 80
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 10
```

### Implementing Secrets for Sensitive Data

For sensitive data like connection strings, use Kubernetes Secrets instead of ConfigMaps:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: kubernetes-demo-secrets
type: Opaque
data:
  connectionstring: <base64-encoded-connection-string>
```

Then reference it in your deployment:

```yaml
env:
- name: ConnectionStrings__DefaultConnection
  valueFrom:
    secretKeyRef:
      name: kubernetes-demo-secrets
      key: connectionstring
```

### Implementing Horizontal Pod Autoscaling

To automatically scale your .NET application based on CPU or memory usage:

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: kubernetes-demo-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: kubernetes-demo
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

### Real-world Example: Microservice Architecture

For a more complex scenario, let's look at how you might deploy a .NET microservices application:

```
/k8s
  /auth-service
    deployment.yaml
    service.yaml
    configmap.yaml
  /product-service
    deployment.yaml
    service.yaml
    configmap.yaml
  /frontend
    deployment.yaml
    service.yaml
    configmap.yaml
  ingress.yaml
  namespace.yaml
```

The ingress definition might look like:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: microservices-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$1
spec:
  rules:
  - host: myapp.local
    http:
      paths:
      - path: /auth(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: auth-service
            port:
              number: 80
      - path: /products(/|$)(.*)
        pathType: Prefix
        backend:
          service:
            name: product-service
            port:
              number: 80
      - path: /(.*)
        pathType: Prefix
        backend:
          service:
            name: frontend
            port:
              number: 80
```

## CI/CD for .NET Kubernetes Deployments

To automate your deployments, you can integrate with CI/CD pipelines. Here's a simple GitHub Actions workflow:

```yaml
name: Build and Deploy

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 6.0.x
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore
      
    - name: Test
      run: dotnet test --no-build
      
    - name: Build and Push Docker Image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        tags: yourusername/kubernetes-demo:${{ github.sha }}
        
    - name: Deploy to Kubernetes
      uses: Azure/k8s-deploy@v1
      with:
        manifests: |
          k8s/deployment.yaml
          k8s/service.yaml
        images: yourusername/kubernetes-demo:${{ github.sha }}
        kubectl-version: 'latest'
```

## Best Practices for .NET Applications on Kubernetes

1. **Use Health Checks**: Implement health checks in your .NET application and configure Kubernetes liveness and readiness probes.

2. **Right-size Resource Requests and Limits**: Set appropriate CPU and memory resources to ensure efficient resource utilization.

3. **Use Kestrel for Production**: Kestrel is a cross-platform web server for ASP.NET Core that is more performant in containerized environments.

4. **Externalize Configuration**: Use ConfigMaps and Secrets to manage configuration outside of your container image.

5. **Keep Images Small**: Use multi-stage builds to create smaller, more efficient images.

6. **Handle Graceful Shutdowns**: Ensure your .NET application handles SIGTERM signals to shut down gracefully:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        })
        .UseConsoleLifetime(); // Handles graceful termination
```

7. **Implement Centralized Logging**: Use a logging framework like Serilog to output logs to stdout/stderr, which Kubernetes can collect:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureLogging(logging =>
        {
            logging.ClearProviders();
            logging.AddConsole(); // Log to console for Kubernetes to pick up
        })
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseStartup<Startup>();
        });
```

## Common Troubleshooting

### Pod Fails to Start

Check the pod logs:

```bash
kubectl logs <pod-name>
```

Common issues include:
- Incorrect image name
- Application crashes on startup
- Insufficient resources

### Service Not Accessible

Verify service and endpoints:

```bash
kubectl get svc kubernetes-demo
kubectl get endpoints kubernetes-demo
```

Common issues include:
- Label selector mismatch
- Pods not ready
- Port configuration issues

### Performance Issues

Use Kubernetes tools to diagnose:

```bash
kubectl top pods
kubectl describe pod <pod-name>
```

## Summary

In this guide, we've explored how to orchestrate .NET applications using Kubernetes, from basic containerization to advanced deployment strategies. We covered:

- Containerizing .NET applications with Docker
- Creating Kubernetes manifests for deployment, services, and configuration
- Advanced scenarios like health checks, secrets, and autoscaling
- Best practices for running .NET applications in Kubernetes
- CI/CD integration and troubleshooting tips

By following these practices, you can deploy scalable, resilient .NET applications in Kubernetes environments, taking advantage of cloud-native capabilities while leveraging your existing .NET skills and codebase.

## Additional Resources

- [Kubernetes Documentation](https://kubernetes.io/docs/home/)
- [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/e-book/microservices-architecture/pdf)
- [GitHub repository with complete examples](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/host-and-deploy/docker)

## Exercises

1. Create a simple .NET Web API and deploy it to a local Kubernetes cluster using the techniques described in this guide.
2. Extend the application to include health checks and set up Kubernetes probes.
3. Create a CI/CD pipeline for your .NET application using GitHub Actions or Azure DevOps.
4. Implement a microservices architecture with multiple .NET services communicating with each other in Kubernetes.
5. Set up a development, staging, and production namespace in Kubernetes and implement a deployment strategy that promotes your application through these environments.

Happy orchestrating your .NET applications with Kubernetes!