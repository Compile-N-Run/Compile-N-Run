---
title: .NET Application Insights
description: Learn how to implement Azure Application Insights in .NET applications to monitor performance, detect issues, and gain valuable insights into your application's behavior.

---

# .NET Application Insights

## Introduction

Application Insights is a powerful application performance management (APM) service provided by Microsoft Azure. It allows developers to monitor live .NET applications, automatically detect performance anomalies, and gain insights into how users interact with your applications. Whether you're building web applications, APIs, or background services, Application Insights provides valuable telemetry data that helps you understand your application's behavior in production environments.

In this guide, you'll learn how to integrate Application Insights into your .NET applications, understand the different types of telemetry it collects, and see how to use this data to improve your application's performance and reliability.

## Why Use Application Insights?

Before diving into implementation details, let's understand why Application Insights is valuable for .NET developers:

1. **Real-time monitoring** - Track application performance and usage in production
2. **Automatic detection of issues** - Get alerts for unusual patterns or performance degradation
3. **Rich analytics** - Analyze telemetry data using powerful query language
4. **End-to-end transaction monitoring** - Follow requests from client to backend services
5. **User behavior analytics** - Understand how users interact with your application
6. **Integration with Azure DevOps** - Create work items from detected issues

## Setting Up Application Insights

### Step 1: Create an Application Insights Resource

First, you need to create an Application Insights resource in Azure:

1. Sign in to the [Azure Portal](https://portal.azure.com)
2. Create a new resource by clicking "Create a resource"
3. Search for "Application Insights" and select it
4. Fill in the required details like subscription, resource group, name, and region
5. Click "Review + create" and then "Create"

Once created, you'll need the **Instrumentation Key** or **Connection String** from the resource overview page.

### Step 2: Add Application Insights to Your .NET Application

#### For .NET Core and .NET 5+ Applications

For ASP.NET Core applications, the easiest way to add Application Insights is via the built-in service:

1. Install the required NuGet package:

```bash
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

2. Add Application Insights to the service collection in your `Program.cs` file:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add Application Insights services
builder.Services.AddApplicationInsightsTelemetry();

// Other services...
builder.Services.AddControllers();

var app = builder.Build();
// Configure middleware
app.Run();
```

3. Configure the connection string in your `appsettings.json`:

```json
{
  "ApplicationInsights": {
    "ConnectionString": "InstrumentationKey=your-instrumentation-key;IngestionEndpoint=https://your-region.in.applicationinsights.azure.com/;LiveEndpoint=https://your-region.livediagnostics.monitor.azure.com/"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
```

#### For .NET Framework Applications

For traditional ASP.NET applications:

1. Install the required NuGet packages:

```bash
Install-Package Microsoft.ApplicationInsights.AspNetCore
Install-Package Microsoft.ApplicationInsights.DependencyCollector
Install-Package Microsoft.ApplicationInsights.PerfCounterCollector
```

2. Add the instrumentation key to your `Web.config` file:

```xml
<configuration>
  <appSettings>
    <add key="ApplicationInsights:InstrumentationKey" value="your-instrumentation-key" />
  </appSettings>
</configuration>
```

3. Initialize Application Insights in `Global.asax.cs`:

```csharp
using Microsoft.ApplicationInsights.Extensibility;

public class MvcApplication : System.Web.HttpApplication
{
    protected void Application_Start()
    {
        // Set up Application Insights
        TelemetryConfiguration.Active.InstrumentationKey = 
            ConfigurationManager.AppSettings["ApplicationInsights:InstrumentationKey"];
            
        // Rest of your startup code
        AreaRegistration.RegisterAllAreas();
        FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
        // Other configuration...
    }
}
```

## Types of Telemetry Collected

Application Insights automatically collects several types of telemetry:

1. **Request data** - HTTP requests to your web application
2. **Dependency calls** - Calls to databases, external APIs, or other services
3. **Exceptions** - Unhandled and handled exceptions
4. **Page views and user behavior** (for web applications)
5. **Performance counters** - CPU, memory usage, etc.
6. **Custom events and metrics** - Data you define and collect

## Logging Custom Telemetry

### Tracking Custom Events

You can track custom events to understand user behavior or application flow:

```csharp
// Inject the telemetry client
public class HomeController : Controller
{
    private readonly ILogger<HomeController> _logger;
    private readonly TelemetryClient _telemetryClient;

    public HomeController(ILogger<HomeController> logger, TelemetryClient telemetryClient)
    {
        _logger = logger;
        _telemetryClient = telemetryClient;
    }

    public IActionResult Index()
    {
        // Track a custom event
        _telemetryClient.TrackEvent("HomePageVisited");
        
        // Track an event with custom properties
        _telemetryClient.TrackEvent("UserAction", new Dictionary<string, string>
        {
            { "UserType", "Registered" },
            { "Feature", "Dashboard" }
        });
        
        return View();
    }
}
```

### Tracking Custom Metrics

Custom metrics help you measure specific aspects of your application:

```csharp
public void ProcessOrder(Order order)
{
    var stopwatch = Stopwatch.StartNew();
    
    // Process the order...
    
    stopwatch.Stop();
    
    // Track processing time
    _telemetryClient.TrackMetric("OrderProcessingTime", stopwatch.ElapsedMilliseconds);
    
    // Track order value
    _telemetryClient.TrackMetric("OrderValue", order.TotalAmount);
}
```

### Tracking Dependencies

You can manually track dependencies that aren't automatically captured:

```csharp
public async Task<ExternalData> CallExternalServiceAsync()
{
    // Start the operation
    var operation = _telemetryClient.StartOperation<DependencyTelemetry>("ExternalService");
    operation.Telemetry.Type = "HTTP";
    operation.Telemetry.Target = "api.externalservice.com";
    
    try
    {
        // Make the external call
        var result = await _httpClient.GetFromJsonAsync<ExternalData>("https://api.externalservice.com/data");
        
        // Mark as successful
        operation.Telemetry.Success = true;
        return result;
    }
    catch (Exception ex)
    {
        // Track the exception
        operation.Telemetry.Success = false;
        _telemetryClient.TrackException(ex);
        throw;
    }
    finally
    {
        // Complete the operation
        _telemetryClient.StopOperation(operation);
    }
}
```

## Viewing and Analyzing Telemetry Data

After deploying your application with Application Insights configured, you can view the collected telemetry data in the Azure Portal:

1. Navigate to your Application Insights resource
2. The overview page shows key metrics like request rates, failure rates, and response times
3. Use the "Application Map" to visualize dependencies between components
4. Explore "Performance" to identify slow requests or dependencies
5. Check "Failures" to find exceptions and failed requests
6. Use "Metrics" to create custom charts and dashboards

### Using Kusto Query Language (KQL)

Application Insights uses Kusto Query Language (KQL) for advanced analysis. Here are some useful queries:

```kql
// Find the slowest requests
requests
| where timestamp > ago(24h)
| order by duration desc
| take 10

// Count exceptions by type
exceptions
| where timestamp > ago(24h)
| summarize count() by type
| order by count_ desc

// User retention analysis
customEvents
| where name == "UserLogin"
| summarize UserCount = dcount(user_Id) by bin(timestamp, 1d)
| render timechart
```

## Real-world Example: Monitoring a Web API

Let's look at a complete example of monitoring a .NET Web API:

1. Create a new Web API project:

```bash
dotnet new webapi -n MonitoredApi
cd MonitoredApi
```

2. Add Application Insights:

```bash
dotnet add package Microsoft.ApplicationInsights.AspNetCore
```

3. Update `Program.cs` to include Application Insights:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add Application Insights
builder.Services.AddApplicationInsightsTelemetry();

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

4. Add a custom controller with telemetry tracking:

```csharp
using Microsoft.ApplicationInsights;
using Microsoft.AspNetCore.Mvc;
using System.Diagnostics;

namespace MonitoredApi.Controllers;

[ApiController]
[Route("[controller]")]
public class OrdersController : ControllerBase
{
    private readonly ILogger<OrdersController> _logger;
    private readonly TelemetryClient _telemetryClient;

    public OrdersController(ILogger<OrdersController> logger, TelemetryClient telemetryClient)
    {
        _logger = logger;
        _telemetryClient = telemetryClient;
    }

    [HttpGet]
    public IActionResult Get()
    {
        // Track a custom event
        _telemetryClient.TrackEvent("OrdersListed");
        
        return Ok(new[] { new { Id = 1, Total = 99.99 }, new { Id = 2, Total = 149.99 } });
    }

    [HttpPost]
    public IActionResult Create([FromBody] OrderModel order)
    {
        var stopwatch = Stopwatch.StartNew();
        
        try
        {
            // Simulate order processing
            if (order.Total <= 0)
            {
                throw new ArgumentException("Order total must be positive");
            }
            
            // Track the business metric
            _telemetryClient.TrackMetric("OrderValue", order.Total);
            
            // Simulate external API call
            SimulateExternalApiCall();
            
            stopwatch.Stop();
            
            // Track processing time
            _telemetryClient.TrackMetric("OrderProcessingTime", stopwatch.ElapsedMilliseconds);
            
            return CreatedAtAction(nameof(Get), new { id = 123 });
        }
        catch (Exception ex)
        {
            // Track exception with custom properties
            _telemetryClient.TrackException(ex, new Dictionary<string, string>
            {
                { "OrderId", order.Id.ToString() },
                { "OrderTotal", order.Total.ToString() }
            });
            
            return BadRequest("Invalid order");
        }
    }
    
    private void SimulateExternalApiCall()
    {
        var operation = _telemetryClient.StartOperation<DependencyTelemetry>("PaymentProcessor");
        operation.Telemetry.Type = "HTTP";
        operation.Telemetry.Target = "api.payments.com";
        
        try
        {
            // Simulate processing time
            Thread.Sleep(200);
            
            // Randomly simulate failures (10% chance)
            if (new Random().Next(10) == 0)
            {
                throw new Exception("Payment processor error");
            }
            
            operation.Telemetry.Success = true;
        }
        catch (Exception ex)
        {
            operation.Telemetry.Success = false;
            _telemetryClient.TrackException(ex);
            throw;
        }
        finally
        {
            _telemetryClient.StopOperation(operation);
        }
    }
}

public class OrderModel
{
    public int Id { get; set; }
    public double Total { get; set; }
}
```

5. Configure in `appsettings.json`:

```json
{
  "ApplicationInsights": {
    "ConnectionString": "YOUR_CONNECTION_STRING_HERE"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    },
    "ApplicationInsights": {
      "LogLevel": {
        "Default": "Information"
      }
    }
  },
  "AllowedHosts": "*"
}
```

After deploying this application, you'll be able to:
- Monitor request rates, response times, and failure rates
- Track custom business metrics like order value and processing time
- Identify issues with the payment processor dependency
- Analyze exceptions with contextual information

## Best Practices

1. **Don't over-instrument** - Focus on business-critical events and metrics
2. **Use sampling** - For high-volume applications, enable sampling to reduce costs
3. **Add context** - Include relevant properties with events and metrics
4. **Set up alerts** - Configure alerts for important thresholds and anomalies
5. **Use operation context** - Correlate related events using operation IDs
6. **Separate development and production** - Use different instrumentation keys for different environments
7. **Be mindful of PII** - Don't track personally identifiable information

## Common Issues and Solutions

### High Data Volume and Costs

If you're collecting too much telemetry:

```csharp
// Configure sampling in Program.cs
builder.Services.AddApplicationInsightsTelemetry(options => {
    options.EnableAdaptiveSampling = true;
    options.SamplingPercentage = 10; // Sample 10% of requests
});
```

### Missing Dependency Data

Make sure you've added the dependency collector:

```bash
dotnet add package Microsoft.ApplicationInsights.DependencyCollector
```

### Custom Configuration

To provide more control over configuration:

```csharp
builder.Services.AddApplicationInsightsTelemetry(options => {
    options.ConnectionString = builder.Configuration["CustomAIConnectionString"];
    options.EnableHeartbeat = true;
    options.EnableDependencyTrackingTelemetryModule = true;
});
```

## Summary

Application Insights provides powerful monitoring capabilities for .NET applications, giving you visibility into your application's performance and behavior in production. By collecting and analyzing telemetry data, you can:

- Detect and diagnose exceptions and performance issues
- Understand user behavior and usage patterns
- Monitor dependencies and external services
- Track custom business metrics
- Receive alerts when issues occur

The integration with .NET applications is straightforward, especially with modern .NET Core and .NET 5+ applications, where most of the configuration is handled automatically. By following the guidelines in this tutorial, you can enhance your application with comprehensive monitoring that helps you build more reliable and performant software.

## Additional Resources

- [Official Application Insights Documentation](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)
- [Application Insights SDK for ASP.NET Core](https://docs.microsoft.com/en-us/azure/azure-monitor/app/asp-net-core)
- [Kusto Query Language (KQL) Documentation](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/)
- [Application Insights Pricing](https://azure.microsoft.com/en-us/pricing/details/monitor/)

## Exercises

1. Add Application Insights to an existing .NET application and monitor its basic metrics.
2. Create custom events to track a user workflow through your application.
3. Set up custom metrics to measure business-specific performance indicators.
4. Configure an alert that notifies you when the response time exceeds a threshold.
5. Use the Kusto Query Language to analyze telemetry data and create a custom report.
6. Implement correlation IDs to track a request across multiple services or components.

By completing these exercises, you'll gain hands-on experience with Application Insights and be well-equipped to monitor your .NET applications in production.