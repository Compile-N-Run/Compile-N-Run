---
title: .NET LINQ Joining
description: Learn how to use LINQ join operations to combine data from different collections in C#, including inner joins, left joins, group joins, and cross joins with practical examples.

---

# LINQ Joining Operations

## Introduction

LINQ (Language Integrated Query) provides powerful ways to combine data from multiple sources through joining operations. If you're familiar with SQL, LINQ joins will feel similar, but they're integrated directly into your C# code. In this tutorial, we'll explore how to use LINQ join operations to merge and correlate data from different collections.

Joins are essential when working with related data that's split across multiple collections. For example, you might need to combine customer data with their orders, or match students with their courses.

## Understanding Join Operations in LINQ

At its core, a join operation connects two collections based on matching keys. LINQ offers several types of join operations:

1. **Inner Join** - Returns elements from both collections that have matching keys
2. **Group Join** - Groups matching elements from the second collection
3. **Left Join** - Returns all elements from the first collection and matching elements from the second
4. **Cross Join** - Returns the Cartesian product of both collections

Let's explore each of these with practical examples.

## Basic Inner Join

The inner join is the most common type of join and returns only the elements with matching keys in both collections.

### Syntax

```csharp
var query = from first in firstCollection
            join second in secondCollection
            on first.Key equals second.Key
            select new { first.Property, second.Property };
```

Or using method syntax:

```csharp
var query = firstCollection.Join(
    secondCollection,
    first => first.Key,
    second => second.Key,
    (first, second) => new { first.Property, second.Property });
```

### Example: Joining Customers and Orders

Let's see a practical example of joining customers with their orders:

```csharp
// Define sample data
var customers = new List<Customer>
{
    new Customer { CustomerID = 1, Name = "Alice" },
    new Customer { CustomerID = 2, Name = "Bob" },
    new Customer { CustomerID = 3, Name = "Charlie" }
};

var orders = new List<Order>
{
    new Order { OrderID = 101, CustomerID = 1, Amount = 100 },
    new Order { OrderID = 102, CustomerID = 2, Amount = 200 },
    new Order { OrderID = 103, CustomerID = 1, Amount = 150 },
    new Order { OrderID = 104, CustomerID = 4, Amount = 300 }
};

// Query syntax join
var customerOrders = from c in customers
                     join o in orders
                     on c.CustomerID equals o.CustomerID
                     select new { CustomerName = c.Name, OrderAmount = o.Amount };

// Method syntax join
var customerOrdersMethod = customers.Join(
    orders,
    c => c.CustomerID,
    o => o.CustomerID,
    (c, o) => new { CustomerName = c.Name, OrderAmount = o.Amount });
                    
// Display results
Console.WriteLine("Customer Orders:");
foreach (var item in customerOrders)
{
    Console.WriteLine($"{item.CustomerName} placed an order for ${item.OrderAmount}");
}
```

**Output:**
```
Customer Orders:
Alice placed an order for $100
Alice placed an order for $150
Bob placed an order for $200
```

Notice that Charlie doesn't appear in the result because he doesn't have any orders. Also, the order with CustomerID 4 doesn't appear because there's no matching customer.

## Group Join

A group join combines elements from two collections and groups the matching elements from the second collection.

### Syntax

```csharp
var query = from first in firstCollection
            join second in secondCollection
            on first.Key equals second.Key into groupedCollection
            select new { first.Property, GroupedItems = groupedCollection };
```

Or using method syntax:

```csharp
var query = firstCollection.GroupJoin(
    secondCollection,
    first => first.Key,
    second => second.Key,
    (first, groupedCollection) => new { first.Property, GroupedItems = groupedCollection });
```

### Example: Grouping Orders by Customer

```csharp
// Query syntax group join
var customerOrderGroups = from c in customers
                          join o in orders
                          on c.CustomerID equals o.CustomerID into customerOrders
                          select new { Customer = c, Orders = customerOrders };

// Method syntax group join
var customerOrderGroupsMethod = customers.GroupJoin(
    orders,
    c => c.CustomerID,
    o => o.CustomerID,
    (c, customerOrders) => new { Customer = c, Orders = customerOrders });
                          
// Display results
Console.WriteLine("\nCustomer Order Groups:");
foreach (var group in customerOrderGroups)
{
    Console.WriteLine($"{group.Customer.Name} has {group.Orders.Count()} order(s):");
    foreach (var order in group.Orders)
    {
        Console.WriteLine($"  - Order {order.OrderID}: ${order.Amount}");
    }
}
```

**Output:**
```
Customer Order Groups:
Alice has 2 order(s):
  - Order 101: $100
  - Order 103: $150
Bob has 1 order(s):
  - Order 102: $200
Charlie has 0 order(s):
```

Note that Charlie appears in the results with zero orders because a group join returns all elements from the first collection.

## Left Join

LINQ doesn't have a direct left join operator, but we can simulate one using a group join followed by a `SelectMany`:

### Example: Left Join to Include All Customers

```csharp
// Left join using group join + SelectMany
var leftJoin = from c in customers
               join o in orders
               on c.CustomerID equals o.CustomerID into customerOrders
               from order in customerOrders.DefaultIfEmpty()
               select new 
               { 
                   CustomerName = c.Name, 
                   OrderID = order != null ? order.OrderID : 0, 
                   Amount = order != null ? order.Amount : 0 
               };
                          
// Display results
Console.WriteLine("\nLeft Join (All Customers):");
foreach (var item in leftJoin)
{
    Console.WriteLine($"{item.CustomerName}: Order {item.OrderID} - ${item.Amount}");
}
```

**Output:**
```
Left Join (All Customers):
Alice: Order 101 - $100
Alice: Order 103 - $150
Bob: Order 102 - $200
Charlie: Order 0 - $0
```

Notice that Charlie appears in the result with a default order (OrderID = 0, Amount = 0) because the left join includes all elements from the first collection.

## Cross Join

A cross join, also called a Cartesian product, combines each element from the first collection with every element from the second collection.

### Example: Cross Join of Categories and Products

```csharp
var categories = new List<string> { "Electronics", "Books", "Clothing" };
var products = new List<string> { "Laptop", "Novel", "T-Shirt" };

// Cross join using query syntax
var crossJoinQuery = from c in categories
                     from p in products
                     select new { Category = c, Product = p };

// Display results
Console.WriteLine("\nCross Join of Categories and Products:");
foreach (var item in crossJoinQuery)
{
    Console.WriteLine($"Category: {item.Category}, Product: {item.Product}");
}
```

**Output:**
```
Cross Join of Categories and Products:
Category: Electronics, Product: Laptop
Category: Electronics, Product: Novel
Category: Electronics, Product: T-Shirt
Category: Books, Product: Laptop
Category: Books, Product: Novel
Category: Books, Product: T-Shirt
Category: Clothing, Product: Laptop
Category: Clothing, Product: Novel
Category: Clothing, Product: T-Shirt
```

## Real-World Example: Customer Order Analysis

Let's create a more practical example that analyzes customer orders using different join operations:

```csharp
// Define sample data
var customers = new List<Customer>
{
    new Customer { CustomerID = 1, Name = "Alice", Region = "North" },
    new Customer { CustomerID = 2, Name = "Bob", Region = "South" },
    new Customer { CustomerID = 3, Name = "Charlie", Region = "North" },
    new Customer { CustomerID = 4, Name = "Diana", Region = "East" }
};

var orders = new List<Order>
{
    new Order { OrderID = 101, CustomerID = 1, Amount = 100, Date = DateTime.Parse("2023-01-05") },
    new Order { OrderID = 102, CustomerID = 2, Amount = 200, Date = DateTime.Parse("2023-01-12") },
    new Order { OrderID = 103, CustomerID = 1, Amount = 150, Date = DateTime.Parse("2023-01-20") },
    new Order { OrderID = 104, CustomerID = 3, Amount = 50, Date = DateTime.Parse("2023-02-01") },
    new Order { OrderID = 105, CustomerID = 1, Amount = 300, Date = DateTime.Parse("2023-02-15") },
    new Order { OrderID = 106, CustomerID = 2, Amount = 120, Date = DateTime.Parse("2023-02-28") }
};

// Calculate total order amount per customer
var customerSummary = customers.GroupJoin(
    orders,
    c => c.CustomerID,
    o => o.CustomerID,
    (c, customerOrders) => new {
        CustomerName = c.Name,
        Region = c.Region,
        TotalOrders = customerOrders.Count(),
        TotalAmount = customerOrders.Sum(o => o.Amount),
        AverageAmount = customerOrders.Any() ? customerOrders.Average(o => o.Amount) : 0
    });

Console.WriteLine("\nCustomer Order Analysis:");
Console.WriteLine("Customer | Region | # Orders | Total | Average");
Console.WriteLine("---------------------------------------------");
foreach (var summary in customerSummary)
{
    Console.WriteLine($"{summary.CustomerName,-8} | {summary.Region,-6} | {summary.TotalOrders,-8} | ${summary.TotalAmount,-5} | ${summary.AverageAmount:F2}");
}

// Regional analysis
var regionalAnalysis = from c in customers
                      join o in orders on c.CustomerID equals o.CustomerID into customerOrders
                      group new { Customer = c, Orders = customerOrders } by c.Region into regionalGroup
                      select new {
                          Region = regionalGroup.Key,
                          CustomerCount = regionalGroup.Count(),
                          TotalAmount = regionalGroup.Sum(x => x.Orders.Sum(o => o.Amount)),
                          OrderCount = regionalGroup.Sum(x => x.Orders.Count())
                      };

Console.WriteLine("\nRegional Sales Analysis:");
Console.WriteLine("Region | Customers | Orders | Total Amount");
Console.WriteLine("----------------------------------------");
foreach (var region in regionalAnalysis)
{
    Console.WriteLine($"{region.Region,-6} | {region.CustomerCount,-9} | {region.OrderCount,-6} | ${region.TotalAmount}");
}
```

**Output:**
```
Customer Order Analysis:
Customer | Region | # Orders | Total | Average
---------------------------------------------
Alice    | North  | 3        | $550   | $183.33
Bob      | South  | 2        | $320   | $160.00
Charlie  | North  | 1        | $50    | $50.00
Diana    | East   | 0        | $0     | $0.00

Regional Sales Analysis:
Region | Customers | Orders | Total Amount
----------------------------------------
North  | 2         | 4      | $600
South  | 1         | 2      | $320
East   | 1         | 0      | $0
```

## Handling Complex Joins with Multiple Conditions

Sometimes you might need to join collections based on multiple conditions. You can do this by creating composite keys:

```csharp
var productInventory = new List<ProductInventory>
{
    new ProductInventory { ProductID = 1, WarehouseID = "A", Quantity = 20 },
    new ProductInventory { ProductID = 1, WarehouseID = "B", Quantity = 10 },
    new ProductInventory { ProductID = 2, WarehouseID = "A", Quantity = 15 },
    new ProductInventory { ProductID = 3, WarehouseID = "B", Quantity = 30 }
};

var productRequests = new List<ProductRequest>
{
    new ProductRequest { ProductID = 1, WarehouseID = "A", RequestedQuantity = 5 },
    new ProductRequest { ProductID = 1, WarehouseID = "B", RequestedQuantity = 15 },
    new ProductRequest { ProductID = 2, WarehouseID = "B", RequestedQuantity = 10 },
    new ProductRequest { ProductID = 3, WarehouseID = "A", RequestedQuantity = 20 }
};

// Join on multiple conditions (both ProductID and WarehouseID must match)
var inventoryAnalysis = from inventory in productInventory
                        join request in productRequests
                        on new { inventory.ProductID, inventory.WarehouseID } 
                        equals new { request.ProductID, request.WarehouseID }
                        select new {
                            inventory.ProductID,
                            inventory.WarehouseID,
                            AvailableQuantity = inventory.Quantity,
                            RequestedQuantity = request.RequestedQuantity,
                            IsSufficient = inventory.Quantity >= request.RequestedQuantity
                        };

Console.WriteLine("\nInventory Request Analysis:");
Console.WriteLine("Product | Warehouse | Available | Requested | Sufficient?");
Console.WriteLine("----------------------------------------------------");
foreach (var item in inventoryAnalysis)
{
    Console.WriteLine($"{item.ProductID,-7} | {item.WarehouseID,-9} | {item.AvailableQuantity,-9} | {item.RequestedQuantity,-9} | {item.IsSufficient}");
}
```

**Output:**
```
Inventory Request Analysis:
Product | Warehouse | Available | Requested | Sufficient?
----------------------------------------------------
1       | A         | 20        | 5         | True
1       | B         | 10        | 15        | False
```

## Performance Considerations

When working with join operations in LINQ, keep these performance tips in mind:

1. **Use appropriate data structures**: For large collections, consider using dictionaries or lookup tables to improve join performance.

2. **Filter before joining**: Apply `Where` clauses before performing joins to reduce the number of elements involved.

3. **Be careful with large data sets**: LINQ join operations load all data into memory, so they may not be appropriate for very large data sets.

Example of optimizing join performance:

```csharp
// Less efficient - joining everything first, then filtering
var inefficientQuery = from c in customers
                       join o in orders on c.CustomerID equals o.CustomerID
                       where o.Amount > 100
                       select new { c.Name, o.Amount };

// More efficient - filtering first, then joining
var efficientQuery = from c in customers
                     join o in orders.Where(o => o.Amount > 100)
                     on c.CustomerID equals o.CustomerID
                     select new { c.Name, o.Amount };
```

## Summary

LINQ join operations provide powerful ways to combine data from multiple collections:

- **Inner joins** match elements with common keys from both collections
- **Group joins** combine and group related elements
- **Left joins** include all elements from the first collection with matching elements from the second
- **Cross joins** produce a Cartesian product of both collections

The ability to perform join operations directly in C# makes LINQ a powerful tool for working with related data across different collections. By understanding these join patterns, you can write clean, expressive code to manipulate and analyze complex data relationships.

## Exercises

To practice what you've learned about LINQ join operations:

1. Create a join between a `Students` collection and a `Courses` collection to display which students are enrolled in which courses.

2. Implement a left join between `Employees` and `Departments` to list all employees with their department names (or "No Department" if not assigned).

3. Use a group join to create a hierarchical view of `Products` grouped by `Categories`.

4. Create a cross join between product colors and sizes to generate a list of all possible combinations.

5. Optimize a join operation by first filtering the collections and using lookup tables.

## Additional Resources

- [Microsoft Documentation on LINQ Join Operations](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/join-operations)
- [C# in Depth: LINQ](https://csharpindepth.com/articles/LINQ)
- [101 LINQ Samples](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)

Happy coding with LINQ joins!