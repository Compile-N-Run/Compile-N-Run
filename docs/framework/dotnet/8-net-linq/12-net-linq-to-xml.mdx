---
title: ".NET LINQ to XML"
description: "Learn how to use LINQ to XML in .NET for efficient and intuitive XML document creation, parsing, and manipulation."

---

# LINQ to XML

## Introduction

LINQ to XML provides a modern, developer-friendly way to work with XML in .NET applications. It's a powerful in-memory XML programming interface that leverages Language Integrated Query (LINQ) capabilities to simplify creating, parsing, and manipulating XML documents. Unlike the traditional DOM (Document Object Model) approach, LINQ to XML offers a more intuitive programming model with better performance characteristics.

In this tutorial, we'll explore how LINQ to XML combines the power of LINQ with XML processing, making it easier to:

- Create XML documents and elements
- Query and transform XML data
- Modify XML content
- Navigate XML hierarchies

LINQ to XML is part of the `System.Xml.Linq` namespace and is available in all modern .NET implementations.

## LINQ to XML Basics

### The Core Classes

Before diving into examples, let's understand the key classes in LINQ to XML:

| Class | Description |
|-------|-------------|
| `XDocument` | Represents an XML document with declarations, root element, etc. |
| `XElement` | Represents an XML element with a name and content |
| `XAttribute` | Represents an XML attribute (name-value pair) |
| `XComment` | Represents an XML comment |
| `XText` | Represents text content within an element |
| `XNamespace` | Represents an XML namespace |

### Creating XML Documents

One of the most powerful aspects of LINQ to XML is its functional construction capability, allowing you to build XML documents in a declarative way.

```csharp
using System;
using System.Xml.Linq;

// Creating a simple XML document
XDocument document = new XDocument(
    new XDeclaration("1.0", "UTF-8", "yes"),
    new XComment("This is a sample XML document"),
    new XElement("Books",
        new XElement("Book",
            new XAttribute("Id", "1"),
            new XElement("Title", "LINQ in Action"),
            new XElement("Author", "Steve Smith"),
            new XElement("Price", 39.99)
        ),
        new XElement("Book",
            new XAttribute("Id", "2"),
            new XElement("Title", "C# Programming"),
            new XElement("Author", "John Doe"),
            new XElement("Price", 44.95)
        )
    )
);

// Display the XML document
Console.WriteLine(document.ToString());
```

The output will be:

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!--This is a sample XML document-->
<Books>
  <Book Id="1">
    <Title>LINQ in Action</Title>
    <Author>Steve Smith</Author>
    <Price>39.99</Price>
  </Book>
  <Book Id="2">
    <Title>C# Programming</Title>
    <Author>John Doe</Author>
    <Price>44.95</Price>
  </Book>
</Books>
```

Notice how the structure of the code resembles the resulting XML hierarchy, making it intuitive to understand.

### Loading XML

LINQ to XML makes it easy to load XML content from various sources:

```csharp
// Load from a string
string xmlString = "<Person><Name>Alice</Name><Age>30</Age></Person>";
XElement personFromString = XElement.Parse(xmlString);

// Load from a file
XDocument documentFromFile = XDocument.Load("books.xml");

// Load from a URL
XDocument documentFromWeb = XDocument.Load("https://example.com/data.xml");
```

## Querying XML with LINQ

The real power of LINQ to XML becomes apparent when we query XML data. Let's look at some examples using our books XML:

```csharp
XDocument document = XDocument.Load("books.xml");

// Query 1: Find all books with price less than 40
var affordableBooks = from book in document.Root.Elements("Book")
                     where (double)book.Element("Price") < 40
                     select new
                     {
                         Title = book.Element("Title").Value,
                         Price = (double)book.Element("Price")
                     };

Console.WriteLine("Books under $40:");
foreach (var book in affordableBooks)
{
    Console.WriteLine($"{book.Title}: ${book.Price}");
}

// Query 2: Find the most expensive book
var mostExpensive = document.Root.Elements("Book")
    .OrderByDescending(b => (double)b.Element("Price"))
    .First();

Console.WriteLine("\nMost expensive book:");
Console.WriteLine($"{mostExpensive.Element("Title").Value}: ${mostExpensive.Element("Price").Value}");

// Query 3: Get all book titles
var titles = document.Descendants("Title").Select(t => t.Value);

Console.WriteLine("\nAll book titles:");
foreach (var title in titles)
{
    Console.WriteLine(title);
}
```

Output:
```
Books under $40:
LINQ in Action: $39.99

Most expensive book:
C# Programming: $44.95

All book titles:
LINQ in Action
C# Programming
```

### Navigating the XML Hierarchy

LINQ to XML provides several methods to navigate through an XML document:

| Method | Description |
|--------|-------------|
| `Elements()` | Gets child elements with the specified name |
| `Element()` | Gets the first child element with the specified name |
| `Descendants()` | Gets all descendant elements with the specified name |
| `Ancestors()` | Gets ancestor elements with the specified name |
| `Attribute()` | Gets the attribute with the specified name |

```csharp
XDocument doc = XDocument.Load("books.xml");

// Get the root element
XElement root = doc.Root;
Console.WriteLine($"Root element: {root.Name}");

// Get all Book elements
IEnumerable<XElement> books = root.Elements("Book");
Console.WriteLine($"Number of books: {books.Count()}");

// Get all descendant elements named "Title"
IEnumerable<XElement> allTitles = doc.Descendants("Title");
Console.WriteLine($"Number of titles: {allTitles.Count()}");

// Get the first book's ID attribute
string firstBookId = root.Element("Book").Attribute("Id").Value;
Console.WriteLine($"First book ID: {firstBookId}");
```

## Modifying XML

LINQ to XML makes it easy to modify XML documents by adding, updating, or removing elements and attributes.

### Adding Elements and Attributes

```csharp
XDocument doc = XDocument.Load("books.xml");

// Add a new book
doc.Root.Add(
    new XElement("Book",
        new XAttribute("Id", "3"),
        new XElement("Title", "XML Fundamentals"),
        new XElement("Author", "Jane Smith"),
        new XElement("Price", 29.99)
    )
);

// Add a new attribute to all books
foreach (var book in doc.Descendants("Book"))
{
    book.Add(new XAttribute("Format", "Paperback"));
}

// Save the modified document
doc.Save("updated_books.xml");
```

### Updating XML Content

```csharp
XDocument doc = XDocument.Load("books.xml");

// Update the price of the first book
XElement firstBook = doc.Root.Elements("Book").First();
firstBook.Element("Price").Value = "42.99";

// Update multiple elements with LINQ
var expensiveBooks = from book in doc.Descendants("Book")
                    where (double)book.Element("Price") > 40
                    select book;

foreach (var book in expensiveBooks)
{
    book.Add(new XElement("Category", "Premium"));
}

doc.Save("updated_books.xml");
```

### Removing Elements and Attributes

```csharp
XDocument doc = XDocument.Load("books.xml");

// Remove the first book
doc.Root.Elements("Book").First().Remove();

// Remove all price elements
doc.Descendants("Price").Remove();

// Remove the Id attribute from all books
foreach (var book in doc.Descendants("Book"))
{
    book.Attribute("Id")?.Remove();
}

doc.Save("cleaned_books.xml");
```

## Real-World Examples

### Example 1: Parsing an RSS Feed

```csharp
using System;
using System.Xml.Linq;
using System.Linq;
using System.Net.Http;
using System.Threading.Tasks;

public class RssFeedReader
{
    public static async Task Main()
    {
        string feedUrl = "https://blogs.msdn.microsoft.com/dotnet/feed/";
        
        using (HttpClient client = new HttpClient())
        {
            string rssFeed = await client.GetStringAsync(feedUrl);
            XDocument doc = XDocument.Parse(rssFeed);
            
            // Define the RSS namespace
            XNamespace ns = "http://www.w3.org/2005/Atom";
            
            var posts = from item in doc.Descendants(ns + "entry")
                        select new
                        {
                            Title = item.Element(ns + "title").Value,
                            Published = DateTime.Parse(item.Element(ns + "published").Value),
                            Link = item.Elements(ns + "link")
                                      .Where(l => l.Attribute("rel").Value == "alternate")
                                      .First()
                                      .Attribute("href").Value
                        };
            
            Console.WriteLine("Latest blog posts:");
            foreach (var post in posts.Take(5))
            {
                Console.WriteLine($"- {post.Title}");
                Console.WriteLine($"  Published: {post.Published.ToShortDateString()}");
                Console.WriteLine($"  Link: {post.Link}");
                Console.WriteLine();
            }
        }
    }
}
```

### Example 2: Generating a Configuration File

```csharp
using System;
using System.Xml.Linq;
using System.IO;

public class ConfigGenerator
{
    public static void CreateAppConfig(string appName, string connectionString, string[] supportedLanguages)
    {
        XDocument config = new XDocument(
            new XDeclaration("1.0", "UTF-8", "yes"),
            new XElement("configuration",
                new XElement("appSettings",
                    new XElement("add", 
                        new XAttribute("key", "ApplicationName"),
                        new XAttribute("value", appName)
                    ),
                    new XElement("add",
                        new XAttribute("key", "Version"),
                        new XAttribute("value", "1.0.0")
                    ),
                    new XElement("add",
                        new XAttribute("key", "Environment"),
                        new XAttribute("value", "Development")
                    )
                ),
                new XElement("connectionStrings",
                    new XElement("add",
                        new XAttribute("name", "DefaultConnection"),
                        new XAttribute("connectionString", connectionString)
                    )
                ),
                new XElement("languages",
                    from lang in supportedLanguages
                    select new XElement("language", 
                        new XAttribute("code", lang)
                    )
                )
            )
        );
        
        config.Save("app.config");
        Console.WriteLine("Config file generated successfully.");
    }
    
    public static void Main()
    {
        CreateAppConfig(
            "MyAwesomeApp",
            "Server=myServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;",
            new[] { "en-US", "es-ES", "fr-FR", "de-DE" }
        );
    }
}
```

### Example 3: Processing Product Catalog

```csharp
using System;
using System.Xml.Linq;
using System.Linq;
using System.Globalization;

public class ProductCatalogProcessor
{
    public static void AnalyzeCatalog(string catalogPath)
    {
        XDocument catalog = XDocument.Load(catalogPath);

        // Get product categories
        var categories = catalog.Descendants("Category")
                              .Select(c => c.Attribute("Name").Value)
                              .Distinct();
        
        Console.WriteLine("Product Categories:");
        foreach (var category in categories)
            Console.WriteLine($"- {category}");
        
        // Calculate statistics by category
        Console.WriteLine("\nCategory Statistics:");
        foreach (var category in categories)
        {
            var products = from p in catalog.Descendants("Product")
                         where p.Parent.Attribute("Name").Value == category
                         select new
                         {
                             Name = p.Element("Name").Value,
                             Price = decimal.Parse(p.Element("Price").Value, CultureInfo.InvariantCulture)
                         };
            
            int count = products.Count();
            decimal avgPrice = products.Average(p => p.Price);
            decimal minPrice = products.Min(p => p.Price);
            decimal maxPrice = products.Max(p => p.Price);
            
            Console.WriteLine($"Category: {category}");
            Console.WriteLine($"  Product count: {count}");
            Console.WriteLine($"  Average price: ${avgPrice:F2}");
            Console.WriteLine($"  Price range: ${minPrice:F2} - ${maxPrice:F2}");
        }
        
        // Find products that need restocking
        var lowStockProducts = from p in catalog.Descendants("Product")
                             let stock = int.Parse(p.Element("Stock").Value)
                             where stock < 10
                             orderby stock
                             select new 
                             {
                                 Name = p.Element("Name").Value,
                                 Stock = stock,
                                 Category = p.Parent.Attribute("Name").Value
                             };
        
        Console.WriteLine("\nProducts that need restocking:");
        foreach (var product in lowStockProducts)
            Console.WriteLine($"- {product.Name} ({product.Category}): {product.Stock} left in stock");
    }
}
```

## Working with XML Namespaces

XML namespaces are a crucial part of many XML documents. LINQ to XML provides a clean way to work with namespaces:

```csharp
// Define namespaces
XNamespace ns = "http://example.org/books";
XNamespace isbn = "http://example.org/isbn";

// Create a document with namespaces
XDocument doc = new XDocument(
    new XElement(ns + "BookStore",
        new XAttribute(XNamespace.Xmlns + "isbn", isbn),
        new XElement(ns + "Book",
            new XAttribute(isbn + "code", "978-1-11111-111-1"),
            new XElement(ns + "Title", "Professional C#"),
            new XElement(ns + "Author", "John Smith")
        )
    )
);

Console.WriteLine(doc.ToString());

// Query with namespaces
var books = from b in doc.Descendants(ns + "Book")
            select new
            {
                Title = b.Element(ns + "Title").Value,
                ISBN = b.Attribute(isbn + "code").Value
            };

foreach (var book in books)
{
    Console.WriteLine($"{book.Title} - ISBN: {book.ISBN}");
}
```

Output:
```xml
<BookStore xmlns="http://example.org/books" xmlns:isbn="http://example.org/isbn">
  <Book isbn:code="978-1-11111-111-1">
    <Title>Professional C#</Title>
    <Author>John Smith</Author>
  </Book>
</BookStore>

Professional C# - ISBN: 978-1-11111-111-1
```

## Performance Considerations

LINQ to XML is designed to be more efficient than older XML APIs, but there are still some best practices to follow:

1. **Avoid repeated querying**: Store query results in variables rather than re-executing the same query multiple times.

2. **Use Element() for single elements**: When you need only one element, use `Element()` rather than `Elements().First()`.

3. **Consider XPath for complex queries**: For certain complex queries, using `XPathSelectElements()` might be more efficient.

4. **Lazy loading**: LINQ to XML uses deferred execution, so queries aren't executed until you iterate through the results.

5. **Large documents**: For very large XML documents, consider using `XmlReader` instead of loading the entire document into memory.

## Summary

LINQ to XML brings together the power of LINQ and XML processing, providing a modern and intuitive way to work with XML documents in .NET applications. We've covered:

- Creating XML documents and elements using functional construction
- Querying XML data using LINQ expressions
- Navigating XML hierarchies with methods like `Elements()`, `Descendants()`, etc.
- Modifying XML by adding, updating, or removing elements and attributes
- Working with XML namespaces
- Real-world examples of LINQ to XML in action

LINQ to XML is a significant improvement over older XML APIs in .NET, offering a cleaner syntax, better performance, and deeper integration with the .NET language features.

## Additional Resources

- [Microsoft Docs: LINQ to XML Overview](https://docs.microsoft.com/en-us/dotnet/standard/linq/linq-xml-overview)
- [Microsoft Docs: LINQ to XML vs. DOM](https://docs.microsoft.com/en-us/dotnet/standard/linq/linq-xml-vs-dom)
- [C# Corner: LINQ to XML Tutorial](https://www.c-sharpcorner.com/UploadFile/mahesh/linq-to-xml-in-C-Sharp/)

## Exercises

1. Create an XML document representing a music library with albums, artists, and songs.

2. Write a LINQ query to find all songs by a specific artist from an XML music catalog.

3. Create a program that reads an XML configuration file and allows users to update settings.

4. Write a function that takes an XML document containing product information and generates an HTML table.

5. Create a program that reads an RSS feed and displays the latest articles sorted by publication date.