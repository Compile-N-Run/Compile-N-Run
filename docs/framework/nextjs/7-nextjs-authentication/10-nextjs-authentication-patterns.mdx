---
title: Next.js Authentication Patterns
description: Learn about different authentication patterns in Next.js applications, from JWT to OAuth, session-based auth, and best practices for securing your app.

---

# Next.js Authentication Patterns

Authentication is a crucial aspect of modern web applications. In this guide, we'll explore various authentication patterns for Next.js applications, from basic strategies to more complex implementations, helping you choose the right approach for your project.

## Introduction to Authentication in Next.js

Authentication verifies a user's identity, ensuring they are who they claim to be. Next.js, as a React framework, provides various ways to implement authentication based on your application's needs. Whether you're building a simple blog or a complex application, understanding these patterns will help you secure your application effectively.

Before diving into specific patterns, it's important to understand that Next.js supports both server-side and client-side authentication approaches, each with its own benefits and trade-offs.

## Common Authentication Patterns

### 1. JWT (JSON Web Token) Authentication

JWT is one of the most popular authentication methods for modern web applications due to its stateless nature.

#### How JWT Works in Next.js

1. The user logs in with credentials
2. The server validates credentials and returns a JWT
3. The client stores the JWT (usually in localStorage or an HTTP-only cookie)
4. The JWT is sent with subsequent requests for authentication

#### Example Implementation

First, let's install the required packages:

```bash
npm install jsonwebtoken cookie
```

Here's a basic API route for handling login:

```javascript
// pages/api/login.js
import jwt from 'jsonwebtoken';
import cookie from 'cookie';

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { username, password } = req.body;
  
  // In a real application, you would validate against a database
  if (username === 'user' && password === 'password') {
    // Create the token
    const token = jwt.sign(
      { id: 1, username: username },
      process.env.JWT_SECRET,
      { expiresIn: '8h' }
    );

    // Set the cookie
    res.setHeader(
      'Set-Cookie',
      cookie.serialize('auth', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV !== 'development',
        maxAge: 8 * 60 * 60,
        sameSite: 'strict',
        path: '/',
      })
    );

    return res.status(200).json({ success: true });
  } else {
    return res.status(401).json({ success: false });
  }
}
```

Then, we can protect routes with a middleware approach:

```javascript
// lib/auth.js
import { verify } from 'jsonwebtoken';
import { parse } from 'cookie';

export function authenticated(fn) {
  return async (req, res) => {
    if (!req.headers.cookie) {
      return res.status(401).json({ message: 'Not authenticated' });
    }

    const { auth } = parse(req.headers.cookie);
    
    if (!auth) {
      return res.status(401).json({ message: 'Not authenticated' });
    }

    try {
      const verified = verify(auth, process.env.JWT_SECRET);
      req.user = verified;
      return await fn(req, res);
    } catch (err) {
      return res.status(401).json({ message: 'Invalid token' });
    }
  };
}
```

Now we can use this middleware in a protected API route:

```javascript
// pages/api/protected-route.js
import { authenticated } from '../../lib/auth';

export default authenticated(async (req, res) => {
  // This route is protected - only authenticated users can access it
  res.json({ message: 'This is protected data', user: req.user });
});
```

### 2. Session-Based Authentication

Session-based authentication uses server-side sessions to track users' authentication status.

#### How Session Authentication Works in Next.js

1. User logs in with credentials
2. Server creates a session with a unique ID
3. Session ID is stored in a cookie
4. Server validates the session ID on subsequent requests

#### Implementation with next-auth

[NextAuth.js](https://next-auth.js.org/) is a complete authentication solution for Next.js applications that makes implementing session-based auth straightforward:

```bash
npm install next-auth
```

First, set up NextAuth:

```javascript
// pages/api/auth/[...nextauth].js
import NextAuth from 'next-auth';
import Providers from 'next-auth/providers';

export default NextAuth({
  providers: [
    Providers.Credentials({
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      authorize: async (credentials) => {
        // Here you would validate against your database
        if (credentials.username === 'user' && credentials.password === 'password') {
          return { id: 1, name: 'John Doe', email: 'john@example.com' };
        } else {
          return null;
        }
      }
    }),
    // You can add more providers here
  ],
  session: {
    jwt: true,
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  callbacks: {
    async jwt(token, user) {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
    async session(session, token) {
      session.user.id = token.id;
      return session;
    },
  },
});
```

Using the authentication in a component:

```jsx
// components/ProtectedComponent.js
import { useSession, signIn } from 'next-auth/client';

export default function ProtectedComponent() {
  const [session, loading] = useSession();

  if (loading) {
    return <div>Loading...</div>;
  }
  
  if (!session) {
    return (
      <div>
        <p>You must be signed in to view this content</p>
        <button onClick={() => signIn()}>Sign in</button>
      </div>
    );
  }

  return (
    <div>
      <p>Welcome, {session.user.name}!</p>
      <p>This is protected content only visible to authenticated users.</p>
    </div>
  );
}
```

### 3. OAuth/Social Authentication

OAuth allows users to authenticate using their existing accounts from services like Google, Facebook, or GitHub.

#### Example with NextAuth.js

```javascript
// pages/api/auth/[...nextauth].js
import NextAuth from 'next-auth';
import Providers from 'next-auth/providers';

export default NextAuth({
  providers: [
    Providers.Google({
      clientId: process.env.GOOGLE_ID,
      clientSecret: process.env.GOOGLE_SECRET
    }),
    Providers.GitHub({
      clientId: process.env.GITHUB_ID,
      clientSecret: process.env.GITHUB_SECRET
    }),
    // Add other providers as needed
  ],
  // Database is optional - without it, data is stored in JWT
  database: process.env.DATABASE_URL,
});
```

Then create a sign-in page:

```jsx
// pages/signin.js
import { getProviders, signIn } from 'next-auth/client';

export default function SignIn({ providers }) {
  return (
    <div className="login-container">
      <h1>Sign In</h1>
      <div>
        {Object.values(providers).map((provider) => (
          <div key={provider.name} style={{ marginBottom: 10 }}>
            <button onClick={() => signIn(provider.id)}>
              Sign in with {provider.name}
            </button>
          </div>
        ))}
      </div>
    </div>
  );
}

export async function getServerSideProps() {
  const providers = await getProviders();
  return {
    props: { providers },
  };
}
```

### 4. Role-Based Access Control (RBAC)

RBAC extends basic authentication by assigning roles to users and controlling access based on these roles.

#### Implementation Example

```javascript
// lib/rbac.js
export const ROLES = {
  ADMIN: 'admin',
  USER: 'user',
  EDITOR: 'editor',
};

export function withRole(role) {
  return function(req, res, next) {
    if (!req.user) {
      return res.status(401).json({ message: 'Not authenticated' });
    }

    if (req.user.role !== role) {
      return res.status(403).json({ message: 'Not authorized' });
    }

    return next(req, res);
  };
}
```

Using the role-based middleware:

```javascript
// pages/api/admin/dashboard.js
import { authenticated } from '../../../lib/auth';
import { withRole, ROLES } from '../../../lib/rbac';

// Compose middleware for admin-only routes
const withAdminRole = (handler) => authenticated(withRole(ROLES.ADMIN)(handler));

export default withAdminRole(async (req, res) => {
  res.json({ message: 'Admin dashboard data', stats: { /* ... */ } });
});
```

## Best Practices for Next.js Authentication

1. **Use HttpOnly Cookies**: Store tokens in HTTP-only cookies to protect against XSS attacks.

```javascript
// Setting an HTTP-only cookie
res.setHeader(
  'Set-Cookie',
  cookie.serialize('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV !== 'development',
    maxAge: 60 * 60 * 24 * 7, // 1 week
    sameSite: 'strict',
    path: '/',
  })
);
```

2. **Implement CSRF Protection**: For cookie-based auth, use CSRF tokens to prevent cross-site request forgery.

3. **Secure API Routes**: Apply authentication middleware consistently across all protected API routes.

4. **Refresh Tokens**: Implement token refresh mechanisms to maintain user sessions securely.

```javascript
// Example token refresh function
async function refreshAccessToken(token) {
  try {
    // Call your refresh token endpoint
    const response = await fetch('/api/auth/refresh', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ refreshToken: token.refreshToken }),
    });

    const refreshedTokens = await response.json();

    if (!response.ok) {
      throw refreshedTokens;
    }

    return {
      ...token,
      accessToken: refreshedTokens.accessToken,
      accessTokenExpires: Date.now() + refreshedTokens.expiresIn * 1000,
      refreshToken: refreshedTokens.refreshToken ?? token.refreshToken,
    };
  } catch (error) {
    return {
      ...token,
      error: "RefreshAccessTokenError",
    };
  }
}
```

5. **Use Environment Variables**: Always store secrets and API keys in environment variables.

```javascript
// .env.local
JWT_SECRET=your_super_secret_key
GOOGLE_CLIENT_ID=your_google_client_id
```

## Authentication Strategies for Different Next.js Rendering Methods

### Authentication with Server-Side Rendering (SSR)

With SSR, you can check authentication on the server before rendering pages:

```javascript
// pages/profile.js
import { getSession } from 'next-auth/client';

export default function Profile({ user }) {
  return (
    <div>
      <h1>Profile</h1>
      <p>Name: {user.name}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}

export async function getServerSideProps(context) {
  const session = await getSession(context);
  
  if (!session) {
    return {
      redirect: {
        destination: '/api/auth/signin',
        permanent: false,
      },
    };
  }
  
  return {
    props: { user: session.user },
  };
}
```

### Authentication with Static Site Generation (SSG)

For static pages that need authentication, combine SSG with client-side verification:

```javascript
// pages/dashboard.js
import { useEffect, useState } from 'react';
import { useSession } from 'next-auth/client';
import { useRouter } from 'next/router';

export default function Dashboard() {
  const [session, loading] = useSession();
  const router = useRouter();
  const [content, setContent] = useState(null);
  
  useEffect(() => {
    if (!loading && !session) {
      router.push('/api/auth/signin');
    }
    
    if (session) {
      // Fetch data that requires authentication
      fetch('/api/dashboard-data')
        .then(res => res.json())
        .then(data => setContent(data));
    }
  }, [session, loading, router]);
  
  if (loading || !session) {
    return <div>Loading...</div>;
  }
  
  return (
    <div>
      <h1>Dashboard</h1>
      {content && <div>{/* Render content */}</div>}
    </div>
  );
}
```

## Summary

Authentication is a critical aspect of web application security. In Next.js, you have multiple patterns to choose from:

1. **JWT Authentication**: Stateless, simple to implement, but needs careful handling of token storage
2. **Session-based Authentication**: More traditional, with server-side state management
3. **OAuth/Social Authentication**: Leverages existing accounts from popular services
4. **Role-Based Access Control**: Extends basic auth with differentiated access levels

The best approach depends on your specific requirements, including security needs, application complexity, and user experience goals.

Libraries like NextAuth.js simplify many aspects of authentication implementation in Next.js applications, providing a secure foundation that's compatible with various authentication providers and strategies.

## Additional Resources

- [NextAuth.js Documentation](https://next-auth.js.org/)
- [Next.js Authentication Tutorial](https://nextjs.org/docs/authentication)
- [JWT.io](https://jwt.io/) - for learning more about JSON Web Tokens
- [Auth0 React SDK](https://auth0.com/docs/quickstart/spa/react) - for implementing Auth0 in Next.js

## Exercises

1. Implement a basic email/password authentication system using JWT in a Next.js application.
2. Create a protected route that only allows authenticated users to access.
3. Add social login (Google or GitHub) to your Next.js app using NextAuth.js.
4. Implement role-based access control that distinguishes between regular users and admins.
5. Create a password reset flow that allows users to reset their passwords securely.

By thoroughly understanding these authentication patterns, you'll be well-equipped to implement secure user authentication in any Next.js project.