---
title: Next.js Docker Deployment
description: Learn how to containerize and deploy your Next.js applications using Docker for consistent, scalable, and portable deployments.

---

# Next.js Docker Deployment

## Introduction

Docker has revolutionized how we deploy applications by providing a consistent environment across development, testing, and production. For Next.js applications, Docker offers an excellent way to package your application with all its dependencies into a standardized unit called a container.

In this guide, you'll learn how to containerize your Next.js application using Docker, allowing for consistent deployments across different environments. We'll cover creating Dockerfiles, optimizing builds for production, and implementing multi-stage builds to keep your containers lightweight and secure.

## Prerequisites

Before we begin, make sure you have:

1. A basic Next.js application
2. [Docker](https://docs.docker.com/get-docker/) installed on your machine
3. Basic familiarity with command line operations

## Understanding Docker Basics

Docker allows you to build, share, and run applications in containers. A container is a lightweight, standalone, executable package that includes everything needed to run an application: code, runtime, system tools, libraries, and settings.

Key Docker concepts:

- **Dockerfile**: A text document containing instructions to build a Docker image
- **Image**: A template for creating containers
- **Container**: A running instance of an image

## Creating a Basic Dockerfile for Next.js

Let's create a simple Dockerfile for a Next.js application:

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm install

COPY . .

RUN npm run build

EXPOSE 3000

CMD ["npm", "start"]
```

### Explanation:

1. `FROM node:18-alpine`: Uses the lightweight Alpine Linux-based Node.js image
2. `WORKDIR /app`: Sets the working directory inside the container
3. `COPY package.json package-lock.json ./`: Copies dependency files first (for better caching)
4. `RUN npm install`: Installs dependencies
5. `COPY . .`: Copies all application files
6. `RUN npm run build`: Builds the Next.js application
7. `EXPOSE 3000`: Documents that the container listens on port 3000
8. `CMD ["npm", "start"]`: Specifies the command to run when the container starts

## Creating a .dockerignore File

To avoid copying unnecessary files into your Docker image, create a `.dockerignore` file in your project root:

```
node_modules
.next
.git
.github
.vscode
Dockerfile
.dockerignore
README.md
```

This helps keep your Docker images smaller and build times faster.

## Building and Running Your Docker Container

Build your Docker image with the following command in your project directory:

```bash
docker build -t nextjs-app .
```

Once the build completes, run your containerized application:

```bash
docker run -p 3000:3000 nextjs-app
```

Now you can access your Next.js application at `http://localhost:3000`.

## Implementing a Multi-Stage Build for Production

For production deployments, we want to keep our Docker images as small as possible. Multi-stage builds help achieve this by using one container to build the application and another slimmer container to run it:

```dockerfile
# Build stage
FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM node:18-alpine AS runner
WORKDIR /app

ENV NODE_ENV production

# Add a non-root user to run the application
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs
USER nextjs

# Copy only necessary files from the build stage
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
```

### Important Note for Multi-Stage Builds

To use the standalone output mode, you need to modify your `next.config.js`:

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
}

module.exports = nextConfig
```

## Environment Variables in Docker

To pass environment variables to your Next.js application running in Docker, you can:

1. Add them to your Dockerfile using the `ENV` instruction:

```dockerfile
ENV DATABASE_URL=your_database_url
ENV API_KEY=your_api_key
```

2. Pass them when running the container:

```bash
docker run -p 3000:3000 -e DATABASE_URL=your_database_url -e API_KEY=your_api_key nextjs-app
```

3. Use a `.env.local` file and copy it to your Docker image (not recommended for secrets in production).

## Docker Compose for Development

For development environments with multiple services (like databases), Docker Compose is very helpful:

Create a `docker-compose.yml` file:

```yaml
version: '3'

services:
  nextjs:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - .:/app
      - /app/node_modules
      - /app/.next
    environment:
      - DATABASE_URL=postgres://user:password@db:5432/mydb
    depends_on:
      - db
  
  db:
    image: postgres:14
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: mydb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

And a simpler development Dockerfile (`Dockerfile.dev`):

```dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "run", "dev"]
```

Run it with:

```bash
docker-compose up
```

## Deploying to Production

Here are some options for deploying your Dockerized Next.js application:

### 1. Deploy to a Cloud Service

Most cloud providers support Docker containers:

- **AWS**: Use Elastic Container Service (ECS) or Elastic Kubernetes Service (EKS)
- **Google Cloud**: Use Google Kubernetes Engine (GKE) or Cloud Run
- **Azure**: Use Azure Kubernetes Service (AKS) or Azure Container Instances
- **DigitalOcean**: Use DigitalOcean App Platform or Kubernetes

### 2. Self-hosting with Docker Swarm or Kubernetes

For more control, you can deploy to your own servers using:

- Docker Swarm for simpler setups
- Kubernetes for more complex, scalable deployments

### Example: Deploying to DigitalOcean App Platform

1. Push your Docker image to Docker Hub:

```bash
docker build -t yourusername/nextjs-app:latest .
docker push yourusername/nextjs-app:latest
```

2. Create a new app on DigitalOcean App Platform
3. Select "Docker Hub" as the source
4. Enter your image name: `yourusername/nextjs-app:latest`
5. Configure environment variables and click "Launch App"

## Best Practices

1. **Use the official Node.js Alpine images** to keep containers small
2. **Implement multi-stage builds** to reduce final image size
3. **Don't run containers as root** for better security
4. **Cache dependencies** by copying package.json first
5. **Use a .dockerignore file** to exclude unnecessary files
6. **Set NODE_ENV=production** for production builds
7. **Properly handle environment variables** for different environments
8. **Scan your Docker images** for security vulnerabilities

## Troubleshooting Common Issues

### Application Not Accessible

If you can't access your application after running the container:

1. Check if the container is running: `docker ps`
2. Verify the port mapping: `-p 3000:3000`
3. Check container logs: `docker logs <container_id>`

### Build Errors

If your Docker build fails:

1. Check your Node.js version compatibility
2. Ensure you have enough disk space
3. Verify that all dependencies are available

### Performance Issues

If your containerized application is slow:

1. Allocate more resources to Docker
2. Optimize your Next.js build
3. Use production build flags

## Summary

In this guide, you've learned how to:

- Create a Dockerfile for your Next.js application
- Implement multi-stage builds for production
- Use Docker Compose for development environments
- Deploy your containerized Next.js application
- Apply best practices for Docker with Next.js

Containerizing your Next.js applications with Docker provides consistency, portability, and scalability across different environments. By following the techniques in this guide, you can create efficient, secure Docker images for your Next.js applications.

## Additional Resources

- [Official Next.js Docker Example](https://github.com/vercel/next.js/tree/canary/examples/with-docker)
- [Docker Documentation](https://docs.docker.com/)
- [Next.js Documentation on Deployment](https://nextjs.org/docs/deployment)
- [Docker Security Best Practices](https://docs.docker.com/develop/security-best-practices/)

## Exercises

1. Create a Docker image for an existing Next.js application and run it locally.
2. Modify the Dockerfile to implement a multi-stage build for production.
3. Set up Docker Compose with a Next.js app and a database of your choice.
4. Deploy your Dockerized Next.js application to a free tier of a cloud provider.
5. Benchmark the performance difference between your local development environment and the Dockerized application.