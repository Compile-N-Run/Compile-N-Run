---
title: Next.js Database Overview
description: A comprehensive introduction to database integration options in Next.js applications, covering SQL and NoSQL databases, ORM tools, and best practices for data persistence.

---

# Next.js Database Overview

In modern web applications, databases play a crucial role in storing, managing, and retrieving data efficiently. Next.js, as a powerful React framework, offers flexible options for integrating various databases into your applications. This guide will provide a comprehensive overview of database integration in Next.js.

## Introduction

Next.js doesn't come with a built-in database solution. This is actually a strength rather than a limitation, as it gives developers the freedom to choose the database technology that best fits their project requirements. Whether you prefer SQL databases like PostgreSQL and MySQL, or NoSQL solutions like MongoDB and Firebase, Next.js can seamlessly work with all of them.

The key to database integration in Next.js lies in understanding:
- Server-side vs. client-side data access
- Data fetching strategies
- API routes
- ORM and database drivers
- Environment configuration for database credentials

## Database Types Compatible with Next.js

### SQL Databases

SQL (Structured Query Language) databases use tables with predefined schemas to store data.

Popular SQL databases used with Next.js include:

- **PostgreSQL**: A powerful, open-source object-relational database system
- **MySQL**: An open-source relational database management system
- **SQLite**: A lightweight, file-based SQL database
- **SQL Server**: Microsoft's enterprise database solution

### NoSQL Databases

NoSQL databases provide more flexible schema designs and different data models.

Common NoSQL options for Next.js applications:

- **MongoDB**: A document-oriented database
- **Firebase**: Google's application development platform with real-time database
- **DynamoDB**: Amazon's key-value and document database
- **Redis**: In-memory data structure store used as database, cache, and message broker

## Database Access in Next.js

In Next.js applications, database access typically happens in one of these contexts:

1. **Server-side rendering (SSR)** using `getServerSideProps`
2. **Static site generation (SSG)** using `getStaticProps`
3. **API routes** for client-side requests
4. **Server Components** (in Next.js 13+ App Router)

Let's look at some examples of how to access a database in these contexts.

### Example: Database Access in API Routes

Here's how you might access a database in a Next.js API route:

```javascript
// pages/api/users.js
import { connectToDatabase } from '../../lib/db';

export default async function handler(req, res) {
  try {
    // Get database connection
    const db = await connectToDatabase();
    
    // Query the database
    const users = await db.collection('users').find({}).limit(20).toArray();
    
    // Return the data
    res.status(200).json(users);
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
}
```

### Example: Database Access in getServerSideProps

```javascript
// pages/users.js
import { connectToDatabase } from '../lib/db';

export default function Users({ users }) {
  return (
    <div>
      <h1>Users</h1>
      <ul>
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    </div>
  );
}

export async function getServerSideProps() {
  try {
    const db = await connectToDatabase();
    const users = await db.collection('users').find({}).limit(20).toArray();
    
    return {
      props: {
        users: JSON.parse(JSON.stringify(users)),
      },
    };
  } catch (error) {
    console.error('Database error:', error);
    return {
      props: {
        users: [],
      },
    };
  }
}
```

## ORM Tools for Next.js

Using an Object-Relational Mapping (ORM) tool can significantly simplify database operations in your Next.js application. Some popular options include:

### Prisma

Prisma is one of the most popular ORMs for Next.js applications. It provides:

- Type-safe database access
- Auto-generated migrations
- Support for multiple databases (PostgreSQL, MySQL, SQLite, SQL Server, MongoDB)
- A clean and intuitive API

Here's a basic example of using Prisma in a Next.js application:

```javascript
// lib/prisma.js
import { PrismaClient } from '@prisma/client';

let prisma;

if (process.env.NODE_ENV === 'production') {
  prisma = new PrismaClient();
} else {
  if (!global.prisma) {
    global.prisma = new PrismaClient();
  }
  prisma = global.prisma;
}

export default prisma;
```

And then in an API route:

```javascript
// pages/api/posts.js
import prisma from '../../lib/prisma';

export default async function handler(req, res) {
  if (req.method === 'GET') {
    try {
      const posts = await prisma.post.findMany({
        include: { author: true },
      });
      res.status(200).json(posts);
    } catch (error) {
      console.error('Request error', error);
      res.status(500).json({ error: 'Error fetching posts' });
    }
  } else {
    res.setHeader('Allow', ['GET']);
    res.status(405).json({ message: `Method ${req.method} Not Allowed` });
  }
}
```

### Mongoose (for MongoDB)

If you're using MongoDB, Mongoose is a popular ODM (Object Data Modeling) library that provides a schema-based solution:

```javascript
// lib/mongoose.js
import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI;

if (!MONGODB_URI) {
  throw new Error('Please define the MONGODB_URI environment variable');
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function connectToDatabase() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    cached.promise = mongoose.connect(MONGODB_URI).then((mongoose) => {
      return mongoose;
    });
  }
  
  cached.conn = await cached.promise;
  return cached.conn;
}

export default connectToDatabase;
```

### TypeORM

TypeORM is another excellent option for TypeScript-based Next.js applications:

```javascript
// lib/typeorm.js
import { createConnection, getConnection } from 'typeorm';
import { User } from '../entities/User';
import { Post } from '../entities/Post';

export async function getDbConnection() {
  try {
    return getConnection();
  } catch (e) {
    return createConnection({
      type: 'postgres',
      url: process.env.DATABASE_URL,
      entities: [User, Post],
      synchronize: process.env.NODE_ENV !== 'production',
    });
  }
}
```

## Database Configuration Best Practices

When integrating a database with Next.js, follow these best practices:

### 1. Environment Variables

Always store database credentials in environment variables:

```
// .env.local
DATABASE_URL=postgresql://username:password@localhost:5432/mydb
```

Access them in your code:

```javascript
const dbUrl = process.env.DATABASE_URL;
```

### 2. Connection Pooling

For production applications, implement connection pooling to efficiently manage database connections:

```javascript
// Example with pg (PostgreSQL) package
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});

export default pool;
```

### 3. Error Handling

Always implement proper error handling for database operations:

```javascript
async function fetchUsers() {
  try {
    const result = await db.query('SELECT * FROM users');
    return result.rows;
  } catch (error) {
    console.error('Database error:', error);
    // Consider logging to a monitoring service in production
    throw new Error('Failed to fetch users');
  }
}
```

## Real-World Example: Blog Application with Prisma and PostgreSQL

Let's build a simple blog API with Next.js, Prisma, and PostgreSQL:

1. First, set up Prisma with a schema:

```prisma
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

2. Create API endpoints for blog posts:

```javascript
// pages/api/posts/index.js
import prisma from '../../../lib/prisma';

export default async function handler(req, res) {
  switch (req.method) {
    case 'GET':
      return getPosts(req, res);
    case 'POST':
      return createPost(req, res);
    default:
      res.setHeader('Allow', ['GET', 'POST']);
      return res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}

// Get all posts
async function getPosts(req, res) {
  try {
    const posts = await prisma.post.findMany({
      include: {
        author: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    });
    
    return res.status(200).json(posts);
  } catch (error) {
    console.error('Request error', error);
    return res.status(500).json({ error: 'Error fetching posts' });
  }
}

// Create a new post
async function createPost(req, res) {
  const { title, content, authorId } = req.body;
  
  try {
    const post = await prisma.post.create({
      data: {
        title,
        content,
        author: { connect: { id: authorId } },
      },
    });
    
    return res.status(201).json(post);
  } catch (error) {
    console.error('Request error', error);
    return res.status(500).json({ error: 'Error creating post' });
  }
}
```

3. Single post endpoint:

```javascript
// pages/api/posts/[id].js
import prisma from '../../../lib/prisma';

export default async function handler(req, res) {
  const { id } = req.query;
  const postId = parseInt(id);
  
  if (isNaN(postId)) {
    return res.status(400).json({ error: 'Invalid post ID' });
  }
  
  switch (req.method) {
    case 'GET':
      return getPost(req, res, postId);
    case 'PUT':
      return updatePost(req, res, postId);
    case 'DELETE':
      return deletePost(req, res, postId);
    default:
      res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
      return res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}

async function getPost(req, res, id) {
  try {
    const post = await prisma.post.findUnique({
      where: { id },
      include: {
        author: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    });
    
    if (!post) {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    return res.status(200).json(post);
  } catch (error) {
    console.error('Request error', error);
    return res.status(500).json({ error: 'Error fetching post' });
  }
}

async function updatePost(req, res, id) {
  const { title, content, published } = req.body;
  
  try {
    const post = await prisma.post.update({
      where: { id },
      data: {
        title,
        content,
        published,
      },
    });
    
    return res.status(200).json(post);
  } catch (error) {
    console.error('Request error', error);
    return res.status(500).json({ error: 'Error updating post' });
  }
}

async function deletePost(req, res, id) {
  try {
    await prisma.post.delete({
      where: { id },
    });
    
    return res.status(204).end();
  } catch (error) {
    console.error('Request error', error);
    return res.status(500).json({ error: 'Error deleting post' });
  }
}
```

## Database Models vs. Frontend Models

It's important to distinguish between database models and frontend models in your Next.js application. You might want to transform your database entities before sending them to the frontend.

Example transformation function:

```javascript
function transformPostForClient(post) {
  return {
    id: post.id,
    title: post.title,
    content: post.content,
    authorName: post.author.name,
    publishedDate: post.createdAt.toISOString(),
    isPublished: post.published,
  };
}

// Use this when returning data to the client
const posts = await prisma.post.findMany({
  include: { author: true },
});
return res.status(200).json(posts.map(transformPostForClient));
```

## Summary

Next.js offers tremendous flexibility when it comes to database integration. Here's what we've learned:

- Next.js works with both SQL and NoSQL databases
- You can access databases from API routes, SSR, SSG, and Server Components
- ORM tools like Prisma, Mongoose, and TypeORM can simplify database interactions
- Best practices include using environment variables, connection pooling, and proper error handling
- Database operations should be performed server-side, either in API routes or data fetching methods
- Proper data transformation between database and client models is important

When choosing a database solution for your Next.js project, consider:

1. Your team's expertise
2. Project requirements (real-time updates, complex queries, etc.)
3. Scaling needs
4. Budget constraints
5. Hosting environment

## Additional Resources and Exercises

### Resources

- [Prisma Documentation](https://www.prisma.io/docs/)
- [MongoDB with Next.js Tutorial](https://www.mongodb.com/developer/languages/javascript/nextjs-with-mongodb/)
- [Next.js Database Best Practices](https://vercel.com/guides/nextjs-prisma-postgres)
- [TypeORM Documentation](https://typeorm.io/)
- [Supabase (PostgreSQL Backend as a Service)](https://supabase.io/docs/guides/with-nextjs)

### Exercises

1. **Basic Exercise**: Set up a simple Next.js application with Prisma and SQLite to create a "Todo" application with basic CRUD operations.

2. **Intermediate Exercise**: Build a blog application with user authentication using Next.js, Prisma, and PostgreSQL. Implement comment functionality.

3. **Advanced Exercise**: Create a real-time chat application using Next.js, MongoDB, and Socket.io that stores message history and supports private messaging.

4. **Challenge**: Implement a multi-tenant application where data is isolated between different users/organizations using database schemas or row-level security.

In the next section, we'll dive deeper into specific database integrations, starting with Prisma and PostgreSQL.