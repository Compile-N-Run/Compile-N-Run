---
title: Next.js Performance Monitoring
description: Learn how to monitor and analyze your Next.js application's performance to ensure optimal user experience.

---

# Next.js Performance Monitoring

## Introduction

Performance monitoring is a critical aspect of maintaining a successful Next.js application. By tracking key metrics and analyzing performance data, you can identify bottlenecks, optimize user experience, and ensure your application runs smoothly across different devices and network conditions.

In this guide, we'll explore various methods and tools for monitoring performance in Next.js applications, from built-in solutions to third-party integrations. You'll learn how to set up monitoring, interpret performance data, and make data-driven optimizations.

## Understanding Web Vitals

Before diving into monitoring tools, it's important to understand the key metrics you should be tracking. Google's Web Vitals are a set of quality signals that are essential to delivering a great user experience on the web.

### Core Web Vitals

- **Largest Contentful Paint (LCP)**: Measures loading performance. A good LCP is 2.5 seconds or less.
- **First Input Delay (FID)**: Measures interactivity. A good FID is 100 milliseconds or less.
- **Cumulative Layout Shift (CLS)**: Measures visual stability. A good CLS is 0.1 or less.

### Other Important Metrics

- **First Contentful Paint (FCP)**: Time until the first content appears.
- **Time to Interactive (TTI)**: Time until the page becomes fully interactive.
- **Total Blocking Time (TBT)**: Sum of time periods between FCP and TTI where the main thread was blocked.

## Built-in Performance Monitoring in Next.js

Next.js comes with built-in performance monitoring capabilities that make it easy to track Web Vitals.

### Using the reportWebVitals Function

Next.js provides a `reportWebVitals` function that you can use to track and analyze Web Vitals metrics.

First, create or modify your `_app.js` file:

```jsx
// pages/_app.js
export function reportWebVitals(metric) {
  console.log(metric);
}

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}

export default MyApp;
```

This will log performance metrics to the console. The `metric` object contains:

- `id`: Unique identifier for the metric
- `name`: Name of the metric
- `startTime`: When the metric started
- `value`: The actual value of the metric
- `label`: The type of metric ('web-vital' or 'custom')

### Sending Metrics to an Analytics Service

Instead of just logging metrics, you can send them to an analytics service for better visualization and analysis:

```jsx
// pages/_app.js
export function reportWebVitals(metric) {
  const { id, name, label, value } = metric;
  
  // Example: Send to Google Analytics
  window.gtag('event', name, {
    event_category: label === 'web-vital' ? 'Web Vitals' : 'Next.js custom metric',
    event_label: id,
    value: Math.round(name === 'CLS' ? value * 1000 : value), // CLS values need to be multiplied
    non_interaction: true,
  });
}

function MyApp({ Component, pageProps }) {
  return <Component {...pageProps} />;
}

export default MyApp;
```

## Setting Up Performance Monitoring with Third-Party Services

While Next.js's built-in capabilities are useful, third-party services can provide more comprehensive insights.

### Vercel Analytics

If you're deploying on Vercel (the creators of Next.js), you can use Vercel Analytics with minimal setup:

1. Install the required package:

```bash
npm install @vercel/analytics
# or
yarn add @vercel/analytics
```

2. Add the Analytics component to your application:

```jsx
// pages/_app.js
import { Analytics } from '@vercel/analytics/react';

function MyApp({ Component, pageProps }) {
  return (
    <>
      <Component {...pageProps} />
      <Analytics />
    </>
  );
}

export default MyApp;
```

### Google Analytics

To use Google Analytics for performance monitoring:

1. Set up Google Analytics for your website
2. Add the tracking code to your Next.js application
3. Send Web Vitals data to Google Analytics

```jsx
// pages/_app.js
import Script from 'next/script';
import { useEffect } from 'react';
import { useRouter } from 'next/router';

// Your Google Analytics measurement ID
const GA_MEASUREMENT_ID = 'G-XXXXXXXXXX';

export function reportWebVitals({ id, name, label, value }) {
  window.gtag('event', name, {
    event_category: label === 'web-vital' ? 'Web Vitals' : 'Next.js custom metric',
    value: Math.round(name === 'CLS' ? value * 1000 : value),
    event_label: id,
    non_interaction: true,
  });
}

function MyApp({ Component, pageProps }) {
  const router = useRouter();
  
  useEffect(() => {
    // Track page views when the route changes
    const handleRouteChange = (url) => {
      window.gtag('config', GA_MEASUREMENT_ID, {
        page_path: url,
      });
    };
    
    router.events.on('routeChangeComplete', handleRouteChange);
    return () => {
      router.events.off('routeChangeComplete', handleRouteChange);
    };
  }, [router.events]);

  return (
    <>
      {/* Global Site Tag (gtag.js) - Google Analytics */}
      <Script
        strategy="afterInteractive"
        src={`https://www.googletagmanager.com/gtag/js?id=${GA_MEASUREMENT_ID}`}
      />
      <Script
        id="gtag-init"
        strategy="afterInteractive"
        dangerouslySetInnerHTML={{
          __html: `
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', '${GA_MEASUREMENT_ID}', {
              page_path: window.location.pathname,
            });
          `,
        }}
      />
      <Component {...pageProps} />
    </>
  );
}

export default MyApp;
```

### Lighthouse CI

For automated performance testing during your CI/CD process, you can use Lighthouse CI:

1. Install Lighthouse CI:

```bash
npm install -g @lhci/cli
```

2. Create a `lighthouserc.js` configuration file:

```js
// lighthouserc.js
module.exports = {
  ci: {
    collect: {
      startServerCommand: 'npm run start',
      url: ['http://localhost:3000/'],
      numberOfRuns: 3,
    },
    upload: {
      target: 'temporary-public-storage',
    },
  },
};
```

3. Add a script to your `package.json`:

```json
{
  "scripts": {
    "build": "next build",
    "start": "next start",
    "lhci": "lhci autorun"
  }
}
```

4. Run Lighthouse CI after your build:

```bash
npm run build
npm run lhci
```

## Creating a Custom Performance Dashboard

For more customized monitoring, you can build your own dashboard to visualize performance metrics.

### Example: Basic Dashboard Component

```jsx
// components/PerformanceMetrics.js
import { useState, useEffect } from 'react';
import styles from './PerformanceMetrics.module.css';

export default function PerformanceMetrics() {
  const [metrics, setMetrics] = useState({
    LCP: null,
    FID: null,
    CLS: null,
    FCP: null,
  });

  useEffect(() => {
    // Set up performance observers
    if (typeof window !== 'undefined') {
      // Load web-vitals library dynamically
      import('web-vitals').then(({ getCLS, getFID, getLCP, getFCP }) => {
        getCLS((metric) => {
          setMetrics((prev) => ({ ...prev, CLS: metric.value }));
        });
        getFID((metric) => {
          setMetrics((prev) => ({ ...prev, FID: metric.value }));
        });
        getLCP((metric) => {
          setMetrics((prev) => ({ ...prev, LCP: metric.value }));
        });
        getFCP((metric) => {
          setMetrics((prev) => ({ ...prev, FCP: metric.value }));
        });
      });
    }
  }, []);

  // Helper function to determine if a metric is good, needs improvement, or poor
  const getMetricStatus = (metric, value) => {
    if (value === null) return 'pending';
    
    switch (metric) {
      case 'LCP':
        return value <= 2500 ? 'good' : value <= 4000 ? 'needs-improvement' : 'poor';
      case 'FID':
        return value <= 100 ? 'good' : value <= 300 ? 'needs-improvement' : 'poor';
      case 'CLS':
        return value <= 0.1 ? 'good' : value <= 0.25 ? 'needs-improvement' : 'poor';
      case 'FCP':
        return value <= 1800 ? 'good' : value <= 3000 ? 'needs-improvement' : 'poor';
      default:
        return 'pending';
    }
  };

  return (
    <div className={styles.dashboard}>
      <h2>Real-time Performance Metrics</h2>
      <div className={styles.metrics}>
        {Object.entries(metrics).map(([metric, value]) => (
          <div 
            key={metric} 
            className={`${styles.metric} ${styles[getMetricStatus(metric, value)]}`}
          >
            <h3>{metric}</h3>
            <p>{value !== null ? (metric === 'CLS' ? value.toFixed(3) : `${value.toFixed(0)}ms`) : 'Loading...'}</p>
          </div>
        ))}
      </div>
    </div>
  );
}
```

```css
/* components/PerformanceMetrics.module.css */
.dashboard {
  background-color: #f5f5f5;
  border-radius: 8px;
  padding: 20px;
  margin: 20px 0;
}

.metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}

.metric {
  padding: 16px;
  border-radius: 6px;
  text-align: center;
}

.good {
  background-color: #d4edda;
  color: #155724;
}

.needs-improvement {
  background-color: #fff3cd;
  color: #856404;
}

.poor {
  background-color: #f8d7da;
  color: #721c24;
}

.pending {
  background-color: #e2e3e5;
  color: #383d41;
}
```

Then you can include this component on your pages:

```jsx
// pages/index.js
import PerformanceMetrics from '../components/PerformanceMetrics';

export default function Home() {
  return (
    <div>
      <h1>Welcome to My Next.js App</h1>
      <p>This is the homepage content...</p>
      
      {/* Only show in development */}
      {process.env.NODE_ENV === 'development' && <PerformanceMetrics />}
    </div>
  );
}
```

## Real-world Case Study: Identifying and Fixing Performance Issues

Let's walk through a real-world example of identifying and solving a performance issue using monitoring tools.

### The Problem

Imagine you've launched a Next.js e-commerce site, and your monitoring tools show that the product listing page has a poor LCP score of 4.5 seconds.

### Diagnosis

1. Using Lighthouse, you identify that large, unoptimized images are causing the slow LCP.
2. Your monitoring dashboard shows that the issue is particularly bad on mobile devices.

### Solution

1. Implement Next.js Image Optimization:

```jsx
// Before
<img src="/product-image.jpg" alt="Product" />

// After
import Image from 'next/image';

<Image 
  src="/product-image.jpg"
  alt="Product"
  width={800}
  height={600}
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,/9j/4AAQSkZJRg..."
  priority={true}
/>
```

2. Implement lazy loading for below-the-fold images

3. Add responsive image sizes:

```jsx
<Image 
  src="/product-image.jpg"
  alt="Product"
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  fill
  style={{ objectFit: 'cover' }}
/>
```

4. Preload critical images:

```jsx
// pages/_document.js
import { Html, Head, Main, NextScript } from 'next/document';

export default function Document() {
  return (
    <Html>
      <Head>
        <link 
          rel="preload" 
          href="/product-hero.jpg" 
          as="image" 
        />
      </Head>
      <body>
        <Main />
        <NextScript />
      </body>
    </Html>
  );
}
```

### Results

After implementing these optimizations and deploying the changes:

1. LCP improved from 4.5s to 1.8s (a 60% improvement)
2. Conversion rate increased by 15%
3. Bounce rate decreased by 20%

This case study demonstrates how performance monitoring can help identify issues and measure the impact of optimizations.

## Best Practices for Performance Monitoring

To get the most out of your performance monitoring:

1. **Monitor consistently**: Set up regular monitoring schedules, not just one-time audits.

2. **Test on multiple devices and networks**: Performance can vary greatly between desktop and mobile, or fast and slow connections.

3. **Set performance budgets**: Define acceptable thresholds for each metric and automatically alert when they're exceeded.

4. **Segment your data**: Analyze performance by device type, location, browser, and other relevant factors.

5. **Focus on real user metrics**: While lab data (like Lighthouse) is useful, real user metrics (RUM) provide insights into actual user experiences.

6. **Correlate with business metrics**: Connect performance data with conversion rates, bounce rates, and other business KPIs.

7. **Monitor after deploys**: Automatically test performance after each deployment to catch regressions.

## Summary

Performance monitoring is an essential practice for maintaining high-quality Next.js applications. In this guide, we've explored:

- Understanding key performance metrics like Web Vitals
- Using Next.js's built-in reportWebVitals function
- Integrating with third-party analytics services
- Setting up automated testing with Lighthouse CI
- Building custom performance dashboards
- Applying monitoring insights to solve real-world performance issues

By implementing these monitoring strategies, you can ensure your Next.js application delivers an excellent user experience, which often translates to better engagement, higher conversion rates, and improved SEO rankings.

## Additional Resources

- [Next.js Documentation on Web Vitals](https://nextjs.org/docs/advanced-features/measuring-performance)
- [Google Web Vitals](https://web.dev/vitals/)
- [Lighthouse Documentation](https://github.com/GoogleChrome/lighthouse)
- [Vercel Analytics Documentation](https://vercel.com/docs/concepts/analytics)

## Exercises

1. Set up basic Web Vitals reporting in a Next.js application and log the values to the console.

2. Create a custom dashboard to visualize Core Web Vitals in real-time.

3. Set up performance monitoring with a third-party service like Google Analytics or Vercel Analytics.

4. Use Lighthouse CI to automate performance testing in your CI/CD pipeline.

5. Analyze a slow-loading page in your Next.js application, identify the bottlenecks using performance monitoring tools, and implement optimizations.