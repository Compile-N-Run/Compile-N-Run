---
title: Next.js Code Splitting
description: Learn how Next.js automatically splits your code to optimize loading times and improve application performance for a better user experience.

---

# Next.js Code Splitting

## Introduction

Code splitting is a crucial performance optimization technique that allows your application to load only the JavaScript code needed for the current page, rather than loading all of your application's code at once. Next.js implements this functionality automatically, which is one of the key reasons why Next.js applications tend to perform well out of the box.

In this tutorial, we'll explore:

- What code splitting is and why it matters
- How Next.js implements automatic code splitting
- Manual code splitting using dynamic imports
- Best practices for optimizing your Next.js application

## Understanding Code Splitting

### What is Code Splitting?

Code splitting is the process of dividing your JavaScript bundle into smaller chunks that can be loaded on demand. Instead of sending your entire application to the user at once, code splitting allows you to send only what's necessary for the current view.

### Why Code Splitting Matters

Without code splitting, your users would need to download your entire application before they can interact with it, leading to:

- Longer initial page load times
- Wasted bandwidth downloading code that might never be used
- Poorer user experience, especially on slower connections or less powerful devices

## Automatic Code Splitting in Next.js

One of Next.js's most powerful features is that it implements code splitting automatically based on your application's structure.

### Page-Based Code Splitting

Next.js automatically splits your code at the page level. When a user visits a specific page, they only download the code required for that page.

For example, if you have the following pages in your application:

```jsx
// pages/index.js
export default function Home() {
  return <h1>Welcome to the Homepage!</h1>;
}

// pages/about.js
export default function About() {
  return <h1>About Us</h1>;
}
```

Next.js will create separate bundles for each page. When a user visits `/`, they only download the code for the homepage. The code for the About page remains unloaded until the user navigates to `/about`.

### Shared Code Bundles

Next.js is also smart about code that's shared between pages. It automatically creates:

1. A main bundle containing the framework code shared across all pages
2. Individual page bundles containing page-specific code
3. Shared chunk bundles for code used across multiple (but not all) pages

This ensures optimal loading without duplicating code across bundles.

## Manual Code Splitting with Dynamic Imports

While Next.js handles page-level code splitting automatically, you can also implement more granular code splitting using dynamic imports.

### Using `next/dynamic`

Next.js provides a `dynamic` function that wraps React's `lazy` and `Suspense` features, making it easy to dynamically import components:

```jsx
import dynamic from 'next/dynamic';

// Instead of importing directly:
// import HeavyComponent from '../components/HeavyComponent';

// Use dynamic import:
const HeavyComponent = dynamic(() => import('../components/HeavyComponent'), {
  loading: () => <p>Loading...</p>,
});

export default function Page() {
  return (
    <div>
      <h1>My Page</h1>
      <HeavyComponent />
    </div>
  );
}
```

In this example, `HeavyComponent` will only be loaded when it's actually needed, not when the page initially loads.

### Practical Use Cases for Dynamic Imports

1. **Heavy third-party libraries**: If you're using a large library that's only needed in specific circumstances.

```jsx
const Chart = dynamic(() => import('react-chartjs-2').then((mod) => mod.Line), {
  loading: () => <p>Loading Chart...</p>,
  ssr: false, // Disable server-side rendering for components with browser-only APIs
});
```

2. **Conditionally rendered components**: For components that are only shown based on user interaction.

```jsx
function ProductPage() {
  const [showReviews, setShowReviews] = useState(false);
  
  // Reviews component is only loaded if the user clicks to show reviews
  const ReviewSection = dynamic(() => import('../components/ReviewSection'));
  
  return (
    <div>
      <h1>Product Details</h1>
      <button onClick={() => setShowReviews(!showReviews)}>
        {showReviews ? 'Hide Reviews' : 'Show Reviews'}
      </button>
      
      {showReviews && <ReviewSection productId="123" />}
    </div>
  );
}
```

## Real-World Example: Building an E-commerce Dashboard

Let's see how code splitting can be applied in a real-world scenario—an e-commerce admin dashboard with multiple features.

```jsx
// pages/admin/dashboard.js
import { useState } from 'react';
import dynamic from 'next/dynamic';
import DashboardLayout from '../../components/DashboardLayout';

// Dynamically import heavy components
const SalesChart = dynamic(() => import('../../components/SalesChart'), {
  loading: () => <div className="chart-placeholder">Loading sales data...</div>,
});

const InventoryManager = dynamic(() => import('../../components/InventoryManager'));
const CustomerAnalytics = dynamic(() => import('../../components/CustomerAnalytics'));

export default function AdminDashboard() {
  const [activeTab, setActiveTab] = useState('sales');
  
  return (
    <DashboardLayout>
      <h1>Admin Dashboard</h1>
      
      <div className="dashboard-tabs">
        <button 
          className={activeTab === 'sales' ? 'active' : ''} 
          onClick={() => setActiveTab('sales')}
        >
          Sales
        </button>
        <button 
          className={activeTab === 'inventory' ? 'active' : ''} 
          onClick={() => setActiveTab('inventory')}
        >
          Inventory
        </button>
        <button 
          className={activeTab === 'customers' ? 'active' : ''} 
          onClick={() => setActiveTab('customers')}
        >
          Customer Analytics
        </button>
      </div>
      
      <div className="dashboard-content">
        {activeTab === 'sales' && <SalesChart />}
        {activeTab === 'inventory' && <InventoryManager />}
        {activeTab === 'customers' && <CustomerAnalytics />}
      </div>
    </DashboardLayout>
  );
}
```

In this example, we've implemented a tabbed interface where each tab loads different heavyweight components. By using dynamic imports, we ensure that:

1. The initial page loads quickly with just the framework and UI skeleton
2. Each tab's component is only loaded when the user clicks on that tab
3. The user doesn't need to wait for all features to load before interacting with the dashboard

## Code Splitting Best Practices

To get the most out of Next.js code splitting:

### 1. Structure Your Application Logically

Organize your code in a way that naturally aligns with how users navigate through your application. This helps Next.js create efficient bundle splits.

### 2. Be Strategic with Dynamic Imports

Not everything needs to be dynamically imported. Consider these factors:

- **Size**: Is the component or library large enough to warrant separate loading?
- **Usage frequency**: Is this code needed on every page or just occasionally?
- **User experience**: Would showing a loading indicator disrupt the flow?

### 3. Analyze Your Bundle Size

Use tools like `@next/bundle-analyzer` to visualize your bundle sizes:

```jsx
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
  // your Next.js config
});
```

Then run your analysis with:

```bash
ANALYZE=true npm run build
```

### 4. Leverage the `loading` Prop for Better UX

Always provide meaningful loading states when dynamically importing components:

```jsx
const ComplexForm = dynamic(() => import('../components/ComplexForm'), {
  loading: () => <FormSkeleton />, // A lightweight placeholder UI
});
```

## Summary

Code splitting is a powerful performance optimization technique that Next.js handles automatically for page-level components, while also providing tools for more granular control through dynamic imports. By understanding and leveraging these features, you can create Next.js applications that are fast to load and provide an excellent user experience.

The key benefits of code splitting in Next.js include:

- Faster initial page loads
- Reduced bandwidth consumption
- Better performance on mobile and low-power devices
- Improved user experience through progressive loading

## Additional Resources

- [Next.js Documentation on Dynamic Imports](https://nextjs.org/docs/advanced-features/dynamic-import)
- [Web.dev Guide to Code Splitting](https://web.dev/reduce-javascript-payloads-with-code-splitting/)
- [React Documentation on Code Splitting](https://reactjs.org/docs/code-splitting.html)

## Exercises

1. **Analyze an existing application**: Use `@next/bundle-analyzer` to analyze the bundle size of a Next.js application you're working on. Identify the largest chunks and consider how you might optimize them.

2. **Optimize a heavy third-party dependency**: Find a large third-party library in your project and implement dynamic loading so it's only loaded when needed.

3. **Create a tabbed interface**: Build a tabbed interface similar to the e-commerce dashboard example, using dynamic imports to load tab content only when selected.

4. **Compare performance**: Create two versions of the same feature—one with code splitting and one without—and measure the difference in load time and bundle size.