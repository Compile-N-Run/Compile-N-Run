---
title: Next.js Bundle Analysis
description: Learn how to analyze and optimize your Next.js application bundles to improve performance

---

# Next.js Bundle Analysis

When building modern web applications with Next.js, understanding and optimizing your JavaScript bundles is crucial for delivering a fast user experience. In this guide, we'll dive into bundle analysis - a technique to examine what makes up your application's JavaScript bundles and how to optimize them.

## Introduction to Bundle Analysis

Bundle analysis is the process of examining the contents, size, and composition of the JavaScript files (bundles) that are delivered to the browser when a user visits your Next.js application. These bundles contain all the JavaScript code necessary for your application to run, including your own code and third-party libraries.

Why is this important? Because:
- Larger bundles take longer to download
- Larger bundles take longer to parse and execute
- Every kilobyte matters for users on slow networks or less powerful devices

## Built-in Bundle Analysis in Next.js

Next.js comes with built-in support for analyzing your application's bundles. Let's explore how to use this feature.

### Setting Up Bundle Analysis

To enable bundle analysis in your Next.js project, you need to install the `@next/bundle-analyzer` package:

```bash
npm install @next/bundle-analyzer
# or
yarn add @next/bundle-analyzer
```

Next, update your `next.config.js` file to use this package:

```javascript
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
})

module.exports = withBundleAnalyzer({
  // Your existing Next.js configuration
})
```

Now, you can run your application in analysis mode:

```bash
# For npm
ANALYZE=true npm run build

# For Windows PowerShell
$env:ANALYZE="true"; npm run build

# For yarn
ANALYZE=true yarn build
```

### Understanding the Output

When you run the analysis, it will generate visual reports using tools like [webpack-bundle-analyzer](https://github.com/webpack-contrib/webpack-bundle-analyzer). Two HTML files will be created:

1. `client.html` - analyzes client-side bundles
2. `server.html` - analyzes server-side bundles

These reports will open automatically in your browser, showing interactive treemap visualizations of your bundle contents.

![Bundle Analyzer Output Example](https://user-images.githubusercontent.com/4060187/61944932-31ebd300-af63-11e9-94fb-24fe0393c064.png)

The visualization represents:
- **Each rectangle**: A module or package
- **Size of rectangle**: Relative file size
- **Color**: File type or category

## Interpreting Bundle Analysis Results

Let's understand what to look for in these reports:

### 1. Large Dependencies

Look for large rectangles in the visualization. These represent the heaviest packages in your bundle. Common culprits include:

- Date libraries (like moment.js)
- UI component libraries
- Icon packs
- Utility libraries

### 2. Duplicate Packages

Sometimes you might have multiple versions of the same library. This often happens when:
- Different dependencies require different versions
- You're mixing import methods
- You have nested dependencies

### 3. Unused Code

Bundle analysis can reveal code that might not be necessary for your application.

## Optimizing Your Bundles

Based on your analysis, here are strategies to optimize your bundles:

### 1. Remove Unnecessary Dependencies

If you notice a large dependency that's only used in a small part of your application, consider:

```javascript
// Before: Importing the entire library
import moment from 'moment';
const formattedDate = moment().format('MMMM Do YYYY');

// After: Using a lighter alternative
import { format } from 'date-fns';
const formattedDate = format(new Date(), 'MMMM do yyyy');
```

### 2. Dynamic Imports for Code Splitting

Use dynamic imports to load code only when needed:

```javascript
// Before: Static import loads with the main bundle
import { Chart } from 'heavy-chart-library';

// After: Dynamic import loads only when used
import dynamic from 'next/dynamic';
const Chart = dynamic(
  () => import('heavy-chart-library').then((mod) => mod.Chart),
  { ssr: false } // If the component uses browser APIs
);
```

### 3. Replace Heavy Libraries

Consider lighter alternatives:

```javascript
// Before: Using a full-featured date library
import moment from 'moment';

// After: Using a more focused library
import { format } from 'date-fns';
// Or for simple cases, use built-in JavaScript:
const date = new Date().toLocaleDateString();
```

## Real-World Example: Optimizing a Dashboard

Let's look at a practical example of optimizing a Next.js dashboard application.

### Initial Bundle Analysis

After running bundle analysis on our dashboard, we notice:

1. Large bundle size (2.5MB total)
2. Chart.js taking up 450KB
3. Moment.js and its locales taking 320KB
4. Material UI components at 600KB

### Optimization Steps

Let's implement optimizations:

#### 1. Replace Moment.js with date-fns

```javascript
// pages/dashboard/stats.js - BEFORE
import moment from 'moment';

export default function StatsPage() {
  return (
    <div>
      <p>Last updated: {moment().format('MMMM Do YYYY, h:mm:ss a')}</p>
      {/* rest of component */}
    </div>
  );
}

// pages/dashboard/stats.js - AFTER
import { format } from 'date-fns';

export default function StatsPage() {
  return (
    <div>
      <p>Last updated: {format(new Date(), 'MMMM do yyyy, h:mm:ss a')}</p>
      {/* rest of component */}
    </div>
  );
}
```

#### 2. Dynamically Load Charts

```javascript
// pages/dashboard/charts.js - BEFORE
import { LineChart, BarChart } from 'chart-library';

export default function ChartsPage() {
  return (
    <div>
      <h1>Dashboard Charts</h1>
      <LineChart data={lineData} />
      <BarChart data={barData} />
    </div>
  );
}

// pages/dashboard/charts.js - AFTER
import dynamic from 'next/dynamic';

const LineChart = dynamic(() => import('chart-library').then(mod => mod.LineChart), {
  loading: () => <p>Loading chart...</p>,
  ssr: false
});

const BarChart = dynamic(() => import('chart-library').then(mod => mod.BarChart), {
  loading: () => <p>Loading chart...</p>,
  ssr: false
});

export default function ChartsPage() {
  return (
    <div>
      <h1>Dashboard Charts</h1>
      <LineChart data={lineData} />
      <BarChart data={barData} />
    </div>
  );
}
```

#### 3. Selective Material UI Imports

```javascript
// BEFORE
import { Button, TextField, Card, Table, /* many more */ } from '@mui/material';

// AFTER - Import only what you need
import Button from '@mui/material/Button';
import TextField from '@mui/material/TextField';
import Card from '@mui/material/Card';
```

### Results After Optimization

After implementing these changes and running bundle analysis again:

- Bundle size reduced from 2.5MB to 1.2MB
- Initial load time decreased by 60%
- Time to interactive improved by 45%

## Advanced Bundle Analysis Techniques

### 1. Analyzing First Load JS

First Load JS represents the JavaScript that loads immediately when a user visits your page. This is critical for initial page load performance.

You can see this metric in the Next.js build output:

```
Route                Size     First Load JS
┌ ○ /                3.45 kB        67.9 kB
├   └ css/d14a81af2f5db265.css      267 B
├   └ css/4dfbfe9715e8e941.css      195 B
└ ○ /about           3.51 kB        68 kB
    └ css/e114138d247e5a9a.css      204 B
+ First Load JS shared by all        64.4 kB
  ├ chunks/framework-2c79e2a64abdb08b.js 45.4 kB
  ├ chunks/main-0ecb9ccfcb6a9b24.js 18.2 kB
  └ other shared chunks             817 B
```

### 2. Using Source Maps for Detailed Analysis

Enable source maps in production builds for more detailed analysis:

```javascript
// next.config.js
module.exports = {
  productionBrowserSourceMaps: true,
  // other config
}
```

### 3. Custom Webpack Configuration

For more advanced cases, you might need to customize the webpack configuration:

```javascript
// next.config.js
module.exports = {
  webpack: (config, { isServer }) => {
    // Example: Ignore specific large modules in specific environments
    if (!isServer) {
      config.plugins.push(
        new webpack.IgnorePlugin({
          resourceRegExp: /^\.\/locale$/,
          contextRegExp: /moment$/,
        })
      );
    }
    
    return config;
  },
}
```

## Summary

Bundle analysis is an essential technique for optimizing Next.js applications. By understanding what makes up your JavaScript bundles, you can make targeted optimizations that significantly improve your application's performance.

Key takeaways:
1. Always analyze your bundles regularly as your application grows
2. Look for large packages that could be replaced or dynamically imported
3. Use code splitting to defer non-critical code
4. Consider the trade-offs between functionality and bundle size
5. Remember that performance is a continuous process, not a one-time task

## Additional Resources

- [Official Next.js Documentation on Bundle Analysis](https://nextjs.org/docs/advanced-features/measuring-performance)
- [Webpack Bundle Analyzer Documentation](https://github.com/webpack-contrib/webpack-bundle-analyzer)
- [Chrome DevTools Performance Panel](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance)
- [web.dev's Guide to JavaScript Optimization](https://web.dev/fast/#optimize-your-javascript)

## Exercises

1. Run bundle analysis on your own Next.js project. Identify the three largest dependencies.
2. Replace a large dependency with a smaller alternative and measure the impact.
3. Implement dynamic imports for at least one component that isn't needed on initial page load.
4. Create a "before and after" comparison showing how your optimizations affected bundle size and load time.
5. Set up a regular bundle analysis check as part of your development workflow to monitor bundle size over time.