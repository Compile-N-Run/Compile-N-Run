---
title: Next.js External API Integration
description: Learn how to integrate external APIs in your Next.js applications using various fetching methods, handle responses, manage errors, and implement caching strategies.

---

# Next.js External API Integration

In modern web development, most applications need to communicate with external services to fetch or send data. Next.js provides powerful tools and patterns to integrate with external APIs efficiently. This guide will walk you through the essentials of consuming external APIs in your Next.js applications.

## Introduction to External API Integration

External API integration allows your Next.js application to communicate with third-party services, databases, or other data sources over the internet. This enables your app to:

- Fetch data from remote services (like weather information, user data, product catalogs)
- Send data to external systems (like payment processors, analytics services)
- Authenticate users through third-party providers
- Leverage functionality you don't want to build yourself

Next.js supports multiple approaches for API integration, each suited for different scenarios and rendering strategies (server-side rendering, static site generation, or client-side rendering).

## Fetching Data Methods in Next.js

### Method 1: Using Fetch API

The native `fetch` API is built into modern browsers and Node.js environments, making it a convenient choice for Next.js applications.

```jsx
// Basic fetch example
async function fetchUserData() {
  const response = await fetch('https://api.example.com/users/1');
  
  if (!response.ok) {
    throw new Error(`Error: ${response.status}`);
  }
  
  const data = await response.json();
  return data;
}
```

### Method 2: Using Axios

Axios is a popular third-party HTTP client with a more feature-rich API compared to fetch.

First, install Axios:

```bash
npm install axios
# or
yarn add axios
```

Then use it in your components:

```jsx
import axios from 'axios';

// Basic axios example
async function fetchUserData() {
  try {
    const response = await axios.get('https://api.example.com/users/1');
    return response.data;
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error;
  }
}
```

### Method 3: Using SWR (Stale-While-Revalidate)

SWR is a React hooks library by Vercel (the creators of Next.js) for data fetching. It handles caching, revalidation, focus tracking, and more.

First, install SWR:

```bash
npm install swr
# or
yarn add swr
```

Basic usage:

```jsx
import useSWR from 'swr';

function UserProfile() {
  const fetcher = (...args) => fetch(...args).then(res => res.json());
  
  const { data, error, isLoading } = useSWR('https://api.example.com/users/1', fetcher);
  
  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error loading user data</div>;
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>Email: {data.email}</p>
    </div>
  );
}
```

## Data Fetching Strategies in Next.js

Next.js offers different methods for fetching data, depending on when and where you need the data.

### 1. Server-Side Rendering (SSR) with getServerSideProps

Use `getServerSideProps` when you need to fetch data on each request:

```jsx
// pages/users/[id].js
export async function getServerSideProps(context) {
  const { id } = context.params;
  
  try {
    const response = await fetch(`https://api.example.com/users/${id}`);
    const userData = await response.json();
    
    return {
      props: {
        user: userData,
      },
    };
  } catch (error) {
    console.error('Failed to fetch user data:', error);
    return {
      props: {
        user: null,
        error: 'Failed to load user data',
      },
    };
  }
}

export default function UserPage({ user, error }) {
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>Loading...</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>Email: {user.email}</p>
    </div>
  );
}
```

### 2. Static Site Generation (SSG) with getStaticProps

For data that doesn't change frequently, use `getStaticProps`:

```jsx
// pages/products.js
export async function getStaticProps() {
  try {
    const response = await fetch('https://api.example.com/products');
    const products = await response.json();
    
    return {
      props: {
        products,
      },
      // Re-generate the page every 60 seconds
      revalidate: 60,
    };
  } catch (error) {
    console.error('Failed to fetch products:', error);
    return {
      props: {
        products: [],
        error: 'Failed to load products',
      },
    };
  }
}

export default function ProductsPage({ products, error }) {
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h1>Our Products</h1>
      <ul>
        {products.map(product => (
          <li key={product.id}>{product.name} - ${product.price}</li>
        ))}
      </ul>
    </div>
  );
}
```

### 3. Client-Side Fetching

For data that changes frequently or is user-specific, fetch it directly from the client:

```jsx
import { useState, useEffect } from 'react';

export default function DashboardPage() {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchDashboardData() {
      try {
        const response = await fetch('/api/dashboard');
        
        if (!response.ok) {
          throw new Error(`Error: ${response.status}`);
        }
        
        const dashboardData = await response.json();
        setData(dashboardData);
      } catch (err) {
        setError(err.message);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchDashboardData();
  }, []);
  
  if (isLoading) return <div>Loading dashboard data...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return (
    <div>
      <h1>Dashboard</h1>
      <p>Total Users: {data.totalUsers}</p>
      <p>Active Sessions: {data.activeSessions}</p>
    </div>
  );
}
```

## Creating API Route Middlewares

Next.js allows you to create API routes that can serve as middlewares between your frontend and external APIs:

```jsx
// pages/api/weather.js
export default async function handler(req, res) {
  // Get the city from the query parameter
  const { city } = req.query;
  
  if (!city) {
    return res.status(400).json({ error: 'City parameter is required' });
  }
  
  // Your API key stored in environment variables
  const apiKey = process.env.WEATHER_API_KEY;
  
  try {
    const apiResponse = await fetch(
      `https://api.weatherservice.com/data?city=${city}&key=${apiKey}`
    );
    
    if (!apiResponse.ok) {
      throw new Error(`Weather API error: ${apiResponse.status}`);
    }
    
    const weatherData = await apiResponse.json();
    
    // Return the processed data
    return res.status(200).json({
      city: weatherData.location.name,
      temperature: weatherData.current.temp_c,
      condition: weatherData.current.condition.text,
      // You can transform or filter the data as needed
    });
  } catch (error) {
    console.error('Weather API error:', error);
    return res.status(500).json({ error: 'Failed to fetch weather data' });
  }
}
```

## Real-World Example: Building a GitHub Repository Explorer

Let's build a more complete example that fetches and displays GitHub repository information:

1. First, create an API route to communicate with the GitHub API:

```jsx
// pages/api/github/repos/[username].js
export default async function handler(req, res) {
  const { username } = req.query;
  
  if (!username) {
    return res.status(400).json({ error: 'Username is required' });
  }
  
  try {
    const response = await fetch(
      `https://api.github.com/users/${username}/repos?sort=updated&per_page=5`,
      {
        headers: {
          'Accept': 'application/vnd.github.v3+json',
          // Add your GitHub token if needed
          // 'Authorization': `token ${process.env.GITHUB_TOKEN}`
        }
      }
    );
    
    if (!response.ok) {
      throw new Error(`GitHub API error: ${response.status}`);
    }
    
    const repos = await response.json();
    
    // Transform data to include only what we need
    const simplifiedRepos = repos.map(repo => ({
      id: repo.id,
      name: repo.name,
      description: repo.description,
      stars: repo.stargazers_count,
      url: repo.html_url,
      language: repo.language
    }));
    
    return res.status(200).json(simplifiedRepos);
  } catch (error) {
    console.error('Error fetching GitHub repositories:', error);
    return res.status(500).json({ error: 'Failed to fetch GitHub repositories' });
  }
}
```

2. Now, create a page that uses this API route:

```jsx
// pages/github/[username].js
import { useState } from 'react';
import { useRouter } from 'next/router';
import useSWR from 'swr';

export default function GitHubUserPage() {
  const router = useRouter();
  const { username } = router.query;
  
  const fetcher = url => fetch(url).then(r => r.json());
  
  const { data: repos, error, isLoading } = useSWR(
    username ? `/api/github/repos/${username}` : null,
    fetcher
  );
  
  if (!username) return <div>Please specify a GitHub username</div>;
  if (isLoading) return <div>Loading repositories...</div>;
  if (error) return <div>Error loading repositories</div>;
  
  return (
    <div>
      <h1>{username}'s GitHub Repositories</h1>
      {repos.length === 0 ? (
        <p>No repositories found</p>
      ) : (
        <ul>
          {repos.map(repo => (
            <li key={repo.id}>
              <h2>
                <a href={repo.url} target="_blank" rel="noopener noreferrer">
                  {repo.name}
                </a>
              </h2>
              <p>{repo.description || 'No description available'}</p>
              <div>
                <span>⭐ {repo.stars}</span>
                {repo.language && <span> • {repo.language}</span>}
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

3. Add a simple form to search for GitHub users:

```jsx
// pages/github/index.js
import { useState } from 'react';
import { useRouter } from 'next/router';

export default function GitHubSearch() {
  const [username, setUsername] = useState('');
  const router = useRouter();
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (username.trim()) {
      router.push(`/github/${username}`);
    }
  };
  
  return (
    <div>
      <h1>GitHub Repository Explorer</h1>
      <form onSubmit={handleSubmit}>
        <label htmlFor="username">GitHub Username:</label>
        <input
          type="text"
          id="username"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
        />
        <button type="submit">View Repositories</button>
      </form>
    </div>
  );
}
```

## Error Handling and Best Practices

When working with external APIs, proper error handling is crucial:

### 1. Use try-catch blocks

Always wrap API calls in try-catch blocks:

```jsx
try {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  return data;
} catch (error) {
  console.error('API call failed:', error);
  // Handle the error appropriately
}
```

### 2. Check for response status

Always check if the response was successful:

```jsx
const response = await fetch('https://api.example.com/data');
if (!response.ok) {
  throw new Error(`API error: ${response.status} ${response.statusText}`);
}
```

### 3. Implement loading states

Show loading indicators to improve user experience:

```jsx
const [isLoading, setIsLoading] = useState(true);

// In your fetch function:
setIsLoading(true);
try {
  // ... fetch data
} finally {
  setIsLoading(false);
}

// In your JSX:
if (isLoading) return <LoadingSpinner />;
```

### 4. Use environment variables for API keys

Never hardcode API keys in your code:

```jsx
// In .env.local file
API_KEY=your_secret_key_here

// In your code
const apiKey = process.env.API_KEY;
```

### 5. Set appropriate timeouts

Avoid hanging requests with timeouts:

```jsx
// With Axios
const response = await axios.get('https://api.example.com/data', {
  timeout: 5000 // 5 seconds
});

// With fetch (using AbortController)
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 5000);

try {
  const response = await fetch('https://api.example.com/data', {
    signal: controller.signal
  });
  clearTimeout(timeoutId);
  const data = await response.json();
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Request timed out');
  }
}
```

## Advanced: Caching Strategies

Implementing proper caching can significantly improve performance and reduce unnecessary API calls.

### 1. Using SWR's built-in caching

SWR provides excellent caching capabilities out of the box:

```jsx
import useSWR from 'swr';

function ProductList() {
  const { data, error } = useSWR('/api/products', fetcher, {
    // Revalidate every 60 seconds
    refreshInterval: 60000,
    // Keep stale data when revalidating
    revalidateOnFocus: false,
    // Cache data even after component unmounts
    dedupingInterval: 600000 // 10 minutes
  });
  
  // Component rendering
}
```

### 2. Using React Query

For more advanced caching needs, consider React Query:

```jsx
import { QueryClient, QueryClientProvider, useQuery } from 'react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Products />
    </QueryClientProvider>
  );
}

function Products() {
  const { data, isLoading, error } = useQuery('products', 
    () => fetch('/api/products').then(res => res.json()),
    {
      staleTime: 60000, // 1 minute
      cacheTime: 900000, // 15 minutes
      refetchOnWindowFocus: false
    }
  );
  
  // Component rendering
}
```

## Summary

In this guide, we've covered:

- Different methods for integrating external APIs in Next.js applications (fetch, Axios, SWR)
- Data fetching strategies for various rendering approaches (SSR, SSG, CSR)
- Creating API route middlewares to proxy external API requests
- A real-world example building a GitHub repository explorer
- Error handling and best practices
- Advanced caching strategies

External API integration is a fundamental aspect of modern web development with Next.js. By understanding these patterns and techniques, you can build more robust, efficient, and user-friendly applications that leverage the vast ecosystem of available APIs.

## Additional Resources

- [Next.js Data Fetching Documentation](https://nextjs.org/docs/basic-features/data-fetching)
- [SWR Documentation](https://swr.vercel.app/)
- [React Query Documentation](https://react-query.tanstack.com/)
- [Axios Documentation](https://axios-http.com/docs/intro)
- [MDN Fetch API Reference](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)

## Exercises

1. **Weather App**: Build a simple weather app that integrates with a weather API, displays current conditions, and allows searching by city.
2. **Movie Database**: Create a movie search application using a public movie API like TMDB.
3. **Currency Converter**: Build a currency converter that fetches real-time exchange rates from a financial API.
4. **News Aggregator**: Create a news application that pulls headlines from a news API and implements caching for better performance.
5. **Authentication**: Implement a login system using a third-party authentication provider like Auth0 or Firebase Authentication.