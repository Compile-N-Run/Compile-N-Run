---
title: Next.js API Authentication
description: Learn how to implement secure authentication for your Next.js API routes to protect your endpoints and ensure only authorized users can access your data.

---

# Next.js API Authentication

Authentication is a critical aspect of web application development, especially when you're building APIs that expose sensitive data or operations. In this guide, we'll explore various approaches to implementing secure authentication for your Next.js API routes.

## Introduction to API Authentication

API authentication is the process of verifying the identity of users or services that attempt to access your API endpoints. Without proper authentication, your API would be vulnerable to unauthorized access, potentially exposing sensitive data or allowing malicious actions.

Next.js provides several ways to implement authentication for your API routes:

- Session-based authentication using cookies
- Token-based authentication with JWT (JSON Web Tokens)
- OAuth and third-party authentication providers
- API keys for service-to-service communication

Let's explore these approaches and learn how to implement them in your Next.js application.

## Prerequisites

Before we begin, make sure you have:

- Basic knowledge of Next.js and API routes
- A Next.js project set up
- Node.js and npm/yarn installed

## Session-based Authentication with Cookies

Session-based authentication is a common approach where a session is created on the server when a user logs in, and a cookie containing a session ID is stored in the user's browser.

### Implementation Steps

1. First, let's create a simple login API route:

```javascript
// pages/api/auth/login.js
import cookie from 'cookie';

export default function handler(req, res) {
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { username, password } = req.body;

  // This is where you would validate credentials against your database
  // For demo purposes, we're using a simple check
  if (username === 'admin' && password === 'password') {
    // Set a cookie with the session information
    res.setHeader(
      'Set-Cookie',
      cookie.serialize('session', JSON.stringify({ username }), {
        httpOnly: true,
        secure: process.env.NODE_ENV !== 'development',
        maxAge: 60 * 60, // 1 hour
        sameSite: 'strict',
        path: '/',
      })
    );

    return res.status(200).json({ success: true, message: 'Login successful' });
  } else {
    return res.status(401).json({ success: false, message: 'Invalid credentials' });
  }
}
```

2. Next, let's create a middleware function to verify the session cookie in protected API routes:

```javascript
// lib/auth.js
export function withAuth(handler) {
  return async (req, res) => {
    // Check for session cookie
    const { session } = req.cookies;
    
    if (!session) {
      return res.status(401).json({ message: 'Authentication required' });
    }
    
    try {
      // Parse the session
      req.user = JSON.parse(session);
      return handler(req, res);
    } catch (error) {
      return res.status(401).json({ message: 'Invalid session' });
    }
  };
}
```

3. Now, let's use this middleware to protect an API route:

```javascript
// pages/api/protected-resource.js
import { withAuth } from '../../lib/auth';

const handler = (req, res) => {
  // req.user contains the authenticated user information
  res.status(200).json({
    message: `Hello, ${req.user.username}! This is a protected resource.`,
    user: req.user
  });
};

export default withAuth(handler);
```

### Testing Session-based Authentication

You can test this using tools like Postman or using `fetch` in your browser:

```javascript
// Login and get a cookie
const login = async () => {
  const response = await fetch('/api/auth/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'admin', password: 'password' }),
    credentials: 'include' // Important to include cookies
  });
  return response.json();
};

// Access protected resource with the cookie
const getProtectedResource = async () => {
  const response = await fetch('/api/protected-resource', {
    credentials: 'include' // Important to include cookies
  });
  return response.json();
};
```

## Token-based Authentication with JWT

Token-based authentication using JSON Web Tokens (JWT) is another popular approach. Instead of storing session data on the server, JWTs contain all necessary information encoded within the token itself.

### Implementation Steps

1. First, install the required packages:

```bash
npm install jsonwebtoken
```

2. Create a login endpoint that issues JWTs:

```javascript
// pages/api/auth/token.js
import jwt from 'jsonwebtoken';

// This should be a secure environment variable in production
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

export default function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Method not allowed' });
  }

  const { username, password } = req.body;

  // Validate credentials (replace with your authentication logic)
  if (username === 'admin' && password === 'password') {
    // Create a JWT token
    const token = jwt.sign(
      { 
        sub: '1234567890',
        username: username,
        role: 'user'
      },
      JWT_SECRET,
      { expiresIn: '1h' }
    );

    return res.status(200).json({ token });
  } else {
    return res.status(401).json({ message: 'Invalid credentials' });
  }
}
```

3. Create middleware to verify JWT tokens:

```javascript
// lib/jwt-auth.js
import jwt from 'jsonwebtoken';

// This should be a secure environment variable in production
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

export function withJwtAuth(handler) {
  return async (req, res) => {
    // Get the token from the Authorization header
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ message: 'Authorization token required' });
    }
    
    const token = authHeader.substring(7); // Remove 'Bearer ' prefix
    
    try {
      // Verify the token
      const decoded = jwt.verify(token, JWT_SECRET);
      req.user = decoded;
      return handler(req, res);
    } catch (error) {
      return res.status(401).json({ message: 'Invalid or expired token' });
    }
  };
}
```

4. Protect an API route with JWT authentication:

```javascript
// pages/api/jwt-protected.js
import { withJwtAuth } from '../../lib/jwt-auth';

const handler = (req, res) => {
  // Access the authenticated user details
  const { username, role } = req.user;
  
  res.status(200).json({
    message: `Hello, ${username}! You have ${role} permissions.`,
    user: req.user
  });
};

export default withJwtAuth(handler);
```

### Testing JWT Authentication

Here's how you'd use the JWT authentication in a client:

```javascript
// Get a JWT token
const getToken = async () => {
  const response = await fetch('/api/auth/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ username: 'admin', password: 'password' })
  });
  const data = await response.json();
  return data.token;
};

// Access a protected resource using JWT
const accessProtectedResource = async (token) => {
  const response = await fetch('/api/jwt-protected', {
    headers: {
      'Authorization': `Bearer ${token}`
    }
  });
  return response.json();
};

// Usage
async function test() {
  const token = await getToken();
  console.log('Token:', token);
  
  const data = await accessProtectedResource(token);
  console.log('Protected data:', data);
}
```

## Authentication with NextAuth.js

For more complex authentication needs, [NextAuth.js](https://next-auth.js.org/) provides a complete authentication solution with built-in support for multiple authentication providers.

### Implementation Steps

1. Install NextAuth.js:

```bash
npm install next-auth
```

2. Create an API route for NextAuth:

```javascript
// pages/api/auth/[...nextauth].js
import NextAuth from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';

export default NextAuth({
  providers: [
    CredentialsProvider({
      // The name to display on the sign-in form
      name: 'Credentials',
      credentials: {
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        // This is where you would validate the user's credentials
        if (credentials.username === 'admin' && credentials.password === 'password') {
          return {
            id: '1',
            name: 'Admin User',
            email: 'admin@example.com',
            role: 'admin'
          };
        }
        
        // Return null if credentials are invalid
        return null;
      }
    })
  ],
  session: {
    strategy: 'jwt',
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  callbacks: {
    async jwt({ token, user }) {
      // Add user role to the token right after sign-in
      if (user) {
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      // Add role to client session
      session.user.role = token.role;
      return session;
    }
  }
});
```

3. Create a protected API route using NextAuth.js:

```javascript
// pages/api/nextauth-protected.js
import { getServerSession } from 'next-auth/next';
import { authOptions } from './auth/[...nextauth]';

export default async function handler(req, res) {
  const session = await getServerSession(req, res, authOptions);

  if (!session) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  return res.status(200).json({
    message: 'This is a protected API route',
    session: session
  });
}
```

### Using NextAuth.js in your Frontend

NextAuth.js provides React hooks for easy use in your components:

```jsx
import { useSession, signIn, signOut } from 'next-auth/react';

export default function Component() {
  const { data: session, status } = useSession();
  
  if (status === 'loading') {
    return <p>Loading...</p>;
  }
  
  if (session) {
    return (
      <>
        <p>Signed in as {session.user.name}</p>
        <button onClick={() => signOut()}>Sign out</button>
      </>
    );
  }
  
  return (
    <>
      <p>Not signed in</p>
      <button onClick={() => signIn()}>Sign in</button>
    </>
  );
}
```

## API Key Authentication for Service-to-Service

For service-to-service communication, API keys are often used. Here's how to implement a simple API key authentication system:

```javascript
// pages/api/service-to-service.js
// This would typically be stored securely, not hardcoded
const API_KEYS = {
  'service1': 'api_key_for_service1',
  'service2': 'api_key_for_service2'
};

export default function handler(req, res) {
  // Get API key from header
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey) {
    return res.status(401).json({ message: 'API key required' });
  }
  
  // Check if the API key is valid
  const service = Object.keys(API_KEYS).find(service => API_KEYS[service] === apiKey);
  
  if (!service) {
    return res.status(401).json({ message: 'Invalid API key' });
  }
  
  // API key is valid, process the request
  res.status(200).json({
    message: `Hello, ${service}! Your API request was successful.`
  });
}
```

Testing with curl:

```bash
curl -X GET http://localhost:3000/api/service-to-service \
  -H "x-api-key: api_key_for_service1"
```

## Role-based Authorization

Once you have authentication in place, you might want to implement role-based authorization:

```javascript
// lib/roles.js
export function withRoles(handler, allowedRoles) {
  return async (req, res) => {
    // Assuming req.user is set by previous auth middleware
    const { role } = req.user;
    
    if (!role || !allowedRoles.includes(role)) {
      return res.status(403).json({ message: 'Forbidden: Insufficient permissions' });
    }
    
    return handler(req, res);
  };
}
```

Usage:

```javascript
// pages/api/admin-only.js
import { withAuth } from '../../lib/auth';
import { withRoles } from '../../lib/roles';

const handler = (req, res) => {
  res.status(200).json({ message: 'Welcome, admin!' });
};

// First authenticate the user, then check their role
export default withAuth(withRoles(handler, ['admin']));
```

## Best Practices for API Authentication

1. **Always use HTTPS**: Never transmit authentication credentials or tokens over unencrypted connections.

2. **Secure your secrets**: Store sensitive information like JWT secrets and API keys as environment variables.

3. **Implement proper error handling**: Return appropriate status codes and don't leak sensitive information in error messages.

4. **Set appropriate token expiration**: Balance security and user experience with token lifetimes.

5. **Use HttpOnly and Secure cookie flags**: Protect cookies from client-side JavaScript and ensure they are only sent over HTTPS.

6. **Implement CSRF protection**: For cookie-based authentication, use CSRF tokens to prevent cross-site request forgery attacks.

7. **Rate limiting**: Implement rate limiting to prevent brute force attacks on your authentication endpoints.

```javascript
// Simple rate limiting middleware example
const rateLimit = {
  windowMs: 15 * 60 * 1000, // 15 minutes
  maxRequests: 100, // limit each IP to 100 requests per windowMs
  store: new Map()
};

export function withRateLimit(handler) {
  return (req, res) => {
    const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
    const now = Date.now();
    
    // Clean up old entries
    if (!rateLimit.store.has(ip)) {
      rateLimit.store.set(ip, { count: 0, resetTime: now + rateLimit.windowMs });
    } else {
      const data = rateLimit.store.get(ip);
      if (data.resetTime < now) {
        data.count = 0;
        data.resetTime = now + rateLimit.windowMs;
      }
    }
    
    const data = rateLimit.store.get(ip);
    data.count += 1;
    
    if (data.count > rateLimit.maxRequests) {
      return res.status(429).json({ message: 'Too many requests, please try again later.' });
    }
    
    return handler(req, res);
  };
}
```

## Summary

In this guide, we've explored various approaches to implementing authentication for Next.js API routes:

1. **Session-based authentication** using cookies for traditional web applications
2. **Token-based authentication** with JWT for stateless APIs
3. **NextAuth.js** for comprehensive authentication with multiple providers
4. **API key authentication** for service-to-service communication
5. **Role-based authorization** to restrict access based on user roles

Each approach has its pros and cons, and the best choice depends on your specific requirements. Always follow security best practices to protect your users' data and your application.

## Additional Resources

- [NextAuth.js Documentation](https://next-auth.js.org/getting-started/introduction)
- [JSON Web Token (JWT) Introduction](https://jwt.io/introduction/)
- [Next.js API Routes Documentation](https://nextjs.org/docs/api-routes/introduction)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)

## Exercises

1. Implement a logout endpoint for the session-based authentication example.
2. Add refresh token functionality to the JWT authentication system.
3. Implement OAuth authentication using NextAuth.js with a provider like Google or GitHub.
4. Create a middleware that combines both authentication and rate limiting for API routes.
5. Build a complete authentication system with registration, login, and password reset functionality.

By completing these exercises, you'll gain valuable experience in implementing secure authentication systems for your Next.js applications.