---
title: Spring Cloud Feign
description: A comprehensive guide to Spring Cloud Feign for implementing declarative REST clients in microservice architecture

---

# Spring Cloud Feign

## Introduction

Spring Cloud Feign is a declarative REST client developed by Netflix and integrated into the Spring Cloud ecosystem. It simplifies the process of writing web service clients by allowing developers to create interfaces with annotations that describe the remote API they're connecting to. These interfaces are then automatically implemented at runtime, significantly reducing the boilerplate code required for making HTTP requests.

Feign is particularly useful in microservices architecture where services need to communicate with each other over HTTP. By abstracting away the details of HTTP requests, Feign lets you focus on the business logic rather than the mechanics of service-to-service communication.

## Prerequisites

Before diving into Feign, you should have:

- Basic knowledge of Spring Boot
- Understanding of RESTful services
- Familiarity with microservices concepts

## Getting Started with Spring Cloud Feign

### Adding Dependencies

To start using Feign in your Spring Boot application, you need to add the following dependencies to your `pom.xml` file:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

For Gradle build system, add this to your `build.gradle` file:

```groovy
implementation 'org.springframework.cloud:spring-cloud-starter-openfeign'
```

### Enabling Feign in Your Application

To enable Feign in your Spring Boot application, add the `@EnableFeignClients` annotation to your main application class:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class MyServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyServiceApplication.class, args);
    }
}
```

## Creating a Feign Client

### Basic Feign Client Interface

Creating a Feign client is as simple as defining an interface with method declarations annotated with Spring MVC annotations. Here's a basic example:

```java
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "user-service", url = "http://localhost:8081")
public interface UserServiceClient {
    
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);
}
```

In this example:
- `@FeignClient` specifies the name of the service and its URL.
- The method `getUserById` maps to a GET request to the `/users/{id}` endpoint.
- The `@PathVariable` annotation binds the method parameter to the path variable in the URL.

### Using the Feign Client in a Service

Now, let's see how to use this Feign client in your service:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    
    private final UserServiceClient userServiceClient;
    
    @Autowired
    public UserService(UserServiceClient userServiceClient) {
        this.userServiceClient = userServiceClient;
    }
    
    public User findUserById(Long id) {
        return userServiceClient.getUserById(id);
    }
}
```

### Complete Example with Domain Model

Let's put everything together with a complete example including the domain model:

1. First, define your User class:

```java
public class User {
    private Long id;
    private String name;
    private String email;
    
    // Constructors, getters, and setters
    
    public User() {}
    
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // Getters and setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    @Override
    public String toString() {
        return "User{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
```

2. Then, create a controller that uses the UserService:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {
    
    private final UserService userService;
    
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping("/api/users/{id}")
    public ResponseEntity<User> getUserDetails(@PathVariable Long id) {
        User user = userService.findUserById(id);
        return ResponseEntity.ok(user);
    }
}
```

### Sample Output

When a client makes a GET request to `/api/users/1`, assuming the remote user-service returns the following JSON:

```json
{
    "id": 1,
    "name": "John Doe",
    "email": "john.doe@example.com"
}
```

The controller will return a ResponseEntity with the User object containing the data above.

## Advanced Feign Features

### Request and Response Customization

#### Custom Headers

You can add headers to your requests using the `@RequestHeader` annotation:

```java
@FeignClient(name = "user-service", url = "http://localhost:8081")
public interface UserServiceClient {
    
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id, 
                     @RequestHeader("Authorization") String authToken);
}
```

#### Request and Response Compression

To enable request or response compression, add these properties to your `application.properties` file:

```properties
feign.compression.request.enabled=true
feign.compression.response.enabled=true
```

### Error Handling

Feign provides mechanisms to handle errors from the remote service. You can create a custom error decoder:

```java
import feign.Response;
import feign.codec.ErrorDecoder;
import org.springframework.stereotype.Component;

@Component
public class CustomErrorDecoder implements ErrorDecoder {
    
    @Override
    public Exception decode(String methodKey, Response response) {
        
        switch (response.status()) {
            case 400:
                return new BadRequestException("Bad request");
            case 404:
                return new NotFoundException("Resource not found");
            case 500:
                return new InternalServerException("Internal server error");
            default:
                return new Exception("Generic error");
        }
    }
}
```

Then register it in your configuration:

```java
import feign.codec.ErrorDecoder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FeignConfiguration {
    
    @Bean
    public ErrorDecoder errorDecoder() {
        return new CustomErrorDecoder();
    }
}
```

And apply it to your Feign client:

```java
@FeignClient(name = "user-service", url = "http://localhost:8081", 
             configuration = FeignConfiguration.class)
public interface UserServiceClient {
    // Methods...
}
```

### Circuit Breaker Integration

Spring Cloud Feign integrates well with circuit breaker libraries. To use it with Resilience4j (the recommended circuit breaker since Spring Cloud 2020.0.0), add these dependencies:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
```

Enable the circuit breaker in your `application.properties`:

```properties
feign.circuitbreaker.enabled=true
```

Create a fallback for your Feign client:

```java
@Component
public class UserServiceFallback implements UserServiceClient {
    
    @Override
    public User getUserById(Long id) {
        return new User(id, "Fallback User", "fallback@example.com");
    }
}
```

And specify it in your Feign client:

```java
@FeignClient(name = "user-service", url = "http://localhost:8081",
             fallback = UserServiceFallback.class)
public interface UserServiceClient {
    
    @GetMapping("/users/{id}")
    User getUserById(@PathVariable("id") Long id);
}
```

## Real-world Example: E-commerce Microservices

Let's consider a real-world example of an e-commerce system with multiple microservices. We'll focus on how an Order Service would communicate with a Product Service and a User Service using Feign.

### Project Structure

```
e-commerce-system/
├── order-service/
│   └── src/
│       ├── main/
│       │   ├── java/
│       │   │   └── com/ecommerce/orderservice/
│       │   │       ├── client/
│       │   │       │   ├── ProductServiceClient.java
│       │   │       │   └── UserServiceClient.java
│       │   │       ├── model/
│       │   │       │   ├── Order.java
│       │   │       │   ├── Product.java
│       │   │       │   └── User.java
│       │   │       ├── service/
│       │   │       │   └── OrderService.java
│       │   │       └── OrderServiceApplication.java
│       │   └── resources/
│       │       └── application.properties
├── product-service/
└── user-service/
```

### Feign Clients

ProductServiceClient:

```java
package com.ecommerce.orderservice.client;

import com.ecommerce.orderservice.model.Product;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "product-service", url = "${product-service.url}")
public interface ProductServiceClient {
    
    @GetMapping("/products/{productId}")
    Product getProductById(@PathVariable("productId") Long productId);
}
```

UserServiceClient:

```java
package com.ecommerce.orderservice.client;

import com.ecommerce.orderservice.model.User;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;

@FeignClient(name = "user-service", url = "${user-service.url}")
public interface UserServiceClient {
    
    @GetMapping("/users/{userId}")
    User getUserById(@PathVariable("userId") Long userId);
}
```

### Model Classes

Order.java:

```java
package com.ecommerce.orderservice.model;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;

public class Order {
    private Long id;
    private Long userId;
    private List<Long> productIds;
    private BigDecimal totalAmount;
    private LocalDateTime orderDate;
    private String status;
    
    // Constructors, getters, and setters
}
```

Product.java and User.java classes would contain the appropriate fields.

### Service Implementation

OrderService.java:

```java
package com.ecommerce.orderservice.service;

import com.ecommerce.orderservice.client.ProductServiceClient;
import com.ecommerce.orderservice.client.UserServiceClient;
import com.ecommerce.orderservice.model.Order;
import com.ecommerce.orderservice.model.Product;
import com.ecommerce.orderservice.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Service
public class OrderService {
    
    private final ProductServiceClient productServiceClient;
    private final UserServiceClient userServiceClient;
    
    @Autowired
    public OrderService(ProductServiceClient productServiceClient, UserServiceClient userServiceClient) {
        this.productServiceClient = productServiceClient;
        this.userServiceClient = userServiceClient;
    }
    
    public Order createOrder(Long userId, List<Long> productIds) {
        // Verify user exists
        User user = userServiceClient.getUserById(userId);
        
        // Get product details and calculate total
        List<Product> products = new ArrayList<>();
        BigDecimal totalAmount = BigDecimal.ZERO;
        
        for (Long productId : productIds) {
            Product product = productServiceClient.getProductById(productId);
            products.add(product);
            totalAmount = totalAmount.add(product.getPrice());
        }
        
        // Create and save order
        Order order = new Order();
        order.setUserId(userId);
        order.setProductIds(productIds);
        order.setTotalAmount(totalAmount);
        order.setOrderDate(LocalDateTime.now());
        order.setStatus("PENDING");
        
        // In a real application, save the order to the database here
        
        return order;
    }
}
```

### Application Properties

application.properties:

```properties
# Server configuration
server.port=8082

# Service URLs
product-service.url=http://localhost:8083
user-service.url=http://localhost:8081

# Feign configuration
feign.client.config.default.connectTimeout=5000
feign.client.config.default.readTimeout=5000
feign.compression.request.enabled=true
feign.compression.response.enabled=true
feign.circuitbreaker.enabled=true
```

### Running the Application

The main application class would include the `@EnableFeignClients` annotation:

```java
package com.ecommerce.orderservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.EnableFeignClients;

@SpringBootApplication
@EnableFeignClients
public class OrderServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

## Summary

Spring Cloud Feign is a powerful library that simplifies HTTP client development in a microservices environment. Its declarative approach allows developers to create REST clients with minimal boilerplate code, focusing instead on defining the desired API through interfaces and annotations.

Key takeaways from this guide include:

1. Feign enables declarative REST clients through simple interfaces with annotations
2. It integrates seamlessly with the Spring ecosystem
3. You can easily customize requests and responses with headers, parameters, and more
4. Feign provides built-in error handling mechanisms
5. It works well with circuit breaker patterns to improve system resilience
6. For real-world applications, Feign simplifies service-to-service communication in microservices architectures

## Additional Resources

- [Spring Cloud Feign Official Documentation](https://spring.io/projects/spring-cloud-openfeign)
- [Netflix Feign GitHub Repository](https://github.com/OpenFeign/feign)
- [Spring Cloud Circuit Breaker](https://spring.io/projects/spring-cloud-circuitbreaker)

## Exercises

1. Create a Feign client to communicate with a public API (like JSONPlaceholder or PokéAPI)
2. Implement a fallback mechanism for your Feign client using Resilience4j
3. Create a microservices project with at least two services that communicate via Feign
4. Implement custom error handling for your Feign clients
5. Extend the e-commerce example by adding inventory checks before creating an order