---
title: "Spring Cloud Ribbon"
description: "Learn how to implement client-side load balancing in your microservices architecture using Spring Cloud Ribbon"

---

# Spring Cloud Ribbon

## Introduction

Spring Cloud Ribbon is a client-side load balancing library that's part of the Spring Cloud Netflix suite of tools. In a microservices architecture, you typically have multiple instances of the same service running to ensure high availability and scalability. When a client needs to call a service, it should distribute its requests evenly across all available instances. This is where Ribbon comes in.

Ribbon provides intelligent load balancing algorithms to help distribute traffic across service instances, improving application resilience and performance. Although Ribbon has been marked as being in maintenance mode (with Spring Cloud LoadBalancer as its replacement), it's still widely used and understanding it is important for working with many Spring Cloud applications.

## What is Client-Side Load Balancing?

Before diving into Ribbon, let's understand the difference between server-side and client-side load balancing:

- **Server-side load balancing**: A dedicated load balancer (like Nginx, HAProxy) sits between clients and services, distributing traffic.
- **Client-side load balancing**: The client itself decides which service instance to send requests to.

Spring Cloud Ribbon implements client-side load balancing, empowering the client application to make intelligent routing decisions.

## Setting Up Spring Cloud Ribbon

### Prerequisites

- Java 8 or higher
- Spring Boot 2.x
- Maven or Gradle

### Adding Dependencies

First, let's add the necessary dependencies to your project:

For Maven:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

For Gradle:

```groovy
implementation 'org.springframework.cloud:spring-cloud-starter-netflix-ribbon'
```

If you're using Spring Cloud Netflix Eureka for service discovery, Ribbon is automatically included with:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
</dependency>
```

## Basic Configuration and Usage

### Enabling Ribbon

To enable Ribbon in your Spring Boot application, simply add `@RibbonClient` annotation:

```java
import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@RibbonClient(name = "product-service")
public class OrderServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

### Configuring Service URLs

You need to tell Ribbon about the available instances of your service. This can be done in your `application.properties` or `application.yml` file:

```yaml
product-service:
  ribbon:
    listOfServers: http://localhost:8081,http://localhost:8082,http://localhost:8083
    ServerListRefreshInterval: 15000
```

Here, we're configuring Ribbon for the `product-service` with three instances running on different ports, and setting the server list to refresh every 15 seconds.

### Using Ribbon with RestTemplate

The most common way to use Ribbon is with a load-balanced `RestTemplate`:

```java
import org.springframework.cloud.client.loadbalancer.LoadBalanced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

@Configuration
public class AppConfig {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

The `@LoadBalanced` annotation enables Ribbon's load balancing capabilities on the `RestTemplate`.

Now you can use this `RestTemplate` to make requests to your services:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class OrderController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/order-with-products")
    public String getOrderWithProducts() {
        // Notice we use the service name instead of a specific URL
        String products = restTemplate.getForObject("http://product-service/products", String.class);
        return "Order contains: " + products;
    }
}
```

In this example, instead of calling a specific URL, we use the service name (`product-service`). Ribbon will intercept the call and route it to one of the available instances using its load balancing algorithm.

## Advanced Ribbon Configuration

### Load Balancing Rules

Ribbon offers several load balancing rules:

1. **RoundRobinRule** (default): Distributes requests sequentially across servers
2. **AvailabilityFilteringRule**: Skips servers that are down or experiencing high concurrency
3. **WeightedResponseTimeRule**: Uses average response times to assign weights; servers with better response times receive more traffic
4. **ZoneAvoidanceRule**: Avoids servers in zones with failures
5. **BestAvailableRule**: Chooses the server with the least number of active requests
6. **RandomRule**: Selects a server randomly
7. **RetryRule**: Retries a server if an operation fails

You can configure which rule to use in your application properties:

```yaml
product-service:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```

Or by creating a custom configuration class:

```java
import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.WeightedResponseTimeRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ProductServiceRibbonConfig {

    @Bean
    public IRule ribbonRule() {
        return new WeightedResponseTimeRule();
    }
}
```

And then reference it in your application:

```java
@RibbonClient(name = "product-service", configuration = ProductServiceRibbonConfig.class)
public class OrderServiceApplication {
    // ...
}
```

### Timeout Configuration

You can configure request timeouts for Ribbon:

```yaml
product-service:
  ribbon:
    ConnectTimeout: 3000
    ReadTimeout: 5000
    MaxAutoRetries: 1
    MaxAutoRetriesNextServer: 1
```

## Ribbon with Eureka

When using Ribbon with Eureka, Ribbon automatically gets the server list from Eureka instead of requiring manual configuration:

```java
@SpringBootApplication
@EnableEurekaClient
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}
```

With this setup, you don't need to specify `listOfServers` in your Ribbon configuration. Ribbon will dynamically discover the available instances from Eureka.

## A Complete Working Example

Let's build a simple example with two services:

1. **product-service**: Provides product information 
2. **order-service**: Orders products and uses Ribbon to load balance requests to product-service

### Product Service (Run on multiple ports)

```java
@SpringBootApplication
public class ProductServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProductServiceApplication.class, args);
    }
    
    @RestController
    class ProductController {
        @Value("${server.port}")
        private String port;
        
        @GetMapping("/products")
        public String getProducts() {
            return "Products list from server running on port: " + port;
        }
    }
}
```

Run this service on multiple ports:
```
java -jar product-service.jar --server.port=8081
java -jar product-service.jar --server.port=8082
java -jar product-service.jar --server.port=8083
```

### Order Service (With Ribbon)

```java
@SpringBootApplication
@RibbonClient(name = "product-service")
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
    
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @RestController
    class OrderController {
        @Autowired
        private RestTemplate restTemplate;
        
        @GetMapping("/order")
        public String createOrder() {
            // Ribbon will load balance this request among the product service instances
            String products = restTemplate.getForObject(
                "http://product-service/products", String.class);
            return "Order created with: " + products;
        }
    }
}
```

Configure Ribbon in `application.yml`:

```yaml
product-service:
  ribbon:
    listOfServers: http://localhost:8081,http://localhost:8082,http://localhost:8083
    ServerListRefreshInterval: 5000
```

### Output

If you call the order service endpoint multiple times, you'll see responses from different product service instances:

```
Call 1: Order created with: Products list from server running on port: 8082
Call 2: Order created with: Products list from server running on port: 8083
Call 3: Order created with: Products list from server running on port: 8081
Call 4: Order created with: Products list from server running on port: 8082
```

This demonstrates that Ribbon is successfully distributing requests across the different product service instances.

## Integration with Other Spring Cloud Components

Ribbon works seamlessly with other Spring Cloud components:

1. **Eureka**: For service discovery
2. **Hystrix**: For circuit breaking
3. **Feign**: For declarative REST clients with built-in load balancing

Example with Feign:

```java
@SpringBootApplication
@EnableFeignClients
public class OrderServiceApplication {
    // ...
}

@FeignClient("product-service")
interface ProductClient {
    @GetMapping("/products")
    String getProducts();
}
```

Feign clients are automatically load-balanced using Ribbon.

## Spring Cloud LoadBalancer: The Ribbon Replacement

As mentioned earlier, Ribbon is in maintenance mode. Spring Cloud now recommends using Spring Cloud LoadBalancer instead. Here's how to migrate:

1. Remove Ribbon dependency:
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
</dependency>
```

2. Add Spring Cloud LoadBalancer:
```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

3. Disable Ribbon (if you're using other Netflix components):
```yaml
spring:
  cloud:
    loadbalancer:
      ribbon:
        enabled: false
```

The `@LoadBalanced` annotation works the same way with Spring Cloud LoadBalancer.

## Summary

Spring Cloud Ribbon provides client-side load balancing for your microservices architecture. It helps distribute traffic across multiple service instances, improving resilience and performance. Key points to remember:

- Ribbon is a client-side load balancer
- It integrates well with Spring Cloud Eureka for dynamic service discovery
- It provides various load balancing algorithms to suit different needs
- The `@LoadBalanced` annotation enables Ribbon on `RestTemplate`
- Ribbon is in maintenance mode; Spring Cloud LoadBalancer is its recommended replacement

By implementing client-side load balancing with Ribbon, you can build more resilient and scalable microservices architectures.

## Additional Resources

- [Spring Cloud Netflix Documentation](https://cloud.spring.io/spring-cloud-netflix/reference/html/)
- [Ribbon GitHub Repository](https://github.com/Netflix/ribbon)
- [Spring Cloud LoadBalancer Documentation](https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer)

## Exercises

1. Create a simple microservices setup with two services and implement Ribbon load balancing between them
2. Experiment with different load balancing rules and observe their effects
3. Implement retry functionality with Ribbon
4. Integrate Ribbon with a Spring Cloud Gateway setup
5. Migrate a Ribbon application to Spring Cloud LoadBalancer

Happy coding!