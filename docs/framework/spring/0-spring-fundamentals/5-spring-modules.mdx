---
title: Spring Modules
description: Learn about the various modules in the Spring Framework and how they fit together to create powerful Java applications.

---

# Spring Modules

## Introduction

The Spring Framework is one of the most popular Java application frameworks, designed to make Java enterprise development easier by providing a comprehensive programming and configuration model. At its core, Spring is modular in nature, allowing developers to use only the parts they need without carrying the entire framework.

In this tutorial, you'll learn about the various Spring modules, their purposes, and how they interact with each other to create robust applications. Understanding the Spring module ecosystem is essential for effective Spring development, as it helps you choose the right tools for your specific requirements.

## Core Spring Modules

The Spring Framework is organized into about 20 modules, grouped into several key areas of functionality. Let's explore the most important ones:

### 1. Core Container

The Core Container is the foundation of the Spring Framework and includes the following modules:

- **Spring Core**: Provides the fundamental parts of the framework, including IoC (Inversion of Control) and DI (Dependency Injection) features.
- **Spring Beans**: Implements the bean factory pattern, which is the foundation for Spring's DI functionality.
- **Spring Context**: Builds on Core and Beans, providing a way to access objects in a framework-style manner.
- **Spring Expression Language (SpEL)**: Supports querying and manipulating object graphs at runtime.

Here's a simple example of the Core Container in action:

```java
// Define a simple bean
public class HelloWorldService {
    public String sayHello() {
        return "Hello, Spring World!";
    }
}

// Configuration class
@Configuration
public class AppConfig {
    @Bean
    public HelloWorldService helloWorldService() {
        return new HelloWorldService();
    }
}

// Usage
public class Application {
    public static void main(String[] args) {
        // Create the application context
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        
        // Get the bean
        HelloWorldService service = context.getBean(HelloWorldService.class);
        
        // Use the bean
        System.out.println(service.sayHello());
        // Output: Hello, Spring World!
    }
}
```

### 2. AOP (Aspect-Oriented Programming)

The AOP module provides aspect-oriented programming functionality, allowing you to define method interceptors and pointcuts to cleanly separate code that implements functionality that should be separated.

```java
// Define an aspect
@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBeforeMethodExecution(JoinPoint joinPoint) {
        System.out.println("Executing: " + joinPoint.getSignature().getName());
    }
}
```

### 3. Data Access/Integration

This group includes modules for working with databases:

- **JDBC**: Provides a JDBC-abstraction layer that removes the need for tedious JDBC coding.
- **ORM**: Offers integration layers for popular object-relational mapping APIs, including JPA and Hibernate.
- **OXM**: Provides an abstraction layer for Object/XML mapping.
- **JMS**: Contains features for producing and consuming messages.
- **Transactions**: Supports programmatic and declarative transaction management.

Here's an example of Spring JDBC:

```java
@Repository
public class EmployeeRepository {
    private final JdbcTemplate jdbcTemplate;
    
    public EmployeeRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    public List<Employee> findAll() {
        return jdbcTemplate.query(
            "SELECT id, first_name, last_name FROM employees",
            (rs, rowNum) -> new Employee(
                rs.getLong("id"),
                rs.getString("first_name"),
                rs.getString("last_name")
            )
        );
    }
}
```

### 4. Web

The Web layer consists of the Spring Web MVC, Spring WebFlux, and other web-related modules:

- **Web MVC**: The traditional Spring MVC framework for building web applications.
- **WebFlux**: A newer, reactive-stack web framework that supports non-blocking, reactive streams.
- **WebSocket**: Provides support for WebSocket-based, two-way communication.

Example of a Spring MVC controller:

```java
@Controller
@RequestMapping("/api/employees")
public class EmployeeController {
    private final EmployeeService employeeService;
    
    public EmployeeController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }
    
    @GetMapping
    public ResponseEntity<List<Employee>> getAllEmployees() {
        List<Employee> employees = employeeService.findAll();
        return ResponseEntity.ok(employees);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable Long id) {
        return employeeService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
}
```

### 5. Test

The Spring Test module supports testing Spring components with JUnit or TestNG, providing mock objects and testing support classes.

```java
@SpringBootTest
public class EmployeeServiceTest {
    @Autowired
    private EmployeeService employeeService;
    
    @MockBean
    private EmployeeRepository employeeRepository;
    
    @Test
    public void testGetAllEmployees() {
        // Setup mock behavior
        when(employeeRepository.findAll()).thenReturn(
            Arrays.asList(new Employee(1L, "John", "Doe"))
        );
        
        // Call the service
        List<Employee> employees = employeeService.findAll();
        
        // Assertions
        assertThat(employees).hasSize(1);
        assertThat(employees.get(0).getFirstName()).isEqualTo("John");
        assertThat(employees.get(0).getLastName()).isEqualTo("Doe");
    }
}
```

## Spring Boot

While not technically a module of the core Spring Framework, Spring Boot has become an essential part of the Spring ecosystem. Spring Boot makes it easy to create stand-alone, production-grade Spring applications with minimal configuration.

Key features of Spring Boot include:

- **Auto-configuration**: Spring Boot can automatically configure your application based on the dependencies you have added.
- **Standalone**: You can run Spring Boot applications with a simple `java -jar` command.
- **Opinionated defaults**: Spring Boot provides sensible defaults for configuration.

Here's a simple Spring Boot application:

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
    
    @RestController
    public class HelloController {
        @GetMapping("/hello")
        public String hello() {
            return "Hello from Spring Boot!";
        }
    }
}
```

## Other Important Spring Projects

Beyond the core modules, the Spring ecosystem includes many specialized projects:

### 1. Spring Security

Spring Security provides comprehensive security services for Java EE-based enterprise software applications, focusing on authentication and authorization.

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/", "/home").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
                .and()
            .logout()
                .permitAll();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 2. Spring Data

Spring Data simplifies data access by reducing boilerplate code needed for database interactions. It supports various database technologies, including JPA, MongoDB, Redis, and more.

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    List<Employee> findByLastName(String lastName);
    
    @Query("SELECT e FROM Employee e WHERE e.firstName LIKE %:name% OR e.lastName LIKE %:name%")
    List<Employee> findByNameContaining(@Param("name") String name);
}
```

### 3. Spring Cloud

Spring Cloud provides tools for developers to quickly build common patterns in distributed systems, facilitating the development of microservices-based architectures.

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}
```

### 4. Spring Batch

Spring Batch provides reusable functions for processing large volumes of records, including logging/tracing, transaction management, job processing statistics, job restart, and resource management.

```java
@Configuration
@EnableBatchProcessing
public class BatchConfig {
    @Autowired
    public JobBuilderFactory jobBuilderFactory;
    
    @Autowired
    public StepBuilderFactory stepBuilderFactory;
    
    @Bean
    public Job importUserJob(Step step1) {
        return jobBuilderFactory.get("importUserJob")
            .incrementer(new RunIdIncrementer())
            .flow(step1)
            .end()
            .build();
    }
    
    @Bean
    public Step step1(ItemReader<Person> reader, ItemProcessor<Person, Person> processor, ItemWriter<Person> writer) {
        return stepBuilderFactory.get("step1")
            .<Person, Person>chunk(10)
            .reader(reader)
            .processor(processor)
            .writer(writer)
            .build();
    }
}
```

## How Modules Work Together: A Real-World Example

Let's tie everything together with a realistic example: a simple employee management system. This example will demonstrate how different Spring modules interact with each other:

```java
// Entity class using JPA (Spring Data JPA)
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "first_name")
    private String firstName;
    
    @Column(name = "last_name")
    private String lastName;
    
    // Getters, setters, constructors...
}

// Repository using Spring Data
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    List<Employee> findByLastName(String lastName);
}

// Service using Spring Core
@Service
public class EmployeeService {
    private final EmployeeRepository repository;
    
    public EmployeeService(EmployeeRepository repository) {
        this.repository = repository;
    }
    
    @Transactional(readOnly = true)
    public List<Employee> findAll() {
        return repository.findAll();
    }
    
    @Transactional(readOnly = true)
    public Optional<Employee> findById(Long id) {
        return repository.findById(id);
    }
    
    @Transactional
    public Employee save(Employee employee) {
        return repository.save(employee);
    }
    
    @Transactional
    public void deleteById(Long id) {
        repository.deleteById(id);
    }
}

// Controller using Spring MVC
@RestController
@RequestMapping("/api/employees")
public class EmployeeController {
    private final EmployeeService service;
    
    public EmployeeController(EmployeeService service) {
        this.service = service;
    }
    
    @GetMapping
    public List<Employee> getAllEmployees() {
        return service.findAll();
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable Long id) {
        return service.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public Employee createEmployee(@RequestBody Employee employee) {
        return service.save(employee);
    }
    
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteEmployee(@PathVariable Long id) {
        service.deleteById(id);
    }
}

// Main application using Spring Boot
@SpringBootApplication
public class EmployeeApplication {
    public static void main(String[] args) {
        SpringApplication.run(EmployeeApplication.class, args);
    }
}
```

In this example:

1. **Spring Data JPA** handles the data access layer
2. **Spring Core** manages dependency injection and transactions
3. **Spring MVC** handles the web layer and HTTP requests
4. **Spring Boot** ties everything together with auto-configuration

## Summary

The Spring Framework is divided into modules that provide specific functionality, allowing developers to use only what they need. The key module groups include:

- **Core Container**: Fundamental Spring features like IoC and DI
- **AOP**: Support for aspect-oriented programming
- **Data Access**: Tools for working with databases and transactions
- **Web**: Frameworks for web application development
- **Test**: Support for unit and integration testing

Beyond the core framework, the Spring ecosystem includes projects like Spring Boot, Spring Security, Spring Data, and Spring Cloud, which extend the framework's capabilities to address specific development needs.

Understanding the Spring module structure helps you choose the right components for your application, ensuring you include only what you need without unnecessary dependencies.

## Additional Resources

To deepen your understanding of Spring modules, consider exploring these resources:

1. [Official Spring Framework Documentation](https://spring.io/projects/spring-framework)
2. [Spring Guides](https://spring.io/guides) for hands-on tutorials
3. [Spring Boot Reference Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
4. [Spring Pet Clinic](https://github.com/spring-projects/spring-petclinic) - A sample application demonstrating Spring capabilities

## Exercises

1. Create a simple Spring Boot application that uses the Core Container to define and use beans.
2. Implement a basic REST API using Spring MVC with CRUD operations.
3. Add transaction management to a service class using Spring's transaction support.
4. Implement a custom aspect that logs method execution times using Spring AOP.
5. Use Spring Data JPA to create a repository for a domain entity of your choice.

By completing these exercises, you'll gain practical experience with the various Spring modules and understand how they work together in real-world applications.