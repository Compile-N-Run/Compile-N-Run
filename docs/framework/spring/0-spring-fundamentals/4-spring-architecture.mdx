---
title: Spring Architecture
description: Learn about the core architectural components of the Spring Framework, including its modular design, dependency injection, and how Spring applications are structured.

---

# Spring Architecture

## Introduction

The Spring Framework is one of the most popular Java application frameworks, known for making Java development easier, more efficient, and more organized. Understanding Spring's architecture is essential for any developer looking to work with this powerful framework.

In this guide, we'll explore the architectural foundations of Spring, including its core principles, key components, and how they all work together to create robust applications. By the end of this tutorial, you'll have a solid understanding of what makes Spring tick and why it's designed the way it is.

## Core Principles of Spring Architecture

Spring's architecture is built around several fundamental principles that make it stand out from other frameworks:

### 1. Inversion of Control (IoC)

At the heart of Spring is the concept of Inversion of Control (IoC). In traditional programming, your custom code calls libraries and frameworks when needed. IoC inverts this control flow:

- **Traditional approach**: Your code is in control and calls the framework
- **IoC approach**: The framework is in control and calls your code

This inversion of control means that instead of creating objects directly, you describe how they should be created, and the Spring container instantiates and manages them for you.

### 2. Dependency Injection (DI)

Dependency Injection is Spring's implementation of IoC. Instead of components creating their dependencies, they are "injected" from outside. This leads to:

- Loose coupling between classes
- Easier testing through mock objects
- More modular and maintainable code
- Simplified configuration management

There are three main types of dependency injection in Spring:

1. Constructor Injection
2. Setter Injection
3. Field Injection

## Key Components of Spring Architecture

Spring's architecture can be visualized as a set of modules built around a core container:

### 1. Spring Core Container

The Core Container provides the fundamental functionality of Spring:

- **BeanFactory**: The basic IoC container that instantiates and wires objects
- **ApplicationContext**: An enhanced container that extends BeanFactory with enterprise features
- **Bean lifecycle management**: Controls how beans are created, initialized, and destroyed
- **Configuration management**: Handles various ways to configure applications

### 2. Spring Modules

Spring Framework is modular by design, allowing you to use only the parts you need:

- **Spring MVC**: For building web applications
- **Spring Data**: For database access and various data technologies
- **Spring Security**: For authentication and authorization
- **Spring Boot**: For simplified application setup and development
- **Spring Cloud**: For building cloud-native applications
- And many more...

## Understanding the Spring Container

The Spring container is responsible for creating objects, wiring them together, configuring them, and managing their lifecycle from creation to destruction.

### Bean Lifecycle

When a Spring application starts:

1. Spring container is created
2. Container reads configuration (XML, annotations, or Java code)
3. Container creates beans based on configuration
4. Dependencies are injected into beans
5. Initialization callbacks are triggered
6. Beans are ready for use
7. When the application shuts down, destruction callbacks are triggered

Let's look at a simple visualization of this process:

```
Application Start
    ↓
Spring Container Creation
    ↓
Configuration Loading
    ↓
Bean Instantiation
    ↓
Dependency Injection
    ↓
Bean Initialization
    ↓
Application Running
    ↓
Bean Destruction
    ↓
Application Shutdown
```

## Spring Architecture in Practice

Let's look at how Spring's architecture manifests in actual code:

### Example 1: Dependency Injection

Here's a simple example demonstrating constructor injection:

```java
// Service interface
public interface MessageService {
    String getMessage();
}

// Service implementation
@Service
public class EmailService implements MessageService {
    @Override
    public String getMessage() {
        return "Email message";
    }
}

// Client class that depends on MessageService
@Component
public class MessageProcessor {
    private final MessageService messageService;
    
    // Constructor injection
    @Autowired
    public MessageProcessor(MessageService messageService) {
        this.messageService = messageService;
    }
    
    public void processMessage() {
        System.out.println("Processing: " + messageService.getMessage());
    }
}
```

In this example:
- `MessageService` is an interface that defines a contract
- `EmailService` implements that interface
- `MessageProcessor` depends on `MessageService`
- Spring injects an implementation of `MessageService` into `MessageProcessor` through its constructor

### Example 2: Spring Application Context

Let's see how to create and use an application context:

```java
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan("com.example")
public class AppConfig {
    // Configuration details go here
}

public class Application {
    public static void main(String[] args) {
        // Create the Spring application context
        AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        // Get a bean from the context
        MessageProcessor processor = context.getBean(MessageProcessor.class);
        
        // Use the bean
        processor.processMessage();
        
        // Close the context
        context.close();
    }
}
```

Output:
```
Processing: Email message
```

In this example:
- `@Configuration` marks `AppConfig` as a source of bean definitions
- `@ComponentScan` tells Spring where to look for annotated components
- The application context is created using this configuration
- We retrieve and use beans from the context
- Finally, we close the context, which triggers bean destruction

## Spring's Layered Architecture

Spring applications typically follow a layered architecture:

### Presentation Layer
- Handles HTTP requests and responses
- Typically implemented using Spring MVC or Spring WebFlux
- Controllers map to specific URL patterns

```java
@Controller
public class UserController {
    private final UserService userService;
    
    @Autowired
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping("/users")
    public String listUsers(Model model) {
        model.addAttribute("users", userService.getAllUsers());
        return "user/list";
    }
}
```

### Service Layer
- Contains business logic
- Manages transactions
- Coordinates multiple repositories if needed

```java
@Service
@Transactional
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    
    @Autowired
    public UserServiceImpl(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Override
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```

### Repository/DAO Layer
- Handles data access operations
- Abstracts database interactions
- Often implemented using Spring Data

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByLastName(String lastName);
}
```

### Model/Domain Layer
- Contains business objects
- Represents domain concepts
- Often includes validation logic

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank
    private String firstName;
    
    @NotBlank
    private String lastName;
    
    @Email
    private String email;
    
    // Getters and setters...
}
```

## Practical Example: Building a Complete Application

Let's tie all these concepts together with a real-world example: a simple task management application.

First, let's define our domain model:

```java
@Entity
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @NotBlank
    private String title;
    
    private String description;
    
    @NotNull
    private LocalDate dueDate;
    
    @NotNull
    private boolean completed;
    
    // Getters and setters omitted for brevity
}
```

Next, create a repository interface:

```java
@Repository
public interface TaskRepository extends JpaRepository<Task, Long> {
    List<Task> findByCompleted(boolean completed);
    List<Task> findByDueDateBefore(LocalDate date);
}
```

Then, implement the service layer:

```java
@Service
@Transactional
public class TaskServiceImpl implements TaskService {
    private final TaskRepository taskRepository;
    
    @Autowired
    public TaskServiceImpl(TaskRepository taskRepository) {
        this.taskRepository = taskRepository;
    }
    
    @Override
    public List<Task> getAllTasks() {
        return taskRepository.findAll();
    }
    
    @Override
    public List<Task> getOverdueTasks() {
        return taskRepository.findByDueDateBefore(LocalDate.now());
    }
    
    @Override
    public Task saveTask(Task task) {
        return taskRepository.save(task);
    }
    
    @Override
    public void deleteTask(Long id) {
        taskRepository.deleteById(id);
    }
}
```

Finally, create a REST controller to expose the functionality:

```java
@RestController
@RequestMapping("/api/tasks")
public class TaskController {
    private final TaskService taskService;
    
    @Autowired
    public TaskController(TaskService taskService) {
        this.taskService = taskService;
    }
    
    @GetMapping
    public List<Task> getAllTasks() {
        return taskService.getAllTasks();
    }
    
    @GetMapping("/overdue")
    public List<Task> getOverdueTasks() {
        return taskService.getOverdueTasks();
    }
    
    @PostMapping
    public Task createTask(@RequestBody Task task) {
        return taskService.saveTask(task);
    }
    
    @DeleteMapping("/{id}")
    public void deleteTask(@PathVariable Long id) {
        taskService.deleteTask(id);
    }
}
```

To tie everything together, create a Spring Boot application class:

```java
@SpringBootApplication
public class TaskManagementApplication {
    public static void main(String[] args) {
        SpringApplication.run(TaskManagementApplication.class, args);
    }
}
```

This example demonstrates:
- Spring's layered architecture
- Dependency injection (constructor injection)
- The use of Spring Data for repository creation
- REST API creation with Spring MVC
- Transaction management with `@Transactional`
- Spring Boot auto-configuration

## Summary

Spring's architecture is built on principles that promote modular, testable, and maintainable code:

- **Inversion of Control (IoC)** shifts the responsibility of creating and managing objects to the Spring container
- **Dependency Injection (DI)** reduces coupling between components
- **Spring Core Container** manages beans and their lifecycle
- **Modular design** lets you use only what you need
- **Layered architecture** organizes code by responsibility

Understanding Spring's architecture is essential for building robust applications with the framework. The principles we've explored here form the foundation for more advanced Spring capabilities like aspect-oriented programming, reactive programming, and cloud-native development.

## Additional Resources

To deepen your understanding of Spring Architecture:

1. [Spring Framework Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/)
2. [Spring Boot Reference Guide](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
3. [Martin Fowler's article on Inversion of Control](https://martinfowler.com/articles/injection.html)

## Practice Exercises

1. Create a simple Spring application that demonstrates the three types of dependency injection (constructor, setter, field).
2. Implement a basic CRUD application with at least two related entities.
3. Add cross-cutting concerns like logging or security using Spring AOP.
4. Refactor an existing application to use Spring's dependency injection instead of direct instantiation.
5. Create a Spring Boot application that exposes a REST API and connects to a database.