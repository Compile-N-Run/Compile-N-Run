---
title: Spring Boot Auto-Configuration
description: Learn how Spring Boot's auto-configuration works, why it matters, and how to customize it for your applications

---

# Spring Boot Auto-Configuration

## Introduction

One of the most powerful features of Spring Boot is its ability to automatically configure your application based on the dependencies you've included in your project. This feature, called **auto-configuration**, drastically reduces the amount of boilerplate configuration code you need to write, making Spring Boot applications quick to develop and easy to maintain.

In traditional Spring applications, you would need to configure various components manually using XML files or Java configuration classes. Spring Boot's auto-configuration intelligently sets up these components for you with sensible defaults, allowing you to focus more on business logic and less on infrastructure setup.

## How Auto-Configuration Works

Spring Boot auto-configuration works on a simple principle: it automatically configures beans based on:

1. The dependencies available on the classpath
2. The properties defined in your `application.properties` or `application.yml` file
3. Beans that you've already manually defined

### The @SpringBootApplication Annotation

The magic starts with the `@SpringBootApplication` annotation that you typically place on your main application class:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

This annotation is actually a combination of three other annotations:

- `@Configuration`: Marks the class as a source of bean definitions
- `@ComponentScan`: Enables component scanning in the package of the annotated class and its sub-packages
- `@EnableAutoConfiguration`: Activates Spring Boot's auto-configuration mechanism

### The EnableAutoConfiguration Annotation

The `@EnableAutoConfiguration` annotation tells Spring Boot to start its auto-configuration process. It does this by scanning for special auto-configuration classes included in your application's dependencies.

## Auto-Configuration in Action

Let's look at some examples to understand how auto-configuration works in practice.

### Example 1: Adding Database Support

Simply by adding the H2 database dependency to your `pom.xml` or `build.gradle`, Spring Boot will:

1. Configure a datasource
2. Set up connection pooling
3. Register a JdbcTemplate
4. Configure transaction management

Maven dependency:

```xml
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

With just these dependencies, you can now work with a database without writing any configuration code:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

@Component
public class DatabaseExample {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @PostConstruct
    public void setupDatabase() {
        jdbcTemplate.execute("CREATE TABLE IF NOT EXISTS users (id INT, name VARCHAR(50))");
        jdbcTemplate.execute("INSERT INTO users VALUES (1, 'John')");
        
        String userName = jdbcTemplate.queryForObject(
            "SELECT name FROM users WHERE id = 1", String.class);
        System.out.println("Found user: " + userName);
    }
}
```

Output:
```
Found user: John
```

### Example 2: Adding Web Support

When you add the Spring Web starter, Spring Boot automatically configures:

1. An embedded Tomcat server
2. Spring MVC with sensible defaults
3. JSON conversion with Jackson
4. Error handling pages

Maven dependency:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

Now you can create REST endpoints without any server configuration:

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello, Auto-configuration!";
    }
}
```

When you run the application and navigate to `http://localhost:8080/hello`, you'll see:
```
Hello, Auto-configuration!
```

## Conditional Auto-Configuration

Spring Boot's auto-configuration isn't applied blindly. It uses a variety of conditions to determine whether specific auto-configuration should be applied. These conditions are defined using annotations like:

- `@ConditionalOnClass`: Applies when a specified class is on the classpath
- `@ConditionalOnMissingBean`: Applies when a specified bean is not already defined
- `@ConditionalOnProperty`: Applies based on a Spring Environment property
- `@ConditionalOnWebApplication`: Applies when the application is a web application

Let's examine an auto-configuration class to understand how conditions work:

```java
@Configuration
@ConditionalOnClass(DataSource.class)
@EnableConfigurationProperties(JdbcProperties.class)
public class JdbcTemplateAutoConfiguration {

    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnSingleCandidate(DataSource.class)
    public JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setQueryTimeout(properties.getQueryTimeout());
        return jdbcTemplate;
    }
}
```

This auto-configuration:
1. Only applies when the `DataSource` class is on the classpath
2. Registers a `JdbcTemplate` bean only if one doesn't already exist
3. Customizes the template based on properties from the application configuration

## Customizing Auto-Configuration

While auto-configuration provides sensible defaults, you often need to customize them for your application. There are several ways to do this:

### 1. Using application.properties/application.yml

The simplest way to customize auto-configuration is by setting properties in your `application.properties` or `application.yml` file:

```properties
# Server configuration
server.port=9090
server.servlet.context-path=/myapp

# Database configuration
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret

# JPA properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

### 2. Defining Your Own Beans

If you want to replace an auto-configured bean with your own custom implementation, simply define the bean yourself:

```java
@Configuration
public class MyDataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        return new MyCustomDataSource();
    }
}
```

Spring Boot will detect your custom bean and won't auto-configure its own version.

### 3. Excluding Specific Auto-Configuration

Sometimes you want to prevent certain auto-configuration from being applied. You can do this using the `exclude` attribute of `@EnableAutoConfiguration`:

```java
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

Alternatively, you can also exclude auto-configuration using a property:

```properties
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

## Understanding Auto-Configuration Reports

Spring Boot provides a way to see which auto-configuration is being applied (or not applied) in your application. This can be very helpful for debugging.

To see the auto-configuration report, you can enable debug logging:

```properties
# In application.properties
debug=true
```

When you start your application, you'll see output like:

```
=========================
AUTO-CONFIGURATION REPORT
=========================

Positive matches:
-----------------
   DataSourceAutoConfiguration matched:
      - @ConditionalOnClass found required class 'javax.sql.DataSource' (OnClassCondition)
      - @ConditionalOnMissingBean did not find any beans of type DataSource (OnBeanCondition)

Negative matches:
-----------------
   MongoAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required class 'com.mongodb.MongoClient' (OnClassCondition)
```

## Real-World Example: Building a REST API with Auto-Configuration

Let's build a simple REST API that demonstrates several auto-configuration features:

1. First, we need our dependencies in `pom.xml`:

```xml
<dependencies>
    <!-- Web support -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Database support -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    
    <!-- Validation -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
</dependencies>
```

2. Create an `application.properties` file to customize some settings:

```properties
# Server configuration
server.port=8080

# Database configuration
spring.datasource.url=jdbc:h2:mem:productdb
spring.datasource.driverClassName=org.h2.Driver
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.h2.console.enabled=true

# JPA properties
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

3. Create a Product entity:

```java
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Positive;

@Entity
public class Product {
    
    @Id
    @GeneratedValue
    private Long id;
    
    @NotBlank(message = "Product name is required")
    private String name;
    
    @Positive(message = "Price must be positive")
    private double price;
    
    // Getters and setters
    // ...
}
```

4. Create a repository interface:

```java
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProductRepository extends JpaRepository<Product, Long> {
    // Spring Data JPA will auto-implement this interface
}
```

5. Create a REST controller:

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import javax.validation.Valid;
import java.util.List;

@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @Autowired
    private ProductRepository productRepository;
    
    @GetMapping
    public List<Product> getAllProducts() {
        return productRepository.findAll();
    }
    
    @PostMapping
    public Product createProduct(@Valid @RequestBody Product product) {
        return productRepository.save(product);
    }
    
    @GetMapping("/{id}")
    public Product getProduct(@PathVariable Long id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Product not found"));
    }
}
```

6. Create the main application class:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ProductApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProductApplication.class, args);
    }
}
```

In this example, Spring Boot auto-configures:
- An embedded web server
- A JPA EntityManagerFactory
- An in-memory H2 database
- Spring Data JPA repositories
- JSON serialization/deserialization
- Bean validation
- Error handling

And we didn't have to write a single configuration class!

## Summary

Spring Boot auto-configuration is a powerful feature that:

1. Automatically configures your application based on the dependencies on your classpath
2. Provides sensible defaults that work for most applications
3. Can be easily customized when you need different behavior
4. Reduces boilerplate configuration code
5. Makes it easier to focus on business logic rather than infrastructure setup

Auto-configuration is one of the key reasons Spring Boot has become so popular for building Java applications. It embodies the "convention over configuration" principle and lets developers be productive from day one.

## Additional Resources

- [Spring Boot Auto-configuration Official Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.auto-configuration)
- [Spring Boot Common Application Properties](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html)
- [Creating Your Own Auto-configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration)

## Exercises

1. Create a Spring Boot application that uses auto-configuration for MongoDB instead of a relational database.
2. Customize the embedded server port and context path using properties.
3. Write a custom configuration class that replaces an auto-configured bean with your own implementation.
4. Enable the debug flag and analyze which auto-configurations are being applied in your application.
5. Create a Spring Boot application that disables web-related auto-configuration but still uses JPA.