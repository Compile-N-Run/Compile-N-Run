---
title: Spring Boot Introduction
description: An introduction to Spring Boot framework, its features, components, and how it simplifies Java application development

---

# Spring Boot Introduction

Spring Boot is a powerful and popular Java-based framework that simplifies the process of building production-ready applications. It's built on top of the Spring Framework but eliminates much of the boilerplate configuration that traditional Spring applications require.

## What is Spring Boot?

Spring Boot is an opinionated framework that makes it easy to create stand-alone, production-grade Spring-based applications with minimal effort. It takes an opinionated view of the Spring platform and third-party libraries, allowing you to get started with minimum fuss.

### Key Features of Spring Boot

- **Autoconfiguration**: Automatically configures your application based on the dependencies you've added
- **Standalone**: Creates applications that can run on their own without requiring an external web server
- **Opinionated Defaults**: Provides sensible defaults to reduce development time
- **Production-Ready**: Includes built-in features for metrics, health checks, and externalized configuration
- **No XML Configuration**: Uses Java-based configuration and annotations instead of XML

## Why Use Spring Boot?

Traditional Spring applications often require extensive configuration and setup before you can start building your actual business logic. Spring Boot addresses this issue by:

1. Reducing boilerplate code
2. Simplifying dependency management
3. Providing embedded servers (like Tomcat, Jetty, or Undertow)
4. Offering production-ready features out-of-the-box
5. Supporting multiple data sources and NoSQL databases

## Getting Started with Spring Boot

Let's create a simple Spring Boot application to understand how it works.

### Prerequisites

- Java 8 or higher
- Maven or Gradle
- Your favorite IDE (IntelliJ IDEA, Eclipse, etc.)

### Creating a Spring Boot Project

There are several ways to create a Spring Boot project:

1. Using [Spring Initializr](https://start.spring.io/)
2. Using an IDE with Spring Boot support
3. Using Spring Boot CLI

Let's use Spring Initializr to create our project.

#### Step 1: Generate the Project Structure

Visit [Spring Initializr](https://start.spring.io/) and configure your project:
- Group: `com.example`
- Artifact: `demo`
- Dependencies: Web, DevTools

Click "Generate" to download a ZIP file containing the project skeleton.

#### Step 2: Extract and Import the Project

Extract the downloaded ZIP file and import it into your IDE.

#### Step 3: Understand the Project Structure

A typical Spring Boot project has the following structure:

```
demo/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── example/
│   │   │           └── demo/
│   │   │               └── DemoApplication.java
│   │   └── resources/
│   │       ├── application.properties
│   │       ├── static/
│   │       └── templates/
│   └── test/
│       └── java/
│           └── com/
│               └── example/
│                   └── demo/
│                       └── DemoApplicationTests.java
├── pom.xml (or build.gradle)
└── README.md
```

#### Step 4: Examine the Main Application Class

The main class is automatically generated:

```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

The `@SpringBootApplication` annotation is a combination of:
- `@Configuration`: Tags the class as a source of bean definitions
- `@EnableAutoConfiguration`: Tells Spring Boot to start adding beans based on classpath settings
- `@ComponentScan`: Tells Spring to look for components in the current package and its subpackages

## Creating Your First REST API

Let's create a simple REST API that returns a greeting message.

### Step 1: Create a Controller Class

Add a new class called `HelloController` in the same package as your main application class:

```java
package com.example.demo;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {

    @GetMapping("/hello")
    public String hello(@RequestParam(value = "name", defaultValue = "World") String name) {
        return String.format("Hello, %s!", name);
    }
}
```

### Step 2: Run the Application

Run the `DemoApplication` class from your IDE or use the following command in the terminal:

```bash
./mvnw spring-boot:run  # For Maven
```

or 

```bash
./gradlew bootRun  # For Gradle
```

### Step 3: Test the API

Open your browser and navigate to:
`http://localhost:8080/hello`

You should see:
```
Hello, World!
```

Try with a name parameter:
`http://localhost:8080/hello?name=Spring`

You should see:
```
Hello, Spring!
```

## Spring Boot Configuration

Spring Boot provides several ways to configure your application.

### application.properties

The `application.properties` file is the default location for configuration properties:

```properties
# Server configuration
server.port=8081
server.servlet.context-path=/api

# Logging
logging.level.root=INFO
logging.level.com.example=DEBUG

# Database
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
```

### application.yml

You can also use YAML format for more structured configuration:

```yaml
server:
  port: 8081
  servlet:
    context-path: /api

logging:
  level:
    root: INFO
    com:
      example: DEBUG

spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
```

## Real-World Example: Building a Task Management API

Let's create a more practical example - a simple task management API:

### Step 1: Add Dependencies

Add the following dependencies to your `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <scope>runtime</scope>
</dependency>
```

### Step 2: Create the Task Entity

```java
package com.example.demo.model;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Task {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String description;
    private boolean completed;
    
    // Constructors
    public Task() {}
    
    public Task(String title, String description) {
        this.title = title;
        this.description = description;
        this.completed = false;
    }
    
    // Getters and Setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getTitle() {
        return title;
    }
    
    public void setTitle(String title) {
        this.title = title;
    }
    
    public String getDescription() {
        return description;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public boolean isCompleted() {
        return completed;
    }
    
    public void setCompleted(boolean completed) {
        this.completed = completed;
    }
}
```

### Step 3: Create a Repository Interface

```java
package com.example.demo.repository;

import com.example.demo.model.Task;
import org.springframework.data.jpa.repository.JpaRepository;

public interface TaskRepository extends JpaRepository<Task, Long> {
    // Spring Data JPA automatically implements this interface
}
```

### Step 4: Create a Controller

```java
package com.example.demo.controller;

import com.example.demo.model.Task;
import com.example.demo.repository.TaskRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/tasks")
public class TaskController {

    @Autowired
    private TaskRepository taskRepository;

    // Get all tasks
    @GetMapping
    public List<Task> getAllTasks() {
        return taskRepository.findAll();
    }

    // Create a new task
    @PostMapping
    public Task createTask(@RequestBody Task task) {
        return taskRepository.save(task);
    }

    // Get a task by id
    @GetMapping("/{id}")
    public ResponseEntity<Task> getTaskById(@PathVariable Long id) {
        Optional<Task> task = taskRepository.findById(id);
        
        if (task.isPresent()) {
            return ResponseEntity.ok(task.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }

    // Update a task
    @PutMapping("/{id}")
    public ResponseEntity<Task> updateTask(@PathVariable Long id, @RequestBody Task taskDetails) {
        Optional<Task> optionalTask = taskRepository.findById(id);
        
        if (!optionalTask.isPresent()) {
            return ResponseEntity.notFound().build();
        }
        
        Task task = optionalTask.get();
        task.setTitle(taskDetails.getTitle());
        task.setDescription(taskDetails.getDescription());
        task.setCompleted(taskDetails.isCompleted());
        
        return ResponseEntity.ok(taskRepository.save(task));
    }

    // Delete a task
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteTask(@PathVariable Long id) {
        Optional<Task> task = taskRepository.findById(id);
        
        if (!task.isPresent()) {
            return ResponseEntity.notFound().build();
        }
        
        taskRepository.delete(task.get());
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}
```

### Step 5: Configure the Database

Add the following to your `application.properties`:

```properties
# H2 Database Configuration
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:taskdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

### Step 6: Test the API

You can test your API using tools like Postman or cURL:

**Create a task:**
```bash
curl -X POST http://localhost:8080/api/tasks -H "Content-Type: application/json" -d '{"title":"Learn Spring Boot", "description":"Complete the tutorial"}'
```

**Get all tasks:**
```bash
curl http://localhost:8080/api/tasks
```

## Spring Boot Actuator

Spring Boot Actuator provides production-ready features to help you monitor and manage your application:

1. Add the dependency:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

2. Access endpoints like `/actuator/health` or `/actuator/info`

## Summary

In this introduction to Spring Boot, we learned:

- What Spring Boot is and its key features
- How to create a Spring Boot project
- Building a simple REST API
- Configuring Spring Boot applications
- Implementing a real-world task management API with database integration
- Using Spring Boot Actuator for monitoring

Spring Boot dramatically simplifies Java application development by providing a convention-over-configuration approach. It allows developers to focus on business logic rather than boilerplate setup and configuration.

## Additional Resources

- [Official Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Spring Boot Guides](https://spring.io/guides)
- [Spring Boot API Documentation](https://docs.spring.io/spring-boot/docs/current/api/)
- [Baeldung Spring Boot Tutorials](https://www.baeldung.com/spring-boot)

## Practice Exercises

1. Extend the task management API to include user authentication
2. Add sorting and pagination to the task list endpoint
3. Create a front-end application (using React, Angular, or Vue) to interact with your API
4. Implement validation for task creation and updates
5. Add custom health indicators using Spring Boot Actuator

By mastering Spring Boot, you'll be able to quickly develop robust, production-ready applications with minimal configuration and maximum productivity.