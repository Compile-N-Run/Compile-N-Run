---
title: "Spring REST Introduction"
description: "An introduction to building RESTful web services with Spring Boot, covering core concepts, annotations, and practical examples for beginners."

---

# Spring REST Introduction

## What is REST?

REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful applications use HTTP requests to perform CRUD (Create, Read, Update, Delete) operations on resources. In REST, resources are identified by URIs (Uniform Resource Identifiers), and are manipulated using a standard set of HTTP methods.

Spring provides excellent support for building RESTful web services through its Spring MVC framework and Spring Boot's simplifications.

## Why Spring REST?

Spring REST offers several advantages for building web services:

- **Easy to use**: Spring's annotations make REST service creation straightforward
- **Integration**: Seamless integration with the Spring ecosystem
- **Flexibility**: Support for various data formats (JSON, XML, etc.)
- **Testing**: Comprehensive testing support
- **Security**: Built-in security features through Spring Security

## Key Components of Spring REST

### 1. Spring MVC Framework

Spring MVC is the foundation for building Spring REST services. It provides the `@RestController` annotation, which combines `@Controller` and `@ResponseBody` to create RESTful endpoints.

### 2. HTTP Methods

REST APIs utilize standard HTTP methods for different operations:

| HTTP Method | CRUD Operation | Description |
|-------------|---------------|-------------|
| GET | Read | Retrieve a resource or collection |
| POST | Create | Create a new resource |
| PUT | Update | Update an existing resource (full update) |
| PATCH | Update | Partially update a resource |
| DELETE | Delete | Remove a resource |

### 3. Spring REST Annotations

Key annotations for building REST APIs in Spring:

- `@RestController`: Marks a class as a REST controller
- `@RequestMapping`: Maps HTTP requests to handler methods
- `@GetMapping`, `@PostMapping`, etc.: Shortcuts for `@RequestMapping` with specific HTTP methods
- `@PathVariable`: Extracts values from the URI path
- `@RequestParam`: Extracts query parameters
- `@RequestBody`: Binds the HTTP request body to an object

## Setting Up Your First Spring REST API

### Prerequisites

- Java 8 or higher
- Maven or Gradle
- Basic knowledge of Spring framework

### Step 1: Create a Spring Boot Project

You can use [Spring Initializr](https://start.spring.io/) to create a new Spring Boot project with the following dependencies:

- Spring Web
- Spring Data JPA (optional, for database access)
- H2 Database (optional, for in-memory database)

### Step 2: Create a Model Class

Let's create a simple `Product` class:

```java
package com.example.demo.model;

public class Product {
    private Long id;
    private String name;
    private double price;
    
    // Default constructor
    public Product() {
    }
    
    // Parameterized constructor
    public Product(Long id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }
    
    // Getters and setters
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public double getPrice() {
        return price;
    }
    
    public void setPrice(double price) {
        this.price = price;
    }
}
```

### Step 3: Create a Controller

Now, let's create a REST controller to handle product-related requests:

```java
package com.example.demo.controller;

import com.example.demo.model.Product;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

@RestController
@RequestMapping("/api/products")
public class ProductController {

    private final ConcurrentHashMap<Long, Product> products = new ConcurrentHashMap<>();
    private final AtomicLong idCounter = new AtomicLong();
    
    // Constructor with some sample data
    public ProductController() {
        Product product1 = new Product(idCounter.incrementAndGet(), "Laptop", 1299.99);
        Product product2 = new Product(idCounter.incrementAndGet(), "Smartphone", 699.99);
        products.put(product1.getId(), product1);
        products.put(product2.getId(), product2);
    }

    // Get all products
    @GetMapping
    public List<Product> getAllProducts() {
        return new ArrayList<>(products.values());
    }
    
    // Get product by ID
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        Product product = products.get(id);
        if (product == null) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        return new ResponseEntity<>(product, HttpStatus.OK);
    }
    
    // Create a new product
    @PostMapping
    public ResponseEntity<Product> createProduct(@RequestBody Product product) {
        product.setId(idCounter.incrementAndGet());
        products.put(product.getId(), product);
        return new ResponseEntity<>(product, HttpStatus.CREATED);
    }
    
    // Update a product
    @PutMapping("/{id}")
    public ResponseEntity<Product> updateProduct(@PathVariable Long id, @RequestBody Product product) {
        if (!products.containsKey(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        product.setId(id);
        products.put(id, product);
        return new ResponseEntity<>(product, HttpStatus.OK);
    }
    
    // Delete a product
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        if (!products.containsKey(id)) {
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
        products.remove(id);
        return new ResponseEntity<>(HttpStatus.NO_CONTENT);
    }
}
```

## Testing Your REST API

You can test your REST API using various tools:

1. **Postman**: A user-friendly tool for API testing
2. **cURL**: Command-line tool for making HTTP requests
3. **Spring Boot Test**: For automated testing

### Example: Testing with cURL

Here are some examples of testing our product API with cURL:

#### Get all products:
```bash
curl -X GET http://localhost:8080/api/products
```

Expected output:
```json
[
  {
    "id": 1,
    "name": "Laptop",
    "price": 1299.99
  },
  {
    "id": 2,
    "name": "Smartphone",
    "price": 699.99
  }
]
```

#### Get a single product:
```bash
curl -X GET http://localhost:8080/api/products/1
```

Expected output:
```json
{
  "id": 1,
  "name": "Laptop",
  "price": 1299.99
}
```

#### Create a new product:
```bash
curl -X POST http://localhost:8080/api/products \
  -H "Content-Type: application/json" \
  -d '{"name": "Tablet", "price": 499.99}'
```

Expected output:
```json
{
  "id": 3,
  "name": "Tablet",
  "price": 499.99
}
```

## Common HTTP Status Codes in REST

Understanding HTTP status codes is crucial when working with REST APIs:

| Status Code | Description | Example Use |
|-------------|-------------|------------|
| 200 OK | Request successful | GET request completed successfully |
| 201 Created | Resource created | POST request created a new resource |
| 204 No Content | Success, but no content returned | DELETE operation completed |
| 400 Bad Request | Invalid request | Client sent malformed data |
| 401 Unauthorized | Authentication required | User not authenticated |
| 403 Forbidden | Permission denied | User lacks necessary permissions |
| 404 Not Found | Resource not found | Requested ID doesn't exist |
| 500 Internal Server Error | Server error | Exception occurred on server |

## Best Practices for REST APIs

1. **Use nouns, not verbs for endpoints**: e.g., `/api/products` instead of `/api/getProducts`
   
2. **Use plural nouns for collections**: e.g., `/api/products` instead of `/api/product`
   
3. **Use HTTP methods appropriately**: 
   - GET for fetching
   - POST for creating
   - PUT for replacing/updating
   - DELETE for removing
   
4. **Use proper HTTP status codes**: Respond with appropriate status codes based on the operation result
   
5. **Versioning**: Consider versioning your API (e.g., `/api/v1/products`)
   
6. **Pagination**: Implement pagination for collections with many items
   
7. **Error handling**: Provide clear error messages and appropriate status codes
   
8. **Security**: Implement authentication and authorization for protected resources

## Real-World Example: Product Catalog API

Let's enhance our basic product example with some real-world features:

### Adding Validation

First, add the validation dependency to your pom.xml:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

Now, update the Product class with validation annotations:

```java
package com.example.demo.model;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

public class Product {
    private Long id;
    
    @NotBlank(message = "Product name is required")
    private String name;
    
    @NotNull(message = "Price is required")
    @Min(value = 0, message = "Price must be positive")
    private Double price;
    
    private String category;
    
    // Constructors, getters and setters
    // ...
}
```

Update the controller to handle validation:

```java
@PostMapping
public ResponseEntity<Object> createProduct(@Valid @RequestBody Product product, BindingResult result) {
    if (result.hasErrors()) {
        Map<String, String> errors = new HashMap<>();
        result.getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }
    
    product.setId(idCounter.incrementAndGet());
    products.put(product.getId(), product);
    return new ResponseEntity<>(product, HttpStatus.CREATED);
}
```

## Summary

In this introduction to Spring REST, we've covered:

1. The fundamentals of REST architecture
2. Setting up a Spring Boot project for RESTful services
3. Creating models and controllers for a basic REST API
4. Using Spring REST annotations to handle HTTP requests
5. Testing REST endpoints with cURL
6. Best practices for designing REST APIs
7. A practical example of a product catalog API

REST APIs are a fundamental component of modern web applications, and Spring provides powerful tools to build them efficiently. As you continue your Spring REST journey, you'll discover more advanced features like security, documentation, and microservices integration.

## Additional Resources

- [Spring Official Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-controller)
- [RESTful Web Services by Roy Fielding](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm)
- [Spring Boot Reference Documentation](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)

## Exercises

1. **Basic Exercise**: Extend the Product API to include filtering by price range using query parameters.
2. **Intermediate Exercise**: Add support for paginating the list of products.
3. **Advanced Exercise**: Implement a search functionality that allows searching products by name and category.
4. **Challenge Exercise**: Add Spring Security to your API and require authentication for POST, PUT, and DELETE operations.

Happy coding with Spring REST!