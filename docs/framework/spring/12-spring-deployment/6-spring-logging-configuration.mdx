---
title: Spring Logging Configuration
description: Learn how to configure and customize logging in Spring applications using SLF4J, Logback, and other logging frameworks.

---

# Spring Logging Configuration

## Introduction

Logging is a critical aspect of application development that allows developers to record events, debug issues, and monitor application behavior. Spring Framework provides a flexible logging architecture that can be configured to suit different environments and requirements.

In this guide, you'll learn how to effectively configure logging in Spring applications. We'll explore various logging frameworks that integrate with Spring, configuration methods, and best practices to implement logging in your applications.

## Spring Logging Architecture

Spring Framework doesn't provide its own logging implementation but relies on [Commons Logging](https://commons.apache.org/proper/commons-logging/) as a bridge to various logging frameworks. This approach gives you the flexibility to choose the logging framework that best suits your needs:

- **SLF4J (Simple Logging Facade for Java)**: A facade that provides a simple abstraction of all logging frameworks
- **Logback**: A widely used logging framework and the successor to Log4j
- **Log4j2**: A modern, high-performance logging framework
- **Java Util Logging (JUL)**: Java's built-in logging utility

Most Spring applications today use SLF4J with Logback as the actual implementation, and this is the approach we'll focus on in this guide.

## Setting Up Basic Logging

### Step 1: Adding Dependencies

First, let's add the necessary dependencies to your project's `pom.xml` file (for Maven):

```xml
<dependencies>
    <!-- Spring Boot Starter includes logging by default -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    
    <!-- If you need additional logging capabilities -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-logging</artifactId>
    </dependency>
</dependencies>
```

If you're using Spring Boot, the `spring-boot-starter` includes Logback as the default logging framework, along with SLF4J as the API.

### Step 2: Creating a Basic Logger

Here's how to create and use a logger in your Spring components:

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    // Create a logger for this class
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);
    
    public void createUser(String username) {
        // Different logging levels
        logger.trace("Trace: Creating user with username: {}", username);
        logger.debug("Debug: Creating user with username: {}", username);
        logger.info("User created: {}", username);
        logger.warn("Warning: User creation may be slow");
        
        try {
            // Some user creation logic
            if (username == null) {
                throw new IllegalArgumentException("Username cannot be null");
            }
        } catch (Exception e) {
            logger.error("Failed to create user: {}", username, e);
        }
    }
}
```

In this example:
- We use SLF4J's `LoggerFactory` to create a logger for the class
- The logger provides different methods for various logging levels
- We use parameterized logging with `{}` placeholders, which is more efficient than string concatenation

## Configuring Logging in Spring Boot

Spring Boot provides several ways to configure logging. Let's explore them:

### Application Properties

The simplest way to customize logging in Spring Boot is through the `application.properties` or `application.yml` file:

```properties
# Set the global log level
logging.level.root=INFO

# Set log level for specific packages
logging.level.org.springframework=WARN
logging.level.com.myapp=DEBUG

# Log file configuration
logging.file.name=application.log
logging.file.path=/var/logs

# Log pattern configuration
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
```

Or with YAML format:

```yaml
logging:
  level:
    root: INFO
    org.springframework: WARN
    com.myapp: DEBUG
  file:
    name: application.log
    path: /var/logs
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
```

### Using a Logback Configuration File

For more advanced configurations, you can use a dedicated Logback configuration file:

1. Create a `logback-spring.xml` file in your `src/main/resources` directory:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- Console Appender -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>

    <!-- File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <encoder>
            <pattern>
                %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
            </pattern>
        </encoder>
    </appender>

    <!-- Logger Configurations -->
    <logger name="com.myapp" level="DEBUG" />
    <logger name="org.springframework" level="WARN" />

    <!-- Root Logger -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
    </root>
</configuration>
```

This configuration:
- Creates a console appender for logging to the terminal
- Creates a file appender that rolls over daily
- Sets specific log levels for different packages
- Configures the root logger to use both appenders

## Advanced Logging Configurations

### Profiles-Specific Logging

Spring Boot allows you to have environment-specific logging configurations using profiles:

```xml
<!-- In logback-spring.xml -->
<springProfile name="development">
    <root level="DEBUG">
        <appender-ref ref="CONSOLE" />
    </root>
</springProfile>

<springProfile name="production">
    <root level="ERROR">
        <appender-ref ref="FILE" />
    </root>
</springProfile>
```

### Customizing Log Colors in Console

For better readability in development, you can customize log colors:

```xml
<configuration>
    <conversionRule conversionWord="clr" 
                    converterClass="org.springframework.boot.logging.logback.ColorConverter" />
                    
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>
                %clr(%d{HH:mm:ss.SSS}){yellow} %clr([%thread]){magenta} %clr(%-5level) %clr(%logger{36}){cyan} - %msg%n
            </pattern>
        </encoder>
    </appender>
    
    <!-- Other configurations -->
</configuration>
```

### JSON Logging for Production

In production environments, it's often useful to log in JSON format for easier integration with log management systems:

```xml
<configuration>
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/application.json</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/application.%d{yyyy-MM-dd}.json</fileNamePattern>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <!-- This encoder produces JSON formatted logs -->
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="JSON_FILE" />
    </root>
</configuration>
```

To use the Logstash encoder, add the following dependency:

```xml
<dependency>
    <groupId>net.logstash.logback</groupId>
    <artifactId>logstash-logback-encoder</artifactId>
    <version>7.3</version>
</dependency>
```

## Practical Example: Complete Application Logging

Let's put everything together with a practical example of a Spring Boot application with proper logging:

### Step 1: Set up the project with proper dependencies

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>net.logstash.logback</groupId>
        <artifactId>logstash-logback-encoder</artifactId>
        <version>7.3</version>
    </dependency>
</dependencies>
```

### Step 2: Create a comprehensive logging configuration file

```xml
<!-- src/main/resources/logback-spring.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property name="LOG_FILE" value="logs/application" />
    <property name="LOG_PATTERN" value="%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n" />
    
    <!-- Console Appender for Development -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
    </appender>

    <!-- Rolling File Appender -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
        </encoder>
    </appender>

    <!-- JSON Appender for Production -->
    <appender name="JSON" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_FILE}.json</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.%i.json</fileNamePattern>
            <maxFileSize>10MB</maxFileSize>
            <maxHistory>7</maxHistory>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder" />
    </appender>

    <!-- Development Environment Configuration -->
    <springProfile name="dev">
        <logger name="com.myapp" level="DEBUG" />
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
            <appender-ref ref="FILE" />
        </root>
    </springProfile>

    <!-- Production Environment Configuration -->
    <springProfile name="prod">
        <logger name="com.myapp" level="INFO" />
        <root level="WARN">
            <appender-ref ref="FILE" />
            <appender-ref ref="JSON" />
        </root>
    </springProfile>

    <!-- Default Configuration (if no profile specified) -->
    <springProfile name="default">
        <root level="INFO">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>
</configuration>
```

### Step 3: Create a controller with proper logging

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {
    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    
    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        logger.debug("Received request to get user with ID: {}", id);
        
        try {
            // Simulate database access
            if (id <= 0) {
                logger.warn("Invalid user ID requested: {}", id);
                throw new IllegalArgumentException("Invalid user ID");
            }
            
            User user = new User(id, "User " + id);
            logger.info("Retrieved user: {}", user);
            return user;
        } catch (Exception e) {
            logger.error("Failed to retrieve user with ID: {}", id, e);
            throw e;
        }
    }
    
    @PostMapping
    public User createUser(@RequestBody User user) {
        logger.info("Creating new user: {}", user);
        
        // Add user processing logic here
        
        logger.debug("User created successfully with ID: {}", user.getId());
        return user;
    }
    
    // User class for the example
    static class User {
        private Long id;
        private String name;
        
        public User(Long id, String name) {
            this.id = id;
            this.name = name;
        }
        
        public Long getId() { return id; }
        public void setId(Long id) { this.id = id; }
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        @Override
        public String toString() {
            return "User{id=" + id + ", name='" + name + "'}";
        }
    }
}
```

### Step 4: Configure application profiles

```yaml
# src/main/resources/application.yml
spring:
  profiles:
    active: dev
```

When testing the application locally and making a request to `/api/users/1`:

**Console Output**:
```
10:15:23.456 [http-nio-8080-exec-1] DEBUG com.myapp.UserController - Received request to get user with ID: 1
10:15:23.510 [http-nio-8080-exec-1] INFO  com.myapp.UserController - Retrieved user: User{id=1, name='User 1'}
```

When deployed to production with `-Dspring.profiles.active=prod`, the logs would be written to files instead of the console, with the JSON format providing structured logging for better log analysis.

## Best Practices for Spring Logging

Here are some recommended practices for logging in Spring applications:

1. **Use the Appropriate Log Level**:
   - `ERROR`: Runtime errors or unexpected conditions that may cause application to abort
   - `WARN`: Potentially harmful situations that won't stop the application
   - `INFO`: Interesting runtime events (startup/shutdown, configuration)
   - `DEBUG`: Detailed information on application flow (development only)
   - `TRACE`: Very detailed information (rarely used)

2. **Use Parameterized Logging**: Always use `logger.info("Found {} records", count)` instead of string concatenation to avoid unnecessary object creation.

3. **Include Context Information**: Log messages should provide enough context to understand what happened.

4. **Consider Log Structure**: Structure your logs consistently to make them more parseable.

5. **Don't Log Sensitive Data**: Never log passwords, tokens, or personally identifiable information.

6. **Configure Different Environments Properly**: Development environments may need more verbose logging than production.

7. **Use MDC (Mapped Diagnostic Context)** for request tracking:

```java
import org.slf4j.MDC;

// In a filter or interceptor
MDC.put("requestId", UUID.randomUUID().toString());
MDC.put("userId", currentUser.getId());

try {
    // Process the request...
} finally {
    MDC.clear(); // Always clean up
}
```

And update your log pattern:

```xml
<pattern>%d{HH:mm:ss.SSS} [%thread] [%X{requestId}] [%X{userId}] %-5level %logger{36} - %msg%n</pattern>
```

## Summary

In this guide, we've covered:

- Spring's logging architecture using SLF4J and Logback
- How to set up basic logging in Spring applications
- Various configuration options using `application.properties` and `logback-spring.xml`
- Advanced logging configurations including profile-specific settings and JSON logging
- A practical example of a complete application with appropriate logging
- Best practices for effective logging

Proper logging is essential for monitoring, troubleshooting, and maintaining Spring applications. By following the techniques and practices outlined in this guide, you'll be able to configure logging effectively for your Spring applications, making them more maintainable and easier to debug.

## Additional Resources

- [Spring Boot Logging Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging)
- [SLF4J Official Documentation](https://www.slf4j.org/manual.html)
- [Logback Project Documentation](https://logback.qos.ch/documentation.html)
- [Logstash Encoder for Logback](https://github.com/logfellow/logstash-logback-encoder)

## Exercises

1. Configure a Spring Boot application to have different logging levels for development and production environments.
2. Implement a custom `LoggingFilter` that logs request details including headers, URL, and response time.
3. Set up log rotation so that your application creates new log files every day and deletes logs older than 14 days.
4. Configure JSON logging and integrate it with a log aggregation tool like ELK stack (Elasticsearch, Logstash, Kibana).
5. Create a custom Logback appender that sends critical error logs as email notifications.