---
title: Spring CI/CD Integration
description: Learn how to integrate Spring Boot applications with Continuous Integration and Continuous Deployment pipelines for automated testing and deployment

---

# Spring CI/CD Integration

## Introduction

Continuous Integration and Continuous Deployment (CI/CD) has become an essential practice in modern software development. For Spring Boot applications, integrating CI/CD pipelines ensures that your code is automatically built, tested, and deployed consistently, reducing manual errors and improving development efficiency.

In this tutorial, we'll explore how to integrate Spring Boot applications with popular CI/CD tools and build automated pipelines that take your code from repository to production environments seamlessly.

## What is CI/CD?

Before diving into the implementation, let's understand the core concepts:

- **Continuous Integration (CI)**: The practice of frequently merging code changes into a central repository, followed by automated builds and tests.
- **Continuous Deployment (CD)**: The practice of automatically deploying all code changes to a testing or production environment after the build stage.

CI/CD provides several benefits for Spring applications:
- Early detection of integration problems
- Automated quality control
- Faster release cycles
- Consistent deployment processes

## Setting Up CI/CD for Spring Boot Applications

### Prerequisites

Before you begin, make sure you have:

- A Spring Boot application with a proper project structure
- A Git repository (GitHub, GitLab, Bitbucket, etc.)
- Basic understanding of build tools like Maven or Gradle

## CI/CD with GitHub Actions for Spring Boot

GitHub Actions is a popular choice for CI/CD due to its tight integration with GitHub repositories.

### Step 1: Create a GitHub Actions Workflow File

In your Spring Boot project, create a directory structure `.github/workflows/` and add a YAML file named `spring-boot-ci.yml`:

```yaml
name: Spring Boot CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package --file pom.xml
    
    - name: Run tests
      run: mvn test
    
    - name: Create build artifact
      run: mkdir staging && cp target/*.jar staging
    
    - name: Upload artifact
      uses: actions/upload-artifact@v3
      with:
        name: spring-app
        path: staging
```

This workflow triggers on pushes to the main branch or when pull requests target the main branch. It sets up Java, builds the project with Maven, runs tests, and uploads the resulting JAR as an artifact.

### Step 2: Add Deployment to Your Workflow

Let's extend our workflow to include deployment:

```yaml
    # Add this job after the 'build' job
    deploy:
      needs: build
      runs-on: ubuntu-latest
      if: github.ref == 'refs/heads/main'
      
      steps:
      - name: Download artifact
        uses: actions/download-artifact@v3
        with:
          name: spring-app
          
      - name: Deploy to production
        run: |
          # This is where you would add your deployment script
          # For example, deploying to a cloud service or server
          echo "Deploying application to production server"
          # Example: scp *.jar user@your-server:/path/to/deploy/
```

## CI/CD with Jenkins for Spring Boot

Jenkins is a powerful, self-hosted CI/CD tool widely used in the industry.

### Step 1: Create a Jenkinsfile

In your Spring Boot project's root directory, create a file named `Jenkinsfile`:

```groovy
pipeline {
    agent any
    
    tools {
        maven 'Maven 3.8.6'
        jdk 'JDK 17'
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        
        stage('Build') {
            steps {
                sh 'mvn clean package -DskipTests'
            }
        }
        
        stage('Test') {
            steps {
                sh 'mvn test'
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }
        
        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('SonarQube') {
                    sh 'mvn sonar:sonar'
                }
            }
        }
        
        stage('Deploy to Dev') {
            when {
                branch 'develop'
            }
            steps {
                echo 'Deploying to Development environment'
                // Add deployment steps here
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                echo 'Deploying to Production environment'
                // Add production deployment steps here
            }
        }
    }
    
    post {
        success {
            echo 'Pipeline succeeded!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}
```

This Jenkins pipeline:
- Checks out your code from version control
- Builds the application with Maven
- Runs the tests and publishes the results
- Performs code quality analysis with SonarQube
- Deploys to different environments based on the branch

## Automating Docker Deployments

For containerized Spring Boot applications, you can add Docker build and push steps.

### Step 1: Create a Dockerfile

First, create a `Dockerfile` in your project root:

```Dockerfile
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app

COPY target/*.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### Step 2: Add Docker Build and Push to Workflow

Add Docker steps to your GitHub Actions workflow:

```yaml
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
      
    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        
    - name: Build and push
      uses: docker/build-push-action@v3
      with:
        context: .
        push: true
        tags: yourusername/spring-app:latest
```

Make sure to add your Docker Hub credentials as secrets in your GitHub repository settings.

## Setting Up a Complete CI/CD Pipeline for Spring Boot

Let's look at a more comprehensive example that includes:
- Building and testing
- Creating a Docker image
- Scanning for vulnerabilities
- Deploying to different environments

### GitHub Actions Example:

```yaml
name: Spring Boot Complete CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package --file pom.xml
      
    - name: Run tests
      run: mvn test
      
    - name: Run integration tests
      run: mvn verify -P integration-test
      
    - name: Cache SonarQube packages
      uses: actions/cache@v3
      with:
        path: ~/.sonar/cache
        key: ${{ runner.os }}-sonar
        
    - name: SonarQube Analysis
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: mvn sonar:sonar
    
    - name: Create build artifact
      run: mkdir staging && cp target/*.jar staging
    
    - name: Upload artifact
      uses: actions/upload-artifact@v3
      with:
        name: spring-app
        path: staging

  docker:
    needs: build
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Download artifact
      uses: actions/download-artifact@v3
      with:
        name: spring-app
        path: staging
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Login to DockerHub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Build and push
      uses: docker/build-push-action@v3
      with:
        context: .
        push: true
        tags: yourusername/spring-app:${{ github.sha }}
        
    - name: Scan Docker image for vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'yourusername/spring-app:${{ github.sha }}'
        format: 'sarif'
        output: 'trivy-results.sarif'

  deploy-dev:
    needs: docker
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    environment: development
    steps:
    - name: Deploy to Dev
      run: |
        echo "Deploying to Dev environment"
        # Add your deployment script here, e.g., using kubectl, helm, ssh, etc.
        
  deploy-prod:
    needs: docker
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    steps:
    - name: Deploy to Production
      run: |
        echo "Deploying to Production environment"
        # Add your production deployment script here
```

## Real-World Example: Spring Boot with Kubernetes Deployment

Let's create a practical example of deploying a Spring Boot application to Kubernetes.

### Step 1: Create Kubernetes Deployment Files

Create a directory called `k8s` and add these files:

**deployment.yml**:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: spring-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: spring-app
  template:
    metadata:
      labels:
        app: spring-app
    spec:
      containers:
      - name: spring-app
        image: ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5
```

**service.yml**:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: spring-app-service
spec:
  selector:
    app: spring-app
  ports:
  - port: 80
    targetPort: 8080
  type: LoadBalancer
```

### Step 2: Add Kubernetes Deployment to Workflow

Extend your GitHub Actions workflow to deploy to Kubernetes:

```yaml
  deploy-to-k8s:
    needs: docker
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
      
    - name: Set up kubectl
      uses: Azure/setup-kubectl@v3
      
    - name: Set Kubernetes context
      uses: Azure/k8s-set-context@v3
      with:
        kubeconfig: ${{ secrets.KUBE_CONFIG }}
        
    - name: Update deployment image
      run: |
        sed -i "s|\${DOCKER_IMAGE_NAME}|yourusername/spring-app|g" k8s/deployment.yml
        sed -i "s|\${DOCKER_IMAGE_TAG}|${{ github.sha }}|g" k8s/deployment.yml
        
    - name: Deploy to Kubernetes
      run: |
        kubectl apply -f k8s/deployment.yml
        kubectl apply -f k8s/service.yml
        kubectl rollout status deployment/spring-app
```

Add your `KUBE_CONFIG` as a secret in your GitHub repository settings.

## Best Practices for Spring Boot CI/CD

1. **Automate Everything**: Aim to automate all aspects of building, testing, and deploying.

2. **Test at Multiple Levels**: Include unit, integration, and end-to-end tests in your pipeline.

3. **Use Spring Profiles**: Configure different Spring profiles for different environments:

```java
@Configuration
@Profile("production")
public class ProductionConfig {
    // Production-specific beans and configuration
}
```

4. **Externalize Configuration**: Use environment variables or ConfigMaps in Kubernetes for environment-specific settings:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: spring-app-config
data:
  application.yml: |
    spring:
      datasource:
        url: jdbc:mysql://production-db:3306/myapp
```

5. **Implement Blue-Green Deployments**: Use strategies that reduce downtime:

```yaml
# In your Kubernetes deployment strategy
spec:
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 1
```

6. **Monitor Your Applications**: Include monitoring and observability tools:

```xml
<!-- Add Spring Boot Actuator for monitoring -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

## Real-World Use Case: E-Commerce Platform Deployment

Let's look at how a real-world e-commerce platform might set up its CI/CD pipeline:

1. **Development Workflow**:
   - Developers work on feature branches
   - Pull requests trigger builds and tests
   - Merged code to develop branch deploys to the staging environment
   - Releases to main branch deploy to production

2. **Environment-Specific Configuration**:

```properties
# application-dev.properties
spring.datasource.url=jdbc:mysql://dev-db:3306/ecommerce
spring.jpa.hibernate.ddl-auto=update

# application-prod.properties
spring.datasource.url=jdbc:mysql://prod-db:3306/ecommerce
spring.jpa.hibernate.ddl-auto=validate
spring.cache.type=redis
```

3. **Database Migration Handling**:

```yaml
# In your CI/CD pipeline
- name: Run database migrations
  run: |
    ./mvnw flyway:migrate -Dflyway.configFiles=flyway-${ENVIRONMENT}.conf
```

4. **Canary Deployments**:
   - Deploy new version to a small subset of users first
   - Monitor for issues
   - Gradually increase traffic to the new version

## Summary

Implementing CI/CD for Spring Boot applications brings numerous benefits including faster feedback cycles, more reliable deployments, and reduced time to market. We've covered:

- Setting up CI/CD pipelines with GitHub Actions and Jenkins
- Docker container integration for Spring applications
- Kubernetes deployment automation 
- Best practices for Spring Boot CI/CD

By adopting these practices, you'll create a more efficient, reliable development workflow for your Spring Boot applications.

## Additional Resources

- [Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [Jenkins Documentation](https://www.jenkins.io/doc/)
- [Docker Documentation](https://docs.docker.com/)
- [Kubernetes Documentation](https://kubernetes.io/docs/home/)

## Exercises

1. Set up a basic GitHub Actions workflow for a Spring Boot application that builds and tests the code.

2. Create a Docker container for your Spring Boot application and push it to Docker Hub.

3. Extend your CI/CD pipeline to include SonarQube code quality analysis.

4. Configure a multi-environment deployment pipeline that deploys to dev, staging, and production environments.

5. Implement blue-green deployment for a Spring Boot application using Kubernetes.