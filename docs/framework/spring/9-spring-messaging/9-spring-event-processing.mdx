---
title: Spring Event Processing
description: Learn how Spring's event processing system works, including publishing and handling application events for decoupled communication between components in Spring applications.

---

# Spring Event Processing

## Introduction

Spring's event processing system provides a powerful mechanism for components to communicate with each other without direct coupling. This event-driven architecture allows for more maintainable and flexible applications by separating the components that generate events (publishers) from those that respond to them (listeners).

In this tutorial, we'll explore Spring's event processing capabilities, how to create custom events, publish them, and handle them in different parts of your application.

## Understanding Spring Events

At its core, Spring's event mechanism consists of three main components:

1. **Events** - Objects that carry information about an action or change in state
2. **Publishers** - Components that detect changes and publish events
3. **Listeners** - Components that listen for specific events and respond to them

Spring provides built-in events (like `ContextRefreshedEvent` when the application context is initialized), but the real power comes from creating and using custom events specific to your application domain.

## Creating Custom Events

Let's create our first custom event. In Spring, all events should extend the `ApplicationEvent` class.

```java
import org.springframework.context.ApplicationEvent;

public class OrderCreatedEvent extends ApplicationEvent {
    
    private final String orderNumber;
    
    public OrderCreatedEvent(Object source, String orderNumber) {
        super(source);
        this.orderNumber = orderNumber;
    }
    
    public String getOrderNumber() {
        return orderNumber;
    }
}
```

This event represents the creation of a new order in our system and carries the order number.

## Publishing Events

To publish an event, we use the `ApplicationEventPublisher` which can be injected into any Spring bean:

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
public class OrderService {

    private final ApplicationEventPublisher eventPublisher;
    
    public OrderService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    public void createOrder(String orderDetails) {
        // Business logic to create an order
        String orderNumber = generateOrderNumber();
        
        // Publish an event that order was created
        eventPublisher.publishEvent(new OrderCreatedEvent(this, orderNumber));
        
        System.out.println("Order " + orderNumber + " created and event published");
    }
    
    private String generateOrderNumber() {
        return "ORD-" + System.currentTimeMillis();
    }
}
```

## Handling Events

There are multiple ways to listen for events in Spring.

### Method 1: Using the @EventListener Annotation

The simplest way to handle events is by using the `@EventListener` annotation on any method in a Spring bean:

```java
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class OrderEventListener {

    @EventListener
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        System.out.println("Received OrderCreatedEvent - Order Number: " + 
                          event.getOrderNumber());
        
        // Process the event - e.g., send confirmation email
        sendOrderConfirmation(event.getOrderNumber());
    }
    
    private void sendOrderConfirmation(String orderNumber) {
        System.out.println("Sending confirmation email for order: " + orderNumber);
        // Email sending logic would go here
    }
}
```

### Method 2: Implementing the ApplicationListener Interface

Alternatively, you can implement the `ApplicationListener` interface:

```java
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class OrderNotificationListener implements ApplicationListener<OrderCreatedEvent> {

    @Override
    public void onApplicationEvent(OrderCreatedEvent event) {
        System.out.println("Notification system received OrderCreatedEvent - Order Number: " + 
                          event.getOrderNumber());
        
        // Notify other systems
        notifyInventorySystem(event.getOrderNumber());
    }
    
    private void notifyInventorySystem(String orderNumber) {
        System.out.println("Notifying inventory system about order: " + orderNumber);
        // Integration code would go here
    }
}
```

## Asynchronous Event Processing

By default, event processing is synchronous, meaning the publisher thread waits until all listeners finish processing the event. For long-running operations, you might want to process events asynchronously.

To enable asynchronous event processing, you need to:

1. Add the `@EnableAsync` annotation to your configuration class
2. Add the `@Async` annotation to your event listener methods

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class AsyncConfig {
    // Configuration details if needed
}
```

```java
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

@Component
public class AsyncOrderEventListener {

    @EventListener
    @Async
    public void handleOrderCreatedEvent(OrderCreatedEvent event) {
        // Simulate time-consuming process
        try {
            System.out.println("Starting async processing for order: " + event.getOrderNumber());
            Thread.sleep(2000);
            System.out.println("Completed async processing for order: " + event.getOrderNumber());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## Ordering Event Listeners

When you have multiple listeners for the same event, you can control their execution order using the `@Order` annotation:

```java
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
public class MultipleOrderEventListeners {

    @EventListener
    @Order(1)
    public void logOrderCreation(OrderCreatedEvent event) {
        System.out.println("[FIRST] Logging order creation: " + event.getOrderNumber());
    }
    
    @EventListener
    @Order(2)
    public void notifyAboutOrder(OrderCreatedEvent event) {
        System.out.println("[SECOND] Sending notifications for order: " + event.getOrderNumber());
    }
}
```

## Conditional Event Processing

Spring allows you to conditionally process events using the `condition` attribute of the `@EventListener` annotation:

```java
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class ConditionalOrderEventListener {

    @EventListener(condition = "#event.orderNumber.startsWith('ORD-2')")
    public void handlePriorityOrders(OrderCreatedEvent event) {
        System.out.println("Priority order detected: " + event.getOrderNumber());
        processPriorityOrder(event.getOrderNumber());
    }
    
    private void processPriorityOrder(String orderNumber) {
        System.out.println("Processing priority order with expedited shipping: " + orderNumber);
    }
}
```

## Complete Example Application

Let's tie everything together in a complete example:

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class EventDemoApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(EventDemoApplication.class, args);
        
        // Get our order service and create some orders
        OrderService orderService = context.getBean(OrderService.class);
        orderService.createOrder("Product A");
        orderService.createOrder("Product B");
        
        // Give some time for async listeners to complete
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        context.close();
    }
}
```

**Output (example):**
```
Order ORD-1630572809123 created and event published
Received OrderCreatedEvent - Order Number: ORD-1630572809123
Sending confirmation email for order: ORD-1630572809123
Notification system received OrderCreatedEvent - Order Number: ORD-1630572809123
Notifying inventory system about order: ORD-1630572809123
[FIRST] Logging order creation: ORD-1630572809123
[SECOND] Sending notifications for order: ORD-1630572809123
Starting async processing for order: ORD-1630572809123
Order ORD-1630572809456 created and event published
Received OrderCreatedEvent - Order Number: ORD-1630572809456
...
Completed async processing for order: ORD-1630572809123
...
```

## Real-world Applications

Spring Events are valuable in many scenarios:

1. **Audit logging** - Record system activities without cluttering business logic
2. **Cache invalidation** - Clear caches when data changes
3. **Notifications** - Send emails, SMS, or push notifications
4. **Integration with external systems** - Trigger workflows in other applications
5. **Multi-step processes** - Coordinate complex workflows across different components

### Example: E-commerce System

In an e-commerce application, events can create a cohesive yet decoupled system:

```java
// Various events
public class OrderCreatedEvent extends ApplicationEvent { /* ... */ }
public class PaymentProcessedEvent extends ApplicationEvent { /* ... */ }
public class OrderShippedEvent extends ApplicationEvent { /* ... */ }

// Different services can react to these events
@Component
public class InventoryService {
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        // Reserve inventory items
    }
}

@Component
public class EmailService {
    @EventListener
    public void sendOrderConfirmation(OrderCreatedEvent event) {
        // Send order confirmation email
    }
    
    @EventListener
    public void sendShippingNotification(OrderShippedEvent event) {
        // Send shipping notification email
    }
}

@Component
public class AnalyticsService {
    @EventListener
    public void updateOrderMetrics(OrderCreatedEvent event) {
        // Update business metrics
    }
}
```

This approach allows each service to focus on its specific responsibility while the event system handles the coordination.

## Summary

Spring's event processing system offers a powerful way to decouple components in your application while maintaining clear communication between them. In this tutorial, we've learned:

- How to create custom event classes
- Different ways to publish events
- How to handle events using annotations and interfaces
- Setting up asynchronous event processing
- Controlling event listener execution order
- Conditionally processing events
- Real-world applications of the event system

By using events effectively, you can build more maintainable, scalable, and flexible Spring applications that follow good design principles like separation of concerns and loose coupling.

## Additional Resources and Exercises

### Further Reading
- [Spring Framework Documentation on Events](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events)
- [Spring Boot Events Explained](https://www.baeldung.com/spring-events)

### Exercises

1. **Basic Event System**:
   Create a `UserRegisteredEvent` and corresponding listeners to send a welcome email and create a user profile.

2. **Transaction Events**:
   Implement an event listener that runs after a database transaction completes using `@TransactionalEventListener`.

3. **Custom Event Publishing**:
   Create a generic event publisher service that can publish different types of events with type safety.

4. **Event Hierarchy**:
   Design a hierarchy of related events (e.g., `AccountEvent` as a parent with `AccountCreatedEvent`, `AccountUpdatedEvent`, etc.) and create listeners that can handle both specific and general events.

5. **Integration Challenge**:
   Build a simplified order processing system where different components communicate exclusively through events.