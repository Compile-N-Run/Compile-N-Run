---
title: Spring JMS
description: Learn how to integrate JMS messaging in Spring applications, including setup, configuration, message sending, receiving, and best practices.

---

# Spring JMS

## Introduction to Spring JMS

Spring JMS (Java Message Service) provides integration with JMS providers, simplifying the development of message-oriented applications. As part of Spring's messaging capabilities, Spring JMS offers templates, listener containers, and annotations that significantly reduce the complexity of working with messaging systems.

JMS is a Java API standard that allows applications to create, send, receive, and read messages asynchronously. It supports both point-to-point (queues) and publish-subscribe (topics) messaging models. Spring JMS builds on this foundation, offering a higher-level abstraction to make implementation easier.

## Why Use Spring JMS?

- **Simplified API**: Abstracts the complexity of working with raw JMS APIs
- **Integration with Spring's Infrastructure**: Works seamlessly with Spring's transaction management, dependency injection, and AOP features
- **Error Handling**: Provides robust error handling mechanisms 
- **JMS Template**: Offers template classes that handle resource creation and release
- **Message-Driven POJOs**: Enables creation of message listeners as plain Java objects

## Getting Started with Spring JMS

### Dependencies

To use Spring JMS in a Spring Boot application, add the following dependency to your `pom.xml`:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>
```

For standalone Spring applications:

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jms</artifactId>
    <version>5.3.23</version>
</dependency>

<dependency>
    <groupId>javax.jms</groupId>
    <artifactId>javax.jms-api</artifactId>
    <version>2.0.1</version>
</dependency>

<!-- Add your JMS provider dependency here (e.g., ActiveMQ) -->
<dependency>
    <groupId>org.apache.activemq</groupId>
    <artifactId>activemq-broker</artifactId>
    <version>5.16.5</version>
</dependency>
```

### Basic Configuration

In a Spring Boot application, JMS can be auto-configured by adding the appropriate dependencies. For custom configuration, create a configuration class:

```java
import org.apache.activemq.ActiveMQConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.springframework.jms.core.JmsTemplate;

@Configuration
public class JmsConfig {

    @Bean
    public ActiveMQConnectionFactory connectionFactory() {
        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
        return factory;
    }

    @Bean
    public JmsTemplate jmsTemplate() {
        return new JmsTemplate(connectionFactory());
    }

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setConcurrency("3-10");
        return factory;
    }
}
```

With Spring Boot's auto-configuration, you can simply configure properties in `application.properties`:

```properties
spring.activemq.broker-url=tcp://localhost:61616
spring.activemq.user=admin
spring.activemq.password=admin
```

## Sending Messages with Spring JMS

Spring's `JmsTemplate` simplifies sending messages. Here's how to send text and object messages:

### Sending Text Messages

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class MessageSender {

    @Autowired
    private JmsTemplate jmsTemplate;

    public void sendMessage(String destination, String message) {
        jmsTemplate.convertAndSend(destination, message);
        System.out.println("Message sent: " + message);
    }
}
```

### Sending Object Messages

To send Java objects, they must be serializable:

```java
import java.io.Serializable;

public class OrderMessage implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String orderId;
    private double amount;
    
    // Constructor, getters, and setters
    public OrderMessage(String orderId, double amount) {
        this.orderId = orderId;
        this.amount = amount;
    }
    
    public String getOrderId() {
        return orderId;
    }
    
    public void setOrderId(String orderId) {
        this.orderId = orderId;
    }
    
    public double getAmount() {
        return amount;
    }
    
    public void setAmount(double amount) {
        this.amount = amount;
    }
    
    @Override
    public String toString() {
        return "OrderMessage{orderId='" + orderId + "', amount=" + amount + '}';
    }
}
```

Send the object:

```java
@Component
public class OrderSender {

    @Autowired
    private JmsTemplate jmsTemplate;

    public void sendOrder(OrderMessage order) {
        jmsTemplate.convertAndSend("orders.queue", order);
        System.out.println("Order sent: " + order);
    }
}
```

## Receiving Messages with Spring JMS

Spring offers two approaches to consume messages:

### 1. Synchronous Reception with JmsTemplate

```java
@Component
public class MessageReceiver {

    @Autowired
    private JmsTemplate jmsTemplate;

    public String receiveMessage(String destination) {
        return (String) jmsTemplate.receiveAndConvert(destination);
    }
}
```

### 2. Asynchronous Reception with @JmsListener (Recommended)

This method uses annotation-driven message listeners:

```java
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class MessageListener {

    @JmsListener(destination = "messages.queue")
    public void receiveMessage(String message) {
        System.out.println("Received message: " + message);
    }
    
    @JmsListener(destination = "orders.queue")
    public void receiveOrder(OrderMessage order) {
        System.out.println("Received order: " + order.getOrderId() + 
                           ", Amount: $" + order.getAmount());
    }
}
```

To enable JMS listeners, add `@EnableJms` to your configuration:

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.annotation.EnableJms;

@Configuration
@EnableJms
public class JmsConfig {
    // Configuration beans
}
```

## Message Conversion

Spring provides `MessageConverter` for converting between Java objects and JMS messages:

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.support.converter.MappingJackson2MessageConverter;
import org.springframework.jms.support.converter.MessageConverter;
import org.springframework.jms.support.converter.MessageType;

@Configuration
public class JmsConfig {
    
    @Bean
    public MessageConverter jacksonJmsMessageConverter() {
        MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter();
        converter.setTargetType(MessageType.TEXT);
        converter.setTypeIdPropertyName("_type");
        return converter;
    }
    
    @Bean
    public JmsTemplate jmsTemplate() {
        JmsTemplate template = new JmsTemplate(connectionFactory());
        template.setMessageConverter(jacksonJmsMessageConverter());
        return template;
    }
}
```

## Error Handling in JMS

### Using Error Handlers

```java
@Configuration
public class JmsErrorConfig {

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
            ConnectionFactory connectionFactory,
            DefaultJmsListenerContainerFactoryConfigurer configurer) {
        
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        configurer.configure(factory, connectionFactory);
        
        factory.setErrorHandler(t -> {
            System.err.println("Error in listener: " + t.getMessage());
            // Additional error handling logic
        });
        
        return factory;
    }
}
```

### Exception Handling in Message Listeners

```java
@Component
public class MessageListener {

    @JmsListener(destination = "messages.queue")
    public void receiveMessage(String message) {
        try {
            // Process message
            System.out.println("Processing: " + message);
            
            // Simulate error for demonstration
            if (message.contains("error")) {
                throw new RuntimeException("Error processing message");
            }
        } catch (Exception e) {
            // Handle exception
            System.err.println("Error in processing: " + e.getMessage());
            // Optionally rethrow or handle differently
        }
    }
}
```

## JMS with Transactions

Spring supports JMS transactions for ensuring message operations are atomic:

```java
@Configuration
public class JmsTransactionConfig {

    @Bean
    public JmsTemplate jmsTemplate(ConnectionFactory connectionFactory) {
        JmsTemplate template = new JmsTemplate(connectionFactory);
        template.setSessionTransacted(true);
        return template;
    }
    
    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
            ConnectionFactory connectionFactory) {
        
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        factory.setSessionTransacted(true);
        return factory;
    }
}
```

Using Spring's transaction management with JMS:

```java
import org.springframework.transaction.annotation.Transactional;

@Component
public class OrderService {

    @Autowired
    private JmsTemplate jmsTemplate;
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Transactional
    public void processOrder(OrderMessage orderMessage) {
        // Save to database
        Order order = new Order(orderMessage.getOrderId(), orderMessage.getAmount());
        orderRepository.save(order);
        
        // Send confirmation message
        jmsTemplate.convertAndSend("order.confirmation", 
                                   "Order " + orderMessage.getOrderId() + " processed");
                                   
        // If an exception occurs here, both the database save and message sending will be rolled back
    }
}
```

## Request-Reply Pattern

Spring JMS supports the request-reply pattern:

```java
@Component
public class RequestReplyExample {

    @Autowired
    private JmsTemplate jmsTemplate;

    public String sendAndReceive(String message) {
        // Send message and wait for response
        String response = (String) jmsTemplate.sendAndReceive("request.queue", 
            session -> session.createTextMessage(message), 
            message -> {
                try {
                    return ((TextMessage) message).getText();
                } catch (JMSException e) {
                    throw new RuntimeException(e);
                }
            }
        );
        
        return response;
    }
    
    @JmsListener(destination = "request.queue")
    @SendTo("response.queue")
    public String handleRequest(String request) {
        return "Response to: " + request;
    }
}
```

## Real-World Example: Order Processing System

Let's build a simple order processing system with Spring JMS:

### 1. Message Model

```java
public class Order implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String id;
    private String customerName;
    private List<OrderItem> items;
    private double total;
    private OrderStatus status;
    
    // Constructors, getters, setters
}

public enum OrderStatus {
    RECEIVED, PROCESSING, COMPLETED, FAILED
}

public class OrderItem implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String product;
    private int quantity;
    private double price;
    
    // Constructors, getters, setters
}
```

### 2. Message Producer

```java
@Service
public class OrderProducer {
    
    @Autowired
    private JmsTemplate jmsTemplate;
    
    public void submitOrder(Order order) {
        order.setStatus(OrderStatus.RECEIVED);
        jmsTemplate.convertAndSend("orders.new", order);
        System.out.println("Order submitted: " + order.getId());
    }
}
```

### 3. Order Processor

```java
@Component
public class OrderProcessor {

    @Autowired
    private JmsTemplate jmsTemplate;
    
    @JmsListener(destination = "orders.new")
    public void processOrder(Order order) {
        System.out.println("Processing order: " + order.getId());
        
        try {
            // Simulate processing time
            Thread.sleep(2000);
            
            // Update order status
            order.setStatus(OrderStatus.PROCESSING);
            
            // Validate items and calculate total
            validateAndCalculateTotal(order);
            
            // Simulate more processing
            Thread.sleep(3000);
            
            // Complete order
            order.setStatus(OrderStatus.COMPLETED);
            
            // Notify completion
            jmsTemplate.convertAndSend("orders.completed", order);
        } catch (Exception e) {
            System.err.println("Error processing order: " + e.getMessage());
            order.setStatus(OrderStatus.FAILED);
            jmsTemplate.convertAndSend("orders.failed", order);
        }
    }
    
    private void validateAndCalculateTotal(Order order) {
        if (order.getItems() == null || order.getItems().isEmpty()) {
            throw new IllegalArgumentException("Order has no items");
        }
        
        double total = order.getItems().stream()
                .mapToDouble(item -> item.getPrice() * item.getQuantity())
                .sum();
                
        order.setTotal(total);
    }
}
```

### 4. Notification Service

```java
@Component
public class NotificationService {

    @JmsListener(destination = "orders.completed")
    public void notifyOrderCompletion(Order order) {
        System.out.println("ORDER COMPLETED - ID: " + order.getId() + 
                           ", Customer: " + order.getCustomerName() + 
                           ", Total: $" + order.getTotal());
    }
    
    @JmsListener(destination = "orders.failed")
    public void handleFailedOrders(Order order) {
        System.err.println("ORDER FAILED - ID: " + order.getId() + 
                           ", Customer: " + order.getCustomerName() + 
                           ", Reason: Processing error");
    }
}
```

### 5. Application Entry Point

```java
@SpringBootApplication
@EnableJms
public class OrderApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(OrderApplication.class, args);
            
        OrderProducer producer = context.getBean(OrderProducer.class);
        
        // Create and submit orders
        Order order1 = createSampleOrder("ORD-001", "John Doe");
        Order order2 = createSampleOrder("ORD-002", "Jane Smith");
        
        producer.submitOrder(order1);
        producer.submitOrder(order2);
    }
    
    private static Order createSampleOrder(String id, String customer) {
        Order order = new Order();
        order.setId(id);
        order.setCustomerName(customer);
        
        List<OrderItem> items = new ArrayList<>();
        items.add(new OrderItem("Product A", 2, 49.99));
        items.add(new OrderItem("Product B", 1, 99.99));
        order.setItems(items);
        
        return order;
    }
}
```

## Best Practices

1. **Use Appropriate Message Models**: Design message structures based on your use cases.
   
2. **Error Handling**: Always implement proper error handling for message processing.
   
3. **Transactions**: Use transactions when appropriate, especially for critical operations.
   
4. **Connection Pool**: Configure appropriate connection pool settings for your JMS connection factory.
   
5. **Dead Letter Queues**: Set up dead letter queues for messages that can't be processed.
   
6. **Message TTL**: Consider setting time-to-live for messages that shouldn't live forever.
   
7. **Message Selectors**: Use JMS message selectors for filtering messages at the provider level.

8. **Asynchronous Consumption**: Prefer @JmsListener for message consumption over synchronous methods for better scalability.

9. **Message Persistence**: Configure message persistence for critical data.

## Summary

Spring JMS provides a powerful and simplified approach to integrating messaging into your applications. It offers:

- Simple configuration with Spring Boot
- Multiple message sending and receiving options
- Robust error handling and transaction support
- Integration with Spring's overall infrastructure

By leveraging Spring JMS, you can build robust, scalable, and maintainable messaging solutions while minimizing boilerplate code.

## Additional Resources

- [Spring JMS Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jms)
- [JMS Specification](https://javaee.github.io/jms-spec/)
- [ActiveMQ Documentation](https://activemq.apache.org/components/classic/documentation)
- [RabbitMQ JMS Client](https://www.rabbitmq.com/jms-client.html)

## Exercises

1. Create a Spring Boot application that uses JMS to implement a simple chat application with multiple channels.

2. Implement a message priority system using JMS message properties.

3. Create a system that uses the request-reply pattern to implement a distributed calculator (operations sent as requests, results returned as replies).

4. Implement both point-to-point and publish-subscribe messaging models in a single application.

5. Add dead letter queue handling to the order processing example to manage failed orders.