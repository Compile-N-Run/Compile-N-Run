---
title: Spring Integration
description: A comprehensive guide to Spring Integration, a key component of Spring Messaging that enables lightweight messaging and integration patterns implementation in Spring applications.

---

# Spring Integration

## Introduction

Spring Integration is an extension of the Spring Framework that provides support for implementing enterprise integration patterns (EIPs) in Spring applications. It enables lightweight messaging within Spring-based applications and supports integration with external systems through declarative adapters.

At its core, Spring Integration aims to provide a simple model for building enterprise integration solutions while maintaining the separation of concerns that is essential for producing maintainable, testable code. Whether you're connecting different components within a single application or integrating multiple systems, Spring Integration offers a consistent programming model that simplifies these tasks.

## Key Concepts in Spring Integration

### 1. Message

In Spring Integration, a `Message` is the fundamental data structure used to communicate between different components. It consists of:

- **Payload**: The actual data being transported
- **Headers**: Metadata associated with the payload (similar to HTTP headers)

```java
// Creating a simple message
Message<String> message = MessageBuilder
    .withPayload("Hello, Spring Integration!")
    .setHeader("priority", "HIGH")
    .build();

// Accessing message components
String payload = message.getPayload();
Object priority = message.getHeaders().get("priority");
```

### 2. Message Channels

Message Channels are the pipes that connect the various components in a Spring Integration flow. They decouple message producers from message consumers.

There are several types of channels:

- **Point-to-Point Channels**: Deliver messages to exactly one consumer
- **Publish-Subscribe Channels**: Deliver messages to all subscribed consumers
- **Priority Channels**: Process messages based on a priority order
- **Rendezvous Channels**: Synchronous handoff between producer and consumer

```java
@Configuration
public class ChannelConfig {
    
    @Bean
    public DirectChannel directChannel() {
        return new DirectChannel(); // Point-to-Point Channel
    }
    
    @Bean
    public PublishSubscribeChannel pubSubChannel() {
        return new PublishSubscribeChannel(); // Publish-Subscribe Channel
    }
}
```

### 3. Message Endpoints

Message Endpoints are the components that connect your application code to the messaging framework. Spring Integration provides various endpoint types:

- **Transformers**: Convert message content from one form to another
- **Filters**: Determine whether a message should be passed to the output channel
- **Routers**: Direct messages to different channels based on conditions
- **Splitters**: Split a composite message into multiple messages
- **Aggregators**: Combine multiple messages into one message
- **Service Activators**: Connect messages to services that process them

## Getting Started with Spring Integration

Let's start by setting up a basic Spring Integration project:

### 1. Maven Dependencies

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.integration</groupId>
        <artifactId>spring-integration-core</artifactId>
        <version>5.5.8</version>
    </dependency>
    <!-- For Java configuration support -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.15</version>
    </dependency>
</dependencies>
```

### 2. Create a Simple Integration Flow

Let's implement a simple flow that processes messages:

```java
@Configuration
@EnableIntegration
public class SimpleIntegrationConfig {

    @Bean
    public MessageChannel inputChannel() {
        return new DirectChannel();
    }

    @Bean
    public MessageChannel outputChannel() {
        return new DirectChannel();
    }

    @Bean
    @Transformer(inputChannel = "inputChannel", outputChannel = "outputChannel")
    public MessageTransformingHandler upperCaseTransformer() {
        return new MessageTransformingHandler(message -> 
            ((String) message.getPayload()).toUpperCase());
    }
    
    @Bean
    @ServiceActivator(inputChannel = "outputChannel")
    public MessageHandler logger() {
        return message -> System.out.println("Received: " + message.getPayload());
    }
}
```

### 3. Using the Integration Flow

```java
@SpringBootApplication
public class IntegrationApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = 
            SpringApplication.run(IntegrationApplication.class, args);
        
        // Get the input channel
        MessageChannel inputChannel = context.getBean("inputChannel", MessageChannel.class);
        
        // Send a message
        inputChannel.send(MessageBuilder.withPayload("hello world").build());
        
        // Output: "Received: HELLO WORLD"
    }
}
```

## More Advanced Spring Integration Concepts

### 1. Gateway Pattern

A Gateway provides a simple interface for sending messages to and receiving replies from an integration flow.

```java
public interface GreetingService {
    String sendGreeting(String name);
}

@Configuration
public class GatewayConfig {
    
    @Bean
    public DirectChannel requestChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel replyChannel() {
        return new DirectChannel();
    }
    
    @Bean
    @ServiceActivator(inputChannel = "requestChannel", outputChannel = "replyChannel")
    public MessageHandler greetingService() {
        return message -> {
            String name = (String) message.getPayload();
            MessageBuilder.withPayload("Hello, " + name + "!")
                          .copyHeadersIfAbsent(message.getHeaders())
                          .build();
        };
    }
    
    @MessagingGateway(defaultRequestChannel = "requestChannel", defaultReplyChannel = "replyChannel")
    public interface GreetingGateway {
        String sendGreeting(String name);
    }
}
```

Usage:

```java
@Autowired
private GreetingGateway gateway;

public void sendMessage() {
    String response = gateway.sendGreeting("John");
    System.out.println(response); // Output: Hello, John!
}
```

### 2. Channel Adapters

Channel Adapters connect the messaging system to external systems. Spring Integration provides both inbound (bringing data in) and outbound (sending data out) adapters.

Example of a File Adapter:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.integration</groupId>
        <artifactId>spring-integration-file</artifactId>
        <version>5.5.8</version>
    </dependency>
</dependencies>
```

```java
@Configuration
public class FileAdapterConfig {
    
    @Bean
    public MessageChannel fileChannel() {
        return new DirectChannel();
    }
    
    @Bean
    @InboundChannelAdapter(channel = "fileChannel", poller = @Poller(fixedDelay = "1000"))
    public MessageSource<File> fileReadingMessageSource() {
        FileReadingMessageSource source = new FileReadingMessageSource();
        source.setDirectory(new File("/path/to/input/directory"));
        source.setFilter(new SimplePatternFileListFilter("*.txt"));
        return source;
    }
    
    @Bean
    @ServiceActivator(inputChannel = "fileChannel")
    public MessageHandler fileWritingMessageHandler() {
        FileWritingMessageHandler handler = new FileWritingMessageHandler(
            new File("/path/to/output/directory"));
        handler.setExpectReply(false); // Important!
        handler.setFileNameGenerator(message -> 
            "processed_" + ((File) message.getPayload()).getName());
        return handler;
    }
}
```

## Real-World Example: Order Processing System

Let's create a more complex example of an order processing system using Spring Integration:

```java
@Configuration
@EnableIntegration
public class OrderProcessingConfig {

    // Channels
    @Bean
    public MessageChannel orderChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public MessageChannel validOrderChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public MessageChannel invalidOrderChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public MessageChannel processedOrderChannel() {
        return new DirectChannel();
    }
    
    // Filter to validate orders
    @Bean
    @Filter(inputChannel = "orderChannel", 
            outputChannel = "validOrderChannel", 
            discardChannel = "invalidOrderChannel")
    public MessageSelector orderValidator() {
        return message -> {
            Order order = (Order) message.getPayload();
            return order.getItems() != null && !order.getItems().isEmpty();
        };
    }
    
    // Transform the order for processing
    @Bean
    @Transformer(inputChannel = "validOrderChannel", outputChannel = "processedOrderChannel")
    public MessageTransformingHandler orderEnricher() {
        return new MessageTransformingHandler(message -> {
            Order order = (Order) message.getPayload();
            order.setProcessedDate(new Date());
            order.setStatus("PROCESSED");
            return MessageBuilder.withPayload(order)
                                .copyHeadersIfAbsent(message.getHeaders())
                                .build();
        });
    }
    
    // Service activator to handle processed orders
    @Bean
    @ServiceActivator(inputChannel = "processedOrderChannel")
    public MessageHandler orderProcessor() {
        return message -> {
            Order order = (Order) message.getPayload();
            System.out.println("Processing order: " + order.getId() + 
                              ", Status: " + order.getStatus());
            // Here you would typically persist the order to a database
            // or send it to another system
        };
    }
    
    // Service activator to handle invalid orders
    @Bean
    @ServiceActivator(inputChannel = "invalidOrderChannel")
    public MessageHandler invalidOrderHandler() {
        return message -> {
            Order order = (Order) message.getPayload();
            System.out.println("Invalid order received: " + order.getId() + 
                              ", sending notification to support team");
            // Here you would typically log the error and notify someone
        };
    }
    
    // Order gateway interface
    @MessagingGateway(defaultRequestChannel = "orderChannel")
    public interface OrderGateway {
        void submitOrder(Order order);
    }
}

// Order class
public class Order {
    private String id;
    private List<OrderItem> items;
    private Date processedDate;
    private String status;
    
    // Getters and setters
}

public class OrderItem {
    private String productId;
    private int quantity;
    
    // Getters and setters
}
```

Usage of this integration flow:

```java
@Service
public class OrderService {
    
    @Autowired
    private OrderProcessingConfig.OrderGateway orderGateway;
    
    public void placeOrder(Order order) {
        // Generate an order ID
        order.setId(UUID.randomUUID().toString());
        
        // Submit the order to the integration flow
        orderGateway.submitOrder(order);
    }
}
```

## Spring Integration DSL

Spring Integration also offers a Domain Specific Language (DSL) for more fluent configuration:

```java
@Configuration
public class IntegrationFlowConfig {
    
    @Bean
    public IntegrationFlow processOrderFlow() {
        return IntegrationFlows.from("orderChannel")
            .<Order, Boolean>filter(order -> 
                order.getItems() != null && !order.getItems().isEmpty(),
                filterEndpointSpec -> filterEndpointSpec.discardChannel("invalidOrderChannel"))
            .<Order>transform(order -> {
                order.setProcessedDate(new Date());
                order.setStatus("PROCESSED");
                return order;
            })
            .handle(message -> {
                Order order = (Order) message.getPayload();
                System.out.println("Processing order: " + order.getId() + 
                                  ", Status: " + order.getStatus());
            })
            .get();
    }
    
    @Bean
    public IntegrationFlow invalidOrderFlow() {
        return IntegrationFlows.from("invalidOrderChannel")
            .handle(message -> {
                Order order = (Order) message.getPayload();
                System.out.println("Invalid order received: " + order.getId() + 
                                  ", sending notification to support team");
            })
            .get();
    }
}
```

## Common Integration Patterns with Spring Integration

Spring Integration implements many of the patterns described in the Enterprise Integration Patterns book:

### 1. Content-Based Router

```java
@Bean
@Router(inputChannel = "routingChannel")
public MessageRouter paymentTypeRouter() {
    return message -> {
        Payment payment = (Payment) message.getPayload();
        return switch(payment.getType()) {
            case "CREDIT_CARD" -> "creditCardPaymentChannel";
            case "PAYPAL" -> "paypalPaymentChannel";
            case "BANK_TRANSFER" -> "bankTransferChannel";
            default -> "unknownPaymentChannel";
        };
    };
}
```

### 2. Splitter and Aggregator

```java
// Splitter configuration
@Bean
@Splitter(inputChannel = "batchOrderChannel", outputChannel = "individualOrderChannel")
public MessageHandler orderBatchSplitter() {
    return message -> {
        OrderBatch batch = (OrderBatch) message.getPayload();
        return batch.getOrders();
    };
}

// Aggregator configuration
@Bean
@Aggregator(inputChannel = "processedItemChannel", outputChannel = "completeOrderChannel")
public MessageHandler orderAggregator() {
    MethodInvokingMessageGroupProcessor processor = 
        new MethodInvokingMessageGroupProcessor(new OrderAggregator(), "aggregate");
    
    AggregatingMessageHandler handler = new AggregatingMessageHandler(processor);
    handler.setReleaseStrategy(group -> 
        group.size() == group.getOne().getHeaders().get("EXPECTED_COUNT", Integer.class));
    handler.setCorrelationStrategy(message -> 
        message.getHeaders().get("ORDER_ID"));
    
    return handler;
}
```

### 3. Channel Interceptors

Channel interceptors allow you to intercept messages before they are sent to a channel and after they are received.

```java
@Bean
public DirectChannel auditedChannel() {
    DirectChannel channel = new DirectChannel();
    channel.addInterceptor(new ChannelInterceptor() {
        @Override
        public Message<?> preSend(Message<?> message, MessageChannel channel) {
            System.out.println("Message about to be sent: " + message.getPayload());
            return message;
        }
        
        @Override
        public void afterSendCompletion(
                Message<?> message, MessageChannel channel, boolean sent, Exception ex) {
            System.out.println("Message was sent: " + sent + 
                            (ex != null ? " with exception: " + ex.getMessage() : ""));
        }
    });
    return channel;
}
```

## Summary

Spring Integration provides a robust framework for implementing enterprise integration patterns in Spring applications. It offers:

1. **Consistent Model**: A uniform programming model regardless of the transport mechanism.
2. **Loose Coupling**: Separation of messaging logic from business logic.
3. **Enterprise Integration Patterns**: Ready-to-use implementations of common EIPs.
4. **Adaptability**: Numerous adapters for connecting to external systems.
5. **Testing Support**: Comprehensive testing tools for integration flows.

By using Spring Integration, developers can create maintainable, testable integration solutions that are flexible and extensible. The framework's declarative approach reduces boilerplate code and lets you focus on business logic rather than integration complexities.

## Additional Resources

1. [Spring Integration Reference Documentation](https://docs.spring.io/spring-integration/reference/html/)
2. [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/) - The book that inspired Spring Integration
3. [Spring Integration GitHub Repository](https://github.com/spring-projects/spring-integration)
4. [Spring Integration Samples](https://github.com/spring-projects/spring-integration-samples)

## Exercises

1. Create a simple file integration flow that reads CSV files, transforms them into objects, and writes summary files.
2. Implement a message filter that validates incoming HTTP requests and routes them to different services based on their content.
3. Build an integration flow that polls an email server, processes new messages, and stores attachments in a file system.
4. Create a publish-subscribe channel with multiple subscribers that process messages differently.
5. Implement an error channel that handles exceptions from various parts of your integration flow and provides appropriate responses.