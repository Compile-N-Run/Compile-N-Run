---
title: Spring Messaging Patterns
description: Learn about common messaging patterns in Spring Framework and how to implement them for effective communication between application components.

---

# Spring Messaging Patterns

## Introduction

In modern distributed systems, components often need to communicate with each other efficiently. Spring Messaging provides robust support for implementing various messaging patterns that allow different parts of your application to exchange information effectively. These patterns help in building scalable, loosely coupled, and resilient systems.

Messaging patterns are proven solutions to common communication challenges in distributed systems. They define how messages are created, routed, transformed, and consumed between different application components.

In this tutorial, we'll explore key messaging patterns supported by Spring's messaging infrastructure and learn how to implement them using Spring Boot and Spring Integration.

## Prerequisites

- Basic knowledge of Spring Framework
- Familiarity with Java programming
- Understanding of basic messaging concepts

## Core Messaging Patterns in Spring

### 1. Point-to-Point Pattern

The point-to-point pattern involves a direct message exchange between a sender and a specific receiver. Each message is delivered to exactly one consumer, even if multiple consumers are listening.

#### Implementation with Spring JMS

```java
@Configuration
public class JmsConfig {
    @Bean
    public Queue orderQueue() {
        return new ActiveMQQueue("order.queue");
    }
}

@Service
public class OrderMessageSender {
    @Autowired
    private JmsTemplate jmsTemplate;
    
    public void sendOrder(Order order) {
        jmsTemplate.convertAndSend("order.queue", order);
        System.out.println("Order sent: " + order.getId());
    }
}

@Service
public class OrderMessageReceiver {
    @JmsListener(destination = "order.queue")
    public void receiveOrder(Order order) {
        System.out.println("Received order: " + order.getId());
        // Process the order
    }
}
```

**Output:**
```
Order sent: 1234
Received order: 1234
```

In this example, the `OrderMessageSender` sends an order to a specific queue, and the `OrderMessageReceiver` processes it. Each message is consumed by only one receiver, making this pattern ideal for task distribution.

### 2. Publish-Subscribe Pattern

In the publish-subscribe pattern, a message is published to a topic, and all active subscribers to that topic receive a copy of the message. This enables broadcasting information to multiple receivers simultaneously.

#### Implementation with Spring Cloud Stream

First, add the required dependencies:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-stream</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-stream-binder-kafka</artifactId>
</dependency>
```

Now, create your message producer and consumers:

```java
@Configuration
public class StreamConfig {
    @Bean
    public Function<String, String> eventProcessor() {
        return message -> {
            System.out.println("Processing: " + message);
            return message.toUpperCase();
        };
    }
}

// In application.properties
// spring.cloud.stream.bindings.eventProcessor-in-0.destination=events-topic
// spring.cloud.stream.bindings.eventProcessor-out-0.destination=processed-events-topic
```

To publish messages:

```java
@Service
public class EventPublisher {
    @Autowired
    private StreamBridge streamBridge;
    
    public void publishEvent(String event) {
        streamBridge.send("events-topic", event);
        System.out.println("Published event: " + event);
    }
}
```

**Output:**
```
Published event: user.login
Processing: user.login
```

Each subscriber to the "events-topic" topic will receive the same message, allowing multiple services to react to the same event.

### 3. Request-Reply Pattern

The request-reply pattern extends simple messaging by adding response handling. A client sends a request and waits for a response from the service provider.

#### Implementation with Spring Integration

```java
@Configuration
public class RequestReplyConfig {
    @Bean
    public DirectChannel requestChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel replyChannel() {
        return new DirectChannel();
    }
    
    @Bean
    @ServiceActivator(inputChannel = "requestChannel")
    public MessageHandler calculateHandler() {
        return message -> {
            Integer number = (Integer) message.getPayload();
            Integer result = number * number;
            
            MessageChannel replyChannel = (MessageChannel) 
                message.getHeaders().get(MessageHeaders.REPLY_CHANNEL);
            
            if (replyChannel != null) {
                MessageBuilder.withPayload(result)
                    .copyHeadersIfAbsent(message.getHeaders())
                    .build();
                replyChannel.send(MessageBuilder.withPayload(result).build());
            }
        };
    }
}
```

Using the request-reply pattern:

```java
@Component
public class MathService {
    @Autowired
    private DirectChannel requestChannel;
    
    @Autowired
    private DirectChannel replyChannel;
    
    public Integer calculateSquare(Integer number) {
        PollableChannel temporaryReplyChannel = new QueueChannel();
        
        Message<Integer> message = MessageBuilder
            .withPayload(number)
            .setReplyChannel(temporaryReplyChannel)
            .build();
        
        requestChannel.send(message);
        
        Message<?> reply = temporaryReplyChannel.receive(5000);
        if (reply != null) {
            return (Integer) reply.getPayload();
        }
        
        throw new RuntimeException("No reply received within timeout");
    }
}
```

**Usage and output:**
```java
@Service
public class CalculationService {
    @Autowired
    private MathService mathService;
    
    public void performCalculation() {
        Integer input = 5;
        Integer result = mathService.calculateSquare(input);
        System.out.println("Square of " + input + " is: " + result);
    }
}

// Output:
// Square of 5 is: 25
```

### 4. Message Routing Pattern

The message routing pattern directs messages to different channels based on certain conditions or message content.

#### Implementation with Spring Integration

```java
@Configuration
public class RouterConfig {
    @Bean
    public DirectChannel inputChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel highPriorityChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel normalPriorityChannel() {
        return new DirectChannel();
    }
    
    @Bean
    @Router(inputChannel = "inputChannel")
    public AbstractMessageRouter priorityRouter() {
        return new AbstractMessageRouter() {
            @Override
            protected Collection<MessageChannel> determineTargetChannels(Message<?> message) {
                Task task = (Task) message.getPayload();
                
                if (task.getPriority() > 7) {
                    return Collections.singleton(highPriorityChannel());
                } else {
                    return Collections.singleton(normalPriorityChannel());
                }
            }
        };
    }
    
    @Bean
    @ServiceActivator(inputChannel = "highPriorityChannel")
    public MessageHandler highPriorityHandler() {
        return message -> {
            Task task = (Task) message.getPayload();
            System.out.println("Processing HIGH priority task: " + task.getName());
        };
    }
    
    @Bean
    @ServiceActivator(inputChannel = "normalPriorityChannel")
    public MessageHandler normalPriorityHandler() {
        return message -> {
            Task task = (Task) message.getPayload();
            System.out.println("Processing normal priority task: " + task.getName());
        };
    }
}
```

**Task class:**
```java
public class Task {
    private String name;
    private int priority;
    
    // Getters, setters, constructor
}
```

**Usage:**
```java
@Service
public class TaskService {
    @Autowired
    private DirectChannel inputChannel;
    
    public void submitTask(Task task) {
        inputChannel.send(MessageBuilder.withPayload(task).build());
    }
}
```

**Output:**
```
Processing HIGH priority task: Urgent bug fix
Processing normal priority task: Feature enhancement
```

### 5. Splitter and Aggregator Pattern

This pattern involves breaking a large message into smaller pieces (splitting), processing them independently, and then recombining the results (aggregation).

```java
@Configuration
public class SplitterAggregatorConfig {
    @Bean
    public DirectChannel orderChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel itemsChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel processedItemsChannel() {
        return new DirectChannel();
    }
    
    @Bean
    public DirectChannel completedOrderChannel() {
        return new DirectChannel();
    }
    
    @Bean
    @Splitter(inputChannel = "orderChannel", outputChannel = "itemsChannel")
    public MessageHandler orderSplitter() {
        return message -> {
            Order order = (Order) message.getPayload();
            return order.getItems(); // Returns a list of OrderItem objects
        };
    }
    
    @Bean
    @ServiceActivator(inputChannel = "itemsChannel", outputChannel = "processedItemsChannel")
    public MessageHandler itemProcessor() {
        return message -> {
            OrderItem item = (OrderItem) message.getPayload();
            item.setProcessed(true);
            return MessageBuilder.withPayload(item)
                .copyHeaders(message.getHeaders())
                .build();
        };
    }
    
    @Bean
    @Aggregator(inputChannel = "processedItemsChannel", outputChannel = "completedOrderChannel")
    public MessageGroupProcessor orderAggregator() {
        return group -> {
            List<OrderItem> processedItems = new ArrayList<>();
            group.getMessages().forEach(message -> 
                processedItems.add((OrderItem) message.getPayload()));
            
            Order completedOrder = new Order();
            completedOrder.setId((String) group.getGroupId());
            completedOrder.setItems(processedItems);
            completedOrder.setCompleted(true);
            
            return MessageBuilder.withPayload(completedOrder).build();
        };
    }
}
```

This pattern is especially useful when:
- You need to process items in parallel
- You want to break down large tasks into smaller ones
- Individual items may fail but you still want to continue with the rest

## Real-World Applications

### Microservices Communication

Let's create a practical example of how these patterns might be used in a microservice architecture:

```java
@Configuration
public class OrderProcessingConfig {
    @Bean
    public Queue newOrdersQueue() {
        return new Queue("new-orders");
    }
    
    @Bean
    public Topic orderStatusTopic() {
        return new Topic("order-status");
    }
}

@Service
public class OrderService {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void placeOrder(Order order) {
        // Using point-to-point pattern for order processing
        rabbitTemplate.convertAndSend("new-orders", order);
        System.out.println("Order " + order.getId() + " placed for processing");
    }
    
    @RabbitListener(queues = "new-orders")
    public void processOrder(Order order) {
        System.out.println("Processing order: " + order.getId());
        
        // Simulate order processing
        order.setStatus("PROCESSED");
        
        // Using publish-subscribe to notify all interested services
        rabbitTemplate.convertAndSend("order-status", order);
        System.out.println("Order status published: " + order.getId());
    }
}
```

**Inventory Service consuming the events:**
```java
@Service
public class InventoryService {
    @RabbitListener(topics = "order-status")
    public void updateInventory(Order order) {
        if ("PROCESSED".equals(order.getStatus())) {
            System.out.println("Updating inventory for order: " + order.getId());
            
            // Update inventory logic
            for (OrderItem item : order.getItems()) {
                System.out.println("Reducing stock for product: " + item.getProductId());
            }
        }
    }
}
```

**Notification Service consuming the same events:**
```java
@Service
public class NotificationService {
    @RabbitListener(topics = "order-status")
    public void sendNotification(Order order) {
        if ("PROCESSED".equals(order.getStatus())) {
            System.out.println("Sending notification for order: " + order.getId());
            
            // Email notification logic
            System.out.println("Email sent to customer: " + order.getCustomerEmail());
        }
    }
}
```

This demonstrates how different services can consume the same events for different purposes, making the system loosely coupled and scalable.

### Event-Driven Architecture Example

Here's a more comprehensive example of an event-driven architecture using Spring Cloud Stream:

```java
@Configuration
public class EventDrivenConfig {
    @Bean
    public Function<String, String> auditLog() {
        return payload -> {
            System.out.println("Audit log: " + payload);
            return payload;
        };
    }
    
    @Bean
    public Function<CustomerEvent, Void> customerProcessor() {
        return event -> {
            System.out.println("Processing customer event: " + event.getType());
            
            if ("REGISTERED".equals(event.getType())) {
                // Handle new customer
            } else if ("UPDATED".equals(event.getType())) {
                // Handle customer update
            }
            
            return null;
        };
    }
}

// application.yml
/*
spring:
  cloud:
    stream:
      bindings:
        auditLog-in-0:
          destination: events
        customerProcessor-in-0:
          destination: customer-events
          group: customer-service
      kafka:
        binder:
          brokers: localhost:9092
*/
```

**Event publisher:**
```java
@Service
public class EventPublisher {
    private final StreamBridge streamBridge;
    
    public EventPublisher(StreamBridge streamBridge) {
        this.streamBridge = streamBridge;
    }
    
    public void publishCustomerEvent(CustomerEvent event) {
        streamBridge.send("customer-events", event);
        System.out.println("Published customer event: " + event.getType());
    }
}
```

This architecture allows you to:
- Add new consumers without modifying producers
- Achieve high scalability and fault tolerance
- Create a truly decoupled system where components only depend on the event structure

## Summary

In this tutorial, we've explored several important Spring Messaging Patterns:

1. **Point-to-Point Pattern**: Direct communication where each message is consumed by exactly one receiver, ideal for task distribution.

2. **Publish-Subscribe Pattern**: Broadcasting messages to multiple consumers, perfect for event notifications.

3. **Request-Reply Pattern**: Two-way communication where the sender expects a response, useful for synchronous operations.

4. **Message Routing Pattern**: Directing messages to different channels based on content or rules.

5. **Splitter and Aggregator Pattern**: Breaking down complex messages, processing them independently, and recombining results.

These patterns form the foundation for building robust, scalable, and loosely coupled distributed systems using Spring's messaging capabilities.

## Exercises

1. Implement a simple chat application using the Publish-Subscribe pattern.
2. Create an order processing system that splits an order into items, processes each separately, and then aggregates the results.
3. Build a priority-based task processing system that routes tasks to different queues based on their priority.
4. Implement a load balancing system using Point-to-Point pattern with multiple consumers.
5. Create a service that processes requests asynchronously and returns responses using Request-Reply pattern.

## Additional Resources

- [Spring Integration Documentation](https://docs.spring.io/spring-integration/reference/html/)
- [Spring Cloud Stream Documentation](https://docs.spring.io/spring-cloud-stream/docs/current/reference/html/)
- [Enterprise Integration Patterns](https://www.enterpriseintegrationpatterns.com/)
- [Spring AMQP Documentation](https://docs.spring.io/spring-amqp/docs/current/reference/html/)
- [Spring for Apache Kafka](https://docs.spring.io/spring-kafka/docs/current/reference/html/)

By mastering these messaging patterns, you'll be well-equipped to design and implement efficient communication systems in your Spring applications.