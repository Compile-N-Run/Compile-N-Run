---
title: Spring Events
description: Understanding Spring's event mechanism for handling application-wide notifications and communication between components

---

# Spring Events

## Introduction

Spring Events provide a powerful mechanism for communication between different components within a Spring application without requiring direct coupling. This event-driven architecture allows parts of your application to react when specific actions occur elsewhere. Think of it as a publish-subscribe pattern where one component publishes an event, and other components can subscribe to receive notifications when that event occurs.

For beginners, understanding Spring Events will help you build more flexible, maintainable applications where components can interact while remaining loosely coupled. This is especially valuable in larger applications where different modules need to communicate without creating tight dependencies.

## Spring Event Architecture

Spring's event handling architecture consists of three main components:

1. **Event**: A class that extends `ApplicationEvent`, representing something that happened
2. **Publisher**: A component that publishes events (usually via `ApplicationEventPublisher`)
3. **Listener**: A component that listens for specific events and reacts accordingly

Let's look at each component in detail.

## Creating Custom Events

To create a custom event, you need to extend the `ApplicationEvent` class:

```java
import org.springframework.context.ApplicationEvent;

public class UserCreatedEvent extends ApplicationEvent {
    
    private String username;
    
    public UserCreatedEvent(Object source, String username) {
        super(source);
        this.username = username;
    }
    
    public String getUsername() {
        return username;
    }
}
```

This event represents a new user being created in the system. It includes the username of the newly created user as additional information.

## Publishing Events

To publish an event, you can use the `ApplicationEventPublisher`. Spring allows you to inject this publisher into any component:

```java
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    
    private final ApplicationEventPublisher eventPublisher;
    
    // Constructor injection
    public UserService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    public void createUser(String username, String password) {
        // Business logic to create user
        System.out.println("Creating user: " + username);
        
        // Publish an event
        eventPublisher.publishEvent(new UserCreatedEvent(this, username));
    }
}
```

## Creating Event Listeners

There are two primary ways to create event listeners in Spring:

### 1. Using the @EventListener Annotation

This is the modern, preferred approach:

```java
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class UserEventListener {

    @EventListener
    public void handleUserCreatedEvent(UserCreatedEvent event) {
        System.out.println("User created event received: " + event.getUsername());
        // Perform additional actions like sending welcome email, etc.
    }
}
```

### 2. Implementing the ApplicationListener Interface (Traditional Approach)

```java
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class UserCreatedListener implements ApplicationListener<UserCreatedEvent> {
    
    @Override
    public void onApplicationEvent(UserCreatedEvent event) {
        System.out.println("User created: " + event.getUsername());
        // Respond to the event
    }
}
```

## Built-in Spring Events

Spring provides several built-in events that are triggered automatically during the application lifecycle:

1. **ContextRefreshedEvent**: Published when the ApplicationContext is initialized or refreshed
2. **ContextStartedEvent**: Published when the ApplicationContext is started
3. **ContextStoppedEvent**: Published when the ApplicationContext is stopped
4. **ContextClosedEvent**: Published when the ApplicationContext is closed
5. **RequestHandledEvent**: Published when an HTTP request is handled (in web applications)

Here's how to listen for a built-in event:

```java
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class StartupListener {

    @EventListener
    public void handleContextRefresh(ContextRefreshedEvent event) {
        System.out.println("Application context refreshed: " + event.getApplicationContext().getDisplayName());
        // Perform any initialization logic here
    }
}
```

## Asynchronous Event Handling

By default, Spring events are processed synchronously (in the same thread). However, sometimes you might want to process events asynchronously to avoid blocking the publisher. Spring supports this with the `@Async` annotation:

```java
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

@Component
public class AsyncUserEventListener {

    @EventListener
    @Async
    public void handleUserCreatedEvent(UserCreatedEvent event) {
        System.out.println("Asynchronously handling user creation for: " + event.getUsername());
        // Perform time-consuming operations like email sending, etc.
    }
}
```

To use `@Async`, you need to enable asynchronous processing in your application by adding the `@EnableAsync` annotation to a configuration class:

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class AsyncConfig {
    // Configuration options can be added here
}
```

## Event Ordering

When multiple listeners are registered for the same event, you might need to control the order in which they're executed. Spring provides the `@Order` annotation for this purpose:

```java
import org.springframework.context.event.EventListener;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
public class OrderedEventListeners {

    @EventListener
    @Order(1) // Will execute first
    public void handleUserCreatedEventFirst(UserCreatedEvent event) {
        System.out.println("First listener: " + event.getUsername());
    }
    
    @EventListener
    @Order(2) // Will execute second
    public void handleUserCreatedEventSecond(UserCreatedEvent event) {
        System.out.println("Second listener: " + event.getUsername());
    }
}
```

## Conditional Event Processing

You can use the `condition` attribute of `@EventListener` to specify a SpEL (Spring Expression Language) expression that determines whether the listener should be invoked:

```java
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class ConditionalEventListener {

    @EventListener(condition = "#event.username == 'admin'")
    public void handleAdminUserCreated(UserCreatedEvent event) {
        System.out.println("Admin user created: " + event.getUsername());
        // Special handling for admin users
    }
}
```

## Complete Example

Let's put everything together with a practical example that demonstrates a real-world application:

### Step 1: Define Events

```java
// Base event class for all order-related events
public abstract class OrderEvent extends ApplicationEvent {
    private final String orderId;
    
    public OrderEvent(Object source, String orderId) {
        super(source);
        this.orderId = orderId;
    }
    
    public String getOrderId() {
        return orderId;
    }
}

// Event for when an order is created
public class OrderCreatedEvent extends OrderEvent {
    private final double amount;
    
    public OrderCreatedEvent(Object source, String orderId, double amount) {
        super(source, orderId);
        this.amount = amount;
    }
    
    public double getAmount() {
        return amount;
    }
}

// Event for when an order is completed
public class OrderCompletedEvent extends OrderEvent {
    public OrderCompletedEvent(Object source, String orderId) {
        super(source, orderId);
    }
}
```

### Step 2: Create Services That Publish Events

```java
@Service
public class OrderService {
    private final ApplicationEventPublisher eventPublisher;
    
    public OrderService(ApplicationEventPublisher eventPublisher) {
        this.eventPublisher = eventPublisher;
    }
    
    public String createOrder(String productId, int quantity, double unitPrice) {
        // Generate order ID (simplified)
        String orderId = "ORD-" + System.currentTimeMillis();
        
        // Calculate total amount
        double amount = quantity * unitPrice;
        
        System.out.println("Creating order " + orderId + " for product " + productId + 
                         ", quantity: " + quantity + ", amount: $" + amount);
        
        // Publish event
        eventPublisher.publishEvent(new OrderCreatedEvent(this, orderId, amount));
        
        return orderId;
    }
    
    public void completeOrder(String orderId) {
        System.out.println("Completing order " + orderId);
        
        // Publish event
        eventPublisher.publishEvent(new OrderCompletedEvent(this, orderId));
    }
}
```

### Step 3: Create Event Listeners

```java
@Component
public class OrderEventListeners {

    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        System.out.println("Order created event received for order: " + event.getOrderId() + 
                         " with amount: $" + event.getAmount());
        
        // Create invoice
        System.out.println("Creating invoice for order: " + event.getOrderId());
    }
    
    @EventListener
    @Async
    public void sendOrderConfirmationEmail(OrderCreatedEvent event) {
        System.out.println("Asynchronously sending confirmation email for order: " + event.getOrderId());
        
        // Simulate email sending delay
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Email sent for order: " + event.getOrderId());
    }
    
    @EventListener
    public void handleOrderCompleted(OrderCompletedEvent event) {
        System.out.println("Order completed event received for order: " + event.getOrderId());
        
        // Update inventory, analytics, etc.
        System.out.println("Updating inventory for completed order: " + event.getOrderId());
    }
}
```

### Step 4: Main Application to Demonstrate the Flow

```java
@SpringBootApplication
@EnableAsync
public class OrderProcessingApplication {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(OrderProcessingApplication.class, args);
        
        // Get the OrderService bean
        OrderService orderService = context.getBean(OrderService.class);
        
        // Create and complete an order
        String orderId = orderService.createOrder("PROD-100", 2, 29.99);
        
        // Small delay to allow async processes to start
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        orderService.completeOrder(orderId);
    }
}
```

### Expected Output:

```
Creating order ORD-1623412345678 for product PROD-100, quantity: 2, amount: $59.98
Order created event received for order: ORD-1623412345678 with amount: $59.98
Creating invoice for order: ORD-1623412345678
Asynchronously sending confirmation email for order: ORD-1623412345678
Completing order ORD-1623412345678
Order completed event received for order: ORD-1623412345678
Updating inventory for completed order: ORD-1623412345678
Email sent for order: ORD-1623412345678
```

This example demonstrates how Spring Events can be used to build a loosely coupled order processing system where different components (invoicing, email notifications, inventory management) react to events without being directly tied to the order processing logic.

## Summary

Spring Events provide a powerful mechanism for implementing an event-driven architecture in your applications, enabling loose coupling between components. Key takeaways include:

1. Events are objects that extend `ApplicationEvent` and contain information about what happened
2. Publishers use `ApplicationEventPublisher` to broadcast events
3. Listeners can be implemented using the `@EventListener` annotation or by implementing `ApplicationListener`
4. Spring provides built-in events for major application lifecycle events
5. Events can be processed asynchronously using `@Async`
6. Listeners can be ordered and conditionally executed

Using Spring Events can significantly improve the maintainability and flexibility of your applications by reducing direct dependencies between components. This pattern is especially useful for cross-cutting concerns like auditing, notifications, cache invalidation, and more.

## Additional Resources and Exercises

### Resources

- [Spring Framework Documentation on Events](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events)
- [Spring Boot Events Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners)

### Exercises

1. **Basic Exercise**: Create a simple file processing system where a `FileUploadedEvent` is published when a file is uploaded, and listeners process the file (e.g., scan for viruses, generate thumbnails).

2. **Intermediate Exercise**: Implement a user registration system where different listeners react to a `UserRegisteredEvent` (e.g., send welcome email, create a profile, add to newsletter).

3. **Advanced Exercise**: Build a transaction processing system using events. Create appropriate events (`TransactionCreatedEvent`, `TransactionApprovedEvent`, `TransactionRejectedEvent`) and listeners to implement a workflow.

4. **Challenge**: Implement a generic audit system using Spring Events, where all important actions in your application publish events that are captured by an audit listener that logs them to a database or file.