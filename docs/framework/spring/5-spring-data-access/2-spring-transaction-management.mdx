---
title: Spring Transaction Management
description: A comprehensive guide to understanding transaction management in Spring Framework, including declarative and programmatic approaches with practical examples.

---

# Spring Transaction Management

## Introduction

Transactions are a fundamental concept in database operations, ensuring data integrity by grouping multiple operations into a single unit of work. When working with databases in enterprise applications, proper transaction management is essential to maintain data consistency, especially during failures or concurrent access.

Spring Framework provides excellent support for transaction management, abstracting away the complexities of direct transaction handling with databases. This abstraction allows developers to focus on business logic while Spring handles the transaction mechanics in the background.

In this guide, we'll explore:
- What transactions are and why they're important
- Spring's transaction management approach
- Declarative transaction management using annotations
- Programmatic transaction management
- Transaction attributes and isolation levels
- Best practices for handling transactions in Spring applications

## Understanding Transactions

### What is a Transaction?

A transaction is a sequence of operations that are treated as a single logical unit of work. Transactions follow the ACID properties:

- **Atomicity**: All operations in a transaction either complete successfully or fail completely. There's no partial execution.
- **Consistency**: A transaction transforms the database from one consistent state to another.
- **Isolation**: Concurrent transactions don't interfere with each other.
- **Durability**: Once a transaction is committed, changes persist even in case of system failures.

### Why Transaction Management Matters

Consider a banking application where transferring money involves:
1. Deducting an amount from one account
2. Adding the same amount to another account

If the system fails after step 1 but before step 2, money would disappear from one account without appearing in the other. Transaction management prevents such scenarios by ensuring both operations succeed or neither does.

## Spring's Transaction Management Approach

Spring provides two distinct approaches to transaction management:

1. **Declarative transaction management**: Uses annotations or XML configuration to manage transactions without modifying your code.
2. **Programmatic transaction management**: Gives you explicit control over transaction boundaries through code.

Most Spring applications use the declarative approach as it's less invasive and follows the principle of separation of concerns.

## Setting Up Transaction Management in Spring

Before we dive into examples, let's set up the necessary configuration for Spring transaction management.

### Maven Dependencies

Add these dependencies to your `pom.xml`:

```xml
<dependencies>
    <!-- Spring Context -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.23</version>
    </dependency>
    
    <!-- Spring JDBC -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-jdbc</artifactId>
        <version>5.3.23</version>
    </dependency>
    
    <!-- Spring Transaction -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-tx</artifactId>
        <version>5.3.23</version>
    </dependency>
</dependencies>
```

### Java Configuration

Here's how you can set up transaction management using Java configuration:

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("org.h2.Driver");
        dataSource.setUrl("jdbc:h2:mem:testdb");
        dataSource.setUsername("sa");
        dataSource.setPassword("");
        return dataSource;
    }
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

The `@EnableTransactionManagement` annotation enables Spring's annotation-driven transaction management capability, while the `transactionManager` bean configures a transaction manager for JDBC operations.

## Declarative Transaction Management

Declarative transaction management is the most common approach in Spring applications. It involves using annotations to define transaction boundaries.

### Using @Transactional Annotation

The `@Transactional` annotation is the cornerstone of Spring's declarative transaction management:

```java
import org.springframework.transaction.annotation.Transactional;

@Service
public class BankService {

    private final AccountRepository accountRepository;
    
    public BankService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }
    
    @Transactional
    public void transferMoney(String fromAccount, String toAccount, double amount) {
        accountRepository.debit(fromAccount, amount);
        accountRepository.credit(toAccount, amount);
    }
}
```

In this example, the `transferMoney` method is executed within a transaction. If any exception occurs during execution, the transaction will be rolled back automatically.

### Transaction Attributes

The `@Transactional` annotation accepts several attributes that control transaction behavior:

```java
@Transactional(
    propagation = Propagation.REQUIRED,
    isolation = Isolation.READ_COMMITTED,
    timeout = 30,
    readOnly = false,
    rollbackFor = Exception.class,
    noRollbackFor = NotFoundException.class
)
public void complexTransactionMethod() {
    // Method implementation
}
```

Let's examine these attributes:

#### Propagation Behavior

Propagation defines how transactions relate to each other:

- **REQUIRED** (default): Uses current transaction, creates new one if none exists
- **REQUIRES_NEW**: Always creates a new transaction
- **SUPPORTS**: Uses current transaction if it exists, otherwise non-transactional
- **NOT_SUPPORTED**: Executes non-transactionally, suspends current transaction
- **MANDATORY**: Must run within existing transaction, throws exception otherwise
- **NEVER**: Must run non-transactionally, throws exception if transaction exists
- **NESTED**: Executes in a nested transaction if one exists

Example of REQUIRES_NEW:

```java
@Service
public class ReportService {

    private final JdbcTemplate jdbcTemplate;
    
    public ReportService(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logAction(String action) {
        jdbcTemplate.update("INSERT INTO action_log (action, timestamp) VALUES (?, ?)", 
                            action, LocalDateTime.now());
    }
}
```

This method always executes in its own transaction, regardless of any existing transaction.

#### Isolation Levels

Isolation levels determine how isolated a transaction is from other transactions:

- **DEFAULT**: Database default isolation level
- **READ_UNCOMMITTED**: Allows dirty reads, non-repeatable reads, and phantom reads
- **READ_COMMITTED**: Prevents dirty reads, but allows non-repeatable reads and phantom reads
- **REPEATABLE_READ**: Prevents dirty reads and non-repeatable reads, but allows phantom reads
- **SERIALIZABLE**: Prevents all concurrency issues, but has lowest performance

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public List<Account> getHighValueAccounts() {
    return accountRepository.findAccountsWithBalanceAbove(1000000);
}
```

#### Read-Only Transactions

For operations that only read data, marking a transaction as read-only can provide performance optimizations:

```java
@Transactional(readOnly = true)
public List<Account> getAllAccounts() {
    return accountRepository.findAll();
}
```

#### Rollback Rules

By default, Spring rolls back transactions for runtime exceptions but not for checked exceptions. You can customize this behavior:

```java
@Transactional(rollbackFor = {SQLException.class, IOException.class})
public void importData(String filePath) throws IOException {
    // Import implementation
}
```

### Transaction Boundaries

It's important to understand where transaction boundaries are established:

```java
@Service
public class UserService {
    
    private final UserRepository userRepository;
    
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Transactional
    public void registerUser(User user) {
        validateUser(user); // This runs in the transaction
        userRepository.save(user); // This runs in the transaction
        sendWelcomeEmail(user); // This also runs in the transaction
    }
    
    private void validateUser(User user) {
        // Validation logic
    }
    
    private void sendWelcomeEmail(User user) {
        // Email sending logic
    }
}
```

The transaction starts when the `registerUser` method is called and commits (or rolls back) when the method completes. All method calls within `registerUser` are part of the same transaction.

## Programmatic Transaction Management

While declarative transactions are preferred, sometimes you need more fine-grained control. Spring provides two approaches for programmatic transaction management.

### Using TransactionTemplate

`TransactionTemplate` is the simplest approach for programmatic transactions:

```java
@Service
public class ProductService {

    private final TransactionTemplate transactionTemplate;
    private final JdbcTemplate jdbcTemplate;
    
    public ProductService(PlatformTransactionManager transactionManager, JdbcTemplate jdbcTemplate) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
        this.jdbcTemplate = jdbcTemplate;
    }
    
    public void createProduct(final Product product) {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                try {
                    jdbcTemplate.update("INSERT INTO products (name, price) VALUES (?, ?)", 
                                      product.getName(), product.getPrice());
                    
                    // More database operations...
                } catch (Exception e) {
                    status.setRollbackOnly();
                    throw e;
                }
            }
        });
    }
    
    // For operations returning a value
    public Product getProductById(final long id) {
        return transactionTemplate.execute(status -> {
            return jdbcTemplate.queryForObject(
                "SELECT id, name, price FROM products WHERE id = ?",
                new Object[] { id },
                (rs, rowNum) -> new Product(
                    rs.getLong("id"),
                    rs.getString("name"),
                    rs.getBigDecimal("price")
                )
            );
        });
    }
}
```

### Using TransactionManager Directly

For even more control, you can use the `PlatformTransactionManager` directly:

```java
@Service
public class InventoryService {
    
    private final PlatformTransactionManager transactionManager;
    private final JdbcTemplate jdbcTemplate;
    
    public InventoryService(PlatformTransactionManager transactionManager, JdbcTemplate jdbcTemplate) {
        this.transactionManager = transactionManager;
        this.jdbcTemplate = jdbcTemplate;
    }
    
    public void updateInventory(Long productId, int quantity) {
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        def.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);
        
        TransactionStatus status = transactionManager.getTransaction(def);
        
        try {
            jdbcTemplate.update("UPDATE inventory SET quantity = quantity + ? WHERE product_id = ?", 
                              quantity, productId);
            
            // Additional operations
            
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}
```

This approach gives you explicit control over transaction definition, commit, and rollback operations.

## Real-World Example: E-commerce Order Processing

Let's see how transaction management works in a real-world e-commerce application:

```java
@Service
public class OrderService {

    private final OrderRepository orderRepository;
    private final ProductRepository productRepository;
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    
    public OrderService(OrderRepository orderRepository, 
                       ProductRepository productRepository,
                       PaymentService paymentService,
                       InventoryService inventoryService) {
        this.orderRepository = orderRepository;
        this.productRepository = productRepository;
        this.paymentService = paymentService;
        this.inventoryService = inventoryService;
    }
    
    @Transactional
    public Order placeOrder(OrderRequest orderRequest) {
        // Create and save order
        Order order = new Order();
        order.setCustomerId(orderRequest.getCustomerId());
        order.setOrderDate(LocalDateTime.now());
        order.setStatus("PENDING");
        orderRepository.save(order);
        
        // Add items to order
        BigDecimal totalAmount = BigDecimal.ZERO;
        
        for (OrderItemRequest itemRequest : orderRequest.getItems()) {
            // Check inventory
            Product product = productRepository.findById(itemRequest.getProductId())
                .orElseThrow(() -> new ProductNotFoundException("Product not found"));
            
            if (product.getAvailableQuantity() < itemRequest.getQuantity()) {
                throw new InsufficientInventoryException("Not enough inventory for product: " + product.getName());
            }
            
            // Create order item
            OrderItem item = new OrderItem();
            item.setOrder(order);
            item.setProduct(product);
            item.setQuantity(itemRequest.getQuantity());
            item.setPrice(product.getPrice());
            order.addItem(item);
            
            // Update inventory
            inventoryService.decreaseInventory(product.getId(), itemRequest.getQuantity());
            
            // Add to total
            totalAmount = totalAmount.add(product.getPrice().multiply(new BigDecimal(itemRequest.getQuantity())));
        }
        
        order.setTotalAmount(totalAmount);
        
        // Process payment
        PaymentResult result = paymentService.processPayment(
            orderRequest.getPaymentDetails(), totalAmount);
            
        if (result.isSuccess()) {
            order.setStatus("PAID");
        } else {
            // If payment fails, transaction will be rolled back
            throw new PaymentFailedException("Payment failed: " + result.getMessage());
        }
        
        // Final save
        return orderRepository.save(order);
    }
}
```

In this example:
1. If payment fails, the transaction rolls back
2. If inventory check fails, the transaction rolls back
3. The entire process is atomic - either the complete order is processed or nothing happens

## Common Transaction Pitfalls

### Self-invocation

Transaction annotations don't work when methods are called within the same class:

```java
@Service
public class UserService {

    @Transactional
    public void createUser(User user) {
        // This runs in a transaction
        saveUser(user);
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveUser(User user) {
        // The REQUIRES_NEW doesn't work when called from createUser
        // It still runs in the same transaction
    }
}
```

The solution is to use dependency injection and call the method on another bean:

```java
@Service
public class UserService {

    private final UserPersistenceService persistenceService;
    
    public UserService(UserPersistenceService persistenceService) {
        this.persistenceService = persistenceService;
    }

    @Transactional
    public void createUser(User user) {
        // This runs in a transaction
        persistenceService.saveUser(user); // This works correctly with REQUIRES_NEW
    }
}

@Service
public class UserPersistenceService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveUser(User user) {
        // This creates a new transaction when called from UserService
    }
}
```

### Unchecked vs Checked Exceptions

Remember that Spring only rolls back automatically for unchecked exceptions:

```java
@Transactional
public void processFile(String path) throws IOException {
    // If an IOException occurs, transaction won't roll back by default
}
```

You need to specify the exception explicitly:

```java
@Transactional(rollbackFor = IOException.class)
public void processFile(String path) throws IOException {
    // Now the transaction will roll back on IOException
}
```

### Transaction Visibility

Transactions might not be immediately visible to other transactions depending on isolation level:

```java
@Service
public class ReportingService {

    @Transactional(isolation = Isolation.READ_COMMITTED)
    public BigDecimal getDailySales(LocalDate date) {
        // This might not see sales that are in-progress in other transactions
    }
}
```

## Best Practices

1. **Keep transactions short**: Long-running transactions can lead to database locks and performance issues.

2. **Use appropriate isolation levels**: Higher isolation levels provide more consistency but reduce concurrency.

3. **Be careful with exceptions**: Configure appropriate rollback rules based on your application's needs.

4. **Don't include non-transactional operations**: Avoid operations like HTTP calls or file I/O in transactional methods.

5. **Use read-only where appropriate**: This helps the database optimize read-only operations.

6. **Consider transaction boundaries carefully**: Place transaction boundaries at service layer rather than repository layer.

7. **Test transaction behavior**: Write tests that verify transaction rollback behavior.

## Summary

Spring Transaction Management provides a powerful abstraction for handling database transactions in your applications. The declarative approach using `@Transactional` is simple and non-invasive, making it the preferred choice for most applications.

Key points to remember:
- Use declarative transaction management with `@Transactional` for most cases
- Understand transaction attributes like propagation and isolation
- Be aware of transaction boundaries and limitations
- Use programmatic transactions when you need fine-grained control
- Follow best practices to avoid common pitfalls

By properly implementing transaction management in your Spring applications, you can ensure data consistency and integrity, even in the face of concurrent access and system failures.

## Additional Resources

- [Spring Framework Transaction Management Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction)
- [Understanding Spring's @Transactional annotation](https://www.baeldung.com/spring-transactional-propagation-isolation)
- [Testing Transaction Rollback in Spring](https://www.baeldung.com/spring-test-programmatic-transactions)

## Exercises

1. Create a simple banking application that transfers money between accounts with proper transaction management.

2. Implement different propagation behaviors and observe their effects when transactions call other transactional methods.

3. Write tests that verify transaction rollback behavior when exceptions occur.

4. Create a scenario with nested transactions using `PROPAGATION_NESTED` and compare it with `PROPAGATION_REQUIRES_NEW`.

5. Implement optimistic locking with transactions to handle concurrent updates to the same entity.