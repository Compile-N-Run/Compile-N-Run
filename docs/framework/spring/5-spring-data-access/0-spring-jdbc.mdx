---
title: Spring JDBC
description: A comprehensive guide to Spring JDBC for beginners, covering core concepts, implementation, and practical examples to simplify database operations in Spring applications.

---

# Spring JDBC

## Introduction

Spring JDBC (Java Database Connectivity) is a powerful module within the Spring Framework that simplifies database interactions in Java applications. It addresses many of the shortcomings of standard JDBC by providing a higher-level abstraction layer that handles common boilerplate code, exception handling, and resource management.

As a beginner, you might find traditional JDBC programming cumbersome with its verbose error handling, connection management, and statement creation. Spring JDBC resolves these challenges with elegant templates, callbacks, and utilities, making database operations more straightforward and less error-prone.

## Why Spring JDBC?

Before diving into Spring JDBC, let's understand why it's preferable to standard JDBC:

1. **Reduced boilerplate code**: Spring JDBC eliminates approximately 70% of the code typically required for JDBC operations
2. **Simplified exception handling**: Converts checked SQLException into more meaningful unchecked exceptions
3. **Resource management**: Automatically handles opening and closing of connections, statements, and result sets
4. **Template patterns**: Provides templates for common database operations
5. **Integration with Spring**: Seamlessly works with Spring's transaction management and other components

## Core Components of Spring JDBC

### JdbcTemplate

The `JdbcTemplate` class is the central component of Spring JDBC, providing a simplified way to interact with relational databases. It handles resource acquisition, connection management, statement creation and execution, and exception handling.

### Setting Up Spring JDBC

To get started with Spring JDBC, you need to add the required dependencies to your project:

**For Maven:**

```xml
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.3.23</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>5.3.23</version>
</dependency>
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.28</version>
</dependency>
```

**For Gradle:**

```groovy
implementation 'org.springframework:spring-jdbc:5.3.23'
implementation 'org.springframework:spring-context:5.3.23'
implementation 'mysql:mysql-connector-java:8.0.28'
```

### Configuring DataSource

Next, you need to configure a `DataSource`, which is the source of database connections. Here's how to configure it using Spring's Java configuration:

```java
@Configuration
public class DatabaseConfig {

    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("username");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

## Basic Database Operations with Spring JDBC

### Creating a Table

Let's start with creating a simple table to store user information:

```java
@Component
public class UserDatabaseInitializer {

    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    public UserDatabaseInitializer(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    public void createTable() {
        jdbcTemplate.execute("CREATE TABLE IF NOT EXISTS users (" +
                "id INT AUTO_INCREMENT PRIMARY KEY," +
                "name VARCHAR(100) NOT NULL," +
                "email VARCHAR(100) NOT NULL," +
                "age INT)");
        
        System.out.println("Table created successfully");
    }
}
```

### Inserting Data

Spring JDBC makes it easy to insert data into your database:

```java
public class User {
    private int id;
    private String name;
    private String email;
    private int age;
    
    // Constructors, getters, and setters
    // ...
}

@Component
public class UserDao {

    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    public UserDao(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }
    
    public void insertUser(User user) {
        String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
        int result = jdbcTemplate.update(sql, user.getName(), user.getEmail(), user.getAge());
        
        if (result > 0) {
            System.out.println("A new user has been inserted.");
        }
    }
}
```

When you run the above code with:

```java
User user = new User();
user.setName("John Doe");
user.setEmail("john.doe@example.com");
user.setAge(30);
userDao.insertUser(user);
```

You will see the output:
```
A new user has been inserted.
```

### Querying Data

Spring JDBC provides several methods to query data:

#### Query for a Single Object

```java
public User getUserById(int id) {
    String sql = "SELECT * FROM users WHERE id = ?";
    
    try {
        return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());
    } catch (EmptyResultDataAccessException e) {
        return null; // User not found
    }
}

// Define a RowMapper to map database rows to objects
class UserRowMapper implements RowMapper<User> {
    @Override
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setId(rs.getInt("id"));
        user.setName(rs.getString("name"));
        user.setEmail(rs.getString("email"));
        user.setAge(rs.getInt("age"));
        return user;
    }
}
```

#### Query for a List of Objects

```java
public List<User> getAllUsers() {
    String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, new UserRowMapper());
}
```

#### Query for Basic Types

```java
public int countUsers() {
    String sql = "SELECT COUNT(*) FROM users";
    return jdbcTemplate.queryForObject(sql, Integer.class);
}

public String getUserName(int id) {
    String sql = "SELECT name FROM users WHERE id = ?";
    try {
        return jdbcTemplate.queryForObject(sql, new Object[]{id}, String.class);
    } catch (EmptyResultDataAccessException e) {
        return null;
    }
}
```

### Updating Data

```java
public void updateUser(User user) {
    String sql = "UPDATE users SET name = ?, email = ?, age = ? WHERE id = ?";
    int result = jdbcTemplate.update(
        sql, 
        user.getName(), 
        user.getEmail(), 
        user.getAge(), 
        user.getId()
    );
    
    if (result > 0) {
        System.out.println("User updated successfully");
    }
}
```

### Deleting Data

```java
public void deleteUser(int id) {
    String sql = "DELETE FROM users WHERE id = ?";
    int result = jdbcTemplate.update(sql, id);
    
    if (result > 0) {
        System.out.println("User deleted successfully");
    }
}
```

## Batch Operations

When you need to execute multiple SQL operations in one go, batch operations come in handy:

```java
public void batchInsertUsers(List<User> users) {
    String sql = "INSERT INTO users (name, email, age) VALUES (?, ?, ?)";
    
    List<Object[]> batchArgs = new ArrayList<>();
    for (User user : users) {
        Object[] args = {user.getName(), user.getEmail(), user.getAge()};
        batchArgs.add(args);
    }
    
    int[] updateCounts = jdbcTemplate.batchUpdate(sql, batchArgs);
    System.out.println(updateCounts.length + " records inserted");
}
```

## Named Parameter JDBC Template

While `JdbcTemplate` uses positional parameters with `?` placeholders, Spring also provides `NamedParameterJdbcTemplate` which allows you to use named parameters in your SQL statements:

```java
@Component
public class NamedParamUserDao {

    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;
    
    @Autowired
    public NamedParamUserDao(DataSource dataSource) {
        this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
    }
    
    public User getUserById(int id) {
        String sql = "SELECT * FROM users WHERE id = :id";
        
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("id", id);
        
        try {
            return namedParameterJdbcTemplate.queryForObject(sql, params, new UserRowMapper());
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }
    
    public void updateUser(User user) {
        String sql = "UPDATE users SET name = :name, email = :email, age = :age WHERE id = :id";
        
        Map<String, Object> params = new HashMap<>();
        params.put("name", user.getName());
        params.put("email", user.getEmail());
        params.put("age", user.getAge());
        params.put("id", user.getId());
        
        int result = namedParameterJdbcTemplate.update(sql, params);
        
        if (result > 0) {
            System.out.println("User updated successfully with named parameters");
        }
    }
}
```

## SimpleJdbcInsert for Simplified Inserts

Spring JDBC provides `SimpleJdbcInsert` for easier insert operations:

```java
@Component
public class SimpleJdbcInsertDemo {

    private SimpleJdbcInsert simpleJdbcInsert;
    
    @Autowired
    public SimpleJdbcInsertDemo(DataSource dataSource) {
        this.simpleJdbcInsert = new SimpleJdbcInsert(dataSource)
            .withTableName("users")
            .usingGeneratedKeyColumns("id");
    }
    
    public int insertUserAndGetId(User user) {
        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", user.getName());
        parameters.put("email", user.getEmail());
        parameters.put("age", user.getAge());
        
        Number newId = simpleJdbcInsert.executeAndReturnKey(parameters);
        return newId.intValue();
    }
}
```

## Practical Example: User Management System

Now, let's build a simple user management system using Spring JDBC:

```java
@Configuration
@ComponentScan("com.example.usermanagement")
public class AppConfig {
    
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/userdb");
        dataSource.setUsername("username");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}

@Component
public class UserService {
    
    private UserDao userDao;
    
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
    
    public void registerUser(String name, String email, int age) {
        User user = new User();
        user.setName(name);
        user.setEmail(email);
        user.setAge(age);
        
        userDao.insertUser(user);
    }
    
    public List<User> findAllUsers() {
        return userDao.getAllUsers();
    }
    
    public User findUserById(int id) {
        return userDao.getUserById(id);
    }
    
    public void updateUserDetails(User user) {
        userDao.updateUser(user);
    }
    
    public void removeUser(int id) {
        userDao.deleteUser(id);
    }
    
    public int getTotalUserCount() {
        return userDao.countUsers();
    }
}

public class UserManagementApp {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        UserDatabaseInitializer initializer = context.getBean(UserDatabaseInitializer.class);
        initializer.createTable();
        
        UserService userService = context.getBean(UserService.class);
        
        // Register some users
        userService.registerUser("Alice Smith", "alice@example.com", 28);
        userService.registerUser("Bob Johnson", "bob@example.com", 35);
        userService.registerUser("Charlie Brown", "charlie@example.com", 42);
        
        // Show all users
        System.out.println("All Users:");
        List<User> allUsers = userService.findAllUsers();
        for (User user : allUsers) {
            System.out.println(user.getId() + ": " + user.getName() + " (" + user.getEmail() + ")");
        }
        
        // Update a user
        User userToUpdate = userService.findUserById(2);
        if (userToUpdate != null) {
            userToUpdate.setEmail("bob.new@example.com");
            userService.updateUserDetails(userToUpdate);
            System.out.println("\nUser updated");
        }
        
        // Show total count
        System.out.println("\nTotal users: " + userService.getTotalUserCount());
        
        // Delete a user
        userService.removeUser(3);
        System.out.println("\nAfter deletion, total users: " + userService.getTotalUserCount());
        
        context.close();
    }
}
```

Output:
```
Table created successfully
A new user has been inserted.
A new user has been inserted.
A new user has been inserted.

All Users:
1: Alice Smith (alice@example.com)
2: Bob Johnson (bob@example.com)
3: Charlie Brown (charlie@example.com)

User updated

Total users: 3

User deleted successfully

After deletion, total users: 2
```

## Exception Handling in Spring JDBC

Spring JDBC simplifies exception handling by converting the checked `SQLException` thrown by JDBC into unchecked `DataAccessException`. This hierarchy includes specific exceptions for different database errors:

```java
public User getUserByIdWithExceptionHandling(int id) {
    try {
        String sql = "SELECT * FROM users WHERE id = ?";
        return jdbcTemplate.queryForObject(sql, new Object[]{id}, new UserRowMapper());
    } catch (EmptyResultDataAccessException e) {
        System.out.println("No user found with ID: " + id);
        return null;
    } catch (DataAccessException e) {
        System.out.println("Database error: " + e.getMessage());
        throw e;
    }
}
```

## Transactions in Spring JDBC

Spring provides declarative transaction management through annotations:

```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

@Service
public class UserTransactionalService {
    
    private UserDao userDao;
    
    @Autowired
    public UserTransactionalService(UserDao userDao) {
        this.userDao = userDao;
    }
    
    @Transactional
    public void transferCredits(int fromUserId, int toUserId, int credits) {
        User fromUser = userDao.getUserById(fromUserId);
        User toUser = userDao.getUserById(toUserId);
        
        if (fromUser == null || toUser == null) {
            throw new IllegalArgumentException("User not found");
        }
        
        // This would require a 'credits' column in the users table
        if (fromUser.getCredits() < credits) {
            throw new IllegalStateException("Insufficient credits");
        }
        
        fromUser.setCredits(fromUser.getCredits() - credits);
        toUser.setCredits(toUser.getCredits() + credits);
        
        userDao.updateUser(fromUser);
        
        // Simulate an error to test transaction rollback
        if (credits > 100) {
            throw new RuntimeException("Transaction failed");
        }
        
        userDao.updateUser(toUser);
    }
}
```

## Summary

Spring JDBC simplifies database interactions by providing a higher-level abstraction over standard JDBC. Some key takeaways from this guide include:

1. Spring JDBC eliminates boilerplate code through templates like `JdbcTemplate` and `NamedParameterJdbcTemplate`
2. It manages resources automatically, ensuring connections, statements, and result sets are properly closed
3. The framework converts checked SQLExceptions to unchecked DataAccessExceptions for easier error handling
4. Spring JDBC supports various operations like querying, inserting, updating, and deleting data with minimal code
5. Advanced features include batch operations, named parameters, and simplified inserts
6. It integrates seamlessly with Spring's transaction management

By using Spring JDBC, you can focus more on your application logic and less on the intricacies of database connectivity and resource management.

## Additional Resources

- [Official Spring JDBC Documentation](https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc)
- [Spring JDBC Tutorial on Baeldung](https://www.baeldung.com/spring-jdbc-jdbctemplate)
- [Spring Data Access Examples on GitHub](https://github.com/spring-projects/spring-data-examples)

## Exercises

1. Create a Spring JDBC application to manage a library system with books and borrowers
2. Implement batch processing to import user data from a CSV file into a database
3. Build a DAO with CRUD operations for a product inventory system
4. Implement a transaction that transfers a product from one warehouse to another
5. Create a Named Parameter example that allows searching for users by multiple criteria

By completing these exercises, you'll gain practical experience with Spring JDBC and reinforce the concepts covered in this guide.