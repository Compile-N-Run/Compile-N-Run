---
title: Express Template Caching
description: Learn how to implement and utilize template caching in Express.js to improve your application's performance

---

# Express Template Caching

## Introduction

Template rendering is a common process in web applications that can consume significant computational resources. Every time a user requests a page, the server processes the template, fills it with data, and then sends the resulting HTML to the client. This operation can become a performance bottleneck as your application scales.

Express.js provides a built-in template caching mechanism to optimize this process. When template caching is enabled, Express will cache the compiled template functions in memory after their first render, reducing processing time and improving response speed for subsequent requests.

In this guide, you'll learn how template caching works in Express, how to configure it properly, and best practices for implementing it in your applications.

## Understanding Template Caching

### What is Template Caching?

Template caching is the process of storing compiled templates in memory to avoid re-compiling them on every request. When a template is first rendered, Express compiles it into a JavaScript function that can quickly output HTML when provided with data. With caching enabled, this compiled function is stored in memory and reused for future requests.

### Benefits of Template Caching

- **Improved Performance**: Eliminates the need to repeatedly compile templates
- **Reduced Server Load**: Decreases CPU usage for template processing
- **Faster Response Times**: Delivers content to users more quickly
- **Better Scalability**: Allows your application to handle more concurrent users

## Configuring Template Caching in Express

Express provides a simple way to configure template caching through the `view cache` option. Let's explore how to use it:

### Default Behavior

By default, Express enables template caching in production mode (`NODE_ENV=production`) and disables it in development mode. This is generally the behavior you want, as it optimizes for performance in production while allowing you to see template changes immediately during development.

### Basic Configuration

Here's how to explicitly configure template caching:

```javascript
const express = require('express');
const app = express();

// Enable template caching
app.set('view cache', true);

// Or disable template caching
app.set('view cache', false);

// Configure your template engine
app.set('view engine', 'pug');
app.set('views', './views');
```

## Example: Template Caching with Different Engines

Let's examine how to implement template caching with some popular templating engines in Express:

### EJS Template Caching

```javascript
const express = require('express');
const app = express();

app.set('view engine', 'ejs');
app.set('views', './views');

// Enable caching for production
if (process.env.NODE_ENV === 'production') {
  app.set('view cache', true);
  console.log('Template caching enabled');
} else {
  app.set('view cache', false);
  console.log('Template caching disabled');
}

app.get('/', (req, res) => {
  res.render('index', { 
    title: 'Template Caching Example',
    message: 'Hello, world!' 
  });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

### Pug (formerly Jade) Template Caching

Pug has additional caching options you can configure:

```javascript
const express = require('express');
const app = express();

app.set('view engine', 'pug');
app.set('views', './views');

// Express view caching
app.set('view cache', true);

// Additional Pug-specific cache configuration
app.locals.cache = true; // Enable Pug's internal cache

app.get('/about', (req, res) => {
  res.render('about', { pageTitle: 'About Us' });
});

app.listen(3000);
```

### Handlebars Template Caching

When using Handlebars with Express via the `express-handlebars` package:

```javascript
const express = require('express');
const exphbs = require('express-handlebars');
const app = express();

// Configure Handlebars
const hbs = exphbs.create({
  defaultLayout: 'main',
  // Handlebars-specific cache configuration
  partialsDir: ['views/partials/'],
  cache: process.env.NODE_ENV === 'production' // Enable caching in production
});

app.engine('handlebars', hbs.engine);
app.set('view engine', 'handlebars');
app.set('views', './views');

// Express view caching
app.set('view cache', process.env.NODE_ENV === 'production');

app.get('/', (req, res) => {
  res.render('home', { title: 'Home Page' });
});

app.listen(3000);
```

## Monitoring Cache Performance

To understand the impact of template caching, you can implement simple monitoring:

```javascript
const express = require('express');
const app = express();

app.set('view engine', 'ejs');
app.set('views', './views');

// Enable caching in production
app.set('view cache', process.env.NODE_ENV === 'production');

// Simple timer middleware to measure rendering time
app.use((req, res, next) => {
  const renderOriginal = res.render;
  res.render = function() {
    const startTime = process.hrtime();
    renderOriginal.apply(res, arguments);
    const endTime = process.hrtime(startTime);
    const duration = endTime[0] * 1000 + endTime[1] / 1000000;
    console.log(`Template rendering took ${duration.toFixed(2)}ms`);
  };
  next();
});

app.get('/', (req, res) => {
  res.render('index', { title: 'Performance Test' });
});

app.listen(3000);
```

With this middleware, you can observe how render times decrease after the first request when caching is enabled.

## Best Practices for Template Caching

### 1. Environment-based Configuration

Enable caching based on the environment:

```javascript
app.set('view cache', process.env.NODE_ENV === 'production');
```

### 2. Partial Caching for Dynamic Content

For pages with mostly static content but some dynamic parts, consider using partial caching:

```javascript
// In your route handler
app.get('/product/:id', (req, res) => {
  // Cacheable parts
  const productTemplate = getProductTemplate(); // Cached
  
  // Dynamic data fetched every time
  const productData = fetchProductData(req.params.id); 
  const userSpecificData = getUserData(req.user.id);
  
  res.render('product', { 
    template: productTemplate, 
    product: productData,
    userData: userSpecificData
  });
});
```

### 3. Cache Invalidation

When your templates change, you may need to clear the cache:

```javascript
// A simple function to clear the view cache
function clearViewCache() {
  Object.keys(require.cache).forEach((key) => {
    if (key.includes('/views/')) {
      delete require.cache[key];
    }
  });
  console.log('View cache cleared');
}

// Route to manually clear cache (admin only)
app.post('/admin/clear-cache', isAdmin, (req, res) => {
  clearViewCache();
  res.send('Cache cleared successfully');
});
```

### 4. Memory Management

Be aware of memory usage when caching templates, especially for large applications:

```javascript
const os = require('os');

// Monitor memory usage
setInterval(() => {
  const used = process.memoryUsage();
  console.log(`Memory usage: ${Math.round(used.rss / 1024 / 1024)} MB`);
  
  // If memory usage is too high, consider clearing the cache
  if (used.rss > 1024 * 1024 * 512) { // 512MB threshold example
    console.log('High memory usage detected, clearing template cache');
    clearViewCache();
  }
}, 60000); // Check every minute
```

## Real-world Application: Caching in a Blog Platform

Let's implement a simple blog application with strategic template caching:

```javascript
const express = require('express');
const app = express();

app.set('view engine', 'ejs');
app.set('views', './views');

// Enable caching based on environment
const isProduction = process.env.NODE_ENV === 'production';
app.set('view cache', isProduction);

// Simulated database
const posts = [
  { id: 1, title: 'Getting Started with Express', content: 'Express is a minimal web framework...' },
  { id: 2, title: 'Template Caching in Express', content: 'Learn how to improve performance...' }
];

// Routes
app.get('/', (req, res) => {
  // Home page rarely changes, good candidate for caching
  res.render('home', { 
    title: 'My Blog',
    posts: posts.map(p => ({ id: p.id, title: p.title })) // Just list titles
  });
});

app.get('/post/:id', (req, res) => {
  const post = posts.find(p => p.id === parseInt(req.params.id));
  if (!post) return res.status(404).render('404', { title: 'Not Found' });
  
  // Individual posts page template cached, but with dynamic content
  res.render('post', { 
    title: post.title,
    post,
    views: Math.floor(Math.random() * 100) + 1, // Dynamic content (view count)
    timestamp: new Date().toISOString() // Dynamic timestamp
  });
});

// Admin route to update posts (requires cache invalidation)
app.post('/admin/post/:id', (req, res) => {
  const post = posts.find(p => p.id === parseInt(req.params.id));
  if (!post) return res.status(404).send('Post not found');
  
  // Update post content
  post.title = req.body.title;
  post.content = req.body.content;
  
  // Clear the view cache if in production
  if (isProduction) {
    clearViewCache();
  }
  
  res.redirect(`/post/${post.id}`);
});

app.listen(3000, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode`);
  console.log(`Template caching is ${isProduction ? 'enabled' : 'disabled'}`);
});
```

This example demonstrates:
- Enabling cache based on environment
- Different rendering strategies for frequently and infrequently changing pages
- Cache invalidation when content is updated

## Summary

Express template caching is a powerful feature that can significantly improve your application's performance by reducing template processing time. Key takeaways include:

1. Template caching is enabled by default in production mode
2. You can explicitly control caching with `app.set('view cache', true/false)`
3. Different template engines may have additional caching options
4. Environment-based configuration is recommended (enabled in production, disabled in development)
5. Consider cache invalidation strategies for dynamic content
6. Monitor memory usage when implementing extensive caching

By properly implementing template caching, you can make your Express applications more responsive and capable of handling higher traffic loads without requiring additional server resources.

## Additional Resources and Exercises

### Resources
- [Express.js Documentation on Template Engines](https://expressjs.com/en/guide/using-template-engines.html)
- [Node.js Performance Optimization Guide](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/)
- [Memory Management in Node.js](https://nodejs.org/api/process.html#process_process_memoryusage)

### Exercises

1. **Compare Rendering Times**: Create a simple application that measures and compares template rendering times with caching enabled and disabled.

2. **Cache Monitoring Tool**: Build a middleware that logs cache hits and misses for your templates.

3. **Dynamic Cache Control**: Implement a system that allows administrators to toggle template caching on and off via an admin panel.

4. **Selective Caching**: Create a system that caches certain templates but not others based on how frequently they change.

5. **Cache Invalidation API**: Develop an API endpoint that allows specific templates to be invalidated from the cache when their underlying data changes.

By applying these concepts and exercises, you'll gain practical experience with Express template caching and develop intuition for when and how to use it effectively in your applications.