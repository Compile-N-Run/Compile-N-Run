---
title: Express Response Headers
description: Learn how to manage HTTP response headers in Express.js applications, including setting, getting, and manipulating headers for better security and performance.

---

# Express Response Headers

HTTP headers are an essential part of communication between clients and servers on the web. When building web applications with Express.js, properly managing response headers allows you to control caching, security, content types, and more. In this tutorial, we'll explore how to work with response headers in Express.js applications.

## What are HTTP Response Headers?

HTTP headers are key-value pairs sent in the response from a server to a client. They provide metadata about the response, such as the content type, caching directives, security policies, and more. Headers help browsers and clients understand how to process the received content.

## Setting Response Headers in Express

Express.js provides several methods to manage response headers in your applications.

### Basic Header Management

The most straightforward way to set a header is using the `res.set()` or `res.header()` methods:

```javascript
app.get('/example', (req, res) => {
  // Set a single header
  res.set('Content-Type', 'text/html');
  
  // Alternative method
  res.header('X-Custom-Header', 'Custom Value');
  
  // Set multiple headers at once
  res.set({
    'X-Powered-By': 'Express',
    'Cache-Control': 'no-store',
    'Content-Language': 'en-US'
  });
  
  res.send('<h1>Response with custom headers</h1>');
});
```

### Common Response Headers

Express provides convenience methods for setting common headers:

```javascript
app.get('/common-headers', (req, res) => {
  // Set content type
  res.type('application/json');
  
  // Set status and a status-specific message
  res.status(200);
  
  // Send the response
  res.json({ message: 'Success!' });
});
```

## Getting and Checking Headers

Sometimes you need to check if a header has been set or retrieve its current value:

```javascript
app.get('/check-headers', (req, res) => {
  // Set a header first
  res.set('X-Custom-Header', 'Original Value');
  
  // Get the header's value
  const headerValue = res.get('X-Custom-Header');
  
  // Check and modify if needed
  if (headerValue === 'Original Value') {
    res.set('X-Custom-Header', 'Modified Value');
  }
  
  res.send(`Header value: ${res.get('X-Custom-Header')}`);
});
```

## Practical Examples of Response Headers

Let's explore some practical applications of response headers in Express.js:

### 1. Security Headers

Enhance your application's security by implementing proper security headers:

```javascript
app.use((req, res, next) => {
  // Prevent MIME type sniffing
  res.set('X-Content-Type-Options', 'nosniff');
  
  // Help protect against XSS attacks
  res.set('X-XSS-Protection', '1; mode=block');
  
  // Control how your site can be framed
  res.set('X-Frame-Options', 'SAMEORIGIN');
  
  // Set Content Security Policy
  res.set(
    'Content-Security-Policy', 
    "default-src 'self'; script-src 'self' 'unsafe-inline'"
  );
  
  // Continue with the request
  next();
});
```

### 2. CORS Headers

Enable Cross-Origin Resource Sharing for your API:

```javascript
app.get('/api/data', (req, res) => {
  res.set({
    'Access-Control-Allow-Origin': 'https://trusted-site.com',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  });
  
  res.json({ data: 'This can be accessed from trusted-site.com' });
});
```

For more complex CORS scenarios, you might want to use the `cors` package:

```javascript
const cors = require('cors');

// Enable CORS for all routes
app.use(cors());

// OR with specific options
const corsOptions = {
  origin: 'https://trusted-site.com',
  methods: 'GET,POST',
  allowedHeaders: 'Content-Type,Authorization'
};

app.use(cors(corsOptions));
```

### 3. Caching Headers

Control how browsers cache your responses:

```javascript
app.get('/static-content', (req, res) => {
  // Cache this content for one day (values in seconds)
  res.set('Cache-Control', 'public, max-age=86400');
  res.send('<h1>This content is cached for 24 hours</h1>');
});

app.get('/dynamic-content', (req, res) => {
  // Prevent caching for dynamic content
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.set('Pragma', 'no-cache');
  res.set('Expires', '0');
  
  res.send(`<h1>Current time: ${new Date().toLocaleTimeString()}</h1>`);
});
```

### 4. Content Type and Encoding

Manage how content is interpreted and encoded:

```javascript
app.get('/text', (req, res) => {
  res.set('Content-Type', 'text/plain');
  res.send('This is plain text content');
});

app.get('/html', (req, res) => {
  res.set('Content-Type', 'text/html; charset=UTF-8');
  res.send('<h1>This is HTML content</h1>');
});

app.get('/compressed', (req, res) => {
  res.set('Content-Encoding', 'gzip');
  // Here you would send gzipped content
  // In practice, you'd use Express's built-in compression middleware
});
```

## Response Headers Middleware

Creating middleware for setting common headers across your application is a best practice:

```javascript
// Security headers middleware
function securityHeaders(req, res, next) {
  // Set security headers
  res.set({
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'SAMEORIGIN',
    'X-XSS-Protection': '1; mode=block'
  });
  next();
}

// Apply the middleware to all routes
app.use(securityHeaders);

// Or apply to specific routes
app.get('/secure-page', securityHeaders, (req, res) => {
  res.send('This page has extra security headers');
});
```

## Common Response Header Pitfalls

### Mistake: Setting Headers After Response is Sent

One common mistake is attempting to set headers after the response has already been sent:

```javascript
app.get('/error-example', (req, res) => {
  res.send('Hello World'); // Response is sent here
  
  // This will cause an error
  res.set('X-Custom-Header', 'Too Late'); // Error: Can't set headers after they are sent
});
```

To avoid this issue, always set headers before sending the response:

```javascript
app.get('/correct-example', (req, res) => {
  res.set('X-Custom-Header', 'Correct Order');
  res.send('Hello World'); // Send response after setting headers
});
```

### Mistake: Inconsistent Content-Type Headers

Ensure your Content-Type header matches the actual content you're sending:

```javascript
// Incorrect
app.get('/incorrect-type', (req, res) => {
  res.set('Content-Type', 'application/json');
  res.send('<h1>This is HTML content</h1>'); // Content doesn't match header
});

// Correct
app.get('/correct-type', (req, res) => {
  res.set('Content-Type', 'text/html');
  res.send('<h1>This is HTML content</h1>');
});

// Even better, use Express convenience methods
app.get('/better-approach', (req, res) => {
  // The res.json() method sets the appropriate Content-Type automatically
  res.json({ message: 'This automatically sets application/json Content-Type' });
});
```

## Working with HTTP/2 Headers

If you're using HTTP/2, keep in mind that header field names are treated as lowercase:

```javascript
app.get('/http2-example', (req, res) => {
  // Both of these set the same header in HTTP/2
  res.set('Content-Type', 'text/html');
  res.set('content-type', 'text/html'); // Same as above in HTTP/2
  
  res.send('<h1>HTTP/2 Header Example</h1>');
});
```

## Summary

Response headers are a crucial part of HTTP communication in web applications. Express.js provides convenient methods to set, get, and manipulate these headers for various purposes including security, caching, and content negotiation. By properly managing headers, you can enhance the security, performance, and functionality of your Express applications.

Key points to remember:
- Use `res.set()` or `res.header()` to set headers
- Set headers before sending the response
- Create middleware for applying common headers across routes
- Use appropriate headers for security, caching, and content types

## Additional Resources

1. [Express.js Response Documentation](https://expressjs.com/en/4x/api.html#res)
2. [MDN HTTP Headers Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
3. [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)

## Exercises

1. Create a middleware that sets appropriate security headers for all routes in an Express application.
2. Build an API endpoint that serves different content types based on the client's `Accept` header.
3. Implement a caching strategy using headers for static assets in your Express application.
4. Create a route that demonstrates proper CORS headers for allowing specific domains to access your API.
5. Build a simple response compression middleware that sets appropriate `Content-Encoding` headers.