---
title: Express Nested Routes
description: Learn how to organize and implement nested routes in Express.js to create more structured and maintainable web applications

---

# Express Nested Routes

## Introduction

When building web applications with Express.js, organizing your routes effectively becomes crucial as your application grows. **Nested routes** provide a way to structure your application's endpoints hierarchically, making your code more maintainable and easier to understand.

Nested routes allow you to group related routes together, creating cleaner URL structures that often mirror the hierarchical nature of your data or application features. For example, in a blog application, you might want to organize routes for posts and their comments in a logical parent-child relationship.

In this tutorial, you'll learn how to implement nested routes in Express.js, starting with basic concepts and progressing to more advanced patterns and real-world applications.

## Understanding Nested Routes

Nested routes represent hierarchical relationships between resources in your application. Consider a simple blog example:

- `/posts` - Get all posts
- `/posts/123` - Get a specific post
- `/posts/123/comments` - Get all comments for a specific post
- `/posts/123/comments/456` - Get a specific comment for a specific post

This hierarchical structure helps organize your application, making routes more intuitive and self-documenting.

## Basic Implementation of Nested Routes

Let's start with a simple example of how to implement nested routes in Express.

### Setting Up Express

First, let's set up a basic Express application:

```javascript
const express = require('express');
const app = express();
const port = 3000;

// Middleware for parsing JSON bodies
app.use(express.json());

// Start the server
app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

### Creating Simple Nested Routes

Now let's implement some basic nested routes for our blog example:

```javascript
// Posts routes
app.get('/posts', (req, res) => {
  res.json({ message: 'Getting all posts' });
});

app.get('/posts/:postId', (req, res) => {
  res.json({ message: `Getting post ${req.params.postId}` });
});

// Nested comment routes
app.get('/posts/:postId/comments', (req, res) => {
  res.json({ message: `Getting all comments for post ${req.params.postId}` });
});

app.get('/posts/:postId/comments/:commentId', (req, res) => {
  res.json({ 
    message: `Getting comment ${req.params.commentId} for post ${req.params.postId}` 
  });
});
```

When you make requests to these endpoints, you'll get responses like:

- `GET /posts` → `{ "message": "Getting all posts" }`
- `GET /posts/123` → `{ "message": "Getting post 123" }`
- `GET /posts/123/comments` → `{ "message": "Getting all comments for post 123" }`
- `GET /posts/123/comments/456` → `{ "message": "Getting comment 456 for post 123" }`

## Using Express Router for Nested Routes

While the above approach works for simple applications, using Express Router provides a more modular and maintainable solution, especially for larger applications.

### Step 1: Create Separate Router Files

Let's organize our code by creating separate router files.

First, create a comments router (`commentRoutes.js`):

```javascript
const express = require('express');
const router = express.Router({ mergeParams: true }); // Important!

// Get all comments for a post
router.get('/', (req, res) => {
  res.json({ message: `Getting all comments for post ${req.params.postId}` });
});

// Get a specific comment for a post
router.get('/:commentId', (req, res) => {
  res.json({
    message: `Getting comment ${req.params.commentId} for post ${req.params.postId}`
  });
});

// Add a new comment to a post
router.post('/', (req, res) => {
  res.json({
    message: `Created new comment for post ${req.params.postId}`,
    data: req.body
  });
});

module.exports = router;
```

Then create a posts router (`postRoutes.js`):

```javascript
const express = require('express');
const router = express.Router();
const commentRoutes = require('./commentRoutes');

// Mount the comments router for the /posts/:postId/comments path
router.use('/:postId/comments', commentRoutes);

// Get all posts
router.get('/', (req, res) => {
  res.json({ message: 'Getting all posts' });
});

// Get a specific post
router.get('/:postId', (req, res) => {
  res.json({ message: `Getting post ${req.params.postId}` });
});

// Create a new post
router.post('/', (req, res) => {
  res.json({
    message: 'Created new post',
    data: req.body
  });
});

module.exports = router;
```

### Step 2: Mount Routers in Main App

Finally, in your main application file:

```javascript
const express = require('express');
const app = express();
const port = 3000;
const postRoutes = require('./postRoutes');

// Middleware for parsing JSON bodies
app.use(express.json());

// Mount post routes at /posts path
app.use('/posts', postRoutes);

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

### The Importance of `mergeParams`

Notice the `{ mergeParams: true }` option in the comments router. This is crucial for nested routes to work correctly. It allows the child router to access parameters defined in parent routes. Without it, `req.params.postId` would be undefined in the comments router.

## Advanced Nested Routing Patterns

Now that we understand the basics, let's explore some advanced patterns for nested routes.

### Dynamic Middleware for Route Parameters

You can add middleware to validate or load resources based on route parameters:

```javascript
// postRoutes.js
const express = require('express');
const router = express.Router();
const commentRoutes = require('./commentRoutes');

// Middleware to load post
const loadPost = async (req, res, next) => {
  try {
    // In a real app, you would fetch from a database
    const postId = req.params.postId;
    
    // Simulate database lookup
    if (postId === '999') {
      return res.status(404).json({ error: 'Post not found' });
    }
    
    // Attach post to request object
    req.post = { id: postId, title: `Post ${postId}`, content: 'Content...' };
    next();
  } catch (error) {
    next(error);
  }
};

// Use the middleware for routes with :postId parameter
router.param('postId', (req, res, next, postId) => {
  // Validate postId format, for example
  if (!/^\d+$/.test(postId)) {
    return res.status(400).json({ error: 'Invalid post ID format' });
  }
  next();
});

// Apply loadPost middleware to specific routes
router.get('/:postId', loadPost, (req, res) => {
  // Since we loaded the post in middleware, we can use it directly
  res.json({ message: 'Post found', post: req.post });
});

// Mount comments routes with same loadPost middleware
router.use('/:postId/comments', loadPost, commentRoutes);

module.exports = router;
```

### Multiple Levels of Nesting

You can create deeper nesting for more complex resource relationships:

```javascript
// User -> Posts -> Comments -> Replies
const express = require('express');
const app = express();

const replyRoutes = require('./replyRoutes');
const commentRoutes = require('./commentRoutes');
const postRoutes = require('./postRoutes');
const userRoutes = require('./userRoutes');

// Each router mounts the next level
userRoutes.use('/:userId/posts', postRoutes);
postRoutes.use('/:postId/comments', commentRoutes);
commentRoutes.use('/:commentId/replies', replyRoutes);

// Mount the top-level router
app.use('/users', userRoutes);
```

This creates routes like `/users/1/posts/2/comments/3/replies/4`.

## Real-World Example: Blog API

Let's build a more complete example of a blog API with nested routes, incorporating best practices:

### Project Structure

```
/blog-api
  /routes
    commentRoutes.js
    postRoutes.js
    userRoutes.js
  /controllers
    commentController.js
    postController.js
    userController.js
  /middleware
    auth.js
    errorHandler.js
  /models
    Comment.js
    Post.js
    User.js
  app.js
  server.js
```

### Implementation

Here's how the post controller might look:

```javascript
// controllers/postController.js
exports.getAllPosts = (req, res) => {
  // In a real app, fetch from database
  res.json({
    success: true,
    data: [
      { id: 1, title: 'First Post', content: 'Content here...' },
      { id: 2, title: 'Second Post', content: 'More content...' }
    ]
  });
};

exports.getPostById = (req, res) => {
  // Using the post loaded by middleware
  res.json({
    success: true,
    data: req.post
  });
};

exports.createPost = (req, res) => {
  // In a real app, save to database
  const { title, content } = req.body;
  
  if (!title || !content) {
    return res.status(400).json({
      success: false,
      error: 'Please provide title and content'
    });
  }
  
  res.status(201).json({
    success: true,
    data: {
      id: Date.now(),
      title,
      content,
      author: req.user.id  // From auth middleware
    }
  });
};
```

And the post routes:

```javascript
// routes/postRoutes.js
const express = require('express');
const router = express.Router({ mergeParams: true });
const postController = require('../controllers/postController');
const commentRoutes = require('./commentRoutes');
const { authenticate, authorize } = require('../middleware/auth');
const { loadPost } = require('../middleware/loaders');

// Re-use the comment routes
router.use('/:postId/comments', loadPost, commentRoutes);

// Get all posts (potentially filtered by user if userId param exists)
router.get('/', postController.getAllPosts);

// Get a single post
router.get('/:postId', loadPost, postController.getPostById);

// Create a new post (requires authentication)
router.post('/', authenticate, postController.createPost);

// Update a post (requires authentication and authorization)
router.put(
  '/:postId',
  authenticate,
  loadPost,
  authorize('isAuthor'),
  postController.updatePost
);

// Delete a post (requires authentication and authorization)
router.delete(
  '/:postId',
  authenticate,
  loadPost,
  authorize('isAuthor'),
  postController.deletePost
);

module.exports = router;
```

And the main app.js file:

```javascript
const express = require('express');
const app = express();
const userRoutes = require('./routes/userRoutes');
const postRoutes = require('./routes/postRoutes');
const errorHandler = require('./middleware/errorHandler');

app.use(express.json());

// Mount routes
app.use('/users', userRoutes);
app.use('/posts', postRoutes);

// Global error handler
app.use(errorHandler);

module.exports = app;
```

## Best Practices for Nested Routes

When working with nested routes in Express, keep these best practices in mind:

1. **Don't Nest Too Deeply**: Limit nesting to 2-3 levels for better maintainability. Extremely deep nesting can create confusing URLs and routes.

2. **Use `mergeParams: true`**: Always enable this option when creating nested routers to ensure parent route parameters are accessible.

3. **Consider Resource Relationships**: Only nest routes when there's a true parent-child relationship between resources.

4. **Use Route Parameters Middleware**: Leverage `router.param()` for validation and loading resources.

5. **Create Flat Routes When Appropriate**: Not everything needs to be nested. For example, you might have:
   - Nested: `/posts/:postId/comments/:commentId` (for operations specific to a post's comments)
   - Flat: `/comments/:commentId` (for direct access to comments)

6. **Document Your API**: With nested routes, clear documentation becomes even more important.

## Common Challenges and Solutions

### Parameter Name Collisions

When different routers use the same parameter name, it can cause confusion:

```javascript
// Challenge: Both routes use :id
app.use('/posts/:id/comments', commentRoutes);
// Inside commentRoutes.js
router.get('/:id', (req, res) => { /* ... */ });
```

**Solution**: Use distinct parameter names or access parent params explicitly:

```javascript
// Better approach
app.use('/posts/:postId/comments', commentRoutes);
// Inside commentRoutes.js
router.get('/:commentId', (req, res) => {
  const { postId, commentId } = req.params;
  // ...
});
```

### Testing Nested Routes

Testing deeply nested routes can be challenging.

**Solution**: Use route mounting in your tests to isolate and test each router independently:

```javascript
const request = require('supertest');
const express = require('express');
const commentRoutes = require('../routes/commentRoutes');

describe('Comment Routes', () => {
  let app;
  
  beforeEach(() => {
    app = express();
    app.use(express.json());
    // Mount router directly with test parameters
    app.use('/posts/123/comments', commentRoutes);
  });
  
  it('should get all comments for a post', async () => {
    const res = await request(app).get('/posts/123/comments');
    expect(res.statusCode).toBe(200);
    // ...more assertions
  });
});
```

## Summary

Nested routes in Express.js provide a powerful way to organize your application's endpoints according to their hierarchical relationships. We've covered:

- Basic implementation of nested routes with plain Express handlers
- Using Express Router for more modular code organization
- Advanced patterns including middleware for loading resources
- Multiple levels of nesting for complex resource relationships
- A real-world example of a blog API with nested routes
- Best practices and common challenges with solutions

With nested routes, you can create more intuitive, self-documenting APIs that reflect the structure of your application's data and relationships. This leads to more maintainable code and a better developer experience.

## Exercises

To solidify your understanding, try these exercises:

1. Create a simple API for an e-commerce application with nested routes for:
   - `/users/:userId/orders`
   - `/products/:productId/reviews`

2. Implement parameter validation middleware that ensures IDs are valid before handling requests.

3. Refactor an existing flat API to use nested routes where appropriate.

4. Create a three-level nested route structure for a forum application:
   - `/forums/:forumId/topics/:topicId/posts`

## Additional Resources

- [Express Router Documentation](https://expressjs.com/en/4x/api.html#router)
- [REST API Design Best Practices](https://restfulapi.net/)
- [Express Middleware Guide](https://expressjs.com/en/guide/using-middleware.html)
- [Building RESTful Web APIs with Node.js and Express](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes)
- [API Design Patterns](https://www.manning.com/books/api-design-patterns)

Happy coding!