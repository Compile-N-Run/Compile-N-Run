---
title: Express Middleware Communication
description: Learn how middleware functions in Express.js can communicate and share data with each other and with route handlers.

---

# Express Middleware Communication

In Express applications, middleware functions don't just process requests in isolation. They can communicate with each other and share data throughout the request-response cycle. Understanding how to pass data between middleware functions is crucial for building robust and maintainable Express applications.

## Introduction to Middleware Communication

When a request comes into your Express application, it may pass through several middleware functions before a response is sent. During this journey, you often need to share information between these functions. For example:

- An authentication middleware might verify a user's identity and share the user information with subsequent middleware.
- A middleware might process form data and make it available to route handlers.
- Error information might need to be collected and passed along the chain.

Express provides several mechanisms for middleware communication, which we'll explore in this guide.

## The `req` Object: Your Communication Channel

The primary method for communication between middleware functions is the `req` (request) object. Express passes this object through each middleware in the stack, allowing you to attach data to it that subsequent middleware can access.

### Using `req` to Share Data

```javascript
app.use((req, res, next) => {
  // Store data on the request object
  req.customData = "This is shared data";
  next();
});

app.use((req, res, next) => {
  // Access data from the previous middleware
  console.log(req.customData); // Output: "This is shared data"
  next();
});

app.get('/', (req, res) => {
  // Route handlers can also access the data
  res.send(`Data from middleware: ${req.customData}`);
});
```

In this example, the first middleware attaches a `customData` property to the `req` object, which is then accessed by both the second middleware and the route handler.

## Using `res.locals` for Response-Specific Data

When you want to pass data specifically intended for view rendering (like data that will be used in templates), Express provides `res.locals`. This is an object that exists throughout the request-response cycle and is only available to the current request.

```javascript
app.use((req, res, next) => {
  // Store data in res.locals
  res.locals.user = {
    id: 1,
    username: 'expressuser'
  };
  next();
});

app.get('/', (req, res) => {
  // res.locals is available here
  res.send(`Hello, ${res.locals.user.username}!`);
  // Output: "Hello, expressuser!"
});
```

This approach is particularly useful when using template engines like EJS, Pug, or Handlebars, as `res.locals` properties are automatically available in your templates.

## Creating Custom Properties

While you can add properties directly to `req` or use `res.locals`, it's often a good practice to namespace your custom properties to avoid conflicts with other middleware or Express itself.

```javascript
app.use((req, res, next) => {
  // Create a namespace for your application
  req.myApp = req.myApp || {};
  req.myApp.startTime = Date.now();
  next();
});

app.get('/', (req, res, next) => {
  req.myApp.endTime = Date.now();
  req.myApp.processingTime = req.myApp.endTime - req.myApp.startTime;
  
  res.send(`Request processed in ${req.myApp.processingTime}ms`);
});
```

## Practical Example: User Authentication

Here's a more complete example showing how middleware communication can be used for user authentication:

```javascript
// Authentication middleware
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  
  if (!authHeader) {
    return res.status(401).send('Authorization header required');
  }
  
  try {
    // Assume this function verifies a token and returns user info
    const user = verifyAuthToken(authHeader.split(' ')[1]);
    
    // Store user info for subsequent middleware and routes
    req.user = user;
    next();
  } catch (error) {
    res.status(401).send('Invalid authentication token');
  }
}

// Role-based authorization middleware
function requireAdmin(req, res, next) {
  // Uses data from the authentication middleware
  if (!req.user) {
    return res.status(401).send('Authentication required');
  }
  
  if (req.user.role !== 'admin') {
    return res.status(403).send('Admin access required');
  }
  
  next();
}

// Apply the middleware to protected routes
app.get('/admin/dashboard', authenticate, requireAdmin, (req, res) => {
  res.send(`Welcome to the admin dashboard, ${req.user.name}!`);
});
```

In this example, the `authenticate` middleware attaches user information to `req.user`, which the `requireAdmin` middleware then uses to check if the user has the required role.

## Error Handling Through Middleware

Middleware can also communicate errors down the chain. Express has a special pattern for error-handling middleware:

```javascript
// Regular middleware
app.use((req, res, next) => {
  if (!req.query.id) {
    // Pass an error to the next middleware
    return next(new Error('ID parameter is required'));
  }
  next();
});

// Another middleware that might generate errors
app.use((req, res, next) => {
  try {
    const result = someRiskyOperation();
    req.operationResult = result;
    next();
  } catch (error) {
    next(error); // Pass the error to error-handling middleware
  }
});

// Error-handling middleware (has 4 parameters)
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send(`Error: ${err.message}`);
});
```

When you call `next()` with an argument, Express skips all remaining "regular" middleware and goes straight to error-handling middleware (those with 4 parameters).

## Advanced: Using a Middleware Instance

Sometimes you need middleware to maintain state across multiple requests. In such cases, you can create middleware as a function that returns a closure:

```javascript
function counterMiddleware() {
  // This state is shared across all requests
  let requestCount = 0;
  
  // Return the actual middleware function
  return function(req, res, next) {
    requestCount++;
    req.requestNumber = requestCount;
    console.log(`Request #${requestCount} received`);
    next();
  };
}

// Use the middleware
app.use(counterMiddleware());

app.get('/', (req, res) => {
  res.send(`This is request #${req.requestNumber}`);
});
```

## Best Practices for Middleware Communication

1. **Namespace your properties**: Use a consistent naming convention for custom properties to avoid conflicts.
2. **Document your middleware**: Clearly document what properties your middleware adds to `req` or `res.locals`.
3. **Don't overwrite existing properties**: Check if a property already exists before setting it.
4. **Use TypeScript declarations**: If you're using TypeScript, extend the Request interface to include your custom properties.

```javascript
// Example of checking before setting
app.use((req, res, next) => {
  if (req.user) {
    console.warn('Warning: req.user is already defined!');
  }
  req.user = getUserFromSomeSource();
  next();
});
```

## Summary

Middleware communication in Express is primarily facilitated through:

1. Adding properties to the `req` object
2. Using `res.locals` for view-related data
3. Passing errors to subsequent error-handling middleware using `next(error)`
4. Creating middleware that maintains state across requests

Understanding these patterns allows you to build Express applications with a clean separation of concerns, where each middleware performs a specific task and shares its results with subsequent middleware and route handlers.

## Additional Resources

- [Express Documentation on Using Middleware](https://expressjs.com/en/guide/using-middleware.html)
- [Express API Reference for Request](https://expressjs.com/en/4x/api.html#req)
- [Express API Reference for Response](https://expressjs.com/en/4x/api.html#res)

## Exercises

1. Create a middleware that tracks the time taken to process each request and logs it at the end.
2. Build a middleware system that validates user input and makes the validated data available to route handlers.
3. Implement an authorization system with multiple middleware functions that communicate with each other.
4. Create a request logger middleware that assigns each request a unique ID and tracks it through multiple middleware functions.

With these concepts mastered, you'll be able to create complex, maintainable Express applications that effectively share data between different components of your request-handling pipeline.