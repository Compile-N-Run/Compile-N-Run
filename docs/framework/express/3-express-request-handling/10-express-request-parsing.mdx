---
title: Express Request Parsing
description: Learn how to parse different types of data from HTTP requests in Express.js including query parameters, URL parameters, and request bodies.

---

# Express Request Parsing

When building web applications with Express.js, one of the most fundamental tasks is extracting and processing data from incoming HTTP requests. This process, known as request parsing, allows your application to understand what the client is asking for and respond accordingly.

## Introduction to Request Parsing

In Express applications, incoming requests can contain data in various formats and locations:

- **Query parameters** in the URL (e.g., `?name=john&age=25`)
- **URL parameters** or route parameters (e.g., `/users/:id`)
- **Request body** (e.g., form submissions, JSON data, file uploads)
- **Headers** containing metadata about the request
- **Cookies** for maintaining client state

Express provides built-in methods and middleware to help you extract and parse this data efficiently, making it available in your route handlers.

## Parsing Query Parameters

Query parameters are key-value pairs that appear after the `?` in a URL.

### Basic Query Parameter Example

```javascript
// Route definition
app.get('/search', (req, res) => {
  // Access query parameters via req.query
  const query = req.query.q;
  const category = req.query.category || 'all';
  
  res.send(`Searching for "${query}" in category: ${category}`);
});
```

When a user visits `/search?q=express&category=tutorials`, the output would be:
```
Searching for "express" in category: tutorials
```

### Query Parameters with Multiple Values

Express automatically handles arrays in query parameters:

```javascript
// URL: /filter?colors=red&colors=blue&colors=green
app.get('/filter', (req, res) => {
  console.log(req.query.colors); // ['red', 'blue', 'green']
  
  res.send(`Selected colors: ${req.query.colors.join(', ')}`);
});
```

## Parsing URL Parameters

URL parameters (also called route parameters) are parts of the URL path that can change and are defined with a colon `:` in your route definition.

### Basic URL Parameter Example

```javascript
app.get('/users/:userId', (req, res) => {
  // Access URL parameters via req.params
  const userId = req.params.userId;
  
  res.send(`Fetching details for user: ${userId}`);
});
```

When a user visits `/users/42`, the output would be:
```
Fetching details for user: 42
```

### Multiple URL Parameters

You can define multiple URL parameters in a single route:

```javascript
app.get('/products/:category/:productId', (req, res) => {
  const { category, productId } = req.params;
  
  res.send(`Viewing ${category} product #${productId}`);
});
```

When a user visits `/products/electronics/laptop-15`, the output would be:
```
Viewing electronics product #laptop-15
```

## Parsing Request Bodies

To parse request bodies, Express requires middleware. The most common ones are:

- `express.json()` - for parsing JSON request bodies
- `express.urlencoded()` - for parsing URL-encoded form data
- `express.raw()` - for parsing request body as Buffer
- `express.text()` - for parsing request body as string

Let's set up the middleware for parsing different types of request bodies:

```javascript
const express = require('express');
const app = express();

// Parse JSON bodies
app.use(express.json());

// Parse URL-encoded bodies (as sent by HTML forms)
app.use(express.urlencoded({ extended: true }));

// Parse text bodies
app.use(express.text());

// Parse raw bodies
app.use(express.raw());
```

### Parsing JSON Bodies

JSON is the most common format for API requests in modern web applications.

```javascript
app.post('/api/users', (req, res) => {
  // req.body contains the parsed JSON data
  const { name, email, age } = req.body;
  
  // Process the data
  console.log(`Creating user: ${name}, ${email}, ${age}`);
  
  // Send a response
  res.status(201).json({
    success: true,
    message: `User ${name} created successfully`,
    userId: generateId() // Assume this function exists
  });
});
```

Example request using fetch:

```javascript
// Client-side code
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com',
    age: 28
  })
})
  .then(response => response.json())
  .then(data => console.log(data));
```

### Parsing Form Data

For handling traditional HTML form submissions:

```javascript
app.post('/login', (req, res) => {
  const { username, password } = req.body;
  
  // Validate credentials (simplified example)
  if (username === 'admin' && password === 'secret') {
    res.send('Login successful!');
  } else {
    res.status(401).send('Invalid credentials');
  }
});
```

HTML form that would submit to this endpoint:

```html
<form action="/login" method="POST">
  <input type="text" name="username" placeholder="Username">
  <input type="password" name="password" placeholder="Password">
  <button type="submit">Login</button>
</form>
```

## Parsing Multipart Form Data (File Uploads)

To handle file uploads, you need additional middleware like `multer`:

```javascript
const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

app.post('/profile', upload.single('avatar'), (req, res) => {
  // req.file contains information about the uploaded file
  // req.body contains other form fields
  
  console.log('Uploaded file:', req.file);
  console.log('Form data:', req.body);
  
  res.send('Profile updated successfully');
});
```

HTML form for file upload:

```html
<form action="/profile" method="POST" enctype="multipart/form-data">
  <input type="text" name="username" placeholder="Username">
  <input type="file" name="avatar">
  <button type="submit">Update Profile</button>
</form>
```

## Request Headers and Cookies

### Accessing Request Headers

Headers provide metadata about the request:

```javascript
app.get('/api/check-auth', (req, res) => {
  // Access headers via req.headers
  const authToken = req.headers.authorization;
  
  if (!authToken) {
    return res.status(401).send('Authentication required');
  }
  
  // Process the token (simplified)
  const token = authToken.replace('Bearer ', '');
  
  // Validate token...
  res.send(`Authenticated with token: ${token}`);
});
```

### Parsing Cookies

For cookies, the `cookie-parser` middleware is commonly used:

```javascript
const cookieParser = require('cookie-parser');

app.use(cookieParser());

app.get('/dashboard', (req, res) => {
  // Access cookies via req.cookies
  const userId = req.cookies.userId;
  
  if (!userId) {
    return res.redirect('/login');
  }
  
  res.send(`Welcome back, user #${userId}`);
});

// Setting cookies
app.post('/login-success', (req, res) => {
  // Set a cookie
  res.cookie('userId', '12345', { 
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    httpOnly: true // For security
  });
  
  res.redirect('/dashboard');
});
```

## Real-world Example: User Registration API

Let's create a more comprehensive example that combines multiple concepts:

```javascript
const express = require('express');
const multer = require('multer');
const path = require('path');

const app = express();
const port = 3000;

// Configure storage for uploaded files
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'public/uploads/');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const extension = path.extname(file.originalname);
    cb(null, `${file.fieldname}-${uniqueSuffix}${extension}`);
  }
});

const upload = multer({ storage });

// Middleware for parsing various request formats
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));

// User registration endpoint
app.post('/api/register', upload.single('profilePicture'), (req, res) => {
  try {
    // Extract body data
    const { username, email, password, birthYear } = req.body;
    
    // Validate required fields
    if (!username || !email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Missing required fields'
      });
    }
    
    // Process file upload
    const profilePicture = req.file 
      ? `/uploads/${req.file.filename}` 
      : '/images/default-avatar.png';
    
    // Access query parameters (optional preferences)
    const newsletter = req.query.newsletter === 'true';
    const theme = req.query.theme || 'light';
    
    // In a real application, you would save this data to a database
    const newUser = {
      id: Date.now().toString(),
      username,
      email,
      // In a real app, never store passwords as plaintext!
      // You would hash the password here
      profilePicture,
      birthYear: parseInt(birthYear) || null,
      preferences: {
        newsletter,
        theme
      },
      createdAt: new Date()
    };
    
    // Log the new user (in a real app, this would be saved to a database)
    console.log('New user registered:', newUser);
    
    // Send successful response
    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      user: {
        id: newUser.id,
        username: newUser.username,
        profilePicture: newUser.profilePicture,
        preferences: newUser.preferences
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      message: 'An error occurred during registration'
    });
  }
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

## Common Errors and Troubleshooting

### Undefined Request Body

**Problem**: Your route handler cannot access `req.body` and it returns `undefined`.

**Solution**: Make sure you've included the appropriate middleware before defining your routes:

```javascript
// Add this BEFORE your route definitions
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Now your routes can access req.body correctly
app.post('/api/data', (req, res) => {
  console.log(req.body); // Should now contain the parsed data
  // ...
});
```

### Type Conversion Issues

**Problem**: Values from request parameters are coming in as strings when you need numbers.

**Solution**: Explicitly convert string values to the appropriate type:

```javascript
app.get('/calculate', (req, res) => {
  // Convert string parameters to numbers
  const a = parseInt(req.query.a) || 0;
  const b = parseInt(req.query.b) || 0;
  
  const sum = a + b;
  
  res.send(`The sum is: ${sum}`);
});
```

### Large Request Bodies

**Problem**: You're getting errors when handling large request bodies.

**Solution**: Configure the body parser middleware with appropriate size limits:

```javascript
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
```

## Summary

In this guide, we covered the essential aspects of request parsing in Express.js:

- Extracting and utilizing query parameters from URLs with `req.query`
- Working with URL/route parameters using `req.params`
- Parsing different types of request bodies (JSON, form data, etc.) using Express middleware
- Handling file uploads with the Multer middleware
- Accessing request headers and cookies
- Building a comprehensive user registration API that combines multiple concepts

Understanding how to effectively parse and process request data is fundamental to building robust Express applications. By mastering these techniques, you'll be able to handle a wide variety of client requests and build more interactive and dynamic web applications.

## Additional Resources

- [Express.js Official Documentation on Request Object](https://expressjs.com/en/4x/api.html#req)
- [Multer Documentation for File Uploads](https://github.com/expressjs/multer)
- [Cookie-Parser Middleware](https://github.com/expressjs/cookie-parser)

## Exercises

1. Create a simple API endpoint that accepts query parameters for sorting and filtering data (e.g., `/api/products?sort=price&minPrice=10&maxPrice=100`).

2. Build a RESTful API endpoint that uses URL parameters to fetch a specific resource (e.g., `/api/articles/:articleId/comments/:commentId`).

3. Create a form submission endpoint that validates the input data and returns appropriate error messages for invalid submissions.

4. Build a file upload system that accepts multiple files and validates them based on file type and size.

5. Create an authentication system that parses and validates JWT tokens from request headers.