---
title: Vue.js Security
description: Learn essential security best practices for Vue.js applications to protect your websites from common vulnerabilities and attacks.

---

# Vue.js Security

## Introduction

Security is a critical aspect of any web application, and Vue.js applications are no exception. As you build interactive user interfaces with Vue.js, understanding potential security vulnerabilities and implementing proper safeguards is essential to protect both your application and its users.

In this guide, we'll explore common security concerns in Vue.js applications and learn practical techniques to mitigate these risks. Whether you're building a simple portfolio site or a complex enterprise application, these security best practices will help you create more robust Vue.js applications.

## Why Vue.js Security Matters

Before diving into specific techniques, it's important to understand that Vue.js, like any frontend framework, operates in the browser environment where several security concerns exist:

1. **Client-side exposure**: All of your frontend code can be inspected by users
2. **User input processing**: Handling user data improperly can lead to vulnerabilities
3. **API communication**: Insecure data transmission to/from your backend servers
4. **Authentication management**: Storing and validating user credentials securely

Let's explore each area and learn how to implement effective security measures.

## XSS Protection in Vue.js

### Understanding XSS Vulnerabilities

Cross-Site Scripting (XSS) is one of the most common web application vulnerabilities. It occurs when an attacker injects malicious scripts into content that is then served to other users.

The good news: Vue.js provides built-in protection against XSS by automatically escaping content. However, there are still scenarios that require your attention.

### Content Escaping

By default, Vue.js escapes HTML content in templates:

```html
<template>
  <!-- This will render the text safely, not as HTML -->
  <div>{{ userProvidedContent }}</div>
</template>

<script>
export default {
  data() {
    return {
      userProvidedContent: '<script>alert("XSS attack!")</script>'
    }
  }
}
</script>
```

Output: The script tag will be displayed as text rather than being executed.

### Dangers of v-html

The `v-html` directive renders HTML directly, bypassing Vue's escaping:

```html
<template>
  <!-- DANGEROUS: Only use with trusted content -->
  <div v-html="userProvidedContent"></div>
</template>
```

**Best Practice**: Avoid using `v-html` with user-provided content. If you must use it, implement a sanitization library like DOMPurify:

```html
<template>
  <div v-html="sanitizedContent"></div>
</template>

<script>
import DOMPurify from 'dompurify';

export default {
  props: {
    userContent: String
  },
  computed: {
    sanitizedContent() {
      return DOMPurify.sanitize(this.userContent);
    }
  }
}
</script>
```

## URL and Dynamic Content Security

### URL Parameters and Routing

When using Vue Router with dynamic parameters, validate the input before using it:

```html
<template>
  <div>
    <h1>Profile: {{ validatedUsername }}</h1>
  </div>
</template>

<script>
export default {
  computed: {
    validatedUsername() {
      // Get the username from URL parameters
      const username = this.$route.params.username;
      
      // Validate the username (example: only allow alphanumeric characters)
      return username.match(/^[a-zA-Z0-9]+$/) ? username : 'Invalid Username';
    }
  }
}
</script>
```

### Dynamic Component Loading

When using `:is` for dynamic components, ensure you're only loading trusted components:

```html
<template>
  <component :is="currentComponent"></component>
</template>

<script>
import SafeComponent1 from './SafeComponent1.vue';
import SafeComponent2 from './SafeComponent2.vue';

export default {
  data() {
    return {
      currentComponentName: 'SafeComponent1'
    }
  },
  computed: {
    currentComponent() {
      // Only allow specific trusted components to be loaded
      const allowedComponents = {
        'SafeComponent1': SafeComponent1,
        'SafeComponent2': SafeComponent2
      };
      
      return allowedComponents[this.currentComponentName] || SafeComponent1;
    }
  }
}
</script>
```

## CSRF Protection

Cross-Site Request Forgery (CSRF) attacks trick authenticated users into performing unwanted actions. To protect against CSRF:

### Using CSRF Tokens with Axios

```html
<script>
import axios from 'axios';

export default {
  created() {
    // Set up axios to include CSRF token with every request
    const token = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    
    axios.defaults.headers.common['X-CSRF-TOKEN'] = token;
  },
  methods: {
    async submitForm() {
      try {
        await axios.post('/api/data', this.formData);
        // Success handling
      } catch (error) {
        // Error handling
      }
    }
  }
}
</script>
```

### SameSite Cookie Attribute

Ensure your backend sets cookies with appropriate SameSite attributes:

```javascript
// This would be in your backend code (Node.js example)
res.cookie('sessionId', 'value', {
  httpOnly: true,
  secure: true,
  sameSite: 'strict'
});
```

## Secure Authentication Practices

### Token Storage

Never store sensitive auth tokens in localStorage or sessionStorage where they can be accessed by JavaScript:

```javascript
// ❌ INSECURE: Don't do this
localStorage.setItem('authToken', response.data.token);

// ✅ BETTER: Use HttpOnly cookies set by your server
// The cookie will be automatically sent with requests but inaccessible to JavaScript
```

### Auth State Management

When managing authentication state in Vuex:

```javascript
// store/modules/auth.js
const state = {
  user: null,
  isAuthenticated: false,
  // Don't store sensitive tokens here!
};

const actions = {
  async login({ commit }, credentials) {
    try {
      await axios.post('/api/login', credentials);
      // The backend sets HttpOnly cookies
      commit('setAuthenticated', true);
      return true;
    } catch (error) {
      return false;
    }
  },
  
  async logout({ commit }) {
    await axios.post('/api/logout');
    // Backend clears the cookies
    commit('setAuthenticated', false);
    commit('setUser', null);
  }
};
```

## API Security

### Secure API Communication

Always use HTTPS for API communication:

```html
<script>
import axios from 'axios';

export default {
  data() {
    return {
      api: axios.create({
        baseURL: 'https://api.yourservice.com',
        timeout: 5000,
      })
    }
  },
  methods: {
    async fetchData() {
      try {
        const response = await this.api.get('/secure-data');
        this.data = response.data;
      } catch (error) {
        this.handleError(error);
      }
    }
  }
}
</script>
```

### Input Validation

Always validate input on both client and server sides:

```html
<template>
  <form @submit.prevent="submitForm">
    <input 
      v-model="email" 
      type="email" 
      required 
      pattern="[^@]+@[^\.]+\..+" 
    />
    <button type="submit" :disabled="!isValidForm">Submit</button>
  </form>
</template>

<script>
export default {
  data() {
    return {
      email: ''
    }
  },
  computed: {
    isValidForm() {
      // Email regex validation (basic example)
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(this.email);
    }
  },
  methods: {
    submitForm() {
      // Even though we validate on the client side,
      // we must also validate on the server side
      if (this.isValidForm) {
        this.sendToApi(this.email);
      }
    }
  }
}
</script>
```

## Environment Variables and Secrets

Never hardcode API keys or secrets in your Vue application:

```javascript
// .env.development
VUE_APP_API_URL=https://dev-api.example.com

// .env.production
VUE_APP_API_URL=https://api.example.com

// In your code
const apiUrl = process.env.VUE_APP_API_URL;
```

Remember that all environment variables accessible from Vue are exposed to the client. For truly sensitive data, always use backend services.

## Security Auditing

### Dependency Scanning

Regularly check for vulnerabilities in your dependencies:

```bash
# Using npm
npm audit

# Using yarn
yarn audit
```

### Vue.js Specific Tools

Consider using ESLint plugins with security rules:

```javascript
// .eslintrc.js
module.exports = {
  extends: [
    'plugin:vue/recommended',
    'plugin:vue-security/recommended'
  ]
}
```

## Real-World Example: Secure Contact Form

Let's build a secure contact form in Vue.js that demonstrates several security best practices:

```html
<template>
  <div class="contact-form">
    <h2>Contact Us</h2>
    
    <div v-if="submissionStatus === 'success'" class="success-message">
      Thank you for your message! We'll respond soon.
    </div>
    
    <div v-if="submissionStatus === 'error'" class="error-message">
      {{ errorMessage }}
    </div>
    
    <form v-if="submissionStatus !== 'success'" @submit.prevent="submitForm">
      <div class="form-group">
        <label for="name">Name:</label>
        <input 
          id="name" 
          v-model.trim="formData.name" 
          type="text" 
          required 
          maxlength="100"
        />
      </div>
      
      <div class="form-group">
        <label for="email">Email:</label>
        <input 
          id="email" 
          v-model.trim="formData.email" 
          type="email" 
          required 
          pattern="[^@]+@[^\.]+\..+"
        />
        <span v-if="!isValidEmail && formData.email" class="validation-error">
          Please enter a valid email address
        </span>
      </div>
      
      <div class="form-group">
        <label for="message">Message:</label>
        <textarea 
          id="message" 
          v-model.trim="formData.message" 
          required 
          maxlength="1000"
        ></textarea>
        <span class="character-count">
          {{ formData.message.length }}/1000
        </span>
      </div>
      
      <!-- Honeypot field to catch bots -->
      <div class="honeypot">
        <input 
          v-model="formData.website" 
          type="text" 
          name="website" 
          tabindex="-1"
        />
      </div>
      
      <div class="form-actions">
        <button 
          type="submit" 
          :disabled="!isValidForm || isSubmitting"
        >
          {{ isSubmitting ? 'Sending...' : 'Send Message' }}
        </button>
      </div>
    </form>
  </div>
</template>

<script>
import axios from 'axios';
import DOMPurify from 'dompurify';

export default {
  data() {
    return {
      formData: {
        name: '',
        email: '',
        message: '',
        website: '' // Honeypot field
      },
      submissionStatus: null,
      errorMessage: '',
      isSubmitting: false
    };
  },
  
  computed: {
    isValidEmail() {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return !this.formData.email || emailRegex.test(this.formData.email);
    },
    
    isValidForm() {
      return this.formData.name && 
        this.formData.email && 
        this.isValidEmail && 
        this.formData.message && 
        !this.formData.website; // Honeypot should be empty
    }
  },
  
  methods: {
    async submitForm() {
      if (!this.isValidForm) return;
      
      // Honeypot check for bots
      if (this.formData.website) {
        // Silently reject bot submissions
        this.submissionStatus = 'success';
        return;
      }
      
      this.isSubmitting = true;
      
      try {
        // Sanitize inputs before sending
        const sanitizedData = {
          name: DOMPurify.sanitize(this.formData.name),
          email: DOMPurify.sanitize(this.formData.email),
          message: DOMPurify.sanitize(this.formData.message)
        };
        
        // Send to your API with CSRF token
        await axios.post('/api/contact', sanitizedData);
        
        this.submissionStatus = 'success';
        this.resetForm();
      } catch (error) {
        this.submissionStatus = 'error';
        this.errorMessage = 'There was a problem sending your message. Please try again later.';
        console.error('Form submission error:', error);
      } finally {
        this.isSubmitting = false;
      }
    },
    
    resetForm() {
      this.formData = {
        name: '',
        email: '',
        message: '',
        website: ''
      };
    }
  }
}
</script>

<style scoped>
.honeypot {
  opacity: 0;
  position: absolute;
  top: 0;
  left: 0;
  height: 0;
  width: 0;
  z-index: -1;
}

.validation-error {
  color: red;
  font-size: 0.8em;
}

/* Additional styling omitted for brevity */
</style>
```

This contact form implements multiple security best practices:

1. Input validation (client-side with pattern attributes and computed properties)
2. Content sanitization with DOMPurify
3. Honeypot trap for bots (invisible field that only bots will fill out)
4. Error handling with user-friendly messages
5. Form state management to prevent double-submission
6. Character limits to prevent overflow attacks

## Summary

Security in Vue.js applications requires attention to multiple areas:

1. **Content security**: Avoid `v-html` with untrusted content and sanitize user inputs
2. **Authentication**: Use secure methods for storing and transmitting credentials
3. **API communication**: Validate inputs, use HTTPS, and implement CSRF protection
4. **Dependency management**: Regularly audit and update dependencies
5. **Environmental configuration**: Properly manage environment variables and secrets

By following these best practices, you can significantly reduce the security risks in your Vue.js applications and protect both your users and your application data.

## Additional Resources

- [Official Vue.js Security Documentation](https://vuejs.org/v2/guide/security.html)
- [OWASP Top Ten Web Application Security Risks](https://owasp.org/www-project-top-ten/)
- [DOMPurify Documentation](https://github.com/cure53/DOMPurify)

## Exercises

1. **Security Review**: Audit one of your existing Vue.js applications for security vulnerabilities.
2. **Secure Form Implementation**: Build a form that implements proper validation, sanitization, and CSRF protection.
3. **Authentication Flow**: Create a secure authentication system using HttpOnly cookies instead of localStorage.
4. **Dependency Audit**: Run a security audit on your dependencies and address any critical vulnerabilities.

By implementing these security practices, you'll be well on your way to building more secure Vue.js applications.