---
title: React CSS Transitions
description: Learn how to implement smooth CSS transitions in React applications to enhance user experience with animated UI elements

---

# React CSS Transitions

## Introduction

CSS transitions provide a way to control animation speed when changing CSS properties. Instead of having property changes take effect immediately, you can make the changes happen smoothly over a specified duration. This creates smooth animations that can significantly improve the user experience of your React applications.

In this tutorial, we'll explore how to implement CSS transitions in React, providing you with the knowledge to create fluid and engaging user interfaces.

## Understanding CSS Transitions

Before diving into React-specific implementations, let's review the core concepts of CSS transitions:

CSS transitions involve four main properties:

- `transition-property`: Specifies the CSS property to which the transition should be applied
- `transition-duration`: Defines how long the transition takes to complete
- `transition-timing-function`: Determines how the intermediate values are calculated
- `transition-delay`: Sets a delay before the transition starts

These can be combined using the shorthand `transition` property.

## Basic CSS Transitions in React

Let's start with a simple example of a button that changes color when hovered:

```jsx
import React, { useState } from 'react';
import './ButtonTransition.css';

function ButtonTransition() {
  return (
    <button className="transition-button">
      Hover me
    </button>
  );
}

export default ButtonTransition;
```

And the corresponding CSS:

```css
.transition-button {
  background-color: #3498db;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  
  /* Adding the transition */
  transition: background-color 0.3s ease;
}

.transition-button:hover {
  background-color: #2980b9;
}
```

In this example, when a user hovers over the button, the background color smoothly transitions from `#3498db` to `#2980b9` over 0.3 seconds with an "ease" timing function.

## Conditional Transitions with React State

React's state management can be combined with CSS transitions to trigger animations based on user interactions or application state:

```jsx
import React, { useState } from 'react';
import './ExpandCard.css';

function ExpandCard() {
  const [expanded, setExpanded] = useState(false);

  return (
    <div 
      className={`card ${expanded ? 'expanded' : ''}`}
      onClick={() => setExpanded(!expanded)}
    >
      <h3>Click to {expanded ? 'collapse' : 'expand'}</h3>
      <div className="content">
        {expanded && <p>This content appears when the card is expanded!</p>}
      </div>
    </div>
  );
}

export default ExpandCard;
```

With the CSS:

```css
.card {
  width: 300px;
  height: 100px;
  background-color: #f8f9fa;
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  cursor: pointer;
  overflow: hidden;
  
  /* Adding the transition */
  transition: height 0.3s ease-out;
}

.card.expanded {
  height: 200px;
}

.content {
  margin-top: 16px;
}
```

Here, clicking on the card toggles the `expanded` state, which adds or removes a class. The CSS transition property ensures the height change happens smoothly.

## Multiple Properties and Timing

You can transition multiple properties with different durations and timing functions:

```jsx
import React from 'react';
import './FancyButton.css';

function FancyButton() {
  return (
    <button className="fancy-button">
      Hover for multiple effects
    </button>
  );
}

export default FancyButton;
```

And the CSS:

```css
.fancy-button {
  background-color: #9b59b6;
  color: white;
  padding: 12px 24px;
  border: none;
  border-radius: 4px;
  font-size: 18px;
  cursor: pointer;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  
  /* Multiple transitions with different properties */
  transition: 
    background-color 0.3s ease,
    transform 0.2s ease-out,
    box-shadow 0.2s linear;
}

.fancy-button:hover {
  background-color: #8e44ad;
  transform: translateY(-3px);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}
```

In this example, hovering the button simultaneously animates the background color, vertical position, and shadow effect, each with its own timing configuration.

## Transitions with CSS-in-JS

If you're using CSS-in-JS libraries like Styled Components or Emotion, you can define transitions directly in your component styles:

```jsx
import React, { useState } from 'react';
import styled from 'styled-components';

// Define styled components with transitions
const ToggleContainer = styled.div`
  display: inline-block;
  width: 60px;
  height: 34px;
  border-radius: 17px;
  background-color: ${props => props.active ? '#2ecc71' : '#e74c3c'};
  position: relative;
  cursor: pointer;
  transition: background-color 0.3s ease;
`;

const ToggleButton = styled.div`
  position: absolute;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background-color: white;
  top: 4px;
  left: ${props => props.active ? '30px' : '4px'};
  transition: left 0.3s ease;
`;

function Toggle() {
  const [active, setActive] = useState(false);

  return (
    <ToggleContainer 
      active={active} 
      onClick={() => setActive(!active)}
    >
      <ToggleButton active={active} />
    </ToggleContainer>
  );
}

export default Toggle;
```

This approach keeps your transitions and styles together in the component definition, which can be easier to maintain in larger applications.

## Handling Transition Events

React provides a way to listen for CSS transition events, allowing you to perform actions when transitions complete:

```jsx
import React, { useState, useRef } from 'react';
import './TransitionEvents.css';

function TransitionEvents() {
  const [isVisible, setIsVisible] = useState(true);
  const elementRef = useRef(null);
  const [message, setMessage] = useState('');

  const toggleVisibility = () => {
    setIsVisible(!isVisible);
  };

  const handleTransitionEnd = (e) => {
    // Only update message for opacity transitions
    if (e.propertyName === 'opacity') {
      setMessage(`Transition completed! Element is now ${isVisible ? 'visible' : 'hidden'}.`);
    }
  };

  return (
    <div className="container">
      <button onClick={toggleVisibility}>
        {isVisible ? 'Hide' : 'Show'} Element
      </button>
      
      <div 
        ref={elementRef}
        className={`animated-box ${isVisible ? 'visible' : 'hidden'}`}
        onTransitionEnd={handleTransitionEnd}
      >
        Animated Content
      </div>
      
      {message && <p className="message">{message}</p>}
    </div>
  );
}

export default TransitionEvents;
```

With CSS:

```css
.animated-box {
  width: 200px;
  height: 200px;
  background-color: #3498db;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  margin: 20px 0;
  opacity: 0;
  transform: translateY(20px);
  transition: 
    opacity 0.5s ease,
    transform 0.5s ease;
}

.animated-box.visible {
  opacity: 1;
  transform: translateY(0);
}

.animated-box.hidden {
  opacity: 0;
  transform: translateY(20px);
}

.message {
  font-style: italic;
  color: #7f8c8d;
}
```

The `onTransitionEnd` event handler allows you to detect when the transition completes and take action accordingly.

## Practical Example: Animated Navigation Menu

Let's build a practical example of an animated mobile navigation menu:

```jsx
import React, { useState } from 'react';
import './MobileNav.css';

function MobileNav() {
  const [menuOpen, setMenuOpen] = useState(false);

  return (
    <div className="mobile-nav-container">
      <header className="nav-header">
        <div className="logo">My App</div>
        <button 
          className={`hamburger ${menuOpen ? 'active' : ''}`}
          onClick={() => setMenuOpen(!menuOpen)}
        >
          <span></span>
          <span></span>
          <span></span>
        </button>
      </header>

      <nav className={`navigation ${menuOpen ? 'open' : ''}`}>
        <ul>
          <li><a href="#home">Home</a></li>
          <li><a href="#about">About</a></li>
          <li><a href="#services">Services</a></li>
          <li><a href="#contact">Contact</a></li>
        </ul>
      </nav>

      <div className="content">
        <h1>Welcome to My App</h1>
        <p>Try opening the mobile menu by clicking the hamburger icon!</p>
      </div>
    </div>
  );
}

export default MobileNav;
```

With the corresponding CSS:

```css
.mobile-nav-container {
  font-family: Arial, sans-serif;
  max-width: 100%;
  overflow-x: hidden;
  position: relative;
  height: 100vh;
}

.nav-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background-color: #333;
  color: white;
}

.logo {
  font-weight: bold;
  font-size: 1.5rem;
}

.hamburger {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  width: 30px;
  height: 20px;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  z-index: 10;
}

.hamburger span {
  width: 100%;
  height: 3px;
  background-color: white;
  border-radius: 2px;
  transition: all 0.3s ease-in-out;
}

.hamburger.active span:nth-child(1) {
  transform: translateY(8.5px) rotate(45deg);
}

.hamburger.active span:nth-child(2) {
  opacity: 0;
}

.hamburger.active span:nth-child(3) {
  transform: translateY(-8.5px) rotate(-45deg);
}

.navigation {
  position: absolute;
  top: 0;
  right: 0;
  width: 70%;
  max-width: 300px;
  height: 100%;
  background-color: #333;
  transform: translateX(100%);
  transition: transform 0.3s ease-in-out;
  z-index: 5;
}

.navigation.open {
  transform: translateX(0);
  box-shadow: -5px 0 15px rgba(0, 0, 0, 0.2);
}

.navigation ul {
  padding: 70px 20px 0;
  list-style: none;
}

.navigation li {
  margin: 20px 0;
}

.navigation a {
  color: white;
  text-decoration: none;
  font-size: 1.2rem;
  transition: color 0.2s ease;
}

.navigation a:hover {
  color: #3498db;
}

.content {
  padding: 2rem;
}
```

This example demonstrates a practical mobile navigation menu with smooth transitions for:

1. The hamburger icon transforming into an X
2. The menu sliding in from the right
3. Menu links changing color on hover

## Best Practices for CSS Transitions in React

To ensure your transitions work well in React applications:

1. **Be Mindful of Component Mounting**: Elements must be in the DOM before transitions can apply. Consider using conditional rendering carefully.

2. **Use the `key` Prop Wisely**: When you want to trigger transition animations on element change, the `key` prop can force re-rendering.

3. **Consider Performance**: Too many transitions or transitions on computationally expensive properties (like `box-shadow`) can impact performance. Use sparingly for critical UI interactions.

4. **Prefer Hardware-Accelerated Properties**: Properties like `transform` and `opacity` perform better than properties like `width` or `height`.

5. **Keep Durations Short**: For UI elements, transitions between 150-300ms provide the best balance between noticeable animation and responsiveness.

```jsx
// Example of using the key prop to trigger animations
import React, { useState } from 'react';
import './NumberTransition.css';

function NumberTransition() {
  const [count, setCount] = useState(0);

  return (
    <div className="counter">
      <button onClick={() => setCount(count - 1)}>-</button>
      
      <div className="number-container">
        {/* Key prop forces re-mount when count changes */}
        <span key={count} className="animated-number">
          {count}
        </span>
      </div>
      
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

```css
.number-container {
  width: 50px;
  height: 50px;
  overflow: hidden;
  position: relative;
  margin: 0 20px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.animated-number {
  font-size: 24px;
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}
```

## Combining CSS Transitions with React Lifecycle

You can create more complex transitions by combining CSS with React component lifecycle:

```jsx
import React, { useState, useEffect } from 'react';
import './LifecycleTransition.css';

function LifecycleTransition() {
  const [items, setItems] = useState([]);
  const [isLoading, setIsLoading] = useState(false);

  // Simulate fetching data
  const fetchData = () => {
    setIsLoading(true);
    
    // Simulate API delay
    setTimeout(() => {
      const newItems = [
        { id: 1, text: 'Item 1' },
        { id: 2, text: 'Item 2' },
        { id: 3, text: 'Item 3' }
      ];
      setItems(newItems);
      setIsLoading(false);
    }, 1500);
  };

  return (
    <div className="lifecycle-container">
      <button 
        onClick={fetchData} 
        disabled={isLoading}
        className={isLoading ? 'loading' : ''}
      >
        {isLoading ? 'Loading...' : 'Load Items'}
      </button>

      <ul className="items-list">
        {items.map((item, index) => (
          <li 
            key={item.id}
            className="item"
            style={{ animationDelay: `${index * 0.1}s` }}
          >
            {item.text}
          </li>
        ))}
      </ul>
    </div>
  );
}

export default LifecycleTransition;
```

With CSS:

```css
.lifecycle-container {
  padding: 20px;
  max-width: 400px;
}

button {
  padding: 10px 20px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
}

button:hover:not(:disabled) {
  background-color: #2980b9;
}

button:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

button.loading {
  width: 120px;
}

.items-list {
  list-style: none;
  padding: 0;
  margin-top: 20px;
}

.item {
  padding: 15px;
  margin: 10px 0;
  background-color: #f8f9fa;
  border-left: 3px solid #3498db;
  border-radius: 3px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  opacity: 0;
  animation: fadeIn 0.5s ease forwards;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}
```

This example shows how to create staggered animations by applying different animation delays to list items as they're added to the DOM.

## Summary

CSS transitions provide a powerful, performance-friendly way to add smooth animations to your React applications. In this tutorial, we've covered:

- The basics of CSS transitions and how they work
- Implementing transitions in React components
- Combining transitions with state management
- Handling transition events
- Creating practical UI components with transitions
- Best practices for implementing transitions

By thoughtfully applying CSS transitions to your React components, you can create more intuitive, engaging, and polished user interfaces. Remember that subtle animations often work best - they should enhance the user experience rather than distract from it.

## Additional Resources

To deepen your understanding of CSS transitions in React:

1. Explore the MDN documentation on [CSS Transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions)
2. Check out [React Transition Group](https://reactcommunity.org/react-transition-group/) for more advanced transition control
3. Look into [Framer Motion](https://www.framer.com/motion/) for more complex animations

## Exercises

1. Create a form with input fields that highlight with a smooth transition when focused
2. Build an accordion component that smoothly expands and collapses sections
3. Implement a card flip effect using CSS transitions
4. Create a notification system where alerts slide in and fade out with transitions
5. Build a tab interface where the content area smoothly transitions between different tabs

By practicing these exercises, you'll become more comfortable using CSS transitions in your React applications and develop an intuition for when and how to apply them effectively.