---
title: React Animation Basics
description: Learn the fundamental concepts and techniques for adding animations to your React applications. This guide covers CSS transitions, keyframes, and React-specific animation approaches for beginners.

---

# React Animation Basics

## Introduction

Animation brings life to user interfaces, making them more engaging, intuitive, and visually appealing. In React applications, well-implemented animations can significantly enhance user experience by providing visual feedback, guiding attention, and creating a sense of polish and professionalism.

In this tutorial, we'll explore the fundamental concepts of adding animations to React components. You'll learn multiple approaches, starting with simple CSS-based animations and gradually moving to React-specific solutions.

## Why Add Animations to React Apps?

Animations serve several important purposes:

1. **Improved user experience** - Smooth transitions help users understand what's happening
2. **Visual feedback** - Animations confirm that actions have been registered
3. **Attention guidance** - Draw focus to important elements or changes
4. **Brand personality** - Express your application's character and style

## Starting with CSS Transitions

The simplest way to add animations to React components is using CSS transitions. These are perfect for simple state changes like hover effects or visibility toggles.

### Basic CSS Transition Example

Let's create a button that changes color smoothly when hovered:

```jsx
import React from 'react';
import './Button.css';

function AnimatedButton() {
  return (
    <button className="animated-button">
      Hover over me!
    </button>
  );
}

export default AnimatedButton;
```

And the corresponding CSS:

```css
.animated-button {
  background-color: #3498db;
  color: white;
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  /* The transition property specifies which properties to animate and how long the animation takes */
  transition: background-color 0.3s ease;
}

.animated-button:hover {
  background-color: #2980b9;
}
```

In this example, the button's background color changes from `#3498db` to `#2980b9` over 0.3 seconds with an "ease" timing function when a user hovers over it.

## CSS Animation with Keyframes

For more complex animations with multiple steps, we use CSS `@keyframes`. This allows us to define sequences of animation states.

### Pulsing Button Example

Let's create a button that pulses continuously to attract attention:

```jsx
import React from 'react';
import './PulsingButton.css';

function PulsingButton() {
  return (
    <button className="pulsing-button">
      Important Action
    </button>
  );
}

export default PulsingButton;
```

With this CSS:

```css
.pulsing-button {
  background-color: #e74c3c;
  color: white;
  padding: 12px 24px;
  border: none;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7);
  }
  
  70% {
    transform: scale(1.05);
    box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
  }
  
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(231, 76, 60, 0);
  }
}
```

This animation creates a pulsing effect by scaling the button and adding a box shadow that fades out, then repeats infinitely.

## Animating Component Mounting and Unmounting

A common animation need in React applications is animating components as they enter or leave the DOM.

### Fade-In Effect with CSS and React

```jsx
import React, { useState } from 'react';
import './Notification.css';

function Notification() {
  const [isVisible, setIsVisible] = useState(false);

  const toggleNotification = () => {
    setIsVisible(!isVisible);
  };

  return (
    <div className="notification-demo">
      <button onClick={toggleNotification}>
        {isVisible ? 'Hide' : 'Show'} Notification
      </button>
      
      {isVisible && (
        <div className="notification">
          This is an important notification message!
        </div>
      )}
    </div>
  );
}

export default Notification;
```

CSS to create the fade-in effect:

```css
.notification {
  background-color: #2ecc71;
  color: white;
  padding: 15px;
  border-radius: 4px;
  margin-top: 10px;
  animation: fadeIn 0.5s;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
```

However, there's a limitation here: when removing the notification, it disappears instantly without animation. To solve this, we need a more React-specific approach.

## Using the React Transition Group Library

React Transition Group is a popular library for managing component transitions. It provides components for defining entering and exiting transitions.

First, install the library:

```bash
npm install react-transition-group
```

Now, let's improve our notification component:

```jsx
import React, { useState } from 'react';
import { CSSTransition } from 'react-transition-group';
import './TransitionNotification.css';

function TransitionNotification() {
  const [showNotification, setShowNotification] = useState(false);

  const toggleNotification = () => {
    setShowNotification(!showNotification);
  };

  return (
    <div className="notification-demo">
      <button onClick={toggleNotification}>
        {showNotification ? 'Hide' : 'Show'} Notification
      </button>
      
      <CSSTransition
        in={showNotification}
        timeout={300}
        classNames="notification"
        unmountOnExit
      >
        <div className="notification">
          This notification animates in AND out!
        </div>
      </CSSTransition>
    </div>
  );
}

export default TransitionNotification;
```

CSS for the transitions:

```css
.notification {
  background-color: #9b59b6;
  color: white;
  padding: 15px;
  border-radius: 4px;
  margin-top: 10px;
}

.notification-enter {
  opacity: 0;
  transform: translateY(-20px);
}

.notification-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms, transform 300ms;
}

.notification-exit {
  opacity: 1;
  transform: translateY(0);
}

.notification-exit-active {
  opacity: 0;
  transform: translateY(-20px);
  transition: opacity 300ms, transform 300ms;
}
```

This approach gives us control over both enter and exit animations.

## Animating Lists with TransitionGroup

When working with lists in React, we often need to animate items as they are added or removed. The `TransitionGroup` component helps with this:

```jsx
import React, { useState } from 'react';
import { TransitionGroup, CSSTransition } from 'react-transition-group';
import './TodoList.css';

function TodoList() {
  const [items, setItems] = useState([
    { id: 1, text: 'Learn React Basics' },
    { id: 2, text: 'Master React Hooks' }
  ]);
  const [inputText, setInputText] = useState('');
  const [nextId, setNextId] = useState(3);

  const addItem = () => {
    if (inputText.trim() !== '') {
      setItems([...items, { id: nextId, text: inputText }]);
      setNextId(nextId + 1);
      setInputText('');
    }
  };

  const removeItem = (id) => {
    setItems(items.filter(item => item.id !== id));
  };

  return (
    <div className="todo-list">
      <h2>Animated Todo List</h2>
      
      <div className="add-item">
        <input
          type="text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          placeholder="Add a new task"
        />
        <button onClick={addItem}>Add</button>
      </div>
      
      <TransitionGroup className="items-list">
        {items.map(item => (
          <CSSTransition
            key={item.id}
            timeout={500}
            classNames="item"
          >
            <div className="todo-item">
              <span>{item.text}</span>
              <button onClick={() => removeItem(item.id)}>Remove</button>
            </div>
          </CSSTransition>
        ))}
      </TransitionGroup>
    </div>
  );
}

export default TodoList;
```

CSS for the list animations:

```css
.todo-list {
  max-width: 500px;
  margin: 0 auto;
}

.add-item {
  display: flex;
  margin-bottom: 20px;
}

.add-item input {
  flex-grow: 1;
  padding: 8px;
  font-size: 16px;
  border: 1px solid #ccc;
  border-radius: 4px 0 0 4px;
}

.add-item button {
  padding: 8px 16px;
  background-color: #2ecc71;
  color: white;
  border: none;
  border-radius: 0 4px 4px 0;
  cursor: pointer;
}

.todo-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  background-color: #f9f9f9;
  border-radius: 4px;
  margin-bottom: 10px;
}

.todo-item button {
  background-color: #e74c3c;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
}

/* Animation classes */
.item-enter {
  opacity: 0;
  transform: translateX(-30px);
}

.item-enter-active {
  opacity: 1;
  transform: translateX(0);
  transition: opacity 500ms, transform 500ms;
}

.item-exit {
  opacity: 1;
}

.item-exit-active {
  opacity: 0;
  transform: translateX(30px);
  transition: opacity 500ms, transform 500ms;
}
```

This creates a visually engaging todo list where items slide in from the left when added and slide out to the right when removed.

## Using State to Trigger Animations

Sometimes you need to animate based on data or application state changes. Let's create a component that animates when its data changes:

```jsx
import React, { useState, useEffect } from 'react';
import './StockTicker.css';

function StockTicker() {
  const [price, setPrice] = useState(100);
  const [isIncreasing, setIsIncreasing] = useState(null);
  
  useEffect(() => {
    // Simulate price changes every 2 seconds
    const interval = setInterval(() => {
      const change = Math.random() > 0.5 ? 1 : -1;
      const amount = Math.random() * 5;
      
      setPrice(prevPrice => {
        const newPrice = prevPrice + change * amount;
        setIsIncreasing(change > 0);
        return parseFloat(newPrice.toFixed(2));
      });
    }, 2000);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div className="stock-ticker">
      <h3>ACME Corp Stock</h3>
      <div className={`price ${isIncreasing === true ? 'increasing' : isIncreasing === false ? 'decreasing' : ''}`}>
        ${price}
      </div>
    </div>
  );
}

export default StockTicker;
```

CSS for the animation:

```css
.stock-ticker {
  text-align: center;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
  width: 200px;
  margin: 0 auto;
}

.price {
  font-size: 24px;
  font-weight: bold;
  transition: transform 0.3s, color 0.3s;
}

.increasing {
  color: #2ecc71;
  transform: scale(1.1);
}

.decreasing {
  color: #e74c3c;
  transform: scale(0.9);
}
```

This example creates a stock ticker that visually indicates price changes with color and scaling animations.

## Animation Best Practices

When implementing animations in React, keep these best practices in mind:

1. **Keep animations subtle** - Avoid excessive or distracting animations
2. **Consider performance** - Animate CSS properties that don't trigger layout recalculations (prefer `opacity` and `transform`)
3. **Add purpose** - Only use animations that enhance user experience
4. **Respect user preferences** - Consider users who prefer reduced motion (using `prefers-reduced-motion` media query)
5. **Maintain accessibility** - Ensure your animations don't create accessibility issues

### Respecting User Motion Preferences

Some users may experience discomfort or health issues with animations. Add support for the `prefers-reduced-motion` media query:

```css
@media (prefers-reduced-motion: reduce) {
  .animated-button,
  .notification-enter-active,
  .notification-exit-active,
  .item-enter-active,
  .item-exit-active,
  .price {
    /* Disable transitions and animations for users who prefer reduced motion */
    transition: none !important;
    animation: none !important;
    transform: none !important;
  }
}
```

## Summary

In this tutorial, we've explored the basics of React animations:

1. **CSS transitions** for simple state changes
2. **CSS keyframes** for complex multi-step animations 
3. **React Transition Group** for component mounting/unmounting animations
4. **TransitionGroup** for list animations
5. **State-based animations** for data-driven visual feedback
6. **Accessibility considerations** for animations

By mastering these fundamental techniques, you can create more engaging and intuitive user interfaces. Remember that animations should enhance rather than distract from the user experience.

## Further Learning and Resources

To continue developing your React animation skills, explore these topics:

1. **React Spring** - A physics-based animation library
2. **Framer Motion** - A powerful React animation library with a simple API
3. **GSAP (GreenSock Animation Platform)** - Advanced animation capabilities
4. **Lottie** - Adding complex pre-created animations to React

## Practice Exercises

1. Create a dropdown menu with smooth opening and closing animations
2. Build an image carousel with slide transitions
3. Implement a loading spinner that animates while data is being fetched
4. Create a form that shakes when validation fails
5. Design a navigation menu where the active link indicator smoothly transitions between items

Master these concepts, and you'll be well on your way to creating delightful, animated React applications!