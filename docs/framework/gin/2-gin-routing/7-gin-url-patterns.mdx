---
title: Gin URL Patterns
description: Learn how to define and use URL patterns in the Gin web framework to create dynamic and flexible routes for your Go web applications.

---

# Gin URL Patterns

## Introduction

When building web applications with Go's Gin framework, understanding URL patterns is crucial for creating clean, organized, and flexible routing systems. URL patterns define how your application responds to different endpoints and how it captures dynamic data from URLs.

In this guide, we'll explore the various URL pattern options available in Gin, from simple static routes to complex patterns with multiple parameters. By the end of this tutorial, you'll be able to create expressive and maintainable route definitions for your web applications.

## Basic Route Patterns

Let's start with the simplest form of routes in Gin - static routes.

### Static Routes

Static routes match exact URL paths without any variable parts.

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    router := gin.Default()

    // Static route
    router.GET("/hello", func(c *gin.Context) {
        c.String(http.StatusOK, "Hello World!")
    })

    router.Run(":8080")
}
```

When you run this code and navigate to `http://localhost:8080/hello`, you'll see "Hello World!" displayed in your browser. The route `/hello` is static because it matches only that exact path.

## Parameter-Based URL Patterns

### Path Parameters

One of Gin's most powerful features is the ability to extract values from the URL path. Parameters are defined using a colon (`:`) followed by the parameter name.

```go
router.GET("/user/:name", func(c *gin.Context) {
    name := c.Param("name")
    c.String(http.StatusOK, "Hello %s!", name)
})
```

When you access a URL like `http://localhost:8080/user/john`, the output will be "Hello john!". The `:name` segment captures whatever value is in that position of the URL.

### Multiple Parameters

You can define routes with multiple parameters:

```go
router.GET("/users/:userID/posts/:postID", func(c *gin.Context) {
    userID := c.Param("userID")
    postID := c.Param("postID")
    c.JSON(http.StatusOK, gin.H{
        "userID": userID,
        "postID": postID,
    })
})
```

For a request to `/users/123/posts/456`, Gin will respond with:

```json
{
  "userID": "123",
  "postID": "456"
}
```

### Wildcard Parameters

Gin also supports wildcard parameters using an asterisk (`*`), which can match any number of path segments:

```go
router.GET("/files/*filepath", func(c *gin.Context) {
    filepath := c.Param("filepath")
    c.String(http.StatusOK, "Accessing file: %s", filepath)
})
```

When accessing `/files/documents/report.pdf`, the output will be "Accessing file: /documents/report.pdf" (note the leading slash in the captured value).

## Query Parameters

While not strictly part of URL patterns, query parameters are often used alongside routes for filtering and options:

```go
router.GET("/products", func(c *gin.Context) {
    category := c.DefaultQuery("category", "all")
    sort := c.DefaultQuery("sort", "newest")
    
    c.JSON(http.StatusOK, gin.H{
        "category": category,
        "sort": sort,
        "message": "Fetching products",
    })
})
```

For a request to `/products?category=electronics&sort=price`, this would return:

```json
{
  "category": "electronics",
  "sort": "price",
  "message": "Fetching products"
}
```

The `DefaultQuery` method takes a default value as the second parameter, which is used if the query parameter isn't present in the request.

## Route Groups

For organizing related routes, Gin provides route groups. This becomes especially useful when applying middleware to a subset of routes or when working with versioned APIs:

```go
func main() {
    router := gin.Default()

    // Simple group: v1
    v1 := router.Group("/v1")
    {
        v1.GET("/users", getV1Users)
        v1.GET("/products", getV1Products)
    }

    // Simple group: v2
    v2 := router.Group("/v2")
    {
        v2.GET("/users", getV2Users)
        v2.GET("/products", getV2Products)
    }

    router.Run(":8080")
}

func getV1Users(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"version": "v1", "resource": "users"})
}

func getV1Products(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"version": "v1", "resource": "products"})
}

func getV2Users(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"version": "v2", "resource": "users"})
}

func getV2Products(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"version": "v2", "resource": "products"})
}
```

This creates routes `/v1/users`, `/v1/products`, `/v2/users`, and `/v2/products`.

## Real-World Example: RESTful API

Let's put everything together in a more comprehensive example. Consider a simple blog API with the following endpoints:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "strconv"
)

type Post struct {
    ID      int    `json:"id"`
    Title   string `json:"title"`
    Content string `json:"content"`
    Author  string `json:"author"`
}

var posts = []Post{
    {ID: 1, Title: "Hello Gin", Content: "Welcome to Gin framework", Author: "Jane"},
    {ID: 2, Title: "URL Patterns", Content: "All about Gin routing", Author: "John"},
}

func main() {
    router := gin.Default()

    // API group
    api := router.Group("/api")
    {
        // Get all posts
        api.GET("/posts", func(c *gin.Context) {
            // Filter by author (query parameter)
            author := c.Query("author")
            if author == "" {
                c.JSON(http.StatusOK, posts)
                return
            }

            var filteredPosts []Post
            for _, post := range posts {
                if post.Author == author {
                    filteredPosts = append(filteredPosts, post)
                }
            }
            c.JSON(http.StatusOK, filteredPosts)
        })

        // Get single post by ID
        api.GET("/posts/:id", func(c *gin.Context) {
            idParam := c.Param("id")
            id, err := strconv.Atoi(idParam)
            if err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
                return
            }

            for _, post := range posts {
                if post.ID == id {
                    c.JSON(http.StatusOK, post)
                    return
                }
            }

            c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
        })

        // Get all posts by an author
        api.GET("/authors/:name/posts", func(c *gin.Context) {
            authorName := c.Param("name")
            var authorPosts []Post
            
            for _, post := range posts {
                if post.Author == authorName {
                    authorPosts = append(authorPosts, post)
                }
            }
            
            c.JSON(http.StatusOK, authorPosts)
        })
    }

    router.Run(":8080")
}
```

This example demonstrates:
- Static routes (like `/api/posts`)
- Path parameters (like `/api/posts/:id` and `/api/authors/:name/posts`)
- Query parameters (filtering posts by author using `?author=Jane`)
- Route groups (grouping all API routes under `/api`)

## Advanced URL Pattern Tips

### Parameter Validation

While Gin doesn't provide built-in path parameter validation, you can validate parameters manually:

```go
router.GET("/users/:id", func(c *gin.Context) {
    id := c.Param("id")
    
    // Check if ID is numeric
    _, err := strconv.Atoi(id)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "User ID must be a number",
        })
        return
    }
    
    // Continue with valid ID...
    c.String(http.StatusOK, "User ID: %s", id)
})
```

### Case-Sensitive Routing

By default, Gin's routes are case-sensitive. This means `/users` and `/Users` are treated as different routes. Keep this in mind when designing your API.

### Trailing Slash Behavior

Gin treats paths with and without trailing slashes as distinct routes. For example, `/users` and `/users/` are different routes. If you want them to be treated the same, you need to define both or handle redirects.

```go
// Both routes need to be defined separately
router.GET("/users", handleUsers)
router.GET("/users/", handleUsers)
```

## Summary

In this guide, we've covered the essentials of Gin URL patterns:

- **Static Routes**: Simple, exact path matching
- **Path Parameters**: Dynamic segments using `:param` syntax
- **Wildcard Parameters**: Matching multiple segments with `*param`
- **Query Parameters**: Additional data passed via the URL query string
- **Route Groups**: Organizing related routes under a common prefix
- **Advanced Patterns and Considerations**: Parameter validation, case sensitivity, and trailing slash behavior

Understanding these patterns allows you to create clean, structured, and flexible routing systems in your Gin-based web applications.

## Additional Resources and Exercises

### Resources
- [Gin Framework Documentation](https://gin-gonic.com/docs/)
- [Gin GitHub Repository](https://github.com/gin-gonic/gin)

### Exercises

1. **Basic URL Pattern Practice**: Create a simple API with routes for managing a to-do list. Include routes to list all items, show a single item, add an item, update an item, and delete an item.

2. **Parameter Challenge**: Design an API for a library system where books can be categorized by genre, author, and publication year. Use both path parameters and query parameters.

3. **Route Grouping Exercise**: Create an API with versioning (v1, v2) and different authentication requirements for different routes.

4. **Wildcard Exercise**: Implement a simple file server that uses wildcard parameters to serve files from a specific directory.

By mastering Gin's URL patterns, you'll be able to build robust, maintainable web applications with clean and intuitive routing structures.