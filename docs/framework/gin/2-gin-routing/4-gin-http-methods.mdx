---
title: "Gin HTTP Methods"
description: "Learn how to use different HTTP methods in Gin framework to create RESTful APIs, handle various request types, and implement CRUD operations in your Go web applications."

---

# Gin HTTP Methods

In web development, HTTP methods form the foundation of communication between clients and servers. Understanding how to handle these methods in the Gin framework is essential for building robust and RESTful web applications in Go. This guide will walk you through the various HTTP methods available in Gin and how to implement them effectively.

## Introduction to HTTP Methods

HTTP methods (also known as HTTP verbs) define the type of action to be performed on a resource. When creating web applications or APIs with Gin, you'll frequently work with these methods to handle different types of client requests.

The most common HTTP methods you'll use in Gin applications include:

- **GET**: Retrieve data from the server
- **POST**: Create a new resource on the server
- **PUT**: Update an existing resource completely
- **PATCH**: Update an existing resource partially
- **DELETE**: Remove a resource from the server

Gin provides intuitive functions for handling each of these methods in your route definitions, making it easy to build RESTful APIs.

## Basic HTTP Method Handlers in Gin

Let's start by setting up a simple Gin application that demonstrates how to define routes for different HTTP methods.

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    // Initialize a Gin router with default middleware
    router := gin.Default()

    // GET request handler
    router.GET("/books", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "GET request to /books",
            "books": []string{"The Go Programming Language", "Web Development with Go"},
        })
    })

    // POST request handler
    router.POST("/books", func(c *gin.Context) {
        c.JSON(http.StatusCreated, gin.H{
            "message": "POST request to /books - Book created",
        })
    })

    // Run the server on port 8080
    router.Run(":8080")
}
```

In this example, we've defined two routes:
1. A `GET` route to `/books` that returns a list of books
2. A `POST` route to `/books` to handle the creation of a new book

## Handling Parameters and Request Bodies

### Path Parameters

Path parameters allow you to capture values from the URL path itself:

```go
// GET request with path parameter
router.GET("/books/:id", func(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{
        "message": "Getting book details",
        "book_id": id,
    })
})
```

With this route, a request to `/books/123` would extract `123` as the `id` parameter.

### Query Parameters

Query parameters are passed through the URL after a question mark:

```go
// GET request with query parameters
router.GET("/books", func(c *gin.Context) {
    // Access query parameters like /books?genre=fiction&author=tolkien
    genre := c.DefaultQuery("genre", "all") // with default value
    author := c.Query("author")             // without default value
    
    c.JSON(http.StatusOK, gin.H{
        "message": "Filtered books list",
        "genre": genre,
        "author": author,
    })
})
```

### Request Bodies

For POST, PUT, and PATCH methods, you typically need to handle request bodies:

```go
// Book represents book data
type Book struct {
    Title  string `json:"title" binding:"required"`
    Author string `json:"author" binding:"required"`
    ISBN   string `json:"isbn"`
}

// POST request with JSON body
router.POST("/books", func(c *gin.Context) {
    var newBook Book
    
    // Bind JSON to struct and validate
    if err := c.ShouldBindJSON(&newBook); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Process the book...
    
    c.JSON(http.StatusCreated, gin.H{
        "message": "Book created successfully",
        "book": newBook,
    })
})
```

## Implementing CRUD Operations with HTTP Methods

Creating a complete CRUD (Create, Read, Update, Delete) API is a common use case. Here's how you could implement it:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "strconv"
)

type Book struct {
    ID     int    `json:"id"`
    Title  string `json:"title" binding:"required"`
    Author string `json:"author" binding:"required"`
}

func main() {
    router := gin.Default()
    
    // In-memory database for demonstration
    books := []Book{
        {ID: 1, Title: "The Go Programming Language", Author: "Alan Donovan & Brian Kernighan"},
        {ID: 2, Title: "Web Development with Go", Author: "Shiju Varghese"},
    }
    
    // GET all books
    router.GET("/books", func(c *gin.Context) {
        c.JSON(http.StatusOK, books)
    })
    
    // GET a specific book
    router.GET("/books/:id", func(c *gin.Context) {
        idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
            return
        }
        
        for _, book := range books {
            if book.ID == id {
                c.JSON(http.StatusOK, book)
                return
            }
        }
        
        c.JSON(http.StatusNotFound, gin.H{"error": "Book not found"})
    })
    
    // POST a new book
    router.POST("/books", func(c *gin.Context) {
        var newBook Book
        
        if err := c.ShouldBindJSON(&newBook); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // Simple ID generation for demo
        newBook.ID = len(books) + 1
        books = append(books, newBook)
        
        c.JSON(http.StatusCreated, newBook)
    })
    
    // PUT to update a book
    router.PUT("/books/:id", func(c *gin.Context) {
        idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
            return
        }
        
        var updatedBook Book
        if err := c.ShouldBindJSON(&updatedBook); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        for i, book := range books {
            if book.ID == id {
                updatedBook.ID = id
                books[i] = updatedBook
                c.JSON(http.StatusOK, updatedBook)
                return
            }
        }
        
        c.JSON(http.StatusNotFound, gin.H{"error": "Book not found"})
    })
    
    // DELETE a book
    router.DELETE("/books/:id", func(c *gin.Context) {
        idParam := c.Param("id")
        id, err := strconv.Atoi(idParam)
        
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
            return
        }
        
        for i, book := range books {
            if book.ID == id {
                books = append(books[:i], books[i+1:]...)
                c.JSON(http.StatusOK, gin.H{"message": "Book deleted"})
                return
            }
        }
        
        c.JSON(http.StatusNotFound, gin.H{"error": "Book not found"})
    })
    
    router.Run(":8080")
}
```

This example demonstrates a complete RESTful API for managing books with all CRUD operations:
- **C**reate: POST `/books`
- **R**ead: GET `/books` and GET `/books/:id`
- **U**pdate: PUT `/books/:id`
- **D**elete: DELETE `/books/:id`

## Other HTTP Methods in Gin

Gin supports all standard HTTP methods:

```go
// PATCH request - partial update
router.PATCH("/books/:id", func(c *gin.Context) {
    // Handle partial update logic
    // ...
})

// HEAD request
router.HEAD("/books", func(c *gin.Context) {
    c.Status(http.StatusOK)
})

// OPTIONS request
router.OPTIONS("/books", func(c *gin.Context) {
    c.Header("Allow", "GET, POST, PUT, DELETE, PATCH")
    c.Status(http.StatusOK)
})
```

## Method Not Allowed Responses

When a client attempts to use an HTTP method that isn't supported for a particular resource, it's good practice to return a proper "Method Not Allowed" response with status code 405.

The Gin router handles this automatically for routes you've defined, but you can also specify custom behavior:

```go
router.NoMethod(func(c *gin.Context) {
    c.JSON(http.StatusMethodNotAllowed, gin.H{
        "message": "Method not allowed",
        "allowed_methods": "GET, POST, PUT, DELETE",
    })
})
```

## Practical Example: A RESTful API with Different Content Types

Let's create an example that handles different content types:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

type User struct {
    Name  string `json:"name" xml:"name" form:"name" binding:"required"`
    Email string `json:"email" xml:"email" form:"email" binding:"required"`
}

func main() {
    router := gin.Default()
    
    // Handle different content types for user creation
    router.POST("/users", func(c *gin.Context) {
        var user User
        
        // Check Content-Type and bind accordingly
        contentType := c.ContentType()
        
        switch contentType {
        case "application/json":
            if err := c.ShouldBindJSON(&user); err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
            }
        case "application/xml":
            if err := c.ShouldBindXML(&user); err != nil {
                c.XML(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
            }
        case "application/x-www-form-urlencoded":
            if err := c.ShouldBind(&user); err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
            }
        default:
            c.JSON(http.StatusUnsupportedMediaType, gin.H{"error": "Unsupported media type"})
            return
        }
        
        // Respond with the same format as the request
        switch contentType {
        case "application/json":
            c.JSON(http.StatusCreated, gin.H{
                "status": "User created",
                "user": user,
            })
        case "application/xml":
            c.XML(http.StatusCreated, gin.H{
                "status": "User created",
                "user": user,
            })
        default:
            c.JSON(http.StatusCreated, gin.H{
                "status": "User created",
                "user": user,
            })
        }
    })
    
    router.Run(":8080")
}
```

This example demonstrates how to handle different content types in a POST request, binding the data appropriately and responding in the same format.

## Working with HTTP Method Groups

For larger applications, you can group routes to make your code more organized:

```go
func main() {
    router := gin.Default()
    
    // Group for API version 1
    v1 := router.Group("/api/v1")
    {
        books := v1.Group("/books")
        {
            books.GET("", getBooks)          // GET /api/v1/books
            books.GET("/:id", getBook)       // GET /api/v1/books/:id
            books.POST("", createBook)       // POST /api/v1/books
            books.PUT("/:id", updateBook)    // PUT /api/v1/books/:id
            books.DELETE("/:id", deleteBook) // DELETE /api/v1/books/:id
        }
        
        users := v1.Group("/users")
        {
            users.GET("", getUsers)          // GET /api/v1/users
            // More user routes...
        }
    }
    
    router.Run(":8080")
}

// Separate handler functions
func getBooks(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"message": "Get all books"})
}

func getBook(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"message": "Get book", "id": id})
}

func createBook(c *gin.Context) {
    c.JSON(http.StatusCreated, gin.H{"message": "Book created"})
}

func updateBook(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"message": "Book updated", "id": id})
}

func deleteBook(c *gin.Context) {
    id := c.Param("id")
    c.JSON(http.StatusOK, gin.H{"message": "Book deleted", "id": id})
}

func getUsers(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"message": "Get all users"})
}
```

This approach helps organize your code better, especially for larger APIs with many endpoints.

## Summary

In this guide, we've explored how to use HTTP methods in the Gin framework to build RESTful APIs:

- **GET** for retrieving data
- **POST** for creating new resources
- **PUT** for complete updates
- **PATCH** for partial updates
- **DELETE** for removing resources

We've also covered:
- Handling URL parameters and query strings
- Processing request bodies in different formats
- Implementing complete CRUD operations
- Organizing routes using route groups
- Handling different content types

By understanding these HTTP methods and how to implement them in Gin, you're well-equipped to build robust web applications and APIs in Go.

## Additional Resources and Exercises

### Resources
1. [Official Gin Documentation](https://gin-gonic.com/docs/)
2. [RESTful API Design Best Practices](https://restfulapi.net/)
3. [MDN HTTP Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)

### Exercises

1. **Basic Exercise**: Create a simple API for a "task" resource with the following endpoints:
   - GET /tasks - List all tasks
   - GET /tasks/:id - Get a specific task
   - POST /tasks - Create a new task
   - PUT /tasks/:id - Update a task
   - DELETE /tasks/:id - Delete a task

2. **Intermediate Exercise**: Extend the task API to include:
   - Query parameters for filtering tasks (e.g., by status, priority)
   - Pagination support with query parameters
   - Validation for task data

3. **Advanced Exercise**: Build a complete API with multiple resources (e.g., users, tasks, categories) that have relationships between them, implementing proper RESTful principles and HTTP status codes.

Remember that practice is key to mastering these concepts. Try building different types of APIs to solidify your understanding of HTTP methods in Gin.