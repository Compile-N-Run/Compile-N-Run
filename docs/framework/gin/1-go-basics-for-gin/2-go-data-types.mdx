---
title: Go Data Types
description: Learn about the fundamental data types in Go programming language, including basic types, composite types, and how to work with them in the context of Gin web framework development.

---

# Go Data Types

Go is a statically typed language, which means you need to define the type of each variable when you declare it. Understanding Go's data types is essential for writing effective Gin applications, as they form the foundation of how you'll process requests, handle data, and return responses.

## Introduction to Go Data Types

In Go, data types specify the kind of value a variable can hold. Having a strong grasp of these types will help you write more efficient and error-free code, especially when developing web applications with Gin.

Go's type system can be categorized into four main groups:

1. Basic types (numbers, strings, and booleans)
2. Aggregate types (arrays and structs)
3. Reference types (pointers, slices, maps, channels, and functions)
4. Interface types

Let's explore each of these in detail.

## Basic Types

### Numeric Types

Go offers several numeric types to handle different kinds of numbers:

#### Integer Types

```go
var age int = 30            // Platform-dependent size (32 or 64 bit)
var small int8 = 127        // 8-bit signed integer (-128 to 127)
var medium int16 = 32767    // 16-bit signed integer
var large int32 = 2147483647 // 32-bit signed integer
var huge int64 = 9223372036854775807 // 64-bit signed integer

// Unsigned integers (only positive values)
var count uint = 30         // Platform-dependent size
var byte_val uint8 = 255    // 8-bit unsigned (0 to 255)
var umedium uint16 = 65535  // 16-bit unsigned
```

#### Floating Point Types

```go
var pi float32 = 3.14159        // 32-bit floating point
var avogadro float64 = 6.022e23 // 64-bit floating point (default for float literals)
```

#### Complex Numbers

```go
var complex_1 complex64 = 1 + 2i  // Complex number with float32 parts
var complex_2 complex128 = 3 + 4i // Complex number with float64 parts
```

### Boolean Type

```go
var isActive bool = true
var isEnabled bool = false
```

Boolean values in Go are represented by the keywords `true` and `false`. They're commonly used in conditionals and for control flow.

### String Type

```go
var greeting string = "Hello, Gin framework!"
var multiLine string = `This string
spans multiple
lines`
```

Strings in Go are immutable sequences of bytes. Go strings are encoded in UTF-8 by default, which makes handling international characters straightforward.

Example displaying different types:

```go
package main

import "fmt"

func main() {
    // Numeric types
    intVal := 42
    floatVal := 3.14

    // String
    strVal := "Go is awesome"

    // Boolean
    boolVal := true

    fmt.Printf("Integer: %d, Type: %T\n", intVal, intVal)
    fmt.Printf("Float: %.2f, Type: %T\n", floatVal, floatVal)
    fmt.Printf("String: %s, Type: %T\n", strVal, strVal)
    fmt.Printf("Boolean: %t, Type: %T\n", boolVal, boolVal)
}
```

Output:
```
Integer: 42, Type: int
Float: 3.14, Type: float64
String: Go is awesome, Type: string
Boolean: true, Type: bool
```

## Composite Types

### Arrays

Arrays in Go have a fixed size defined at compile time:

```go
var fruits [3]string = [3]string{"apple", "orange", "banana"}

// Shorthand declaration
numbers := [5]int{1, 2, 3, 4, 5}

// Using ... to let the compiler determine the size
colors := [...]string{"red", "green", "blue"}
```

### Slices

Slices are more flexible than arrays and are used more commonly in Go:

```go
// Creating a slice
var names []string = []string{"John", "Jane", "Bob"}

// Shorthand
scores := []int{98, 93, 77, 82, 83}

// Using make for zero-value initialization
users := make([]string, 5)      // Creates a slice of 5 empty strings
buffer := make([]byte, 0, 1024) // Creates a slice with 0 elements and capacity of 1024
```

Working with slices:

```go
package main

import "fmt"

func main() {
    // Initialize a slice
    numbers := []int{1, 2, 3, 4, 5}
    
    // Append elements
    numbers = append(numbers, 6, 7)
    
    // Slice operations (from index 2 up to but not including index 5)
    subSlice := numbers[2:5]
    
    fmt.Println("Original slice:", numbers)
    fmt.Println("Sub-slice:", subSlice)
    
    // Modifying the sub-slice affects the original slice
    subSlice[0] = 30
    fmt.Println("After modification:")
    fmt.Println("Original slice:", numbers)
    fmt.Println("Sub-slice:", subSlice)
}
```

Output:
```
Original slice: [1 2 3 4 5 6 7]
Sub-slice: [3 4 5]
After modification:
Original slice: [1 2 30 4 5 6 7]
Sub-slice: [30 4 5]
```

### Maps

Maps are Go's implementation of hash tables or dictionaries:

```go
// Declaration and initialization
var userAges map[string]int = map[string]int{
    "Alice": 25,
    "Bob":   30,
    "Carol": 27,
}

// Shorthand
httpCodes := map[int]string{
    200: "OK",
    404: "Not Found",
    500: "Internal Server Error",
}

// Using make
config := make(map[string]interface{})
```

Working with maps:

```go
package main

import "fmt"

func main() {
    // Create a map of user roles
    userRoles := map[string]string{
        "alice": "admin",
        "bob":   "user",
        "carol": "moderator",
    }
    
    // Accessing values
    fmt.Println("Bob's role:", userRoles["bob"])
    
    // Adding a new key-value pair
    userRoles["dave"] = "guest"
    
    // Checking if a key exists
    role, exists := userRoles["eve"]
    if exists {
        fmt.Println("Eve's role:", role)
    } else {
        fmt.Println("Eve is not in the system")
    }
    
    // Deleting a key-value pair
    delete(userRoles, "alice")
    
    // Iterating over a map
    fmt.Println("\nUser roles:")
    for user, role := range userRoles {
        fmt.Printf("%s: %s\n", user, role)
    }
}
```

Output:
```
Bob's role: user
Eve is not in the system

User roles:
bob: user
carol: moderator
dave: guest
```

### Structs

Structs are composite types that group together variables of different types:

```go
// Defining a struct
type User struct {
    ID        int
    Username  string
    Email     string
    Active    bool
    CreatedAt time.Time
}

// Creating a struct instance
user1 := User{
    ID:        1,
    Username:  "johndoe",
    Email:     "john@example.com",
    Active:    true,
    CreatedAt: time.Now(),
}

// Accessing fields
fmt.Println("Username:", user1.Username)

// Nested structs
type Address struct {
    Street  string
    City    string
    Country string
    Zipcode string
}

type Customer struct {
    Name    string
    Age     int
    Address Address
}
```

## Reference Types

### Pointers

Pointers store the memory address of another variable:

```go
var x int = 10
var p *int = &x  // p points to x

fmt.Println("Value of x:", x)     // 10
fmt.Println("Address of x:", &x)  // Memory address like 0xc000014088
fmt.Println("Value of p:", p)     // Same memory address
fmt.Println("Value at p:", *p)    // 10 (dereferencing)

// Modifying the value through the pointer
*p = 20
fmt.Println("New value of x:", x) // 20
```

### Functions

Functions in Go are first-class citizens, meaning they can be assigned to variables and passed as parameters:

```go
// Function definition
func add(a, b int) int {
    return a + b
}

// Function type as a variable
var mathOperation func(int, int) int = add

// Using the function variable
result := mathOperation(5, 3) // 8
```

## Type Conversion

Go requires explicit type conversion between different types:

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// String conversion
str := "100"
num, err := strconv.Atoi(str) // string to int
if err != nil {
    fmt.Println("Conversion error:", err)
} else {
    fmt.Println("Converted number:", num)
}

// Int to string
count := 200
countStr := strconv.Itoa(count)
fmt.Println("Count as string:", countStr)
```

## Practical Examples with Gin

Let's see how different data types are used in a typical Gin web application:

### Handling Form Data

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "strconv"
)

// User struct to represent user data
type User struct {
    Name     string `json:"name" form:"name"`
    Email    string `json:"email" form:"email"`
    Age      int    `json:"age" form:"age"`
    IsActive bool   `json:"is_active" form:"is_active"`
}

func main() {
    router := gin.Default()
    
    router.POST("/register", func(c *gin.Context) {
        var user User
        
        // Bind form data to the user struct
        if err := c.ShouldBind(&user); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": err.Error(),
            })
            return
        }
        
        // Use the data types
        user.Name = user.Name + " (registered)"
        user.Age = user.Age + 1
        
        c.JSON(http.StatusOK, gin.H{
            "message": "Registration successful",
            "user":    user,
        })
    })
    
    router.Run(":8080")
}
```

### Working with Query Parameters

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "strconv"
)

func main() {
    router := gin.Default()
    
    router.GET("/products", func(c *gin.Context) {
        // Get query parameters with different types
        query := c.DefaultQuery("q", "")
        
        // String to int conversion
        page, err := strconv.Atoi(c.DefaultQuery("page", "1"))
        if err != nil {
            page = 1
        }
        
        limit, err := strconv.Atoi(c.DefaultQuery("limit", "10"))
        if err != nil {
            limit = 10
        }
        
        // Parse boolean
        inStock := c.DefaultQuery("in_stock", "false")
        isInStock := inStock == "true"
        
        // Using the parsed data
        c.JSON(http.StatusOK, gin.H{
            "query":     query,
            "page":      page,
            "limit":     limit,
            "in_stock":  isInStock,
            "result":    "Product list would go here",
        })
    })
    
    router.Run(":8080")
}
```

### Using Maps for Dynamic JSON Responses

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    router := gin.Default()
    
    router.GET("/api/dashboard", func(c *gin.Context) {
        // Using maps for dynamic response structure
        stats := map[string]interface{}{
            "users_count": 1250,
            "active_users_percentage": 67.8,
            "top_countries": []string{"USA", "India", "Germany", "Brazil"},
            "growth": map[string]float64{
                "weekly": 2.4,
                "monthly": 8.7,
                "yearly": 23.5,
            },
            "is_growing": true,
        }
        
        c.JSON(http.StatusOK, stats)
    })
    
    router.Run(":8080")
}
```

## Zero Values

In Go, variables that are declared but not assigned a value are given a "zero value" depending on their type:

| Type Category | Zero Value |
|--------------|------------|
| Numeric types | `0` |
| Boolean | `false` |
| Strings | `""` (empty string) |
| Pointers | `nil` |
| Functions | `nil` |
| Interfaces | `nil` |
| Slices | `nil` |
| Channels | `nil` |
| Maps | `nil` |
| Structs | Each field has its zero value |

Understanding zero values helps prevent nil pointer exceptions and unexpected behavior in your Go applications.

## Summary

In this lesson, we've covered Go's type system in depth, including:

- Basic types: integers, floats, booleans, and strings
- Composite types: arrays, slices, maps, and structs
- Reference types: pointers and functions
- Type conversion and zero values
- Practical applications of these types in Gin web development

Understanding these data types is crucial for building robust Gin web applications. Types influence how you structure your code, handle data, and ensure your program behaves correctly.

## Exercises

1. Create a Gin API endpoint that receives a JSON object with various data types (string, int, bool, array, nested objects) and returns it with some modifications.

2. Implement a form validation function that checks if required fields are provided and have the correct data types.

3. Create a struct that represents a product in an e-commerce store with appropriate fields and data types. Then create a Gin handler that manages product operations (create, read, update).

4. Implement a map-based in-memory cache that stores different types of values using empty interfaces and type assertions to retrieve them.

## Additional Resources

- [Go Language Specification: Types](https://golang.org/ref/spec#Types)
- [Effective Go: Data](https://golang.org/doc/effective_go#data)
- [Go Tour: Basic Types](https://tour.golang.org/basics/11)
- [Gin Framework Documentation](https://gin-gonic.com/docs/)

Learning to work effectively with Go's type system will give you a solid foundation for developing robust and efficient web applications with Gin. As you progress, you'll find that Go's static typing catches many potential bugs at compile time, leading to more reliable software.