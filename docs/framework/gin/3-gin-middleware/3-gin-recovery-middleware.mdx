---
title: Gin Recovery Middleware
description: Learn how to handle panics and recover from errors in Gin web applications with the built-in Recovery middleware

---

# Gin Recovery Middleware

## Introduction

When developing web applications, unexpected errors can occur that might cause your application to crash. In Go, these critical errors often manifest as "panics." Unlike regular errors, which can be handled with try-catch-like structures, panics will terminate your program unless they're recovered.

Gin, a popular web framework for Go, provides a built-in middleware called **Recovery** that catches panics in HTTP handlers and prevents your entire application from crashing. This middleware allows your server to continue running even if one request handler encounters a critical error, making your application more resilient and reliable.

In this guide, we'll explore:

- What the Recovery middleware does and why it's essential
- How to implement the Recovery middleware in your Gin application
- Customizing the Recovery behavior
- Best practices for error handling with Recovery

## Understanding Recovery Middleware

### What is Recovery?

Recovery middleware is one of Gin's default middlewares that acts as a safety net for your application. It:

1. Catches any panics that occur during the processing of HTTP requests
2. Recovers from these panics to prevent your server from crashing
3. Returns a 500 Internal Server Error to the client
4. Logs the error and stack trace (by default)

### Why Use Recovery Middleware?

Without recovery middleware, a single panic in your handler would crash your entire web server, affecting all users. With recovery in place, only the specific request that caused the panic will fail, while your server continues to handle other requests.

## Implementing Basic Recovery Middleware

Gin includes Recovery middleware by default when you use `gin.Default()`. Here's a simple example:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    // Creates a router with default middleware:
    // logger and recovery (crash-free) middleware
    router := gin.Default()

    router.GET("/", func(c *gin.Context) {
        c.String(http.StatusOK, "Hello World")
    })

    router.GET("/panic", func(c *gin.Context) {
        // This will cause a panic
        panic("This is a panic!")
    })

    router.Run(":8080")
}
```

When you run this application and navigate to `/panic`, the server will:
1. Catch the panic
2. Log the error and stack trace
3. Return a 500 Internal Server Error
4. Continue running, handling other requests normally

### Output in Console

When a panic occurs, you'll see something like this in your console:

```
[Recovery] 2023/05/15 - 15:04:32 panic recovered:
This is a panic!
/usr/local/go/src/runtime/panic.go:1038 (0x0)
/path/to/your/app/main.go:18 (0x0)
...
```

## Manual Recovery Middleware Setup

If you're using `gin.New()` instead of `gin.Default()`, you need to explicitly add the Recovery middleware:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    // Creates a router without any middleware by default
    router := gin.New()

    // Add Recovery middleware
    router.Use(gin.Recovery())

    // Add your routes
    router.GET("/", func(c *gin.Context) {
        c.String(http.StatusOK, "Hello World")
    })

    router.GET("/panic", func(c *gin.Context) {
        // This will cause a panic
        panic("This is a panic!")
    })

    router.Run(":8080")
}
```

## Customizing Recovery Behavior

While the default Recovery middleware is useful, you might want to customize its behavior. Let's see how to create a custom recovery middleware:

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "runtime/debug"
    "time"

    "github.com/gin-gonic/gin"
)

func CustomRecovery() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // Log time, error, and stack trace
                log.Printf("[ERROR] %s\nPanic: %v\n%s\n", time.Now().Format("2006/01/02 - 15:04:05"), err, debug.Stack())
                
                // You could also send the error to a monitoring service
                // sendToMonitoringService(err, debug.Stack())
                
                // Return a custom error response
                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": "Internal Server Error",
                    "message": "The server encountered an error and could not process your request",
                })
                
                // Abort the request
                c.Abort()
            }
        }()
        
        // Process the request
        c.Next()
    }
}

func main() {
    router := gin.New()
    
    // Use our custom recovery middleware
    router.Use(CustomRecovery())
    
    // Add routes
    router.GET("/", func(c *gin.Context) {
        c.String(http.StatusOK, "Hello World")
    })
    
    router.GET("/panic", func(c *gin.Context) {
        panic("This is a panic!")
    })
    
    router.Run(":8080")
}
```

The custom recovery middleware above:
1. Creates a deferred function that will run when the handler completes
2. Checks if a panic occurred using `recover()`
3. If a panic happened, it logs the details with timestamp
4. Returns a JSON response to the client with a user-friendly message
5. Aborts the middleware chain to prevent further processing

## Real-World Applications

### Application 1: JSON API with Custom Error Handling

In a JSON API, you might want to return structured error responses:

```go
package main

import (
    "fmt"
    "log"
    "net/http"
    "runtime/debug"
    "time"

    "github.com/gin-gonic/gin"
)

// ErrorResponse defines the structure of error responses
type ErrorResponse struct {
    Error       string    `json:"error"`
    Message     string    `json:"message"`
    Status      int       `json:"status"`
    Timestamp   time.Time `json:"timestamp"`
    RequestID   string    `json:"request_id,omitempty"`
}

func APIRecovery() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Generate a unique request ID
        requestID := generateRequestID() // Implement this function as needed
        c.Set("RequestID", requestID)
        
        defer func() {
            if err := recover(); err != nil {
                // Log the error with request ID
                stackTrace := string(debug.Stack())
                log.Printf("[PANIC] [RequestID: %s] %v\n%s", requestID, err, stackTrace)
                
                // Return structured error response
                errorResponse := ErrorResponse{
                    Error:     "internal_server_error",
                    Message:   "The server encountered an unexpected condition",
                    Status:    http.StatusInternalServerError,
                    Timestamp: time.Now(),
                    RequestID: requestID,
                }
                
                c.JSON(http.StatusInternalServerError, errorResponse)
                c.Abort()
            }
        }()
        
        c.Next()
    }
}

func generateRequestID() string {
    // In a real app, you'd generate a unique ID
    return fmt.Sprintf("%d", time.Now().UnixNano())
}

func main() {
    router := gin.New()
    router.Use(APIRecovery())
    
    // API routes
    router.GET("/api/users", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{"users": []string{"user1", "user2"}})
    })
    
    router.GET("/api/error", func(c *gin.Context) {
        // Simulate database error
        panic("Database connection failed")
    })
    
    router.Run(":8080")
}
```

### Application 2: Recovery with Different Responses Based on Environment

In production, you might want to hide detailed error information from users:

```go
package main

import (
    "log"
    "net/http"
    "os"
    "runtime/debug"

    "github.com/gin-gonic/gin"
)

func EnvironmentAwareRecovery() gin.HandlerFunc {
    environment := os.Getenv("APP_ENV")
    if environment == "" {
        environment = "development" // Default to development
    }
    
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // Always log the full error details
                log.Printf("[PANIC] %v\n%s", err, debug.Stack())
                
                switch environment {
                case "production":
                    // In production, return a simple error message
                    c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "Internal Server Error",
                    })
                default:
                    // In development, return detailed error information
                    c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Internal Server Error",
                        "message": err,
                        "stack":   string(debug.Stack()),
                    })
                }
                
                c.Abort()
            }
        }()
        
        c.Next()
    }
}

func main() {
    router := gin.New()
    router.Use(EnvironmentAwareRecovery())
    
    router.GET("/", func(c *gin.Context) {
        c.String(http.StatusOK, "Hello World")
    })
    
    router.GET("/panic", func(c *gin.Context) {
        panic("This is a panic!")
    })
    
    router.Run(":8080")
}
```

To test this with different environments:
```bash
# Run in development mode (default)
go run main.go

# Run in production mode
APP_ENV=production go run main.go
```

## Best Practices for Using Recovery Middleware

1. **Always use recovery middleware** in production applications to prevent server crashes.

2. **Log errors thoroughly** so you can investigate issues later. Include timestamps, request details, and stack traces.

3. **Consider your audience** when designing error responses:
   - For APIs used by other developers, include helpful error details
   - For end-user applications, provide user-friendly messages without technical details

4. **Use different error handling strategies** based on environment (development vs. production).

5. **Monitor and alert on panics** - while Recovery prevents crashes, panics indicate serious issues that need attention.

6. **Don't rely on Recovery for normal error handling** - use standard Go error handling for expected error conditions.

7. **Consider integrating with monitoring services** (like Sentry, New Relic, or Datadog) to track errors.

## Summary

Gin's Recovery middleware is an essential tool for building robust web applications in Go. It acts as a safety net, catching panics that would otherwise crash your server and allowing your application to continue serving other requests.

We've covered:
- How to use Gin's built-in Recovery middleware
- Creating custom recovery middleware for more control
- Real-world applications with structured error responses
- Best practices for error handling with Recovery middleware

With proper use of Recovery middleware, your Gin applications will be more resilient to unexpected errors, providing a better experience for your users and making your systems easier to maintain.

## Additional Resources

- [Gin Framework Official Documentation](https://gin-gonic.com/docs/)
- [Go's Built-in Recover Function](https://golang.org/pkg/builtin/#recover)
- [Error Handling in Go](https://go.dev/blog/error-handling-and-go)

## Exercises

1. **Basic Recovery**: Set up a basic Gin application with the default Recovery middleware and create a route that causes a panic. Observe the behavior.

2. **Custom Error Messages**: Modify the Recovery middleware to return custom error messages based on the type of panic that occurred.

3. **Integration with Monitoring**: Extend the custom Recovery middleware to send error details to a logging service or monitoring platform (you can mock this functionality).

4. **Different Status Codes**: Create a Recovery middleware that returns different HTTP status codes based on the panic message (e.g., return 400 Bad Request for "invalid input" panics).

5. **Advanced**: Implement a Recovery middleware that attempts to reconnect to a database if the panic was caused by a lost database connection.