---
title: "Gin API Versioning"
description: "Learn how to implement and manage API versioning strategies in your Gin framework applications to ensure backward compatibility and smooth evolution of your RESTful services."

---

# Gin API Versioning

## Introduction

API versioning is a crucial aspect of building maintainable and evolving web services. As your API changes over time, you'll need to ensure that existing clients continue to function while you add new features or modify existing ones. In this guide, we'll explore different approaches to implementing API versioning in Gin, a high-performance web framework written in Go.

Proper API versioning helps you:

- Make changes without breaking existing client applications
- Gradually migrate clients to new API versions 
- Maintain multiple API versions simultaneously during transition periods
- Communicate changes to API consumers in a structured manner

Let's dive into the various strategies for implementing API versioning in Gin applications.

## Versioning Strategies

There are several common approaches to API versioning:

1. **URI Path Versioning**: Including the version in the URL path (e.g., `/api/v1/users`)
2. **Query Parameter Versioning**: Specifying the version as a query parameter (e.g., `/api/users?version=1`)
3. **Header-Based Versioning**: Using custom HTTP headers to specify the version
4. **Content Negotiation**: Using the Accept header to specify the desired version

We'll explore each of these approaches with Gin implementation examples.

## URI Path Versioning

URI path versioning is the most straightforward and widely used approach. It involves including the version number directly in the URL path.

### Implementation Example

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	router := gin.Default()

	// API v1 routes
	v1 := router.Group("/api/v1")
	{
		v1.GET("/users", getUsersV1)
		v1.GET("/users/:id", getUserV1)
		v1.POST("/users", createUserV1)
	}

	// API v2 routes
	v2 := router.Group("/api/v2")
	{
		v2.GET("/users", getUsersV2)
		v2.GET("/users/:id", getUserV2)
		v2.POST("/users", createUserV2)
	}

	router.Run(":8080")
}

func getUsersV1(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"version": "v1",
		"users":   []string{"Alice", "Bob"},
	})
}

func getUserV1(c *gin.Context) {
	id := c.Param("id")
	c.JSON(http.StatusOK, gin.H{
		"version": "v1",
		"id":      id,
		"name":    "Alice",
	})
}

func createUserV1(c *gin.Context) {
	c.JSON(http.StatusCreated, gin.H{
		"version": "v1",
		"message": "User created successfully",
	})
}

func getUsersV2(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"version": "v2",
		"users": []map[string]interface{}{
			{"id": 1, "name": "Alice", "role": "Admin"},
			{"id": 2, "name": "Bob", "role": "User"},
		},
	})
}

func getUserV2(c *gin.Context) {
	id := c.Param("id")
	c.JSON(http.StatusOK, gin.H{
		"version": "v2",
		"user": map[string]interface{}{
			"id":       id,
			"name":     "Alice",
			"role":     "Admin",
			"metadata": map[string]string{"last_login": "2023-07-01"},
		},
	})
}

func createUserV2(c *gin.Context) {
	c.JSON(http.StatusCreated, gin.H{
		"version": "v2",
		"message": "User created successfully",
		"user_id": 123,
	})
}
```

### Testing the API

You can test these endpoints with curl:

```bash
# V1 API
curl http://localhost:8080/api/v1/users
# Output: {"users":["Alice","Bob"],"version":"v1"}

# V2 API
curl http://localhost:8080/api/v2/users
# Output: {"users":[{"id":1,"name":"Alice","role":"Admin"},{"id":2,"name":"Bob","role":"User"}],"version":"v2"}
```

Notice how the V2 API returns more detailed user information compared to V1, which is a common scenario in API evolution.

## Query Parameter Versioning

Another approach is to use query parameters to specify the API version.

### Implementation Example

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	router := gin.Default()

	api := router.Group("/api")
	{
		api.GET("/users", getUsers)
		api.GET("/users/:id", getUser)
	}

	router.Run(":8080")
}

func getUsers(c *gin.Context) {
	version := c.DefaultQuery("version", "1")
	
	if version == "1" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v1",
			"users":   []string{"Alice", "Bob"},
		})
		return
	}
	
	if version == "2" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v2",
			"users": []map[string]interface{}{
				{"id": 1, "name": "Alice", "role": "Admin"},
				{"id": 2, "name": "Bob", "role": "User"},
			},
		})
		return
	}
	
	c.JSON(http.StatusBadRequest, gin.H{
		"error": "Unsupported API version",
	})
}

func getUser(c *gin.Context) {
	id := c.Param("id")
	version := c.DefaultQuery("version", "1")
	
	if version == "1" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v1",
			"id":      id,
			"name":    "Alice",
		})
		return
	}
	
	if version == "2" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v2",
			"user": map[string]interface{}{
				"id":       id,
				"name":     "Alice",
				"role":     "Admin",
				"metadata": map[string]string{"last_login": "2023-07-01"},
			},
		})
		return
	}
	
	c.JSON(http.StatusBadRequest, gin.H{
		"error": "Unsupported API version",
	})
}
```

### Testing the API

```bash
# V1 API (default)
curl http://localhost:8080/api/users
# Output: {"users":["Alice","Bob"],"version":"v1"}

# V2 API
curl http://localhost:8080/api/users?version=2
# Output: {"users":[{"id":1,"name":"Alice","role":"Admin"},{"id":2,"name":"Bob","role":"User"}],"version":"v2"}
```

## Header-Based Versioning

You can also specify the API version using custom HTTP headers.

### Implementation Example

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

func main() {
	router := gin.Default()

	api := router.Group("/api")
	{
		api.GET("/users", getUsersHeaderVersion)
		api.GET("/users/:id", getUserHeaderVersion)
	}

	router.Run(":8080")
}

func getUsersHeaderVersion(c *gin.Context) {
	version := c.GetHeader("X-API-Version")
	if version == "" {
		version = "1" // Default version
	}
	
	if version == "1" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v1",
			"users":   []string{"Alice", "Bob"},
		})
		return
	}
	
	if version == "2" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v2",
			"users": []map[string]interface{}{
				{"id": 1, "name": "Alice", "role": "Admin"},
				{"id": 2, "name": "Bob", "role": "User"},
			},
		})
		return
	}
	
	c.JSON(http.StatusBadRequest, gin.H{
		"error": "Unsupported API version",
	})
}

func getUserHeaderVersion(c *gin.Context) {
	id := c.Param("id")
	version := c.GetHeader("X-API-Version")
	if version == "" {
		version = "1" // Default version
	}
	
	if version == "1" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v1",
			"id":      id,
			"name":    "Alice",
		})
		return
	}
	
	if version == "2" {
		c.JSON(http.StatusOK, gin.H{
			"version": "v2",
			"user": map[string]interface{}{
				"id":       id,
				"name":     "Alice",
				"role":     "Admin",
				"metadata": map[string]string{"last_login": "2023-07-01"},
			},
		})
		return
	}
	
	c.JSON(http.StatusBadRequest, gin.H{
		"error": "Unsupported API version",
	})
}
```

### Testing the API

```bash
# V1 API (default)
curl http://localhost:8080/api/users
# Output: {"users":["Alice","Bob"],"version":"v1"}

# V2 API
curl -H "X-API-Version: 2" http://localhost:8080/api/users
# Output: {"users":[{"id":1,"name":"Alice","role":"Admin"},{"id":2,"name":"Bob","role":"User"}],"version":"v2"}
```

## Content Negotiation (Accept Header)

Content negotiation uses the HTTP Accept header to specify the desired API version.

### Implementation Example

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
	"strings"
)

func main() {
	router := gin.Default()

	api := router.Group("/api")
	{
		api.GET("/users", getUsersAcceptHeader)
		api.GET("/users/:id", getUserAcceptHeader)
	}

	router.Run(":8080")
}

func getUsersAcceptHeader(c *gin.Context) {
	acceptHeader := c.GetHeader("Accept")
	
	// Default to v1 if no specific version is requested
	if !strings.Contains(acceptHeader, "version") || strings.Contains(acceptHeader, "version=1") {
		c.JSON(http.StatusOK, gin.H{
			"version": "v1",
			"users":   []string{"Alice", "Bob"},
		})
		return
	}
	
	if strings.Contains(acceptHeader, "version=2") {
		c.JSON(http.StatusOK, gin.H{
			"version": "v2",
			"users": []map[string]interface{}{
				{"id": 1, "name": "Alice", "role": "Admin"},
				{"id": 2, "name": "Bob", "role": "User"},
			},
		})
		return
	}
	
	c.JSON(http.StatusBadRequest, gin.H{
		"error": "Unsupported API version",
	})
}

func getUserAcceptHeader(c *gin.Context) {
	id := c.Param("id")
	acceptHeader := c.GetHeader("Accept")
	
	// Default to v1 if no specific version is requested
	if !strings.Contains(acceptHeader, "version") || strings.Contains(acceptHeader, "version=1") {
		c.JSON(http.StatusOK, gin.H{
			"version": "v1",
			"id":      id,
			"name":    "Alice",
		})
		return
	}
	
	if strings.Contains(acceptHeader, "version=2") {
		c.JSON(http.StatusOK, gin.H{
			"version": "v2",
			"user": map[string]interface{}{
				"id":       id,
				"name":     "Alice",
				"role":     "Admin",
				"metadata": map[string]string{"last_login": "2023-07-01"},
			},
		})
		return
	}
	
	c.JSON(http.StatusBadRequest, gin.H{
		"error": "Unsupported API version",
	})
}
```

### Testing the API

```bash
# V1 API (default)
curl http://localhost:8080/api/users
# Output: {"users":["Alice","Bob"],"version":"v1"}

# V2 API
curl -H "Accept: application/json;version=2" http://localhost:8080/api/users
# Output: {"users":[{"id":1,"name":"Alice","role":"Admin"},{"id":2,"name":"Bob","role":"User"}],"version":"v2"}
```

## Real-World Example: API Versioning with Controller Pattern

For a more structured application, you can use a controller pattern with versioned routes:

### Project Structure

```
/api-project
  /controllers
    /v1
      users.go
    /v2
      users.go
  main.go
```

### Implementation

#### controllers/v1/users.go

```go
package v1

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

type UsersController struct{}

func NewUsersController() *UsersController {
	return &UsersController{}
}

func (c *UsersController) GetUsers(ctx *gin.Context) {
	ctx.JSON(http.StatusOK, gin.H{
		"version": "v1",
		"users":   []string{"Alice", "Bob"},
	})
}

func (c *UsersController) GetUser(ctx *gin.Context) {
	id := ctx.Param("id")
	ctx.JSON(http.StatusOK, gin.H{
		"version": "v1",
		"id":      id,
		"name":    "Alice",
	})
}
```

#### controllers/v2/users.go

```go
package v2

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

type UsersController struct{}

func NewUsersController() *UsersController {
	return &UsersController{}
}

func (c *UsersController) GetUsers(ctx *gin.Context) {
	ctx.JSON(http.StatusOK, gin.H{
		"version": "v2",
		"users": []map[string]interface{}{
			{"id": 1, "name": "Alice", "role": "Admin"},
			{"id": 2, "name": "Bob", "role": "User"},
		},
	})
}

func (c *UsersController) GetUser(ctx *gin.Context) {
	id := ctx.Param("id")
	ctx.JSON(http.StatusOK, gin.H{
		"version": "v2",
		"user": map[string]interface{}{
			"id":       id,
			"name":     "Alice",
			"role":     "Admin",
			"metadata": map[string]string{"last_login": "2023-07-01"},
		},
	})
}
```

#### main.go

```go
package main

import (
	"github.com/gin-gonic/gin"
	v1 "your-app/controllers/v1"
	v2 "your-app/controllers/v2"
)

func main() {
	router := gin.Default()

	// Initialize controllers
	v1UsersController := v1.NewUsersController()
	v2UsersController := v2.NewUsersController()

	// API v1 routes
	apiV1 := router.Group("/api/v1")
	{
		apiV1.GET("/users", v1UsersController.GetUsers)
		apiV1.GET("/users/:id", v1UsersController.GetUser)
	}

	// API v2 routes
	apiV2 := router.Group("/api/v2")
	{
		apiV2.GET("/users", v2UsersController.GetUsers)
		apiV2.GET("/users/:id", v2UsersController.GetUser)
	}

	router.Run(":8080")
}
```

## Best Practices for API Versioning

1. **Choose a consistent versioning strategy** - Pick one approach and stick with it across your API.

2. **Use semantic versioning** - Consider using semantic versioning principles (MAJOR.MINOR.PATCH) where:
   - MAJOR version changes for incompatible API changes
   - MINOR version changes for backward-compatible additions
   - PATCH version changes for backward-compatible bug fixes

3. **Document your versioning strategy** - Make sure API consumers understand how versioning works and when to expect changes.

4. **Consider deprecation policies** - Clearly communicate when older versions will be deprecated and eventually removed.

5. **Keep backward compatibility when possible** - Try to design your API so that changes are additive rather than breaking.

6. **Version at the right level** - Version your entire API or specific resources depending on your needs.

7. **Use API blueprints or specifications** - Consider using tools like Swagger/OpenAPI to document and test different API versions.

## Summary

In this guide, we've explored different strategies for implementing API versioning in Gin applications:

1. **URI Path Versioning**: Simple and explicit but can lead to URI duplication
2. **Query Parameter Versioning**: Clean URIs but less visible in API endpoints
3. **Header-Based Versioning**: Keeps URIs clean but less discoverable
4. **Content Negotiation**: Standards-compliant but can be more complex to implement

Each approach has its advantages and disadvantages. The right choice depends on your specific requirements, your API consumers' needs, and your team's preferences.

By implementing effective API versioning, you can evolve your API while maintaining backward compatibility, ensuring a smooth experience for your API consumers.

## Additional Resources

- [Gin Framework Documentation](https://github.com/gin-gonic/gin)
- [RESTful API Design: Best Practices](https://restfulapi.net/)
- [Semantic Versioning](https://semver.org/)
- [OpenAPI Specification](https://swagger.io/specification/)

## Exercises

1. Implement a versioned API with Gin that supports both V1 and V2 versions of a "products" endpoint.
2. Create an API that supports multiple versioning strategies simultaneously (e.g., both path and header versioning).
3. Implement a middleware in Gin that detects API version from different sources and adds it to the context.
4. Create a deprecation system that warns users when they're using an API version scheduled for removal.
5. Build a version negotiation middleware that selects the most appropriate API version based on the client's capabilities.