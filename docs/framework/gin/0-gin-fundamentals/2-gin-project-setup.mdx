---
title: "Gin Project Setup"
description: "Learn how to set up your first Gin web application project from scratch, including installation, directory structure, and basic configuration for beginners."

---

# Gin Project Setup

Welcome to the world of web development with Go's Gin framework! In this tutorial, you'll learn how to set up your first Gin project from scratch. By the end, you'll have a working Gin application structure that follows best practices and sets you up for success in your web development journey.

## What is Gin?

Before we dive into the setup, let's understand what Gin is. Gin is a web framework written in Go (Golang) that features a martini-like API but with much better performance. It's designed to be lightweight, fast, and perfect for building web applications and microservices.

## Prerequisites

Before we begin, make sure you have:

1. Go installed on your machine (version 1.16 or later recommended)
2. Basic knowledge of Go programming
3. A code editor (VS Code, GoLand, etc.)
4. Terminal/Command Prompt access

## Step 1: Install Go

If you haven't installed Go yet, download it from the [official Go website](https://golang.org/dl/) and follow the installation instructions for your operating system.

To verify your Go installation, open a terminal and run:

```bash
go version
```

You should see output similar to:

```
go version go1.19.4 darwin/amd64
```

## Step 2: Initialize Your Go Project

Let's create a new directory for our project and initialize it:

```bash
mkdir gin-demo
cd gin-demo
go mod init github.com/yourusername/gin-demo
```

The `go mod init` command creates a new Go module, which allows Go to manage dependencies for your project. Replace "yourusername" with your actual GitHub username or any other module path you prefer.

## Step 3: Install Gin Framework

Now, let's add the Gin framework to our project:

```bash
go get -u github.com/gin-gonic/gin
```

This command downloads and installs the latest version of Gin and adds it to your project's dependencies.

## Step 4: Create Basic Directory Structure

A well-organized project structure helps maintain your code as it grows. Here's a recommended structure for a Gin project:

```bash
mkdir -p controllers middleware models routes static templates
touch main.go
```

This creates:
- `controllers/`: Handles request processing logic
- `middleware/`: Contains middleware functions
- `models/`: Defines data structures and database operations
- `routes/`: Manages route definitions
- `static/`: Stores static files (CSS, JavaScript, images)
- `templates/`: Holds HTML templates
- `main.go`: Entry point of your application

## Step 5: Create Your First Gin Application

Let's create a simple "Hello World" application to test our setup. Open `main.go` and add the following code:

```go
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func main() {
	// Create a default gin router
	r := gin.Default()

	// Define a route handler for the root path
	r.GET("/", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{
			"message": "Welcome to Gin Framework!",
		})
	})

	// Route that returns plain text
	r.GET("/ping", func(c *gin.Context) {
		c.String(http.StatusOK, "pong")
	})

	// Route with parameters
	r.GET("/hello/:name", func(c *gin.Context) {
		name := c.Param("name")
		c.JSON(http.StatusOK, gin.H{
			"message": "Hello " + name + "!",
		})
	})

	// Start the server on port 8080
	r.Run(":8080")
}
```

## Step 6: Run Your Application

Now, let's run our application:

```bash
go run main.go
```

You should see output like this:

```
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)
[GIN-debug] GET    /                         --> main.main.func1 (3 handlers)
[GIN-debug] GET    /ping                     --> main.main.func2 (3 handlers)
[GIN-debug] GET    /hello/:name              --> main.main.func3 (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080
```

## Step 7: Test Your Application

Open your browser or use tools like `curl` to test the endpoints:

1. Visit `http://localhost:8080/` to see:
```json
{"message":"Welcome to Gin Framework!"}
```

2. Visit `http://localhost:8080/ping` to see:
```
pong
```

3. Visit `http://localhost:8080/hello/YourName` to see:
```json
{"message":"Hello YourName!"}
```

## Enhancing Your Project Structure

For a more organized application, let's refine our structure by moving route handlers to controllers and setting up proper routing.

### Create a Controller

Create a file `controllers/home_controller.go`:

```go
package controllers

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// HomeController handles home-related routes
type HomeController struct{}

// Welcome displays the welcome message
func (h HomeController) Welcome(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		"message": "Welcome to Gin Framework!",
	})
}

// Ping responds with pong
func (h HomeController) Ping(c *gin.Context) {
	c.String(http.StatusOK, "pong")
}

// Greeting responds with a personalized greeting
func (h HomeController) Greeting(c *gin.Context) {
	name := c.Param("name")
	c.JSON(http.StatusOK, gin.H{
		"message": "Hello " + name + "!",
	})
}
```

### Create Routes

Create a file `routes/routes.go`:

```go
package routes

import (
	"github.com/gin-gonic/gin"
	"github.com/yourusername/gin-demo/controllers"
)

// SetupRoutes configures all the routes for our application
func SetupRoutes(r *gin.Engine) {
	// Initialize controllers
	homeController := controllers.HomeController{}

	// Home routes
	r.GET("/", homeController.Welcome)
	r.GET("/ping", homeController.Ping)
	r.GET("/hello/:name", homeController.Greeting)

	// You can group routes for better organization
	api := r.Group("/api")
	{
		api.GET("/status", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"status": "API is running",
			})
		})
	}
}
```

### Update Main File

Now, update your `main.go` to use these routes:

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/yourusername/gin-demo/routes"
)

func main() {
	// Create a default gin router
	r := gin.Default()

	// Setup all routes
	routes.SetupRoutes(r)

	// Start the server on port 8080
	r.Run(":8080")
}
```

Remember to replace "yourusername" with your actual module name.

## Step 8: Adding Configuration

For a real-world application, you'll want to manage configuration. Let's create a simple configuration setup:

Create a file `config/config.go`:

```go
package config

import (
	"os"
	"strconv"
)

// Config holds all configuration for our application
type Config struct {
	Port    string
	DebugMode bool
}

// LoadConfig loads configuration from environment variables
func LoadConfig() Config {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port
	}
	
	debugMode := true
	debugStr := os.Getenv("DEBUG_MODE")
	if debugStr != "" {
		var err error
		debugMode, err = strconv.ParseBool(debugStr)
		if err != nil {
			debugMode = true // Default to debug mode on error
		}
	}
	
	return Config{
		Port:    port,
		DebugMode: debugMode,
	}
}
```

Update `main.go` to use this configuration:

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/yourusername/gin-demo/config"
	"github.com/yourusername/gin-demo/routes"
)

func main() {
	// Load configuration
	cfg := config.LoadConfig()
	
	// Set Gin mode based on configuration
	if !cfg.DebugMode {
		gin.SetMode(gin.ReleaseMode)
	}
	
	// Create a gin router
	r := gin.Default()
	
	// Setup all routes
	routes.SetupRoutes(r)
	
	// Start the server with configured port
	r.Run(":" + cfg.Port)
}
```

## Real-World Example: Building a Simple Todo API

Let's put everything together to build a simple Todo API:

### Create the Todo Model

Create `models/todo.go`:

```go
package models

import "time"

// Todo represents a todo item
type Todo struct {
	ID        uint      `json:"id"`
	Title     string    `json:"title" binding:"required"`
	Completed bool      `json:"completed"`
	CreatedAt time.Time `json:"created_at"`
}

// TodoStore provides an in-memory store for todos
type TodoStore struct {
	todos  []Todo
	lastID uint
}

// NewTodoStore creates a new todo store
func NewTodoStore() *TodoStore {
	return &TodoStore{
		todos:  make([]Todo, 0),
		lastID: 0,
	}
}

// GetAll returns all todos
func (s *TodoStore) GetAll() []Todo {
	return s.todos
}

// Add adds a new todo
func (s *TodoStore) Add(title string) Todo {
	s.lastID++
	todo := Todo{
		ID:        s.lastID,
		Title:     title,
		Completed: false,
		CreatedAt: time.Now(),
	}
	s.todos = append(s.todos, todo)
	return todo
}

// GetByID returns a todo by ID
func (s *TodoStore) GetByID(id uint) (Todo, bool) {
	for _, todo := range s.todos {
		if todo.ID == id {
			return todo, true
		}
	}
	return Todo{}, false
}

// Update updates a todo
func (s *TodoStore) Update(id uint, completed bool) (Todo, bool) {
	for i, todo := range s.todos {
		if todo.ID == id {
			s.todos[i].Completed = completed
			return s.todos[i], true
		}
	}
	return Todo{}, false
}

// Delete deletes a todo by ID
func (s *TodoStore) Delete(id uint) bool {
	for i, todo := range s.todos {
		if todo.ID == id {
			s.todos = append(s.todos[:i], s.todos[i+1:]...)
			return true
		}
	}
	return false
}
```

### Create the Todo Controller

Create `controllers/todo_controller.go`:

```go
package controllers

import (
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/yourusername/gin-demo/models"
)

// TodoController handles todo-related operations
type TodoController struct {
	store *models.TodoStore
}

// NewTodoController creates a new todo controller
func NewTodoController() *TodoController {
	return &TodoController{
		store: models.NewTodoStore(),
	}
}

// GetAll returns all todos
func (tc *TodoController) GetAll(c *gin.Context) {
	c.JSON(http.StatusOK, tc.store.GetAll())
}

// Create creates a new todo
func (tc *TodoController) Create(c *gin.Context) {
	var todo struct {
		Title string `json:"title" binding:"required"`
	}

	if err := c.ShouldBindJSON(&todo); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	newTodo := tc.store.Add(todo.Title)
	c.JSON(http.StatusCreated, newTodo)
}

// GetByID returns a todo by ID
func (tc *TodoController) GetByID(c *gin.Context) {
	idStr := c.Param("id")
	id, err := strconv.ParseUint(idStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
		return
	}

	todo, found := tc.store.GetByID(uint(id))
	if !found {
		c.JSON(http.StatusNotFound, gin.H{"error": "Todo not found"})
		return
	}

	c.JSON(http.StatusOK, todo)
}

// Update updates a todo's completion status
func (tc *TodoController) Update(c *gin.Context) {
	idStr := c.Param("id")
	id, err := strconv.ParseUint(idStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
		return
	}

	var req struct {
		Completed bool `json:"completed"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	todo, found := tc.store.Update(uint(id), req.Completed)
	if !found {
		c.JSON(http.StatusNotFound, gin.H{"error": "Todo not found"})
		return
	}

	c.JSON(http.StatusOK, todo)
}

// Delete deletes a todo
func (tc *TodoController) Delete(c *gin.Context) {
	idStr := c.Param("id")
	id, err := strconv.ParseUint(idStr, 10, 32)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
		return
	}

	if deleted := tc.store.Delete(uint(id)); !deleted {
		c.JSON(http.StatusNotFound, gin.H{"error": "Todo not found"})
		return
	}

	c.Status(http.StatusNoContent)
}
```

### Update Routes

Update `routes/routes.go` to include the todo routes:

```go
package routes

import (
	"github.com/gin-gonic/gin"
	"github.com/yourusername/gin-demo/controllers"
)

// SetupRoutes configures all the routes for our application
func SetupRoutes(r *gin.Engine) {
	// Initialize controllers
	homeController := controllers.HomeController{}
	todoController := controllers.NewTodoController()

	// Home routes
	r.GET("/", homeController.Welcome)
	r.GET("/ping", homeController.Ping)
	r.GET("/hello/:name", homeController.Greeting)

	// API routes
	api := r.Group("/api")
	{
		// Todo API endpoints
		todos := api.Group("/todos")
		{
			todos.GET("", todoController.GetAll)
			todos.POST("", todoController.Create)
			todos.GET("/:id", todoController.GetByID)
			todos.PATCH("/:id", todoController.Update)
			todos.DELETE("/:id", todoController.Delete)
		}
	}
}
```

### Testing the Todo API

You can test your Todo API using tools like curl, Postman, or any API client:

1. Get all todos (initially empty):
```bash
curl http://localhost:8080/api/todos
```

2. Create a new todo:
```bash
curl -X POST http://localhost:8080/api/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Learn Gin Framework"}'
```

3. Get a specific todo:
```bash
curl http://localhost:8080/api/todos/1
```

4. Update a todo:
```bash
curl -X PATCH http://localhost:8080/api/todos/1 \
  -H "Content-Type: application/json" \
  -d '{"completed": true}'
```

5. Delete a todo:
```bash
curl -X DELETE http://localhost:8080/api/todos/1
```

## Summary

Congratulations! You've set up a complete Gin project structure and built a simple Todo API application. In this tutorial, you learned:

- How to initialize a Go project with Gin
- How to create a structured, maintainable project layout
- How to define routes and controllers
- How to handle configuration
- How to implement a simple API with CRUD operations

This organized structure will serve you well as your application grows. It separates concerns, makes testing easier, and follows good design practices.

## Additional Resources

To continue learning about Gin, check out these resources:

- [Gin Framework Official Documentation](https://github.com/gin-gonic/gin)
- [Go Programming Language Tour](https://tour.golang.org/)
- [Build RESTful API with Go and Gin](https://go.dev/doc/tutorial/web-service-gin)

## Exercises

To reinforce your learning, try these exercises:

1. Add data validation for the Todo API (e.g., ensure titles are between 3-100 characters)
2. Implement search functionality for todos
3. Add due dates to the todos
4. Implement user authentication for the API
5. Create a simple frontend using HTML templates to interact with your Todo API

Happy coding with Gin!