---
title: Gin Request Handling
description: Learn how to handle HTTP requests in Gin, including routing, parameters, query strings, and request bodies

---

# Gin Request Handling

## Introduction

Request handling is at the core of any web application. In Gin, a popular Go web framework, handling requests involves capturing, parsing, and responding to HTTP requests in an efficient manner. This guide will walk you through the fundamentals of request handling in Gin, from simple routes to complex request processing.

Gin makes it easy to build web servers and APIs by providing a simple, yet powerful, interface for handling HTTP requests. Whether you need to create a simple endpoint or process complex form submissions, Gin offers the tools you need.

## Setting Up a Basic Gin Server

Before diving into request handling, let's set up a basic Gin server:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

func main() {
    // Create a default Gin router
    r := gin.Default()
    
    // Define a simple route
    r.GET("/hello", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "Hello, Gin!",
        })
    })
    
    // Run the server on port 8080
    r.Run(":8080")
}
```

When you run this code and navigate to `http://localhost:8080/hello` in your browser or API client, you'll see:

```json
{
  "message": "Hello, Gin!"
}
```

## The Context Object

The `gin.Context` is the most important part of Gin. It carries request details, validates data, serializes JSON, and more. Every request handler in Gin receives a context object:

```go
func someHandler(c *gin.Context) {
    // c contains all the request information and helper methods
}
```

## Basic Routing

Gin provides intuitive methods for handling different HTTP methods:

```go
// GET request
r.GET("/path", handlerFunction)

// POST request
r.POST("/path", handlerFunction)

// PUT request
r.PUT("/path", handlerFunction)

// DELETE request
r.DELETE("/path", handlerFunction)

// Any HTTP method
r.Any("/path", handlerFunction)
```

You can also group routes with common prefixes:

```go
// Group routes under /api/v1
v1 := r.Group("/api/v1")
{
    v1.GET("/users", getUsers)
    v1.POST("/users", createUser)
    v1.GET("/users/:id", getUserByID)
}
```

## URL Parameters

Capturing dynamic values from URLs is a common requirement. Gin makes this easy with path parameters:

```go
r.GET("/users/:id", func(c *gin.Context) {
    // Get the id parameter
    id := c.Param("id")
    
    c.JSON(http.StatusOK, gin.H{
        "message": "User details for ID: " + id,
        "id": id,
    })
})
```

If you visit `/users/123`, you'll see:

```json
{
  "id": "123",
  "message": "User details for ID: 123"
}
```

## Query Parameters

Query parameters (the part after `?` in a URL) are also easy to access:

```go
// GET /search?q=golang&page=2
r.GET("/search", func(c *gin.Context) {
    query := c.Query("q")         // Get the query parameter "q"
    page := c.DefaultQuery("page", "1") // Get "page" with default value "1"
    
    c.JSON(http.StatusOK, gin.H{
        "query": query,
        "page": page,
    })
})
```

Example request: `/search?q=golang&page=2`

Output:
```json
{
  "page": "2",
  "query": "golang"
}
```

## Form Data

For form submissions, Gin provides methods to access form values:

```go
r.POST("/form", func(c *gin.Context) {
    username := c.PostForm("username")
    password := c.DefaultPostForm("password", "default_password")
    
    c.JSON(http.StatusOK, gin.H{
        "username": username,
        "password": password,
    })
})
```

If you submit a form with `username=johndoe` and no password:

```json
{
  "password": "default_password",
  "username": "johndoe"
}
```

## Handling JSON Requests

Modern APIs often work with JSON. Gin makes it easy to bind JSON request bodies to Go structs:

```go
type User struct {
    Username string `json:"username" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Age      int    `json:"age" binding:"gte=18"`
}

r.POST("/users", func(c *gin.Context) {
    var user User
    
    // Bind JSON to struct with validation
    if err := c.ShouldBindJSON(&user); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Process the user data
    c.JSON(http.StatusOK, gin.H{
        "message": "User created successfully",
        "user": user,
    })
})
```

If you send this JSON:

```json
{
  "username": "johndoe",
  "email": "john@example.com",
  "age": 25
}
```

You'll get:

```json
{
  "message": "User created successfully",
  "user": {
    "username": "johndoe",
    "email": "john@example.com",
    "age": 25
  }
}
```

But if you send invalid data (like missing fields or an age under 18), you'll get a validation error.

## File Uploads

Gin also handles file uploads with ease:

```go
r.POST("/upload", func(c *gin.Context) {
    // Single file
    file, err := c.FormFile("file")
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return
    }
    
    // Save the file
    dst := "./uploads/" + file.Filename
    if err := c.SaveUploadedFile(file, dst); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "message": "File uploaded successfully",
        "filename": file.Filename,
        "size": file.Size,
    })
})
```

## Multiple Handlers for a Route

You can chain multiple handlers for a single route. This is useful for middleware:

```go
// Auth middleware
func authRequired() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token != "valid-token" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            return
        }
        // Continue to the next handler
        c.Next()
    }
}

// Protected route with middleware
r.GET("/protected", authRequired(), func(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{"message": "You're authorized!"})
})
```

## Real-World Example: RESTful API

Let's put everything together in a more complete example of a simple REST API for a blog:

```go
package main

import (
    "github.com/gin-gonic/gin"
    "net/http"
    "strconv"
)

// Post model
type Post struct {
    ID      int    `json:"id"`
    Title   string `json:"title" binding:"required"`
    Content string `json:"content" binding:"required"`
    Author  string `json:"author" binding:"required"`
}

// In-memory database
var posts = []Post{
    {ID: 1, Title: "First Post", Content: "Hello Gin!", Author: "Jane Doe"},
    {ID: 2, Title: "Second Post", Content: "Learning Go is fun", Author: "John Doe"},
}

func main() {
    r := gin.Default()
    
    // API group
    api := r.Group("/api")
    {
        // Get all posts
        api.GET("/posts", func(c *gin.Context) {
            c.JSON(http.StatusOK, posts)
        })
        
        // Get post by ID
        api.GET("/posts/:id", func(c *gin.Context) {
            id, err := strconv.Atoi(c.Param("id"))
            if err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
            }
            
            for _, post := range posts {
                if post.ID == id {
                    c.JSON(http.StatusOK, post)
                    return
                }
            }
            
            c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
        })
        
        // Create a new post
        api.POST("/posts", func(c *gin.Context) {
            var newPost Post
            if err := c.ShouldBindJSON(&newPost); err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
            }
            
            // Assign a new ID (in a real app, this would be handled by the database)
            newPost.ID = len(posts) + 1
            posts = append(posts, newPost)
            
            c.JSON(http.StatusCreated, newPost)
        })
        
        // Update a post
        api.PUT("/posts/:id", func(c *gin.Context) {
            id, err := strconv.Atoi(c.Param("id"))
            if err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
            }
            
            var updatedPost Post
            if err := c.ShouldBindJSON(&updatedPost); err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
            }
            
            for i, post := range posts {
                if post.ID == id {
                    updatedPost.ID = id // Ensure ID remains the same
                    posts[i] = updatedPost
                    c.JSON(http.StatusOK, updatedPost)
                    return
                }
            }
            
            c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
        })
        
        // Delete a post
        api.DELETE("/posts/:id", func(c *gin.Context) {
            id, err := strconv.Atoi(c.Param("id"))
            if err != nil {
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
            }
            
            for i, post := range posts {
                if post.ID == id {
                    posts = append(posts[:i], posts[i+1:]...)
                    c.JSON(http.StatusOK, gin.H{"message": "Post deleted"})
                    return
                }
            }
            
            c.JSON(http.StatusNotFound, gin.H{"error": "Post not found"})
        })
    }
    
    r.Run(":8080")
}
```

This example demonstrates a complete RESTful API with CRUD operations, proper status codes, and error handling.

## Summary

Gin provides a powerful and flexible system for handling HTTP requests in Go applications. In this guide, we've covered:

- Basic routing and HTTP methods
- Working with URL parameters, query strings, and form data
- Binding and validating JSON request bodies
- File uploading
- Using middleware with request handlers
- Building a complete RESTful API

With these fundamentals, you're well on your way to building robust web applications and APIs using Gin.

## Additional Resources & Exercises

### Resources
- [Gin Official Documentation](https://github.com/gin-gonic/gin)
- [Go Web Examples - Gin](https://gowebexamples.com/gin/)
- [Gin GitHub Repository](https://github.com/gin-gonic/gin)

### Exercises

1. **Basic API**: Create a simple API with endpoints for listing, creating, updating, and deleting items in a to-do list.

2. **Authentication**: Implement a login system using JWT tokens and protect certain routes.

3. **File Upload API**: Build an API that allows users to upload images and retrieve them later.

4. **Validation**: Create an API endpoint that validates complex user registration data with custom validation rules.

5. **Logging Middleware**: Implement a middleware that logs all incoming requests with details like method, path, and response time.

By working through these exercises, you'll gain practical experience with Gin's request handling capabilities and be ready to build more complex applications.