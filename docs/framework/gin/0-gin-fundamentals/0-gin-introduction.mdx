---
title: Gin Introduction
description: A comprehensive introduction to the Gin web framework for Golang, covering its basic concepts, setup, and fundamental features for beginners.
slug: /framework/gin
---

# Gin Introduction

## What is Gin?

<div style={{
    "width": "20%",
    "margin": "0 auto",
    "text-align": "center"
}}>
    ![Gin logo](./img/gin_logo.png)
</div>


Gin is a high-performance HTTP web framework written in Go (Golang). It offers a martini-like API but with much better performance - up to 40 times faster thanks to its use of httprouter. If you're building web applications or microservices with Go, Gin provides a great balance of simplicity, performance, and functionality.

As a beginner-friendly framework, Gin simplifies many common web development tasks while maintaining the speed that Go is known for.

## Why Choose Gin?

- **Fast**: Built on top of httprouter, one of the fastest HTTP routers for Go
- **Middleware support**: Built-in support for middleware with an easy-to-use API
- **Crash-free**: Gin can catch panics and recover, ensuring your server stays up
- **JSON validation**: Easy validation of JSON requests
- **Routing groups**: For better API organization
- **Error management**: Helpful for managing HTTP errors
- **Rendering**: Built-in support for JSON, XML, and HTML rendering

## Setting Up Your First Gin Project

Let's get started with Gin by creating a simple "Hello World" application.

### Prerequisites

- Go installed on your system (version 1.16 or later recommended)
- Basic knowledge of Go syntax

### Step 1: Create a New Project

First, create a new directory for your project:

```bash
mkdir gin-hello-world
cd gin-hello-world
go mod init example/gin-hello-world
```

### Step 2: Install Gin

Install the Gin package:

```bash
go get -u github.com/gin-gonic/gin
```

### Step 3: Create Your First Gin Application

Create a file named `main.go` and add the following code:

```go
package main

import (
    "net/http"
    "github.com/gin-gonic/gin"
)

func main() {
    // Create a default Gin router
    router := gin.Default()
    
    // Define a route for the root path
    router.GET("/", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "message": "Hello, Gin World!",
        })
    })
    
    // Run the server on port 8080
    router.Run(":8080")
}
```

### Step 4: Run Your Application

Run your application with the following command:

```bash
go run main.go
```

You should see output similar to this:

```
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)
[GIN-debug] GET    /                         --> main.main.func1 (3 handlers)
[GIN-debug] Listening and serving HTTP on :8080
```

Now, open your browser and navigate to `http://localhost:8080` or use a tool like curl:

```bash
curl http://localhost:8080
```

You should see the JSON response:

```json
{"message":"Hello, Gin World!"}
```

## Understanding the Basic Structure

Let's break down the code example above:

1. **Importing Packages**: We import the Gin framework and the standard HTTP package.
   
2. **Creating a Router**: `gin.Default()` creates a router with default middleware (Logger and Recovery).
   
3. **Defining Routes**: `router.GET("/", ...)` defines what happens when a GET request is made to the root path.
   
4. **Handler Functions**: The function passed to `router.GET()` is called when the route is matched.
   
5. **Context**: The `gin.Context` parameter contains all the information about the request and provides methods to send responses.
   
6. **Sending Response**: `c.JSON()` sends a JSON response with a specified HTTP status code.
   
7. **Starting the Server**: `router.Run(":8080")` starts the server on the specified port.

## Working with Route Parameters

Gin makes it easy to extract parameters from URLs. Let's create an example:

```go
package main

import (
    "net/http"
    "github.com/gin-gonic/gin"
)

func main() {
    router := gin.Default()
    
    // Route with parameter
    router.GET("/user/:name", func(c *gin.Context) {
        name := c.Param("name")
        c.JSON(http.StatusOK, gin.H{
            "message": "Hello, " + name + "!",
        })
    })
    
    router.Run(":8080")
}
```

If you visit `http://localhost:8080/user/John`, you'll get:

```json
{"message":"Hello, John!"}
```

## Query Parameters

You can also handle query parameters easily:

```go
package main

import (
    "net/http"
    "github.com/gin-gonic/gin"
)

func main() {
    router := gin.Default()
    
    // Route with query parameters
    router.GET("/welcome", func(c *gin.Context) {
        name := c.DefaultQuery("name", "Guest")
        c.JSON(http.StatusOK, gin.H{
            "message": "Welcome, " + name + "!",
        })
    })
    
    router.Run(":8080")
}
```

If you visit `http://localhost:8080/welcome?name=Alice`, you'll get:

```json
{"message":"Welcome, Alice!"}
```

And if you visit without a parameter (`http://localhost:8080/welcome`), you'll get:

```json
{"message":"Welcome, Guest!"}
```

## Handling Form Data

Gin makes it simple to handle form submissions:

```go
package main

import (
    "net/http"
    "github.com/gin-gonic/gin"
)

func main() {
    router := gin.Default()
    
    router.POST("/form", func(c *gin.Context) {
        username := c.PostForm("username")
        password := c.PostForm("password")
        
        c.JSON(http.StatusOK, gin.H{
            "username": username,
            "password": "******", // Don't send real passwords!
            "status": "form received",
        })
    })
    
    router.Run(":8080")
}
```

You can test this using curl:

```bash
curl -X POST -d "username=johndoe&password=secret" http://localhost:8080/form
```

Output:

```json
{"password":"******","status":"form received","username":"johndoe"}
```

## A Real-World Example: Simple Task API

Let's create a more practical example - a simple REST API for managing tasks:

```go
package main

import (
    "net/http"
    "strconv"
    "github.com/gin-gonic/gin"
)

// Task represents a task with ID, title and status
type Task struct {
    ID     int    `json:"id"`
    Title  string `json:"title"`
    Status string `json:"status"`
}

func main() {
    router := gin.Default()
    
    // In-memory task storage
    tasks := []Task{
        {ID: 1, Title: "Learn Go", Status: "in progress"},
        {ID: 2, Title: "Learn Gin", Status: "pending"},
    }
    
    // Get all tasks
    router.GET("/tasks", func(c *gin.Context) {
        c.JSON(http.StatusOK, tasks)
    })
    
    // Get a specific task
    router.GET("/tasks/:id", func(c *gin.Context) {
        idStr := c.Param("id")
        id, err := strconv.Atoi(idStr)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID format"})
            return
        }
        
        for _, task := range tasks {
            if task.ID == id {
                c.JSON(http.StatusOK, task)
                return
            }
        }
        
        c.JSON(http.StatusNotFound, gin.H{"error": "Task not found"})
    })
    
    // Create a new task
    router.POST("/tasks", func(c *gin.Context) {
        var newTask Task
        if err := c.ShouldBindJSON(&newTask); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }
        
        // Assign a new ID (in a real app, this would be handled differently)
        newTask.ID = len(tasks) + 1
        tasks = append(tasks, newTask)
        
        c.JSON(http.StatusCreated, newTask)
    })
    
    router.Run(":8080")
}
```

This simple API allows you to:
1. Get all tasks (`GET /tasks`)
2. Get a specific task (`GET /tasks/:id`)
3. Create a new task (`POST /tasks`)

You can test the POST endpoint with:

```bash
curl -X POST -H "Content-Type: application/json" -d '{"title":"Learn RESTful API", "status":"pending"}' http://localhost:8080/tasks
```

## Using Middleware

Middleware functions are a powerful feature of Gin. They allow you to process requests before they reach your route handlers.

Here's a simple logging middleware example:

```go
package main

import (
    "log"
    "time"
    "github.com/gin-gonic/gin"
)

// Logger is a middleware function that logs request details
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        startTime := time.Now()
        
        // Process request
        c.Next()
        
        // After request is processed
        endTime := time.Now()
        latency := endTime.Sub(startTime)
        
        log.Printf("[%s] %s %s %v", 
            c.Request.Method, 
            c.Request.URL.Path, 
            c.ClientIP(), 
            latency,
        )
    }
}

func main() {
    router := gin.New() // Create a new router without any middleware
    
    // Use our custom logger middleware
    router.Use(Logger())
    
    // Recovery middleware recovers from any panics
    router.Use(gin.Recovery())
    
    router.GET("/", func(c *gin.Context) {
        c.JSON(200, gin.H{
            "message": "Hello, World!",
        })
    })
    
    router.Run(":8080")
}
```

When you make a request to the server, the middleware will log information about the request.

## Summary

In this introduction to Gin, we've learned:

- What Gin is and why it's a popular Go web framework
- How to set up a basic Gin project
- How to define routes and handle HTTP requests
- Working with route parameters and query parameters
- Handling form data and JSON payloads
- Creating a simple RESTful API
- Using middleware for request processing

Gin's combination of simplicity, performance, and functionality makes it an excellent choice for building web applications and APIs in Go, especially for beginners.

## Additional Resources

- [Official Gin Documentation](https://gin-gonic.com/docs/)
- [Gin GitHub Repository](https://github.com/gin-gonic/gin)
- [Go Web Examples: Gin](https://gowebexamples.com/gin/)

## Exercises

1. Extend the task API to include endpoints for updating and deleting tasks.
2. Create a middleware that checks for an API key in the request header.
3. Build a simple blog API with posts and comments using Gin.
4. Implement user authentication with JWT tokens.
5. Add proper validation for the task creation endpoint using Gin's binding features.