---
title: Echo Template Rendering
description: Learn how to render Echo templates to generate dynamic HTML content in your web applications.

---

# Echo Template Rendering

## Introduction

Template rendering is a crucial aspect of web development that allows you to generate dynamic HTML content. In the Echo framework, template rendering provides a way to separate your application's logic from its presentation layer. This separation makes your code more maintainable and helps you adhere to the Model-View-Controller (MVC) architectural pattern.

In this guide, we'll explore how to set up and use Echo's template rendering system to create dynamic web pages. Whether you're building a blog, e-commerce site, or any web application that requires dynamic content, understanding template rendering is essential.

## Understanding Template Rendering Basics

Template rendering involves two main components:
1. **Templates** - HTML files with special placeholders for dynamic content
2. **Data** - The values that will be inserted into those placeholders

When a user requests a page, the server processes the template and data together to generate a complete HTML page that's sent back to the user's browser.

## Setting Up Template Rendering in Echo

To use template rendering in Echo, you'll need to implement the `echo.Renderer` interface. Let's start with the basic setup:

```go
package main

import (
  "github.com/labstack/echo/v4"
  "html/template"
  "io"
  "net/http"
)

// TemplateRenderer is a custom renderer for Echo
type TemplateRenderer struct {
  templates *template.Template
}

// Render implements the echo.Renderer interface
func (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c echo.Context) error {
  return t.templates.ExecuteTemplate(w, name, data)
}

func main() {
  e := echo.New()
  
  // Initialize renderer
  renderer := &TemplateRenderer{
    templates: template.Must(template.ParseGlob("views/*.html")),
  }
  
  // Set renderer
  e.Renderer = renderer
  
  // Routes
  e.GET("/", func(c echo.Context) error {
    return c.Render(http.StatusOK, "index.html", map[string]interface{}{
      "title": "Echo Template Rendering",
      "message": "Hello, World!",
    })
  })
  
  e.Logger.Fatal(e.Start(":8080"))
}
```

In the code above, we:
1. Create a `TemplateRenderer` struct that implements the `echo.Renderer` interface
2. Load all HTML templates from a "views" directory
3. Register the renderer with Echo
4. Set up a route that renders the "index.html" template with some data

## Creating Your First Template

Let's create a simple template file. Create a directory named `views` and inside it, create a file called `index.html`:

```html
<!DOCTYPE html>
<html>
<head>
  <title>{{.title}}</title>
</head>
<body>
  <h1>{{.title}}</h1>
  <p>{{.message}}</p>
</body>
</html>
```

In this template:
- `{{.title}}` and `{{.message}}` are placeholders that will be replaced with actual values during rendering
- The dot (`.`) refers to the data passed to the template

## Passing Data to Templates

You can pass various types of data to your templates:

```go
e.GET("/user", func(c echo.Context) error {
  // Pass a struct as data
  user := struct {
    Name  string
    Email string
    Age   int
  }{
    Name:  "John Doe",
    Email: "john@example.com",
    Age:   30,
  }
  
  return c.Render(http.StatusOK, "user.html", user)
})
```

With the corresponding `user.html` template:

```html
<!DOCTYPE html>
<html>
<head>
  <title>User Profile</title>
</head>
<body>
  <h1>User Profile</h1>
  <ul>
    <li>Name: {{.Name}}</li>
    <li>Email: {{.Email}}</li>
    <li>Age: {{.Age}}</li>
  </ul>
</body>
</html>
```

## Template Logic and Control Structures

Go templates support conditional statements, loops, and other control structures:

### Conditionals

```html
{{if .IsAdmin}}
  <div class="admin-panel">
    <h2>Admin Controls</h2>
    <button>Manage Users</button>
  </div>
{{else}}
  <p>You need admin privileges to access additional features.</p>
{{end}}
```

### Loops

```html
<h2>Product List</h2>
<ul>
  {{range .Products}}
    <li>{{.Name}} - ${{.Price}}</li>
  {{end}}
</ul>
```

## Using Template Functions

Go templates support functions that can transform data. Echo allows you to add custom functions to your templates:

```go
func main() {
  e := echo.New()
  
  // Create template with functions
  t := template.New("views").Funcs(template.FuncMap{
    "formatDate": func(t time.Time) string {
      return t.Format("Jan 02, 2006")
    },
    "upper": strings.ToUpper,
  })
  
  // Parse templates
  templates, err := t.ParseGlob("views/*.html")
  if err != nil {
    e.Logger.Fatal(err)
  }
  
  // Set renderer
  e.Renderer = &TemplateRenderer{
    templates: templates,
  }
  
  // Routes...
}
```

In your template, you can use these functions:

```html
<p>Published on: {{formatDate .PublishedAt}}</p>
<p>Category: {{upper .Category}}</p>
```

## Template Inheritance and Composition

For larger applications, you might want to use template inheritance to avoid code duplication. This involves creating a base template and then extending it in other templates.

First, create a `base.html` template:

```html
<!DOCTYPE html>
<html>
<head>
  <title>{{template "title" .}}</title>
  <link rel="stylesheet" href="/static/css/styles.css">
</head>
<body>
  <header>
    <nav>
      <a href="/">Home</a>
      <a href="/about">About</a>
      <a href="/contact">Contact</a>
    </nav>
  </header>
  
  <main>
    {{template "content" .}}
  </main>
  
  <footer>
    &copy; {{.Year}} My Website
  </footer>
</body>
</html>
```

Then create a `home.html` template that extends it:

```html
{{define "title"}}Home Page{{end}}

{{define "content"}}
  <h1>Welcome to our site!</h1>
  <p>{{.message}}</p>
  
  <section class="featured">
    <h2>Featured Articles</h2>
    <ul>
      {{range .featuredArticles}}
        <li>
          <h3>{{.Title}}</h3>
          <p>{{.Summary}}</p>
        </li>
      {{end}}
    </ul>
  </section>
{{end}}
```

## Real-World Example: Blog Post Rendering

Let's create a more comprehensive example of a blog site with template rendering:

```go
package main

import (
  "github.com/labstack/echo/v4"
  "html/template"
  "io"
  "net/http"
  "time"
)

type Post struct {
  ID        int
  Title     string
  Content   string
  Author    string
  CreatedAt time.Time
}

type TemplateRenderer struct {
  templates *template.Template
}

func (t *TemplateRenderer) Render(w io.Writer, name string, data interface{}, c echo.Context) error {
  return t.templates.ExecuteTemplate(w, name, data)
}

func main() {
  e := echo.New()
  
  // Create template functions
  funcMap := template.FuncMap{
    "formatDate": func(t time.Time) string {
      return t.Format("Jan 02, 2006")
    },
    "excerpt": func(content string, length int) string {
      if len(content) <= length {
        return content
      }
      return content[:length] + "..."
    },
  }
  
  // Initialize renderer with functions
  t := template.New("views").Funcs(funcMap)
  templates, err := t.ParseGlob("views/*.html")
  if err != nil {
    e.Logger.Fatal(err)
  }
  
  e.Renderer = &TemplateRenderer{
    templates: templates,
  }
  
  // Mock database
  posts := []Post{
    {
      ID:        1,
      Title:     "Getting Started with Echo",
      Content:   "Echo is a high performance, extensible, minimalist web framework for Go.",
      Author:    "John Doe",
      CreatedAt: time.Now().AddDate(0, 0, -3),
    },
    {
      ID:        2,
      Title:     "Template Rendering in Echo",
      Content:   "Learn how to render beautiful templates with Echo framework.",
      Author:    "Jane Smith",
      CreatedAt: time.Now().AddDate(0, 0, -1),
    },
  }
  
  // Routes
  e.GET("/", func(c echo.Context) error {
    return c.Render(http.StatusOK, "blog-list.html", map[string]interface{}{
      "title": "My Tech Blog",
      "posts": posts,
      "year":  time.Now().Year(),
    })
  })
  
  e.GET("/post/:id", func(c echo.Context) error {
    id := c.Param("id")
    for _, post := range posts {
      if post.ID == 1 { // In a real app, parse ID from string
        return c.Render(http.StatusOK, "blog-post.html", map[string]interface{}{
          "title": post.Title,
          "post":  post,
          "year":  time.Now().Year(),
        })
      }
    }
    return c.String(http.StatusNotFound, "Post not found")
  })
  
  e.Logger.Fatal(e.Start(":8080"))
}
```

Now, create these templates in your `views` directory:

`blog-list.html`:
```html
{{define "title"}}{{.title}}{{end}}

{{define "content"}}
  <h1>{{.title}}</h1>
  
  <div class="blog-posts">
    {{range .posts}}
      <article class="post-preview">
        <h2><a href="/post/{{.ID}}">{{.Title}}</a></h2>
        <div class="meta">
          By {{.Author}} on {{formatDate .CreatedAt}}
        </div>
        <p>{{excerpt .Content 100}}</p>
        <a href="/post/{{.ID}}">Read more â†’</a>
      </article>
    {{end}}
  </div>
{{end}}
```

`blog-post.html`:
```html
{{define "title"}}{{.title}}{{end}}

{{define "content"}}
  <article class="blog-post">
    <h1>{{.post.Title}}</h1>
    
    <div class="meta">
      Written by {{.post.Author}} on {{formatDate .post.CreatedAt}}
    </div>
    
    <div class="content">
      {{.post.Content}}
    </div>
    
    <div class="actions">
      <a href="/">&larr; Back to all posts</a>
    </div>
  </article>
{{end}}
```

## Performance Considerations

Template rendering can be resource-intensive, especially for large templates or high-traffic sites. Here are some performance tips:

1. **Pre-compile templates**: Load and parse templates during application startup rather than on each request
2. **Cache rendered content**: For pages that don't change frequently
3. **Use template fragments**: Render only what's necessary instead of entire pages
4. **Consider template caching middleware**: For complex applications

## Common Pitfalls and Solutions

### Missing Template Files

If you get "template not found" errors, check:
- File paths are correct
- Template naming is consistent
- The template exists in the directory specified in `ParseGlob`

### Data Not Displaying

If your data isn't showing up:
- Ensure variable names match between your Go code and templates
- Check for typos in field names
- Verify the data is actually being passed correctly

### HTML Escaping Issues

By default, Go templates escape HTML to prevent XSS attacks. If you need to output HTML safely:

```html
<!-- This will be escaped: -->
<div>{{.htmlContent}}</div>

<!-- This will NOT be escaped: -->
<div>{{.htmlContent | safeHTML}}</div>
```

To enable the `safeHTML` function:

```go
funcMap := template.FuncMap{
  "safeHTML": func(s string) template.HTML {
    return template.HTML(s)
  },
}
```

## Summary

Echo template rendering provides a flexible and powerful way to generate dynamic HTML content for your web applications. In this guide, we've covered:

- Setting up a template renderer in Echo
- Creating and structuring templates
- Passing different types of data to templates
- Using conditionals and loops in templates
- Adding custom functions to enhance templates
- Implementing template inheritance for DRY code
- Building a real-world blog example
- Performance considerations and common pitfalls

By mastering template rendering, you can create more maintainable web applications with a clear separation between logic and presentation.

## Additional Resources

- [Echo Documentation](https://echo.labstack.com/guide/templates)
- [Go Template Package Documentation](https://golang.org/pkg/html/template/)
- [Echo GitHub Repository](https://github.com/labstack/echo)

## Exercises

1. Create a template for a product listing page that includes filters and sorting options
2. Implement a contact form template that shows validation errors
3. Build a dashboard template with multiple widgets that each display different data
4. Extend the blog example to include categories and tags
5. Create a template with pagination for large collections of items

Remember that practice is key to mastering template rendering. Start with simple templates and gradually add complexity as your skills improve.