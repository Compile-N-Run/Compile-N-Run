---
title: Echo Security Middleware
description: Learn how to implement and customize security middleware in Echo framework to protect your web applications from common vulnerabilities and attacks.

---

# Echo Security Middleware

## Introduction

Security is a critical aspect of any web application. As your application grows and becomes more complex, it becomes increasingly important to implement robust security measures to protect against various threats and vulnerabilities. The Echo framework provides several built-in security middleware components that you can easily integrate into your applications to enhance security.

In this guide, we'll explore Echo's security middleware options, understand how they work, and learn how to implement them effectively in your web applications.

## What is Security Middleware?

Security middleware in Echo acts as a protective layer that sits between the incoming HTTP requests and your application's handlers. These middleware functions inspect, validate, and potentially modify requests and responses to ensure they meet specific security criteria before reaching your application logic.

Echo provides several built-in security middleware components that address common security concerns:

- CORS (Cross-Origin Resource Sharing)
- CSRF (Cross-Site Request Forgery) Protection
- Secure Headers
- Rate Limiting
- JWT (JSON Web Token) Authentication

## Basic Security Middleware Setup

Let's start by learning how to integrate security middleware into your Echo application:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    // Create a new Echo instance
    e := echo.New()
    
    // Implement basic security middleware
    e.Use(middleware.Secure())
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Routes
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Hello, secure world!")
    })
    
    // Start server
    e.Logger.Fatal(e.Start(":8080"))
}
```

In this example, we've added the `middleware.Secure()` middleware, which applies several security-related HTTP headers to responses. Let's dive deeper into each security middleware component.

## CORS Middleware

Cross-Origin Resource Sharing (CORS) is a mechanism that allows resources on a web page to be requested from another domain outside the domain from which the resource originated.

### Basic CORS Implementation

```go
// Enable CORS with default configuration
e.Use(middleware.CORS())
```

### Customized CORS Configuration

```go
// Custom CORS configuration
e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
    AllowOrigins: []string{"https://example.com", "https://another-site.com"},
    AllowMethods: []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete},
    AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept},
    AllowCredentials: true,
    MaxAge: 86400, // Maximum age (in seconds) of the preflight request cache
}))
```

When a request comes from `https://example.com` to your API, the CORS middleware will add appropriate headers to allow the request to proceed. For origins not listed, the request will be blocked by the browser.

## CSRF Protection

Cross-Site Request Forgery (CSRF) is an attack that forces authenticated users to execute unwanted actions on a web application in which they're currently authenticated.

### Basic CSRF Implementation

```go
// Enable CSRF protection
e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
    TokenLookup: "form:csrf",
    CookieName:  "csrf",
    CookieMaxAge: 3600,
}))
```

### Example with CSRF in HTML Form

```go
// Server-side handler to render a form with CSRF token
e.GET("/form", func(c echo.Context) error {
    // Get the CSRF token
    token := c.Get(middleware.DefaultCSRFConfig.ContextKey).(string)
    
    // Render form with CSRF token
    form := `
    <form method="POST" action="/process">
        <input type="hidden" name="csrf" value="` + token + `">
        <input type="text" name="name">
        <button type="submit">Submit</button>
    </form>
    `
    return c.HTML(http.StatusOK, form)
})

// Handler to process the form
e.POST("/process", func(c echo.Context) error {
    return c.String(http.StatusOK, "Form processed successfully!")
})
```

When a user visits the `/form` endpoint, they'll receive an HTML form with a hidden CSRF token. When they submit the form, the CSRF middleware will validate the token before allowing the POST request to proceed.

## Secure Headers

The `Secure` middleware adds several security-related HTTP headers to protect your application:

```go
// Default secure headers
e.Use(middleware.Secure())

// Customized secure headers
e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
    XSSProtection:         "1; mode=block",
    ContentTypeNosniff:    "nosniff",
    XFrameOptions:         "SAMEORIGIN",
    HSTSMaxAge:            3600,
    HSTSExcludeSubdomains: false,
    ContentSecurityPolicy: "default-src 'self'",
}))
```

This middleware adds headers like:
- `X-XSS-Protection` to mitigate cross-site scripting attacks
- `X-Content-Type-Options` to prevent MIME-sniffing
- `X-Frame-Options` to prevent clickjacking
- `Strict-Transport-Security` to enforce HTTPS
- `Content-Security-Policy` to control resources the browser is allowed to load

## Rate Limiting

Rate limiting helps protect your application from brute force attacks and DoS attacks by limiting the number of requests a client can make within a specific time period.

```go
// Rate limiting middleware
e.Use(middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
    Store: middleware.NewRateLimiterMemoryStore(20), // 20 requests per second
}))
```

For more advanced configuration:

```go
// More customized rate limiting
e.Use(middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
    Skipper: middleware.DefaultSkipper,
    Store: middleware.NewRateLimiterMemoryStoreWithConfig(
        middleware.RateLimiterMemoryStoreConfig{
            Rate:      10,  // 10 requests per time unit
            Burst:     30,  // Allow bursts of up to 30 requests
            ExpiresIn: 1 * time.Minute, // Time unit (1 minute)
        },
    ),
    IdentifierExtractor: func(c echo.Context) (string, error) {
        // Use IP address as identifier
        return c.RealIP(), nil
    },
    ErrorHandler: func(c echo.Context, err error) error {
        return c.JSON(http.StatusTooManyRequests, map[string]string{
            "message": "Too many requests, please try again later.",
        })
    },
    DenyHandler: func(c echo.Context, identifier string, err error) error {
        return c.JSON(http.StatusTooManyRequests, map[string]string{
            "message": "Rate limit exceeded.",
        })
    },
}))
```

This configuration will limit each IP address to 10 requests per minute, with the ability to burst up to 30 requests. When the limit is exceeded, the client will receive a "429 Too Many Requests" response.

## JWT Authentication

JSON Web Tokens (JWT) provide a way to secure your API endpoints by requiring valid authentication tokens for access.

### Setting Up JWT Middleware

```go
// JWT middleware
e.Use(middleware.JWTWithConfig(middleware.JWTConfig{
    SigningKey: []byte("your-secret-key"),
    TokenLookup: "header:Authorization",
}))

// Protected route
e.GET("/protected", func(c echo.Context) error {
    // Get user from JWT token
    user := c.Get("user").(*jwt.Token)
    claims := user.Claims.(jwt.MapClaims)
    name := claims["name"].(string)
    return c.String(http.StatusOK, "Welcome "+name+"!")
})
```

### Example of JWT Token Generation

```go
// Login endpoint to generate JWT token
e.POST("/login", func(c echo.Context) error {
    username := c.FormValue("username")
    password := c.FormValue("password")
    
    // Check credentials (this is simplified - use proper authentication)
    if username == "admin" && password == "password" {
        // Create token
        token := jwt.New(jwt.SigningMethodHS256)
        
        // Set claims
        claims := token.Claims.(jwt.MapClaims)
        claims["name"] = username
        claims["admin"] = true
        claims["exp"] = time.Now().Add(time.Hour * 24).Unix()
        
        // Generate encoded token
        t, err := token.SignedString([]byte("your-secret-key"))
        if err != nil {
            return err
        }
        
        return c.JSON(http.StatusOK, map[string]string{
            "token": t,
        })
    }
    
    return echo.ErrUnauthorized
})
```

When a user successfully logs in, they receive a JWT token. To access protected routes, they must include this token in the Authorization header of subsequent requests.

## Combining Multiple Security Middleware

In real-world applications, you'll typically use multiple security middleware components together:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
    "net/http"
)

func main() {
    e := echo.New()
    
    // Logger and recovery middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Security middleware
    e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
        XSSProtection:         "1; mode=block",
        ContentTypeNosniff:    "nosniff",
        XFrameOptions:         "SAMEORIGIN",
        HSTSMaxAge:            3600,
        ContentSecurityPolicy: "default-src 'self'",
    }))
    
    // CORS
    e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
        AllowOrigins: []string{"https://example.com"},
        AllowMethods: []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete},
    }))
    
    // Rate limiting
    e.Use(middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
        Store: middleware.NewRateLimiterMemoryStore(10), // 10 requests per second
    }))
    
    // Public routes
    e.POST("/login", loginHandler)
    e.GET("/public", publicHandler)
    
    // Protected group
    r := e.Group("/api")
    
    // JWT middleware for protected routes
    r.Use(middleware.JWTWithConfig(middleware.JWTConfig{
        SigningKey: []byte("your-secret-key"),
    }))
    
    // Protected routes
    r.GET("/users", getUsersHandler)
    r.POST("/users", createUserHandler)
    
    e.Logger.Fatal(e.Start(":8080"))
}

// Handler functions
func loginHandler(c echo.Context) error {
    // Implementation...
    return nil
}

func publicHandler(c echo.Context) error {
    return c.String(http.StatusOK, "This is a public endpoint")
}

func getUsersHandler(c echo.Context) error {
    return c.String(http.StatusOK, "Get all users")
}

func createUserHandler(c echo.Context) error {
    return c.String(http.StatusCreated, "User created")
}
```

This example shows a more complete application structure with both public and protected routes, using multiple security middleware components.

## Creating Custom Security Middleware

Sometimes you may need to create custom security middleware for specific requirements. Here's an example of a simple API key authentication middleware:

```go
// APIKeyMiddleware checks for a valid API key in the request header
func APIKeyMiddleware(validAPIKeys []string) echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            // Get API key from header
            apiKey := c.Request().Header.Get("X-API-Key")
            
            // Check if API key is valid
            valid := false
            for _, key := range validAPIKeys {
                if apiKey == key {
                    valid = true
                    break
                }
            }
            
            if !valid {
                return echo.NewHTTPError(http.StatusUnauthorized, "Invalid API key")
            }
            
            return next(c)
        }
    }
}
```

Using the custom middleware:

```go
// Valid API keys
validKeys := []string{"key1", "key2", "key3"}

// Apply API key middleware to specific group
apiGroup := e.Group("/api")
apiGroup.Use(APIKeyMiddleware(validKeys))

// Protected routes
apiGroup.GET("/data", getDataHandler)
```

With this middleware, requests to `/api/data` must include a valid API key in the `X-API-Key` header.

## Best Practices for Echo Security Middleware

1. **Use HTTPS**: Always serve your production application over HTTPS.
2. **Store Secrets Securely**: Don't hardcode secret keys in your code. Use environment variables or a secure vault.
3. **Implement Proper Rate Limiting**: Adjust rate limits based on your application's needs and resources.
4. **Set Appropriate CORS Policies**: Only allow trusted domains to access your API.
5. **Use Strong JWT Secrets**: Use long, random strings for JWT signing keys and rotate them periodically.
6. **Enable Security Headers**: Always use the Secure middleware to set important security headers.
7. **Validate All Input**: Even with security middleware, always validate and sanitize user input.
8. **Implement Proper Error Handling**: Don't expose sensitive information in error messages.

## Summary

Echo's security middleware provides a robust set of tools to protect your web applications from common vulnerabilities and attacks. By implementing CORS, CSRF protection, secure headers, rate limiting, and JWT authentication, you can significantly enhance the security posture of your application.

Remember that security is a layered approach, and middleware is just one component of a comprehensive security strategy. Always follow security best practices and keep your dependencies updated to protect against emerging threats.

## Additional Resources

- [Echo Middleware Documentation](https://echo.labstack.com/middleware/)
- [OWASP Top Ten](https://owasp.org/www-project-top-ten/) - Common web application security risks
- [JWT.io](https://jwt.io/) - Information and debugging tools for JWT
- [Content Security Policy Reference](https://content-security-policy.com/)

## Exercise

1. Create an Echo application with at least three protected routes using JWT authentication.
2. Implement rate limiting that allows different limits for authenticated vs. unauthenticated users.
3. Create a custom middleware that logs detailed information about potential security incidents (failed logins, rate limit exceeded, etc.).
4. Implement different security configurations for development vs. production environments.