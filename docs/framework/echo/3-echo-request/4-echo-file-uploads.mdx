---
title: Echo File Uploads
description: Learn how to handle file uploads in Echo web applications, including multipart form data processing, file validation, and saving uploaded files to the server.

---

# Echo File Uploads

When building web applications, handling file uploads is a common requirement. Whether you're building an image gallery, a document management system, or simply allowing users to upload profile pictures, understanding how to process file uploads is crucial. In this tutorial, we'll explore how to handle file uploads in Echo, a high-performance web framework for Go.

## Introduction to File Uploads in Echo

Echo makes handling file uploads straightforward through its context object and built-in multipart form parsing capabilities. File uploads typically happen through HTML forms with the `enctype="multipart/form-data"` attribute, which allows the browser to send files along with other form data.

The uploaded files are accessible via the `FormFile()` method in the Echo context, which returns the file, header information, and any errors encountered during the upload process.

## Basic File Upload Setup

Let's start with a basic example of handling file uploads in Echo:

### HTML Form

First, we need an HTML form that enables users to select and upload files:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Echo File Upload</title>
</head>
<body>
    <h1>Upload File</h1>
    <form action="/upload" method="POST" enctype="multipart/form-data">
        <input type="file" name="file">
        <button type="submit">Upload</button>
    </form>
</body>
</html>
```

### Echo Server to Handle the Upload

Now, let's create an Echo server that can handle the file upload:

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "path/filepath"

    "github.com/labstack/echo/v4"
)

func main() {
    e := echo.New()

    // Serve the HTML form
    e.GET("/", func(c echo.Context) error {
        return c.File("public/upload.html")
    })

    // Handle file upload
    e.POST("/upload", handleFileUpload)

    e.Logger.Fatal(e.Start(":1323"))
}

func handleFileUpload(c echo.Context) error {
    // Get the file from the request
    file, err := c.FormFile("file")
    if err != nil {
        return err
    }

    // Source file
    src, err := file.Open()
    if err != nil {
        return err
    }
    defer src.Close()

    // Create upload directory if it doesn't exist
    uploadDir := "uploads"
    if err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {
        return err
    }

    // Destination file
    dst, err := os.Create(filepath.Join(uploadDir, file.Filename))
    if err != nil {
        return err
    }
    defer dst.Close()

    // Copy the uploaded file to the destination file
    if _, err = io.Copy(dst, src); err != nil {
        return err
    }

    return c.HTML(http.StatusOK, fmt.Sprintf("<p>File %s uploaded successfully.</p>", file.Filename))
}
```

In this basic example:
1. We define a route to serve an HTML form for file upload
2. We create a POST route to handle the upload
3. We retrieve the file from the request using `c.FormFile()`
4. We create a destination file and copy the contents from the uploaded file

## Handling Multiple File Uploads

Sometimes you need to allow users to upload multiple files at once. Here's how to modify our code to handle multiple file uploads:

### HTML Form for Multiple Files

```html
<!DOCTYPE html>
<html>
<head>
    <title>Echo Multiple File Upload</title>
</head>
<body>
    <h1>Upload Multiple Files</h1>
    <form action="/upload-multiple" method="POST" enctype="multipart/form-data">
        <input type="file" name="files" multiple>
        <button type="submit">Upload</button>
    </form>
</body>
</html>
```

### Echo Server to Handle Multiple Files

```go
func handleMultipleFileUploads(c echo.Context) error {
    // Get the form
    form, err := c.MultipartForm()
    if err != nil {
        return err
    }
    
    // Get the files from the form
    files := form.File["files"]
    
    // Create upload directory
    uploadDir := "uploads"
    if err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {
        return err
    }
    
    // Process each file
    for _, file := range files {
        // Source
        src, err := file.Open()
        if err != nil {
            return err
        }
        defer src.Close()
        
        // Destination
        dst, err := os.Create(filepath.Join(uploadDir, file.Filename))
        if err != nil {
            return err
        }
        defer dst.Close()
        
        // Copy
        if _, err = io.Copy(dst, src); err != nil {
            return err
        }
    }
    
    return c.HTML(http.StatusOK, fmt.Sprintf("<p>%d files uploaded successfully.</p>", len(files)))
}
```

## File Validation

It's important to validate uploaded files for security reasons. Let's add some basic validation:

```go
func handleFileUploadWithValidation(c echo.Context) error {
    // Source file
    file, err := c.FormFile("file")
    if err != nil {
        return err
    }
    
    // Validate file size (max 5MB)
    if file.Size > 5*1024*1024 {
        return c.String(http.StatusBadRequest, "File too large! Maximum size is 5MB")
    }
    
    // Validate file type by extension
    ext := filepath.Ext(file.Filename)
    allowedExts := map[string]bool{
        ".jpg": true,
        ".jpeg": true,
        ".png": true,
        ".gif": true,
    }
    
    if !allowedExts[ext] {
        return c.String(http.StatusBadRequest, "Invalid file type! Only JPG, PNG, and GIF files are allowed")
    }
    
    // Continue with file handling...
    src, err := file.Open()
    if err != nil {
        return err
    }
    defer src.Close()
    
    // Generate a unique filename to prevent overwriting
    uniqueFilename := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
    uploadPath := filepath.Join("uploads", uniqueFilename)
    
    // Create destination file
    dst, err := os.Create(uploadPath)
    if err != nil {
        return err
    }
    defer dst.Close()
    
    // Copy contents
    if _, err = io.Copy(dst, src); err != nil {
        return err
    }
    
    return c.HTML(http.StatusOK, fmt.Sprintf("<p>File uploaded successfully as %s</p>", uniqueFilename))
}
```

## Practical Example: Image Upload Service

Let's build a more complete example of an image upload service:

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
    "path/filepath"
    "strings"
    "time"

    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    e := echo.New()
    
    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Serve static files
    e.Static("/uploads", "uploads")
    
    // Routes
    e.GET("/", func(c echo.Context) error {
        return c.File("public/index.html")
    })
    
    e.POST("/upload", uploadImage)
    
    // Start server
    e.Logger.Fatal(e.Start(":1323"))
}

func uploadImage(c echo.Context) error {
    // Get file from request
    file, err := c.FormFile("image")
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "No file provided",
        })
    }
    
    // Validate file size (max 5MB)
    if file.Size > 5*1024*1024 {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "File too large! Maximum size is 5MB",
        })
    }
    
    // Validate file type
    ext := strings.ToLower(filepath.Ext(file.Filename))
    if ext != ".jpg" && ext != ".jpeg" && ext != ".png" && ext != ".gif" {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid file type! Only JPG, PNG, and GIF files are allowed",
        })
    }
    
    // Create uploads directory if it doesn't exist
    uploadDir := "uploads"
    if err := os.MkdirAll(uploadDir, os.ModePerm); err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to create upload directory",
        })
    }
    
    // Generate unique filename
    uniqueFilename := fmt.Sprintf("%d%s", time.Now().UnixNano(), ext)
    uploadPath := filepath.Join(uploadDir, uniqueFilename)
    
    // Source
    src, err := file.Open()
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to open uploaded file",
        })
    }
    defer src.Close()
    
    // Destination
    dst, err := os.Create(uploadPath)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to create destination file",
        })
    }
    defer dst.Close()
    
    // Copy contents
    if _, err = io.Copy(dst, src); err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to save the file",
        })
    }
    
    // Return success response with file URL
    return c.JSON(http.StatusOK, map[string]string{
        "message": "File uploaded successfully",
        "filename": uniqueFilename,
        "url": "/uploads/" + uniqueFilename,
    })
}
```

The corresponding HTML for this example would be:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Image Upload Service</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
        .preview { margin-top: 20px; }
        img { max-width: 100%; }
    </style>
</head>
<body>
    <h1>Image Upload Service</h1>
    
    <form id="uploadForm">
        <input type="file" id="imageInput" name="image" accept="image/*">
        <button type="submit">Upload</button>
    </form>
    
    <div class="preview" id="preview"></div>
    
    <script>
        document.getElementById('uploadForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            const fileInput = document.getElementById('imageInput');
            if (!fileInput.files.length) {
                alert('Please select a file first!');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', fileInput.files[0]);
            
            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok) {
                    const preview = document.getElementById('preview');
                    preview.innerHTML = `
                        <h3>Upload successful!</h3>
                        <p>File URL: <a href="${result.url}" target="_blank">${result.url}</a></p>
                        <img src="${result.url}" alt="Uploaded image">
                    `;
                } else {
                    alert(`Error: ${result.error}`);
                }
            } catch (error) {
                alert('An error occurred during the upload.');
                console.error(error);
            }
        });
    </script>
</body>
</html>
```

## Advanced Topics

### Progress Tracking

For larger file uploads, providing progress feedback to users can greatly improve the user experience. While Echo doesn't directly provide progress tracking, you can implement it using JavaScript on the client side:

```html
<script>
document.getElementById('uploadForm').addEventListener('submit', function(e) {
    e.preventDefault();
    
    const fileInput = document.getElementById('imageInput');
    const progressBar = document.getElementById('progressBar');
    
    if (!fileInput.files.length) {
        alert('Please select a file first!');
        return;
    }
    
    const formData = new FormData();
    formData.append('image', fileInput.files[0]);
    
    const xhr = new XMLHttpRequest();
    
    // Track upload progress
    xhr.upload.addEventListener('progress', function(e) {
        if (e.lengthComputable) {
            const percentComplete = (e.loaded / e.total) * 100;
            progressBar.value = percentComplete;
            document.getElementById('progressText').textContent = `${Math.round(percentComplete)}%`;
        }
    });
    
    xhr.open('POST', '/upload', true);
    
    xhr.onload = function() {
        if (xhr.status === 200) {
            const result = JSON.parse(xhr.responseText);
            const preview = document.getElementById('preview');
            preview.innerHTML = `
                <h3>Upload successful!</h3>
                <p>File URL: <a href="${result.url}" target="_blank">${result.url}</a></p>
                <img src="${result.url}" alt="Uploaded image">
            `;
        } else {
            alert('Upload failed');
        }
    };
    
    xhr.send(formData);
});
</script>
```

### Handling Large File Uploads

For large file uploads, you might need to adjust some server configurations:

```go
func main() {
    e := echo.New()
    
    // Set maximum request body size to 20MB
    e.Use(middleware.BodyLimit("20M"))
    
    // Other configurations...
    
    e.POST("/upload", uploadFile)
    
    e.Logger.Fatal(e.Start(":1323"))
}
```

### File Storage Considerations

For production applications, you might want to store uploaded files in cloud storage services like AWS S3, Google Cloud Storage, or Azure Blob Storage rather than on the local filesystem. Here's a simplified example using AWS S3:

```go
import (
    "github.com/aws/aws-sdk-go/aws"
    "github.com/aws/aws-sdk-go/aws/session"
    "github.com/aws/aws-sdk-go/service/s3/s3manager"
)

func uploadToS3(c echo.Context) error {
    // Get file from request
    file, err := c.FormFile("file")
    if err != nil {
        return err
    }
    
    src, err := file.Open()
    if err != nil {
        return err
    }
    defer src.Close()
    
    // Create an AWS session
    sess := session.Must(session.NewSession(&aws.Config{
        Region: aws.String("us-west-2"),
    }))
    
    // Create S3 uploader
    uploader := s3manager.NewUploader(sess)
    
    // Upload to S3
    result, err := uploader.Upload(&s3manager.UploadInput{
        Bucket: aws.String("your-bucket-name"),
        Key:    aws.String(file.Filename),
        Body:   src,
        ACL:    aws.String("public-read"),
    })
    if err != nil {
        return err
    }
    
    return c.JSON(http.StatusOK, map[string]string{
        "message": "File uploaded successfully to S3",
        "url":     result.Location,
    })
}
```

## Summary

In this tutorial, we covered how to handle file uploads in Echo web applications, including:

1. Basic file upload handling
2. Multiple file uploads
3. File validation (size and type)
4. Building a complete image upload service
5. Advanced topics like progress tracking and large file handling
6. Considerations for cloud storage solutions

File uploads are an essential part of many web applications, and Echo provides the tools you need to handle them efficiently and securely. Remember to always validate uploads for security reasons and consider using cloud storage solutions for scalable production applications.

## Additional Resources

- [Echo Framework Documentation](https://echo.labstack.com/)
- [Go's multipart package documentation](https://golang.org/pkg/mime/multipart/)
- [AWS SDK for Go Documentation](https://docs.aws.amazon.com/sdk-for-go/)
- [Google Cloud Storage Client Libraries](https://cloud.google.com/storage/docs/reference/libraries)

## Exercises

1. Implement a simple file uploader that accepts PDF documents and validates their content type
2. Create a photo gallery application that generates thumbnails for uploaded images
3. Implement a drag-and-drop file upload interface with progress tracking
4. Build a file upload system with a maximum quota per user
5. Create a secure file sharing system where uploads are only accessible with a generated token

By applying the concepts you've learned in this tutorial, you'll be well-equipped to implement robust file upload functionality in your Echo web applications.