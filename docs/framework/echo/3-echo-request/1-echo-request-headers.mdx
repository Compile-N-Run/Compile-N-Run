---
title: Echo Request Headers
description: Learn how to view, manipulate, and use HTTP request headers in your web applications, with practical examples and best practices.

---

# Echo Request Headers

## Introduction

HTTP request headers are a crucial part of web communication, containing important information about the request being sent from a client to a server. These headers provide metadata about the request, such as the client's browser type, preferred languages, authentication credentials, and much more.

Understanding how to access and manipulate request headers is an essential skill for web developers, as it allows you to create more dynamic, responsive, and secure web applications. In this guide, we'll explore how to echo (display and use) HTTP request headers in your applications.

## What are HTTP Request Headers?

HTTP request headers are key-value pairs sent by the client (usually a web browser) to the server when making a request. Each header communicates specific information that helps the server understand how to process the request.

Common request headers include:

- `User-Agent`: Identifies the client application or browser
- `Accept`: Specifies which content types the client can understand
- `Authorization`: Contains credentials for authenticating the client
- `Content-Type`: Indicates the media type of the request body
- `Cookie`: Contains stored HTTP cookies previously sent by the server

## Accessing Request Headers

Different programming languages and frameworks provide various ways to access request headers. Let's look at some common approaches:

### Node.js with Express

```javascript
const express = require('express');
const app = express();

app.get('/headers', (req, res) => {
  const headers = req.headers;
  res.json(headers);
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});
```

### Python with Flask

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/headers')
def get_headers():
    headers = dict(request.headers)
    return jsonify(headers)

if __name__ == '__main__':
    app.run(debug=True, port=3000)
```

### PHP

```php
<?php
header('Content-Type: application/json');

$headers = getallheaders();
echo json_encode($headers, JSON_PRETTY_PRINT);
?>
```

## Displaying Specific Headers

Often, you'll only need specific headers rather than all of them. Here's how you can access individual headers:

### Node.js with Express

```javascript
app.get('/user-agent', (req, res) => {
  const userAgent = req.headers['user-agent'];
  res.send(`Your User-Agent is: ${userAgent}`);
});

app.get('/accept-language', (req, res) => {
  const language = req.headers['accept-language'];
  res.send(`Your preferred language is: ${language}`);
});
```

## Output Example

When a client makes a request to the `/headers` endpoint, they might receive a response like this:

```json
{
  "host": "localhost:3000",
  "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
  "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
  "accept-language": "en-US,en;q=0.5",
  "accept-encoding": "gzip, deflate, br",
  "connection": "keep-alive",
  "upgrade-insecure-requests": "1",
  "cache-control": "max-age=0"
}
```

## Practical Applications

### 1. Content Negotiation

Content negotiation allows you to serve different formats based on what the client can accept:

```javascript
app.get('/data', (req, res) => {
  const acceptHeader = req.headers.accept;
  
  // Check what format the client prefers
  if (acceptHeader.includes('application/json')) {
    return res.json({ message: "This is JSON data" });
  } else if (acceptHeader.includes('text/html')) {
    return res.send("<html><body><h1>This is HTML data</h1></body></html>");
  } else {
    return res.send("This is plain text data");
  }
});
```

### 2. Language Localization

Detect the user's preferred language and serve localized content:

```javascript
app.get('/welcome', (req, res) => {
  const languages = req.headers['accept-language'] || '';
  
  if (languages.includes('es')) {
    return res.send('Â¡Bienvenido a nuestro sitio web!');
  } else if (languages.includes('fr')) {
    return res.send('Bienvenue sur notre site web!');
  } else {
    return res.send('Welcome to our website!');
  }
});
```

### 3. Device Detection

Tailor content based on the user's device:

```javascript
app.get('/device', (req, res) => {
  const userAgent = req.headers['user-agent'] || '';
  
  if (userAgent.match(/mobile|android|iphone/i)) {
    return res.send('You are viewing the mobile version');
  } else {
    return res.send('You are viewing the desktop version');
  }
});
```

## Security Considerations

While header information is useful, be aware of these security considerations:

1. **Don't Trust Headers Blindly**: Headers can be spoofed, so don't rely on them for security-critical decisions without additional verification.

2. **Sensitive Information**: Avoid including sensitive information in custom headers, as they might be accessible to intermediaries.

3. **Cross-Site Request Forgery (CSRF)**: Implement proper CSRF protection rather than relying solely on header checks.

4. **HTTP Strict Transport Security (HSTS)**: Consider implementing HSTS to ensure secure connections.

## Creating a Header Echo Service

Let's build a complete example of a header echo service that shows all headers and provides specific information about the request:

```javascript
const express = require('express');
const app = express();

// Middleware to enable CORS
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  next();
});

app.get('/echo-headers', (req, res) => {
  const headerInfo = {
    all: req.headers,
    browser: req.headers['user-agent'],
    language: req.headers['accept-language'],
    contentTypes: req.headers['accept'],
    host: req.headers['host'],
    custom: {}
  };
  
  // Extract any custom headers (those starting with 'x-')
  Object.keys(req.headers).forEach(key => {
    if (key.toLowerCase().startsWith('x-')) {
      headerInfo.custom[key] = req.headers[key];
    }
  });
  
  res.json(headerInfo);
});

app.listen(3000, () => {
  console.log('Header echo service running on port 3000');
});
```

## Testing Your Header Echo Service

You can test your header echo service using tools like:

1. **Web Browser**: Simply navigate to your endpoint (e.g., `http://localhost:3000/echo-headers`)

2. **cURL**:
   ```bash
   curl -H "X-Custom-Header: HelloWorld" http://localhost:3000/echo-headers
   ```

3. **Fetch API in JavaScript**:
   ```javascript
   fetch('http://localhost:3000/echo-headers', {
     headers: {
       'X-Custom-Header': 'HelloWorld'
     }
   })
   .then(response => response.json())
   .then(data => console.log(data))
   .catch(error => console.error('Error:', error));
   ```

## Summary

HTTP request headers provide valuable information about client requests, enabling developers to create more intelligent and responsive web applications. By understanding how to access and use these headers, you can implement features like content negotiation, language localization, and device-specific experiences.

Remember that headers should be handled with care, especially when they influence security-related decisions in your application. Always validate and sanitize header information before using it in critical operations.

## Additional Resources

- [MDN Web Docs: HTTP Headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers)
- [Express.js Documentation](https://expressjs.com/en/api.html#req.headers)
- [HTTP Request Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)

## Exercises

1. Create a simple server that returns different responses based on the `Accept` header.
2. Build a service that detects if a request is coming from a mobile device and redirects accordingly.
3. Implement a basic authentication system using the `Authorization` header.
4. Create a logger that records information about incoming requests, including relevant headers.
5. Extend the echo service to validate and sanitize custom headers before processing them.