---
title: Echo Form Data
description: Learn how to work with form data in Echo framework, including form parsing, validation, and handling different types of form submissions

---

# Echo Form Data

In web development, processing form data is a fundamental skill. Whether you're building a simple contact form or a complex multi-page registration system, understanding how to handle form submissions is essential. This guide will walk you through handling form data in the Echo web framework for Go.

## Introduction to Form Data in Echo

Form data is information submitted by users through HTML forms on your website. When a user fills out a form and clicks "Submit," this data is sent to your server for processing. Echo provides convenient methods to access and work with this data.

Forms can be submitted in two common ways:
- As URL-encoded form data (typically with `application/x-www-form-urlencoded` content type)
- As multipart form data (typically with `multipart/form-data` content type, used when forms include file uploads)

## Basic Form Data Handling

### Accessing Form Values

Echo makes it simple to retrieve form data using the `FormValue()` method:

```go
// Handler to process a simple login form
func handleLogin(c echo.Context) error {
    // Get form values
    username := c.FormValue("username")
    password := c.FormValue("password")
    
    // Use the form data
    fmt.Printf("Login attempt: username=%s, password=%s\n", username, password)
    
    return c.String(http.StatusOK, "Login form received")
}
```

This works with both URL-encoded and multipart form submissions.

### HTML Form Example

Here's a simple HTML form that would send data to the above handler:

```html
<form action="/login" method="POST">
    <div>
        <label for="username">Username:</label>
        <input type="text" id="username" name="username">
    </div>
    <div>
        <label for="password">Password:</label>
        <input type="password" id="password" name="password">
    </div>
    <button type="submit">Login</button>
</form>
```

## Working with Multiple Values

Some form fields like checkboxes or multi-select dropdowns can send multiple values with the same name. Echo provides a `FormValues()` method to handle these cases:

```go
// Handler to process a form with multiple selections
func handlePreferences(c echo.Context) error {
    // Get all values for the "interests" field
    interests := c.FormValues()["interests"]
    
    return c.JSON(http.StatusOK, map[string]interface{}{
        "selected_interests": interests,
    })
}
```

HTML form with multiple selections:

```html
<form action="/preferences" method="POST">
    <p>Select your interests:</p>
    <input type="checkbox" name="interests" value="programming"> Programming<br>
    <input type="checkbox" name="interests" value="sports"> Sports<br>
    <input type="checkbox" name="interests" value="music"> Music<br>
    <input type="checkbox" name="interests" value="art"> Art<br>
    <button type="submit">Save Preferences</button>
</form>
```

## File Uploads

Handling file uploads is a common requirement in web applications. Echo makes this process straightforward:

```go
func uploadHandler(c echo.Context) error {
    // Get the file from the request
    file, err := c.FormFile("file")
    if err != nil {
        return err
    }
    
    // Source
    src, err := file.Open()
    if err != nil {
        return err
    }
    defer src.Close()
    
    // Destination
    dst, err := os.Create("uploads/" + file.Filename)
    if err != nil {
        return err
    }
    defer dst.Close()
    
    // Copy
    if _, err = io.Copy(dst, src); err != nil {
        return err
    }
    
    return c.HTML(http.StatusOK, fmt.Sprintf("<p>File %s uploaded successfully.</p>", file.Filename))
}
```

HTML form for file upload:

```html
<form action="/upload" method="POST" enctype="multipart/form-data">
    <input type="file" name="file">
    <button type="submit">Upload</button>
</form>
```

Note the `enctype="multipart/form-data"` attribute, which is required for file uploads.

## Binding Form Data to Structs

Echo provides a convenient way to automatically bind form data to Go structs:

```go
// User represents the form data structure
type User struct {
    Name     string `form:"name"`
    Email    string `form:"email"`
    Age      int    `form:"age"`
    IsActive bool   `form:"active"`
}

func registerHandler(c echo.Context) error {
    u := new(User)
    if err := c.Bind(u); err != nil {
        return err
    }
    
    // Now 'u' contains all the form data mapped to the struct fields
    return c.JSON(http.StatusOK, u)
}
```

This form would bind to the above struct:

```html
<form action="/register" method="POST">
    <div>
        <label for="name">Name:</label>
        <input type="text" id="name" name="name">
    </div>
    <div>
        <label for="email">Email:</label>
        <input type="email" id="email" name="email">
    </div>
    <div>
        <label for="age">Age:</label>
        <input type="number" id="age" name="age">
    </div>
    <div>
        <label for="active">Active:</label>
        <input type="checkbox" id="active" name="active" value="true">
    </div>
    <button type="submit">Register</button>
</form>
```

## Form Validation

Validation is crucial when processing form data. You can implement basic validation manually:

```go
func validateFormHandler(c echo.Context) error {
    name := c.FormValue("name")
    email := c.FormValue("email")
    
    // Basic validation
    if name == "" {
        return c.String(http.StatusBadRequest, "Name is required")
    }
    
    if email == "" || !strings.Contains(email, "@") {
        return c.String(http.StatusBadRequest, "Valid email is required")
    }
    
    // Process the valid form data
    return c.String(http.StatusOK, "Form validation passed")
}
```

For more complex validation, consider using a validation library like `go-playground/validator`:

```go
type RegistrationForm struct {
    Username string `form:"username" validate:"required,min=3,max=20"`
    Email    string `form:"email" validate:"required,email"`
    Age      int    `form:"age" validate:"required,gte=18"`
    Password string `form:"password" validate:"required,min=8"`
}

func registerWithValidation(c echo.Context) error {
    // Create a new form instance
    form := new(RegistrationForm)
    
    // Bind data to the form
    if err := c.Bind(form); err != nil {
        return c.String(http.StatusBadRequest, "Invalid form data")
    }
    
    // Initialize validator
    validate := validator.New()
    
    // Validate the form
    if err := validate.Struct(form); err != nil {
        return c.String(http.StatusBadRequest, "Validation failed: " + err.Error())
    }
    
    // Process the valid data
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Registration successful",
        "username": form.Username,
        "email": form.Email,
    })
}
```

## Real-world Example: Contact Form with Validation and Email Sending

Here's a more complete example showing a contact form implementation:

```go
package main

import (
    "fmt"
    "net/http"
    "net/smtp"
    
    "github.com/labstack/echo/v4"
    "github.com/go-playground/validator/v10"
)

// ContactForm represents a contact form submission
type ContactForm struct {
    Name    string `form:"name" validate:"required"`
    Email   string `form:"email" validate:"required,email"`
    Subject string `form:"subject" validate:"required"`
    Message string `form:"message" validate:"required,min=10"`
}

// Custom validator
type CustomValidator struct {
    validator *validator.Validate
}

func (cv *CustomValidator) Validate(i interface{}) error {
    return cv.validator.Struct(i)
}

func main() {
    e := echo.New()
    
    // Set up the validator
    e.Validator = &CustomValidator{validator: validator.New()}
    
    // Routes
    e.GET("/contact", showContactForm)
    e.POST("/contact", handleContactForm)
    
    e.Logger.Fatal(e.Start(":8080"))
}

// Show contact form page
func showContactForm(c echo.Context) error {
    // In a real app, you'd render a template
    return c.HTML(http.StatusOK, `
        <form action="/contact" method="POST">
            <div>
                <label for="name">Name:</label>
                <input type="text" id="name" name="name" required>
            </div>
            <div>
                <label for="email">Email:</label>
                <input type="email" id="email" name="email" required>
            </div>
            <div>
                <label for="subject">Subject:</label>
                <input type="text" id="subject" name="subject" required>
            </div>
            <div>
                <label for="message">Message:</label>
                <textarea id="message" name="message" required minlength="10"></textarea>
            </div>
            <button type="submit">Send Message</button>
        </form>
    `)
}

// Process contact form submission
func handleContactForm(c echo.Context) error {
    // Bind and validate the form data
    form := new(ContactForm)
    if err := c.Bind(form); err != nil {
        return c.String(http.StatusBadRequest, "Invalid form data")
    }
    
    if err := c.Validate(form); err != nil {
        return c.String(http.StatusBadRequest, "Validation failed: " + err.Error())
    }
    
    // Send email (simplified example)
    err := sendEmail(form)
    if err != nil {
        return c.String(http.StatusInternalServerError, "Failed to send email")
    }
    
    return c.HTML(http.StatusOK, "<h1>Thank you for your message!</h1><p>We'll get back to you soon.</p>")
}

// Function to send email (simplified)
func sendEmail(form *ContactForm) error {
    // This is a simplified example
    // In a real application, you would use proper configuration and error handling
    from := "your-app@example.com"
    password := "your-password"
    to := []string{"admin@example.com"}
    
    subject := "Contact Form: " + form.Subject
    body := fmt.Sprintf("From: %s <%s>\n\n%s", form.Name, form.Email, form.Message)
    message := []byte("To: admin@example.com\r\n" +
        "Subject: " + subject + "\r\n" +
        "\r\n" +
        body + "\r\n")
    
    auth := smtp.PlainAuth("", from, password, "smtp.example.com")
    
    // In a real app, don't ignore this error
    return smtp.SendMail("smtp.example.com:587", auth, from, to, message)
}
```

## Security Considerations

When working with form data, consider these security practices:

1. **Input validation**: Always validate all form inputs to prevent injection attacks.

2. **CSRF protection**: Echo doesn't include CSRF protection by default. Consider adding it with middleware.

3. **File upload limits**: Set size limits for file uploads to prevent denial of service attacks:

```go
// Limit file uploads to 10MB
e.Use(middleware.BodyLimit("10M"))
```

4. **Sanitize data**: Especially important when outputting user-submitted data in HTML responses.

## Summary

Echo provides robust tools for working with form data in web applications. You've learned how to:

- Access basic form values with `FormValue()` and `FormValues()`
- Handle file uploads
- Bind form data to Go structs
- Implement form validation
- Process form data in a complete example application

These skills form the foundation of dynamic web application development with Echo. By understanding how to process and validate user input, you can create interactive and responsive web applications.

## Additional Resources

- [Echo Framework Documentation](https://echo.labstack.com/guide/)
- [Go Validator Library](https://github.com/go-playground/validator)
- [HTML Forms Tutorial](https://developer.mozilla.org/en-US/docs/Learn/Forms)

## Exercises

1. Create a registration form with password and password confirmation fields, validating that they match.
2. Build a multi-step form that preserves data between steps using sessions.
3. Implement a form that allows users to upload multiple files with a progress indicator.
4. Create a dynamic form with fields that appear/disappear based on user selections.