---
title: Echo Request Filters
description: Learn how to use filters with Echo requests to modify and transform your API responses

---

# Echo Request Filters

## Introduction

When working with Echo requests in your applications, there are often scenarios where you need to modify, format, or filter the response data before it reaches the client. Echo Request Filters provide a powerful way to intercept and transform data within the request-response cycle. This article will guide you through understanding and implementing filters in Echo requests to enhance your API responses.

Filters are middleware components that sit between your route handlers and the client, allowing you to:
- Transform response data
- Filter out sensitive information
- Format data consistently across endpoints
- Add metadata to responses
- Implement complex business logic rules

## Understanding Echo Request Filters

### What are Request Filters?

Request filters are middleware functions that process incoming requests or outgoing responses. In the Echo framework, these filters can be applied globally to all routes or selectively to specific endpoints.

A typical filter function looks like this:

```javascript
const myFilter = (req, res, next) => {
  // Perform operations on request or response
  next(); // Continue to the next middleware or handler
};
```

### Types of Echo Request Filters

Echo request filters typically fall into three categories:

1. **Pre-processing filters**: Execute before the main handler processes the request
2. **Post-processing filters**: Execute after the handler but before sending the response
3. **Error handling filters**: Execute when errors occur in the request pipeline

## Implementing Basic Echo Request Filters

Let's start with a simple example of implementing a filter that logs information about each request:

```javascript
const express = require('express');
const app = express();

// Request logger filter
const requestLogger = (req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
};

// Apply the filter globally
app.use(requestLogger);

// A sample route
app.get('/echo', (req, res) => {
  res.json({ message: 'Hello World!' });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

When you make a request to `/echo`, you'll see output like this in your console:

```
[2023-06-15T14:32:45.123Z] GET /echo
```

## Response Transformation Filters

One of the most common uses for Echo request filters is transforming API responses. Let's create a filter that wraps all JSON responses in a standard format:

```javascript
const standardizeResponse = (req, res, next) => {
  // Store the original res.json function
  const originalJson = res.json;
  
  // Override the res.json function
  res.json = function(data) {
    // Transform the response
    const standardResponse = {
      success: true,
      timestamp: new Date().toISOString(),
      data: data
    };
    
    // Call the original json function with our transformed data
    return originalJson.call(this, standardResponse);
  };
  
  next();
};

app.use(standardizeResponse);

app.get('/users', (req, res) => {
  res.json([
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' }
  ]);
});
```

With this filter, a request to `/users` will return:

```json
{
  "success": true,
  "timestamp": "2023-06-15T14:35:12.456Z",
  "data": [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
}
```

## Selective Filter Application

You might want to apply filters only to specific routes. Here's how to do that:

```javascript
// Authentication filter
const authFilter = (req, res, next) => {
  const authToken = req.headers.authorization;
  
  if (!authToken || !authToken.startsWith('Bearer ')) {
    return res.status(401).json({ 
      success: false, 
      message: 'Authentication required' 
    });
  }
  
  // In a real app, you'd validate the token here
  const token = authToken.split(' ')[1];
  req.user = { id: 123, role: 'admin' }; // Example user data
  next();
};

// Public route - no auth needed
app.get('/public', (req, res) => {
  res.json({ message: 'This is public' });
});

// Protected route - uses auth filter
app.get('/admin', authFilter, (req, res) => {
  res.json({ 
    message: 'Admin area', 
    user: req.user 
  });
});
```

## Chaining Multiple Filters

You can chain multiple filters to process requests through a series of transformations:

```javascript
// Rate limiting filter
const rateLimit = (req, res, next) => {
  // Simple rate limiter (in production, use a library)
  const clientIP = req.ip;
  // Check if this IP has made too many requests recently
  // For this example, we'll just pass through
  next();
};

// Response time tracking filter
const trackResponseTime = (req, res, next) => {
  const start = Date.now();
  
  // When response finishes
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`Request to ${req.url} took ${duration}ms`);
  });
  
  next();
};

// Apply filters to specific route
app.get('/data', 
  rateLimit,
  trackResponseTime,
  authFilter,
  (req, res) => {
    res.json({ sensitive: 'data' });
  }
);
```

## Real-world Application: Content Filtering

Let's implement a practical example of a content filtering system that can remove sensitive data from responses:

```javascript
// Sensitive data filter
const sanitizeUserData = (req, res, next) => {
  const originalJson = res.json;
  
  res.json = function(data) {
    // Check if we're dealing with user data
    if (data && data.users) {
      // Remove sensitive fields from each user
      data.users = data.users.map(user => {
        const { password, ssn, ...safeUser } = user;
        return safeUser;
      });
    }
    
    return originalJson.call(this, data);
  };
  
  next();
};

app.use(sanitizeUserData);

app.get('/users/details', (req, res) => {
  // In a real app, this would come from a database
  const users = [
    { 
      id: 1, 
      name: 'Alice', 
      email: 'alice@example.com',
      password: 'hashed_password_1', 
      ssn: '123-45-6789',
      role: 'user'
    },
    { 
      id: 2, 
      name: 'Bob', 
      email: 'bob@example.com',
      password: 'hashed_password_2', 
      ssn: '987-65-4321',
      role: 'admin'
    }
  ];
  
  res.json({ users });
});
```

The output for a request to `/users/details` would be:

```json
{
  "users": [
    {
      "id": 1,
      "name": "Alice",
      "email": "alice@example.com",
      "role": "user"
    },
    {
      "id": 2,
      "name": "Bob",
      "email": "bob@example.com",
      "role": "admin"
    }
  ]
}
```

Notice that the `password` and `ssn` fields have been stripped from the response.

## Error Handling Filters

Error handling is critical in any application. Here's how to create an error handling filter:

```javascript
// Error handling filter
const errorHandler = (err, req, res, next) => {
  console.error(`Error: ${err.message}`);
  
  // Determine status code, default to 500
  const statusCode = err.statusCode || 500;
  
  // Send standardized error response
  res.status(statusCode).json({
    success: false,
    error: {
      message: err.message,
      code: err.code || 'INTERNAL_ERROR',
      // In production, you might want to hide stack traces
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    }
  });
};

// This should be registered AFTER all your routes
app.use(errorHandler);

// Example route that throws an error
app.get('/error-demo', (req, res, next) => {
  try {
    // Simulate an error
    throw new Error('Something went wrong');
  } catch (err) {
    // Forward the error to our error handler
    next(err);
  }
});
```

## Conditional Filter Logic

Sometimes you want your filters to behave differently based on the request context:

```javascript
// Content negotiation filter
const contentNegotiation = (req, res, next) => {
  const acceptHeader = req.headers.accept || '';
  
  if (acceptHeader.includes('application/xml')) {
    // Client wants XML
    const originalJson = res.json;
    
    res.json = function(data) {
      // In a real app, use a proper XML converter library
      const xmlData = `<response>
        <success>true</success>
        <data>${JSON.stringify(data)}</data>
      </response>`;
      
      res.type('application/xml');
      return res.send(xmlData);
    };
  } else if (acceptHeader.includes('text/csv')) {
    // Client wants CSV
    const originalJson = res.json;
    
    res.json = function(data) {
      // Very simplified CSV conversion for demonstration
      let csvData = 'id,name\n';
      if (Array.isArray(data)) {
        csvData += data.map(item => `${item.id},${item.name}`).join('\n');
      }
      
      res.type('text/csv');
      return res.send(csvData);
    };
  }
  // Else, fall back to JSON (default)
  
  next();
};

app.use(contentNegotiation);
```

## Best Practices for Echo Request Filters

When implementing request filters, keep these best practices in mind:

1. **Order matters**: Filters are executed in the order they're registered
2. **Keep filters focused**: Each filter should handle a specific concern
3. **Error handling**: Always handle potential errors in your filters
4. **Performance**: Be mindful of performance impacts, especially for filters that run on every request
5. **Avoid side effects**: Filters should be predictable and avoid unexpected side effects
6. **Documentation**: Document your filters' behavior for other developers

## Summary

Echo Request Filters provide a powerful mechanism for transforming, validating, and enhancing API responses in your applications. By implementing filters, you can:

- Standardize response formats across your API
- Remove sensitive data before it leaves your server
- Implement authentication and authorization checks
- Transform responses based on client preferences
- Track and log request metrics

Through the examples provided in this guide, you've seen how to implement various types of filters for different use cases, from basic logging to complex data transformation and security enhancements.

## Additional Resources and Exercises

### Resources

- [Express.js Middleware Documentation](https://expressjs.com/en/guide/using-middleware.html)
- [Understanding Middleware in Node.js](https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/)
- [Best Practices for API Security](https://owasp.org/www-project-api-security/)

### Exercises

1. **Build a caching filter**: Create a filter that caches responses for specific routes and returns the cached response for repeated requests within a time window.

2. **Data pagination filter**: Implement a filter that automatically paginates large data sets in your responses.

3. **Language localization**: Create a filter that translates response messages based on the client's `Accept-Language` header.

4. **Response compression**: Build a filter that compresses responses using gzip or brotli compression when the client supports it.

5. **Activity logging**: Develop a filter that logs all API activities to a database for audit purposes.

By working through these exercises, you'll gain practical experience implementing filters for common real-world scenarios, further enhancing your Echo request handling capabilities.