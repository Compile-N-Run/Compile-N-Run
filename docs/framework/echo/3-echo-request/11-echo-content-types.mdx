---
title: Echo Content Types
description: Learn about different content types supported in Echo requests, how to format your request body, and how content types affect response handling in web applications.

---

# Echo Content Types

## Introduction

When making HTTP requests, the `Content-Type` header tells the server what kind of data you're sending. In Echo framework (and web applications in general), understanding content types is crucial for properly formatting your request body and correctly parsing the response. This guide will explore various content types supported in Echo requests, their purposes, and how to work with them effectively.

## What are Content Types?

Content types (also known as MIME types) are standardized labels used to identify the format of data. They consist of a type and subtype, like `text/html`, `application/json`, or `image/png`. When making an Echo request, the content type helps the server understand how to interpret the data you're sending.

## Common Content Types in Echo Requests

Let's explore the most commonly used content types when working with Echo:

### 1. JSON (application/json)

JSON is the most widely used format for API communication due to its simplicity and readability.

```javascript
// Making a POST request with JSON content type
fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'John Doe',
    email: 'john@example.com',
    age: 25
  })
})
.then(response => response.json())
.then(data => console.log(data));
```

On the Echo server side, you would handle this request like:

```go
// Echo server handling JSON
e.POST("/api/users", func(c echo.Context) error {
  user := new(User)
  if err := c.Bind(user); err != nil {
    return err
  }
  // Process user data
  return c.JSON(http.StatusOK, user)
})
```

### 2. Form Data (application/x-www-form-urlencoded)

This is the default content type when submitting HTML forms.

```html
<form action="/api/submit" method="post">
  <input type="text" name="username" value="john_doe">
  <input type="email" name="email" value="john@example.com">
  <input type="submit" value="Submit">
</form>
```

The request will be sent with the `application/x-www-form-urlencoded` content type, and the data will look like:

```
username=john_doe&email=john%40example.com
```

In JavaScript, you can create this type of request like:

```javascript
// Making a POST request with form-urlencoded content
const formData = new URLSearchParams();
formData.append('username', 'john_doe');
formData.append('email', 'john@example.com');

fetch('/api/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: formData
})
.then(response => response.json())
.then(data => console.log(data));
```

### 3. Multipart Form Data (multipart/form-data)

This content type is used when the form includes file uploads.

```html
<form action="/api/upload" method="post" enctype="multipart/form-data">
  <input type="text" name="description" value="Profile picture">
  <input type="file" name="file">
  <input type="submit" value="Upload">
</form>
```

In JavaScript using the Fetch API:

```javascript
// Making a POST request with multipart/form-data (file upload)
const formData = new FormData();
formData.append('description', 'Profile picture');
formData.append('file', document.querySelector('input[type="file"]').files[0]);

fetch('/api/upload', {
  method: 'POST',
  body: formData
  // Note: Don't set Content-Type header when using FormData
  // The browser will set it automatically with the correct boundary
})
.then(response => response.json())
.then(data => console.log(data));
```

### 4. Plain Text (text/plain)

Used for sending raw text data.

```javascript
fetch('/api/log', {
  method: 'POST',
  headers: {
    'Content-Type': 'text/plain'
  },
  body: 'This is a log message from the client application.'
})
.then(response => response.text())
.then(data => console.log(data));
```

### 5. XML (application/xml)

Some APIs still use XML for data exchange.

```javascript
const xmlData = `
<user>
  <name>John Doe</name>
  <email>john@example.com</email>
  <age>25</age>
</user>`;

fetch('/api/users', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/xml'
  },
  body: xmlData
})
.then(response => response.text())
.then(data => console.log(data));
```

## Content Type Negotiation

Echo can automatically negotiate content types between client and server using the `Accept` header. This allows the server to respond with the format that the client prefers.

```javascript
// Client requesting JSON response
fetch('/api/users/123', {
  headers: {
    'Accept': 'application/json'
  }
})
.then(response => response.json())
.then(data => console.log(data));
```

On the server side, Echo can handle this with:

```go
e.GET("/api/users/:id", func(c echo.Context) error {
  user := getUser(c.Param("id"))
  
  // Respond based on Accept header
  switch c.Request().Header.Get("Accept") {
  case "application/xml":
    return c.XML(http.StatusOK, user)
  default:
    return c.JSON(http.StatusOK, user)
  }
})
```

## Working with Different Content Types in Echo

### Reading JSON Data

```go
e.POST("/api/users", func(c echo.Context) error {
  user := new(User)
  if err := c.Bind(user); err != nil {
    return err
  }
  // Process user
  return c.JSON(http.StatusOK, user)
})
```

### Reading Form Data

```go
e.POST("/api/submit", func(c echo.Context) error {
  username := c.FormValue("username")
  email := c.FormValue("email")
  
  // Process form data
  return c.String(http.StatusOK, "Form submitted successfully")
})
```

### Handling File Uploads

```go
e.POST("/api/upload", func(c echo.Context) error {
  // Get description
  description := c.FormValue("description")
  
  // Get file
  file, err := c.FormFile("file")
  if err != nil {
    return err
  }
  
  // Save the file
  src, err := file.Open()
  if err != nil {
    return err
  }
  defer src.Close()
  
  // Create destination file
  dst, err := os.Create("uploads/" + file.Filename)
  if err != nil {
    return err
  }
  defer dst.Close()
  
  // Copy file content
  if _, err = io.Copy(dst, src); err != nil {
    return err
  }
  
  return c.String(http.StatusOK, "File uploaded successfully")
})
```

## Content Type in the Real World

### Example 1: API Integration

When integrating with third-party APIs, you'll often need to format your requests according to their expected content type:

```javascript
// Integrating with a weather API that expects JSON
async function getWeatherForecast(city) {
  const response = await fetch('https://weather-api.example.com/forecast', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer YOUR_API_KEY'
    },
    body: JSON.stringify({
      city: city,
      units: 'metric',
      days: 5
    })
  });
  
  return response.json();
}

// Usage
getWeatherForecast('New York')
  .then(forecast => {
    console.log('5-day forecast:', forecast);
  })
  .catch(error => {
    console.error('Error fetching weather:', error);
  });
```

### Example 2: Building a File Upload Service

A practical application would be building a profile picture upload service:

```javascript
// Client-side code for uploading a profile picture
document.getElementById('profileForm').addEventListener('submit', async function(e) {
  e.preventDefault();
  
  const formData = new FormData();
  formData.append('userId', currentUser.id);
  formData.append('profilePic', document.getElementById('profilePic').files[0]);
  
  try {
    const response = await fetch('/api/profile/picture', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    if (response.ok) {
      document.getElementById('userAvatar').src = result.imageUrl;
      showNotification('Profile picture updated successfully!');
    } else {
      showError(result.message);
    }
  } catch (error) {
    showError('Network error. Please try again.');
  }
});
```

## Common Pitfalls and Solutions

### 1. Missing or Incorrect Content-Type Header

**Problem:** Server can't parse your request data correctly.

**Solution:** Always set the appropriate `Content-Type` header to match your request body.

### 2. Handling FormData vs. JSON

**Problem:** Confusion about when to use which format.

**Solution:** 
- Use `application/json` for API communication 
- Use `multipart/form-data` when uploading files
- Use `application/x-www-form-urlencoded` for simple form submissions

### 3. CORS Issues with Content Types

**Problem:** Cross-Origin requests with custom content types can trigger preflight requests.

**Solution:** Be aware that using content types other than `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain` will trigger a preflight OPTIONS request in cross-origin scenarios.

## Summary

Understanding content types is essential when working with Echo requests and web development in general. By correctly setting the `Content-Type` header, you ensure that:

1. The server correctly interprets your request data
2. Data binding works properly in your Echo application
3. File uploads and other special data transfers work as expected
4. Your APIs maintain compatibility with various clients

The most common content types you'll work with are:
- `application/json` for structured data
- `application/x-www-form-urlencoded` for simple forms
- `multipart/form-data` for forms with file uploads
- `text/plain` for raw text
- `application/xml` for XML-based APIs

## Additional Resources

- [MDN Web Docs: MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)
- [Echo Framework Documentation](https://echo.labstack.com/)
- [HTTP Content Negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)

## Exercises

1. Create a simple HTML form that submits data using `application/x-www-form-urlencoded` and write the Echo handler to process it.
2. Build a file upload system using `multipart/form-data` that validates file types and sizes before saving.
3. Create an API endpoint that can respond with either JSON or XML based on the client's `Accept` header.
4. Write a client-side function that sends a JSON request to an Echo endpoint and handles the response.
5. Implement content type validation in an Echo middleware to ensure requests have the expected format.

Happy coding!