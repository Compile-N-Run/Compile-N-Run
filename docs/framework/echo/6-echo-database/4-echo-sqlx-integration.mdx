---
title: Echo SQLx Integration
description: Learn how to integrate SQLx with Echo framework in Go to build powerful database-driven web applications

---

# Echo SQLx Integration

## Introduction

Echo is a high-performance, minimalist Go web framework that makes it easy to build web applications. When building web applications, you'll often need to interact with databases. This is where SQLx comes in â€“ it's an extension of Go's standard `database/sql` package that adds powerful functionality while maintaining simplicity.

In this guide, we'll explore how to integrate SQLx with Echo to create robust, database-driven web applications. We'll cover setting up the connection, creating models, implementing CRUD operations, and handling common patterns you'll encounter in real-world applications.

## Prerequisites

Before diving in, make sure you have:

- Basic understanding of Go programming
- Familiarity with Echo framework basics
- A database system installed (we'll use PostgreSQL in our examples)
- Go installed on your system

## Setting Up the Project

First, let's create a new project and install the necessary dependencies:

```bash
mkdir echo-sqlx-demo
cd echo-sqlx-demo
go mod init github.com/yourusername/echo-sqlx-demo
go get github.com/labstack/echo/v4
go get github.com/jmoiron/sqlx
go get github.com/lib/pq
```

## Connecting to the Database

Let's start by creating a database connection using SQLx:

```go
package database

import (
	"fmt"
	"log"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq" // PostgreSQL driver
)

// DB is a global variable to hold the database connection
var DB *sqlx.DB

// Config holds database configuration
type Config struct {
	Host     string
	Port     int
	User     string
	Password string
	DBName   string
	SSLMode  string
}

// Connect establishes a connection to the database
func Connect(config Config) (*sqlx.DB, error) {
	dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		config.Host, config.Port, config.User, config.Password, config.DBName, config.SSLMode)

	db, err := sqlx.Connect("postgres", dsn)
	if err != nil {
		return nil, err
	}

	if err = db.Ping(); err != nil {
		return nil, err
	}

	DB = db
	log.Println("Connected to the database successfully!")
	return db, nil
}
```

## Creating Models

Now, let's create a simple model for our application. We'll use a `User` model as an example:

```go
package models

import (
	"time"
)

// User represents a user in our system
type User struct {
	ID        int       `db:"id" json:"id"`
	FirstName string    `db:"first_name" json:"first_name"`
	LastName  string    `db:"last_name" json:"last_name"`
	Email     string    `db:"email" json:"email"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

// Users is a collection of User
type Users []User
```

Notice how we're using struct tags to map the database column names to our struct fields. The `db` tag is used by SQLx to map database columns to struct fields, while the `json` tag is used by Echo to serialize/deserialize JSON.

## Setting Up Repository Pattern

The repository pattern is a design pattern that separates the data access logic from business logic. Let's implement a repository for our `User` model:

```go
package repositories

import (
	"time"

	"github.com/jmoiron/sqlx"
	"github.com/yourusername/echo-sqlx-demo/models"
)

// UserRepository handles database operations for the User model
type UserRepository struct {
	DB *sqlx.DB
}

// NewUserRepository creates a new UserRepository
func NewUserRepository(db *sqlx.DB) *UserRepository {
	return &UserRepository{DB: db}
}

// FindAll returns all users from the database
func (r *UserRepository) FindAll() (models.Users, error) {
	users := models.Users{}
	err := r.DB.Select(&users, "SELECT * FROM users ORDER BY id")
	return users, err
}

// FindByID returns a single user by ID
func (r *UserRepository) FindByID(id int) (models.User, error) {
	var user models.User
	err := r.DB.Get(&user, "SELECT * FROM users WHERE id = $1", id)
	return user, err
}

// Create adds a new user to the database
func (r *UserRepository) Create(user *models.User) error {
	now := time.Now()
	user.CreatedAt = now
	user.UpdatedAt = now

	query := `
		INSERT INTO users (first_name, last_name, email, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`
	return r.DB.QueryRow(query, user.FirstName, user.LastName, user.Email, user.CreatedAt, user.UpdatedAt).Scan(&user.ID)
}

// Update modifies an existing user in the database
func (r *UserRepository) Update(user *models.User) error {
	user.UpdatedAt = time.Now()

	query := `
		UPDATE users
		SET first_name = $1, last_name = $2, email = $3, updated_at = $4
		WHERE id = $5
	`
	_, err := r.DB.Exec(query, user.FirstName, user.LastName, user.Email, user.UpdatedAt, user.ID)
	return err
}

// Delete removes a user from the database
func (r *UserRepository) Delete(id int) error {
	_, err := r.DB.Exec("DELETE FROM users WHERE id = $1", id)
	return err
}
```

## Creating Echo Handlers

Now, let's create Echo handlers that use our repositories to interact with the database:

```go
package handlers

import (
	"net/http"
	"strconv"

	"github.com/labstack/echo/v4"
	"github.com/yourusername/echo-sqlx-demo/models"
	"github.com/yourusername/echo-sqlx-demo/repositories"
)

// UserHandler handles HTTP requests for users
type UserHandler struct {
	repo *repositories.UserRepository
}

// NewUserHandler creates a new UserHandler
func NewUserHandler(repo *repositories.UserRepository) *UserHandler {
	return &UserHandler{repo: repo}
}

// GetUsers returns all users
func (h *UserHandler) GetUsers(c echo.Context) error {
	users, err := h.repo.FindAll()
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusOK, users)
}

// GetUser returns a single user by ID
func (h *UserHandler) GetUser(c echo.Context) error {
	idParam := c.Param("id")
	id, err := strconv.Atoi(idParam)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID format"})
	}

	user, err := h.repo.FindByID(id)
	if err != nil {
		return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
	}
	return c.JSON(http.StatusOK, user)
}

// CreateUser adds a new user
func (h *UserHandler) CreateUser(c echo.Context) error {
	user := new(models.User)
	if err := c.Bind(user); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}

	if err := h.repo.Create(user); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusCreated, user)
}

// UpdateUser modifies an existing user
func (h *UserHandler) UpdateUser(c echo.Context) error {
	idParam := c.Param("id")
	id, err := strconv.Atoi(idParam)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID format"})
	}

	user := new(models.User)
	if err := c.Bind(user); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
	}
	user.ID = id

	if err := h.repo.Update(user); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.JSON(http.StatusOK, user)
}

// DeleteUser removes a user
func (h *UserHandler) DeleteUser(c echo.Context) error {
	idParam := c.Param("id")
	id, err := strconv.Atoi(idParam)
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID format"})
	}

	if err := h.repo.Delete(id); err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	return c.NoContent(http.StatusNoContent)
}
```

## Setting Up Routes

Let's put it all together by setting up our Echo routes:

```go
package main

import (
	"log"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	"github.com/yourusername/echo-sqlx-demo/database"
	"github.com/yourusername/echo-sqlx-demo/handlers"
	"github.com/yourusername/echo-sqlx-demo/repositories"
)

func main() {
	// Connect to the database
	dbConfig := database.Config{
		Host:     "localhost",
		Port:     5432,
		User:     "postgres",
		Password: "password",
		DBName:   "echo_demo",
		SSLMode:  "disable",
	}

	db, err := database.Connect(dbConfig)
	if err != nil {
		log.Fatalf("Failed to connect to the database: %v", err)
	}
	defer db.Close()

	// Create repositories
	userRepo := repositories.NewUserRepository(db)

	// Create handlers
	userHandler := handlers.NewUserHandler(userRepo)

	// Create Echo instance
	e := echo.New()

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Routes
	e.GET("/users", userHandler.GetUsers)
	e.GET("/users/:id", userHandler.GetUser)
	e.POST("/users", userHandler.CreateUser)
	e.PUT("/users/:id", userHandler.UpdateUser)
	e.DELETE("/users/:id", userHandler.DeleteUser)

	// Start server
	e.Logger.Fatal(e.Start(":8080"))
}
```

## Database Migrations

In a real-world application, you'll also need to handle database migrations. Let's create a simple migration file to set up our `users` table:

```go
package database

import (
	"github.com/jmoiron/sqlx"
)

// Migrate creates necessary tables if they don't exist
func Migrate(db *sqlx.DB) error {
	schema := `
		CREATE TABLE IF NOT EXISTS users (
			id SERIAL PRIMARY KEY,
			first_name VARCHAR(100) NOT NULL,
			last_name VARCHAR(100) NOT NULL,
			email VARCHAR(255) NOT NULL UNIQUE,
			created_at TIMESTAMP NOT NULL,
			updated_at TIMESTAMP NOT NULL
		);
	`
	_, err := db.Exec(schema)
	return err
}
```

Don't forget to call this migration function in your `main.go` after connecting to the database:

```go
// After successful database connection
if err := database.Migrate(db); err != nil {
    log.Fatalf("Failed to migrate database: %v", err)
}
```

## Transactions with SQLx

For operations that require multiple database queries to be executed atomically, we can use transactions. Here's an example of how to implement a transaction in our repository:

```go
// CreateUserWithProfile creates a user and their profile in a transaction
func (r *UserRepository) CreateUserWithProfile(user *models.User, profile *models.Profile) error {
	tx, err := r.DB.Beginx()
	if err != nil {
		return err
	}

	// Try to execute all database operations
	now := time.Now()
	user.CreatedAt = now
	user.UpdatedAt = now

	userQuery := `
		INSERT INTO users (first_name, last_name, email, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5)
		RETURNING id
	`
	err = tx.QueryRow(userQuery, user.FirstName, user.LastName, user.Email, user.CreatedAt, user.UpdatedAt).Scan(&user.ID)
	if err != nil {
		tx.Rollback()
		return err
	}

	profile.UserID = user.ID
	profile.CreatedAt = now
	profile.UpdatedAt = now

	profileQuery := `
		INSERT INTO profiles (user_id, bio, location, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5)
	`
	_, err = tx.Exec(profileQuery, profile.UserID, profile.Bio, profile.Location, profile.CreatedAt, profile.UpdatedAt)
	if err != nil {
		tx.Rollback()
		return err
	}

	// If everything went well, commit the transaction
	return tx.Commit()
}
```

## Testing Our API

Let's test our API using `curl`:

1. Create a new user:

```bash
curl -X POST -H "Content-Type: application/json" -d '{"first_name":"John","last_name":"Doe","email":"john@example.com"}' http://localhost:8080/users
```

Expected output:
```json
{"id":1,"first_name":"John","last_name":"Doe","email":"john@example.com","created_at":"2023-09-10T12:00:00Z","updated_at":"2023-09-10T12:00:00Z"}
```

2. Get all users:

```bash
curl http://localhost:8080/users
```

Expected output:
```json
[{"id":1,"first_name":"John","last_name":"Doe","email":"john@example.com","created_at":"2023-09-10T12:00:00Z","updated_at":"2023-09-10T12:00:00Z"}]
```

3. Get a specific user:

```bash
curl http://localhost:8080/users/1
```

Expected output:
```json
{"id":1,"first_name":"John","last_name":"Doe","email":"john@example.com","created_at":"2023-09-10T12:00:00Z","updated_at":"2023-09-10T12:00:00Z"}
```

4. Update a user:

```bash
curl -X PUT -H "Content-Type: application/json" -d '{"first_name":"John","last_name":"Smith","email":"john.smith@example.com"}' http://localhost:8080/users/1
```

Expected output:
```json
{"id":1,"first_name":"John","last_name":"Smith","email":"john.smith@example.com","created_at":"2023-09-10T12:00:00Z","updated_at":"2023-09-10T12:05:00Z"}
```

5. Delete a user:

```bash
curl -X DELETE http://localhost:8080/users/1
```

Expected output: No content (204 status code)

## Best Practices

1. **Connection Pooling**: SQLx automatically creates a connection pool. You can configure its size:

```go
db.SetMaxOpenConns(25)  // Maximum number of open connections to the database
db.SetMaxIdleConns(5)   // Maximum number of connections in the idle connection pool
db.SetConnMaxLifetime(5 * time.Minute) // Maximum amount of time a connection may be reused
```

2. **Prepared Statements**: SQLx handles prepared statements automatically when using methods like `Get`, `Select`, and `NamedExec`.

3. **Error Handling**: Always check for errors and provide meaningful responses to clients.

4. **Input Validation**: Validate user input before sending it to the database.

5. **Use Context**: For long-running operations, use context to handle timeouts and cancellations.

```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

var users models.Users
err := r.DB.SelectContext(ctx, &users, "SELECT * FROM users")
```

## Common Pitfalls and How to Avoid Them

1. **Not Closing Rows**: When using `Query` directly, always defer `rows.Close()` to prevent resource leaks.

2. **SQL Injection**: Always use parameterized queries (as shown in our examples) to prevent SQL injection attacks.

3. **Database Connection Leaks**: Make sure to close all resources properly, including database connections when the application shuts down.

4. **Ignoring Transaction Rollbacks**: Always handle transaction rollbacks properly in case of errors.

## Summary

In this guide, we've covered:

- Setting up SQLx with Echo
- Creating and using models with SQLx struct tags
- Implementing the repository pattern
- Creating Echo handlers for CRUD operations
- Handling transactions with SQLx
- Testing our API
- Best practices and common pitfalls

By integrating SQLx with Echo, you can create powerful, database-driven web applications that are both performant and maintainable. The combination of Echo's ease of use and SQLx's powerful extensions to the standard `database/sql` package makes for a robust development experience.

## Additional Resources and Exercises

### Resources
- [SQLx GitHub Repository](https://github.com/jmoiron/sqlx)
- [Echo Framework Documentation](https://echo.labstack.com/)
- [Go Database/SQL Tutorial](http://go-database-sql.org/)

### Exercises

1. **Add Search Functionality**: Implement a search endpoint that allows searching users by email or name.

2. **Implement Pagination**: Modify the `GetUsers` endpoint to support pagination with limit and offset parameters.

3. **Add Validation**: Integrate a validation library like validator to validate input data before persisting it to the database.

4. **Create a Many-to-Many Relationship**: Implement a system where users can have multiple roles, demonstrating a many-to-many relationship with SQLx.

5. **Advanced Querying**: Implement advanced query features like filtering, sorting, and joining related tables.

By completing these exercises, you'll gain a deeper understanding of how to use SQLx with Echo in real-world scenarios, making you better prepared for building robust web applications.