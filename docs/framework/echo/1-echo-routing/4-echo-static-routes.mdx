---
title: Echo Static Routes
description: Learn how to define and use static routes in Echo framework for Go, including route parameters, HTTP methods, and route groups.

---

# Echo Static Routes

## Introduction

In web development, routing is the process of determining how an application responds to client requests to specific endpoints, defined by URIs (or paths) and HTTP methods (GET, POST, etc.). Echo is a high-performance, extensible, and minimalist web framework for Go that provides excellent routing capabilities.

Static routes are pre-defined paths that your application can handle. Unlike dynamic routes which contain parameters, static routes are fixed paths like `/home`, `/about`, or `/contact`. In this tutorial, we'll explore how to implement and manage static routes in Echo framework.

## Prerequisites

Before we dive in, make sure you have:

- Go installed on your system
- Basic understanding of Go programming
- Echo framework installed (`go get github.com/labstack/echo/v4`)

## Getting Started with Echo Routes

### Setting Up a Basic Echo Server

Let's start by creating a simple Echo server:

```go
package main

import (
    "net/http"
    
    "github.com/labstack/echo/v4"
)

func main() {
    // Create a new Echo instance
    e := echo.New()
    
    // Define a simple route
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Hello, World!")
    })
    
    // Start the server
    e.Logger.Fatal(e.Start(":8080"))
}
```

When you run this program and navigate to `http://localhost:8080/` in your browser, you'll see "Hello, World!" displayed.

## HTTP Methods in Echo

Echo supports all standard HTTP methods. Here's how to define routes for different methods:

```go
// GET request
e.GET("/users", getUsers)

// POST request
e.POST("/users", createUser)

// PUT request
e.PUT("/users/:id", updateUser)

// DELETE request
e.DELETE("/users/:id", deleteUser)

// PATCH request
e.PATCH("/users/:id", partialUpdateUser)

// OPTIONS request
e.OPTIONS("/users", optionsUser)

// HEAD request
e.HEAD("/users", headUser)
```

You can also handle any HTTP method using the `Match` function:

```go
// Handle multiple HTTP methods for a route
e.Match([]string{"GET", "POST"}, "/users", handleUsers)
```

## Creating Route Handlers

Route handlers in Echo are functions that accept an `echo.Context` parameter and return an error. Here's a more detailed example:

```go
package main

import (
    "net/http"
    
    "github.com/labstack/echo/v4"
)

func main() {
    e := echo.New()
    
    // Define multiple routes
    e.GET("/", homeHandler)
    e.GET("/about", aboutHandler)
    e.GET("/contact", contactHandler)
    
    e.Logger.Fatal(e.Start(":8080"))
}

// Home page handler
func homeHandler(c echo.Context) error {
    return c.String(http.StatusOK, "Welcome to the homepage!")
}

// About page handler
func aboutHandler(c echo.Context) error {
    return c.String(http.StatusOK, "This is the about page")
}

// Contact page handler
func contactHandler(c echo.Context) error {
    return c.String(http.StatusOK, "Contact us at support@example.com")
}
```

## Response Types

Echo provides several convenient methods to send different types of responses:

```go
// String response
e.GET("/string", func(c echo.Context) error {
    return c.String(http.StatusOK, "This is a string response")
})

// HTML response
e.GET("/html", func(c echo.Context) error {
    return c.HTML(http.StatusOK, "<h1>Hello, World!</h1>")
})

// JSON response
e.GET("/json", func(c echo.Context) error {
    type User struct {
        Name  string `json:"name"`
        Email string `json:"email"`
    }
    user := User{
        Name:  "John Doe",
        Email: "john@example.com",
    }
    return c.JSON(http.StatusOK, user)
})

// XML response
e.GET("/xml", func(c echo.Context) error {
    type User struct {
        Name  string `xml:"name"`
        Email string `xml:"email"`
    }
    user := User{
        Name:  "John Doe",
        Email: "john@example.com",
    }
    return c.XML(http.StatusOK, user)
})
```

## Route Groups

Echo allows you to group routes with a common prefix to make your code more organized. This is especially useful for API versioning or feature-based routing:

```go
package main

import (
    "net/http"
    
    "github.com/labstack/echo/v4"
)

func main() {
    e := echo.New()
    
    // API v1 routes
    v1 := e.Group("/api/v1")
    {
        v1.GET("/users", getAllUsersV1)
        v1.GET("/products", getAllProductsV1)
    }
    
    // API v2 routes
    v2 := e.Group("/api/v2")
    {
        v2.GET("/users", getAllUsersV2)
        v2.GET("/products", getAllProductsV2)
    }
    
    // Admin routes
    admin := e.Group("/admin")
    {
        admin.GET("/dashboard", adminDashboard)
        admin.GET("/users", adminUsersList)
    }
    
    e.Logger.Fatal(e.Start(":8080"))
}

// Handler functions (simplified for example)
func getAllUsersV1(c echo.Context) error {
    return c.String(http.StatusOK, "API v1: List of all users")
}

func getAllProductsV1(c echo.Context) error {
    return c.String(http.StatusOK, "API v1: List of all products")
}

func getAllUsersV2(c echo.Context) error {
    return c.String(http.StatusOK, "API v2: Enhanced list of all users")
}

func getAllProductsV2(c echo.Context) error {
    return c.String(http.StatusOK, "API v2: Enhanced list of all products")
}

func adminDashboard(c echo.Context) error {
    return c.String(http.StatusOK, "Admin Dashboard")
}

func adminUsersList(c echo.Context) error {
    return c.String(http.StatusOK, "Admin: List of all users")
}
```

## Route Middleware

You can apply middleware to specific routes or groups of routes. Middleware functions are executed in the order they are added:

```go
package main

import (
    "log"
    "net/http"
    
    "github.com/labstack/echo/v4"
)

// Logger middleware
func loggerMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        log.Printf("Request: %s %s", c.Request().Method, c.Request().URL.Path)
        return next(c)
    }
}

// Auth middleware (simplified)
func authMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        token := c.Request().Header.Get("Authorization")
        if token != "valid-token" {
            return c.JSON(http.StatusUnauthorized, map[string]string{
                "error": "Unauthorized access",
            })
        }
        return next(c)
    }
}

func main() {
    e := echo.New()
    
    // Apply logger middleware to all routes
    e.Use(loggerMiddleware)
    
    // Public routes
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Public homepage")
    })
    
    // Secure routes with auth middleware
    secure := e.Group("/secure")
    secure.Use(authMiddleware)
    {
        secure.GET("/dashboard", func(c echo.Context) error {
            return c.String(http.StatusOK, "Secure dashboard")
        })
        
        secure.GET("/profile", func(c echo.Context) error {
            return c.String(http.StatusOK, "User profile")
        })
    }
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Serving Static Files

Echo makes it easy to serve static files like CSS, JavaScript, and images:

```go
// Serve a single file
e.File("/favicon.ico", "assets/favicon.ico")

// Serve all files from a directory
e.Static("/static", "public")

// Custom handler for serving static files
e.GET("/downloads/*", echo.StaticDirectoryHandler("downloads", false))
```

## Real-World Example: Building a Simple Blog API

Now let's put everything together and create a simple blog API with static routes:

```go
package main

import (
    "net/http"
    "strconv"
    
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

// Blog post structure
type Post struct {
    ID      int    `json:"id"`
    Title   string `json:"title"`
    Content string `json:"content"`
    Author  string `json:"author"`
}

// In-memory database
var posts = []Post{
    {ID: 1, Title: "Introduction to Echo", Content: "Echo is a high performance framework", Author: "John"},
    {ID: 2, Title: "Static Routes in Echo", Content: "Learn how to define static routes", Author: "Jane"},
    {ID: 3, Title: "Echo Middleware", Content: "Middleware provides additional functionality", Author: "Bob"},
}

func main() {
    e := echo.New()
    
    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // CORS
    e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
        AllowOrigins: []string{"*"},
        AllowMethods: []string{http.MethodGet, http.MethodPost, http.MethodPut, http.MethodDelete},
    }))
    
    // Routes
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Welcome to the Blog API")
    })
    
    // Blog API routes
    api := e.Group("/api")
    {
        // Get all posts
        api.GET("/posts", getAllPosts)
        
        // Get a specific post
        api.GET("/posts/:id", getPost)
        
        // Create a new post
        api.POST("/posts", createPost)
        
        // Update a post
        api.PUT("/posts/:id", updatePost)
        
        // Delete a post
        api.DELETE("/posts/:id", deletePost)
    }
    
    // Start the server
    e.Logger.Fatal(e.Start(":8080"))
}

// Get all posts
func getAllPosts(c echo.Context) error {
    return c.JSON(http.StatusOK, posts)
}

// Get a specific post
func getPost(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post ID",
        })
    }
    
    for _, post := range posts {
        if post.ID == id {
            return c.JSON(http.StatusOK, post)
        }
    }
    
    return c.JSON(http.StatusNotFound, map[string]string{
        "error": "Post not found",
    })
}

// Create a new post
func createPost(c echo.Context) error {
    post := new(Post)
    if err := c.Bind(post); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post data",
        })
    }
    
    // Generate a new ID
    post.ID = len(posts) + 1
    posts = append(posts, *post)
    
    return c.JSON(http.StatusCreated, post)
}

// Update a post
func updatePost(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post ID",
        })
    }
    
    post := new(Post)
    if err := c.Bind(post); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post data",
        })
    }
    
    for i, p := range posts {
        if p.ID == id {
            post.ID = id
            posts[i] = *post
            return c.JSON(http.StatusOK, post)
        }
    }
    
    return c.JSON(http.StatusNotFound, map[string]string{
        "error": "Post not found",
    })
}

// Delete a post
func deletePost(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post ID",
        })
    }
    
    for i, post := range posts {
        if post.ID == id {
            // Remove the post
            posts = append(posts[:i], posts[i+1:]...)
            return c.NoContent(http.StatusNoContent)
        }
    }
    
    return c.JSON(http.StatusNotFound, map[string]string{
        "error": "Post not found",
    })
}
```

## Testing the API

You can test this API using curl:

```bash
# Get all posts
curl http://localhost:8080/api/posts

# Get a specific post
curl http://localhost:8080/api/posts/1

# Create a new post
curl -X POST http://localhost:8080/api/posts \
  -H "Content-Type: application/json" \
  -d '{"title":"New Post","content":"This is a new post","author":"Alice"}'

# Update a post
curl -X PUT http://localhost:8080/api/posts/1 \
  -H "Content-Type: application/json" \
  -d '{"title":"Updated Post","content":"This post has been updated","author":"John"}'

# Delete a post
curl -X DELETE http://localhost:8080/api/posts/3
```

## Summary

In this tutorial, we've covered:

1. **Basic Echo Setup**: How to initialize an Echo server and define basic routes
2. **HTTP Methods**: Handling different HTTP methods like GET, POST, PUT, DELETE
3. **Route Handlers**: Creating functions to handle route requests
4. **Response Types**: Returning different types of responses (String, HTML, JSON, XML)
5. **Route Groups**: Organizing routes with common prefixes
6. **Middleware**: Adding functionality like logging and authentication
7. **Static Files**: Serving static content
8. **Real-World Example**: Building a simple blog API

Echo's static routing system provides a clean, intuitive way to define how your application responds to HTTP requests. With its lightweight design and powerful features, Echo is an excellent choice for building web applications and APIs in Go.

## Additional Resources

- [Official Echo Documentation](https://echo.labstack.com/)
- [Echo GitHub Repository](https://github.com/labstack/echo)
- [Go Web Programming](https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/)

## Exercises

1. Extend the blog API to include user authentication
2. Add pagination to the GetAllPosts endpoint
3. Implement a search feature that allows filtering posts by title or author
4. Create a frontend using HTML templates to display the blog posts
5. Add validation for post creation and updates to ensure all fields are provided

By practicing these exercises, you'll gain more confidence in working with Echo's static routes and building robust web applications.