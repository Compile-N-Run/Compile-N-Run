---
title: Echo Route Priority
description: Learn how route priority works in Echo framework and how to control the order in which routes are matched and processed.

  - echo
  - routing
  - priority
  - middleware
  - golang
---

# Echo Route Priority

## Introduction

When building web applications with Echo, understanding how routes are matched and processed is crucial for proper application behavior. Echo routes incoming requests to handler functions based on the HTTP method and path. However, when multiple routes could potentially match the same request, how does Echo decide which one to use? This is where **route priority** comes into play.

In this tutorial, we'll explore how Echo determines which route handler to execute when multiple routes match a request, and how you can control this behavior in your applications.

## Understanding Route Priority in Echo

Echo uses a specific set of rules to determine the priority of routes when multiple routes match the same request. The following list outlines the priority order from highest to lowest:

1. Static routes (exact path matches)
2. Routes with parameters (e.g., `/users/:id`)
3. Catch-all routes (e.g., `/files/*`)

Let's explore each of these with examples to understand how they work.

## Static Routes vs Parameterized Routes

Static routes always take precedence over parameterized routes. This makes sense because static routes are more specific than routes with parameters.

```go
e := echo.New()

// Static route (higher priority)
e.GET("/users/profile", func(c echo.Context) error {
    return c.String(http.StatusOK, "Static user profile page")
})

// Parameterized route (lower priority)
e.GET("/users/:id", func(c echo.Context) error {
    id := c.Param("id")
    return c.String(http.StatusOK, "User ID: " + id)
})
```

In this example:
- A request to `/users/profile` will match the static route and return "Static user profile page"
- A request to `/users/123` will match the parameterized route and return "User ID: 123"

Echo correctly routes the requests despite both routes technically being able to match `/users/profile` (where "profile" could be treated as the `:id` parameter).

## Routes with Parameters vs Catch-All Routes

Routes with parameters take precedence over catch-all routes. Again, this happens because parameterized routes are more specific than catch-all routes.

```go
e := echo.New()

// Parameterized route (higher priority)
e.GET("/files/:filename", func(c echo.Context) error {
    filename := c.Param("filename")
    return c.String(http.StatusOK, "Accessing specific file: " + filename)
})

// Catch-all route (lower priority)
e.GET("/files/*", func(c echo.Context) error {
    path := c.Param("*")
    return c.String(http.StatusOK, "Accessing file path: " + path)
})
```

With this setup:
- A request to `/files/document.pdf` will match the parameterized route
- A request to `/files/documents/report.pdf` will match the catch-all route since it contains a slash after `/files/`

## Order of Registration Impact

While Echo has built-in priority rules, the order in which you register routes can also matter in certain edge cases, especially when routes have the same priority level.

```go
e := echo.New()

// Registered first
e.GET("/api/:resource", func(c echo.Context) error {
    resource := c.Param("resource")
    return c.String(http.StatusOK, "API Resource: " + resource)
})

// Registered second
e.GET("/api/:version", func(c echo.Context) error {
    version := c.Param("version")
    return c.String(http.StatusOK, "API Version: " + version)
})
```

In this case, both routes have the same priority (parameterized routes), and they have the same pattern structure. When a request comes in for `/api/v1`, Echo will route it to the first registered handler, treating "v1" as the "resource" parameter rather than the "version" parameter.

To avoid such ambiguities, it's better to use more specific paths:

```go
e := echo.New()

e.GET("/api/resource/:name", func(c echo.Context) error {
    name := c.Param("name")
    return c.String(http.StatusOK, "API Resource: " + name)
})

e.GET("/api/v:version", func(c echo.Context) error {
    version := c.Param("version")
    return c.String(http.StatusOK, "API Version: " + version)
})
```

## Real-World Application: RESTful API

Let's look at a more comprehensive example of how route priority helps in building a RESTful API for a blog application:

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
)

func main() {
    e := echo.New()
    
    // Static routes (highest priority)
    e.GET("/blog/featured", getFeaturedPosts)
    e.GET("/blog/recent", getRecentPosts)
    
    // Parameterized routes (medium priority)
    e.GET("/blog/:year/:month", getPostsByMonth)
    e.GET("/blog/:id", getPostById)
    
    // Catch-all route (lowest priority)
    e.GET("/blog/*", searchBlog)
    
    e.Logger.Fatal(e.Start(":8080"))
}

func getFeaturedPosts(c echo.Context) error {
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Returning featured blog posts",
    })
}

func getRecentPosts(c echo.Context) error {
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Returning recent blog posts",
    })
}

func getPostsByMonth(c echo.Context) error {
    year := c.Param("year")
    month := c.Param("month")
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Posts from " + month + "/" + year,
    })
}

func getPostById(c echo.Context) error {
    id := c.Param("id")
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Returning blog post with ID: " + id,
    })
}

func searchBlog(c echo.Context) error {
    path := c.Param("*")
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Searching blog with path: " + path,
    })
}
```

Request matching in this example:
- `/blog/featured` → `getFeaturedPosts()`
- `/blog/recent` → `getRecentPosts()`
- `/blog/2023/05` → `getPostsByMonth()` with year="2023" and month="05"
- `/blog/123` → `getPostById()` with id="123"
- `/blog/category/tech/golang` → `searchBlog()` with path="category/tech/golang"

## Advanced: Custom Route Priority

Sometimes, you might want to have more control over route priority. Echo doesn't provide direct methods to manipulate route priority, but you can use groups or middleware to influence routing behavior:

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    e := echo.New()
    
    // Define a special route that should take highest priority
    specialRoute := e.Group("/api")
    specialRoute.Use(middleware.KeyAuth(func(key string, c echo.Context) (bool, error) {
        return key == "valid-api-key", nil
    }))
    
    // This route will only be matched if proper API key is provided
    specialRoute.GET("/data/:id", func(c echo.Context) error {
        id := c.Param("id")
        return c.JSON(http.StatusOK, map[string]string{
            "message": "Special access granted for data " + id,
        })
    })
    
    // Fallback route for the same path but without valid auth
    e.GET("/api/data/:id", func(c echo.Context) error {
        id := c.Param("id")
        return c.JSON(http.StatusOK, map[string]string{
            "message": "Public data " + id + " (limited access)",
        })
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

In this example, the same path can route to different handlers based on the presence of a valid API key, effectively creating a custom priority mechanism.

## Common Pitfalls and Best Practices

1. **Avoid overlapping routes**: Design your API with clear, distinct paths to avoid relying on route priority for correct behavior.

2. **Most specific routes first**: Even though Echo has built-in priority, registering more specific routes first makes your code more readable and maintainable.

3. **Using catch-all routes wisely**: Catch-all routes should typically be registered last and used sparingly for special cases like file servers or fallback handlers.

4. **Testing route priorities**: Always test your route matching with various inputs to ensure the intended handler is being called.

5. **Documentation**: Document any non-obvious route matching behavior in your application for other developers.

## Summary

Echo's route priority mechanism follows a logical pattern, preferring more specific routes over general ones:

1. Static routes have the highest priority
2. Parameterized routes have medium priority
3. Catch-all routes have the lowest priority

Understanding this priority system helps you design cleaner and more predictable APIs. By following the best practices outlined in this guide, you can avoid common routing issues and create robust web applications with Echo.

## Further Exercises

1. Create an API with nested resources (e.g., `/users/:userId/posts/:postId`) and test how route priority works with different URL patterns.

2. Implement a versioned API with routes like `/api/v1/users` and `/api/v2/users` and explore how to structure your code to handle different versions.

3. Build a file server with special handling for certain file types, using a combination of parameterized routes and a catch-all route.

4. Experiment with route groups and middleware to create sophisticated routing logic that goes beyond Echo's built-in priority rules.

## Additional Resources

- [Echo Framework Documentation](https://echo.labstack.com/)
- [Echo Routing Guide](https://echo.labstack.com/guide/routing/)
- [Golang HTTP Router Benchmarks](https://github.com/julienschmidt/go-http-routing-benchmarks)
- [RESTful API Design Best Practices](https://restfulapi.net/)