---
title: Echo Request Handling
description: Learn how Echo framework processes and handles HTTP requests, including routing, middleware, and response methods.

---

# Echo Request Handling

## Introduction

Echo is a high-performance, extensible, and minimalist Go web framework that makes it easy to build web applications and APIs. One of its core strengths is its efficient request handling system. In this guide, we'll explore how Echo processes incoming HTTP requests, how to define routes, work with different types of parameters, and how to respond to client requests appropriately.

Understanding request handling is fundamental to building web applications with Echo, as it forms the foundation for all user interactions with your application.

## The Request Lifecycle

When a client (like a web browser or mobile app) makes a request to your Echo-powered server, the request goes through several stages:

1. The server receives the HTTP request
2. Echo's router matches the request to the appropriate handler function
3. Middleware is executed in the order it was registered
4. Your handler function processes the request
5. A response is generated and sent back to the client

Let's break down each of these components in detail.

## Setting Up an Echo Server

Before we can handle any requests, we need to initialize an Echo instance:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "net/http"
)

func main() {
    // Create a new Echo instance
    e := echo.New()
    
    // Define a simple route
    e.GET("/hello", handleHello)
    
    // Start the server
    e.Start(":8080")
}

// Handler function
func handleHello(c echo.Context) error {
    return c.String(http.StatusOK, "Hello, World!")
}
```

When you run this code, Echo starts a web server on port 8080 that responds with "Hello, World!" when you visit `http://localhost:8080/hello`.

## Defining Routes

Echo uses a routing system to map HTTP request methods and URLs to handler functions. The basic syntax is:

```go
e.METHOD(path, handlerFunc)
```

Where:
- `METHOD` is the HTTP method (GET, POST, PUT, DELETE, etc.)
- `path` is the URL pattern
- `handlerFunc` is the function that will handle the request

Here are some examples:

```go
// GET request to /users
e.GET("/users", listUsers)

// POST request to /users
e.POST("/users", createUser)

// PUT request to /users/:id
e.PUT("/users/:id", updateUser)

// DELETE request to /users/:id
e.DELETE("/users/:id", deleteUser)

// Handle any request method to /health
e.Any("/health", healthCheck)
```

## Working with Request Parameters

Echo provides several ways to extract parameters from requests:

### Path Parameters

Path parameters are defined with a colon in the route path:

```go
e.GET("/users/:id", func(c echo.Context) error {
    // Extract the id parameter
    id := c.Param("id")
    return c.String(http.StatusOK, "User ID: "+id)
})
```

**Example:**
- Request: `GET /users/42`
- Output: `User ID: 42`

### Query Parameters

Query parameters are extracted from the URL's query string:

```go
e.GET("/search", func(c echo.Context) error {
    // Get query parameter
    query := c.QueryParam("q")
    return c.String(http.StatusOK, "Searching for: "+query)
})
```

**Example:**
- Request: `GET /search?q=echo+framework`
- Output: `Searching for: echo framework`

### Form Parameters

For form submissions, you can retrieve form values:

```go
e.POST("/submit", func(c echo.Context) error {
    // Get form parameter
    name := c.FormValue("name")
    return c.String(http.StatusOK, "Form submitted by: "+name)
})
```

**Example:**
- Request: `POST /submit` with form data `name=John`
- Output: `Form submitted by: John`

## Request Body Binding

Echo can automatically bind request bodies to Go structs:

```go
type User struct {
    Name  string `json:"name" form:"name"`
    Email string `json:"email" form:"email"`
}

e.POST("/users", func(c echo.Context) error {
    u := new(User)
    if err := c.Bind(u); err != nil {
        return err
    }
    return c.JSON(http.StatusCreated, u)
})
```

**Example:**
- Request: `POST /users` with JSON body `{"name":"John","email":"john@example.com"}`
- Output: `{"name":"John","email":"john@example.com"}` with status code 201

## Response Methods

Echo provides various methods to send responses:

```go
// String response
c.String(http.StatusOK, "Hello, World!")

// HTML response
c.HTML(http.StatusOK, "<h1>Hello, World!</h1>")

// JSON response
c.JSON(http.StatusOK, map[string]string{"message": "Hello, World!"})

// XML response
c.XML(http.StatusOK, User{Name: "John"})

// File download
c.File("path/to/file.txt")

// Attachment (download with filename)
c.Attachment("path/to/file.pdf", "report.pdf")

// Redirect
c.Redirect(http.StatusMovedPermanently, "https://example.com")
```

## Middleware Integration

Middleware functions can process requests before and after your handler functions. They're useful for tasks like authentication, logging, and error handling.

```go
// Logger middleware
e.Use(middleware.Logger())

// Recover middleware (recovers from panics)
e.Use(middleware.Recover())

// Custom middleware
e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        // Before request
        c.Set("start_time", time.Now())
        
        // Call the next handler
        err := next(c)
        
        // After request
        duration := time.Since(c.Get("start_time").(time.Time))
        fmt.Printf("Request took %v\n", duration)
        
        return err
    }
})
```

## Practical Example: RESTful API

Let's build a simple REST API for a task management application:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
    "net/http"
    "strconv"
)

// Task represents a to-do item
type Task struct {
    ID        int    `json:"id"`
    Title     string `json:"title"`
    Completed bool   `json:"completed"`
}

// In-memory task store
var (
    tasks  = map[int]*Task{}
    nextID = 1
)

func main() {
    e := echo.New()

    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())

    // Routes
    e.GET("/tasks", getAllTasks)
    e.POST("/tasks", createTask)
    e.GET("/tasks/:id", getTask)
    e.PUT("/tasks/:id", updateTask)
    e.DELETE("/tasks/:id", deleteTask)

    // Start server
    e.Start(":8080")
}

// Get all tasks
func getAllTasks(c echo.Context) error {
    // Convert map to slice for JSON response
    taskList := make([]*Task, 0, len(tasks))
    for _, task := range tasks {
        taskList = append(taskList, task)
    }
    return c.JSON(http.StatusOK, taskList)
}

// Create a new task
func createTask(c echo.Context) error {
    task := new(Task)
    if err := c.Bind(task); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid task data"})
    }
    
    task.ID = nextID
    nextID++
    tasks[task.ID] = task
    
    return c.JSON(http.StatusCreated, task)
}

// Get a task by ID
func getTask(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
    }
    
    task, exists := tasks[id]
    if !exists {
        return c.JSON(http.StatusNotFound, map[string]string{"error": "Task not found"})
    }
    
    return c.JSON(http.StatusOK, task)
}

// Update a task
func updateTask(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
    }
    
    task, exists := tasks[id]
    if !exists {
        return c.JSON(http.StatusNotFound, map[string]string{"error": "Task not found"})
    }
    
    updatedTask := new(Task)
    if err := c.Bind(updatedTask); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid task data"})
    }
    
    task.Title = updatedTask.Title
    task.Completed = updatedTask.Completed
    
    return c.JSON(http.StatusOK, task)
}

// Delete a task
func deleteTask(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
    }
    
    if _, exists := tasks[id]; !exists {
        return c.JSON(http.StatusNotFound, map[string]string{"error": "Task not found"})
    }
    
    delete(tasks, id)
    
    return c.NoContent(http.StatusNoContent)
}
```

This example implements a complete CRUD API for managing tasks. You can:
- GET all tasks
- POST a new task
- GET a specific task by ID
- PUT updates to an existing task
- DELETE a task

## Best Practices for Request Handling

1. **Use appropriate HTTP status codes**: Return the correct status code for each response (200 for success, 400 for bad request, 404 for not found, etc.).

2. **Validate input data**: Always validate and sanitize input data to prevent security issues.

3. **Use middleware for cross-cutting concerns**: Authentication, logging, and error handling are best implemented as middleware.

4. **Group related routes**: Use Echo's route grouping to organize your API endpoints.

   ```go
   // Group routes with a common prefix
   api := e.Group("/api")
   {
       api.GET("/users", getUsers)
       api.POST("/users", createUser)
       
       // Nested group for user-specific operations
       user := api.Group("/users/:id")
       {
           user.GET("", getUser)
           user.PUT("", updateUser)
           user.DELETE("", deleteUser)
       }
   }
   ```

5. **Document your API**: Use comments or a documentation tool to describe your API endpoints, parameters, and responses.

## Summary

Echo provides a powerful and flexible system for handling HTTP requests in Go web applications. In this guide, we've covered:

- Setting up an Echo server
- Defining routes for different HTTP methods
- Working with path, query, and form parameters
- Binding request bodies to structured data
- Sending various types of responses
- Using middleware to extend your application's functionality
- Building a complete RESTful API

With these fundamentals, you can create robust and efficient web applications that handle user requests elegantly and respond appropriately.

## Further Learning

Here are some exercises to reinforce your understanding:

1. Build a simple blog API with endpoints for listing, creating, and viewing posts
2. Implement JWT authentication middleware to protect certain routes
3. Create a file upload endpoint that saves files to the server
4. Implement request validation using a library like go-playground/validator
5. Add rate limiting middleware to protect your API from abuse

## Additional Resources

- [Echo Framework Official Documentation](https://echo.labstack.com/)
- [Go Programming Language Documentation](https://golang.org/doc/)
- [RESTful API Design Best Practices](https://restfulapi.net/)
- [HTTP Status Codes](https://httpstatuses.com/)
- [JWT Authentication Tutorial for Echo](https://echo.labstack.com/middleware/jwt/)

Echo's request handling system strikes a balance between simplicity and power. By mastering these concepts, you'll be well-equipped to build everything from simple APIs to complex web applications.