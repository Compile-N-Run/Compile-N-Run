---
title: Echo Development Workflow
description: Learn the fundamental development workflow when working with Echo, from project setup to deployment, with practical examples and best practices.

---

# Echo Development Workflow

Welcome to the Echo Development Workflow guide! In this tutorial, you'll learn the standard workflow for developing web applications using the Echo framework in Go. Whether you're building a simple API or a complex web service, understanding this workflow will help you develop efficiently and with best practices.

## Introduction

Echo is a high-performance, minimalist Go web framework designed to build RESTful APIs and web applications. It provides a streamlined development experience while maintaining excellent performance. Before diving into complex features, it's essential to understand the basic workflow of an Echo application.

In this guide, we'll cover:

1. Setting up your Echo project
2. Creating and structuring your application
3. Implementing routes and handlers
4. Testing your endpoints
5. Building and deploying your application

## Prerequisites

Before getting started, make sure you have:

- Go installed on your machine (version 1.16+ recommended)
- Basic knowledge of Go programming
- A code editor (VS Code, GoLand, etc.)
- Terminal/command-line access

## 1. Setting Up Your Echo Project

### Creating a New Project

Let's start by setting up a new Go project with Echo:

```bash
# Create a new directory for your project
mkdir echo-demo
cd echo-demo

# Initialize a Go module
go mod init github.com/yourusername/echo-demo

# Install Echo framework
go get github.com/labstack/echo/v4
```

### Project Structure

A typical Echo project might have the following structure:

```
echo-demo/
├── main.go              # Entry point of the application
├── handlers/            # HTTP request handlers
│   └── user_handler.go
├── models/              # Data models
│   └── user.go
├── routes/              # Route definitions
│   └── routes.go
├── middleware/          # Custom middleware
│   └── auth.go
├── config/              # Configuration files
│   └── config.go
├── static/              # Static files (CSS, JavaScript, images)
├── templates/           # HTML templates (if using server-side rendering)
├── go.mod               # Go module file
└── go.sum               # Go module checksum file
```

For a simple application, you might not need all these directories, but as your application grows, this structure helps keep your code organized.

## 2. Creating Your First Echo Application

Let's create a basic Echo application in `main.go`:

```go
package main

import (
	"net/http"
	
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

func main() {
	// Create a new Echo instance
	e := echo.New()
	
	// Add middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	
	// Define routes
	e.GET("/", hello)
	e.GET("/users/:id", getUser)
	
	// Start the server
	e.Logger.Fatal(e.Start(":8080"))
}

// Handler for the root path
func hello(c echo.Context) error {
	return c.String(http.StatusOK, "Hello, Echo!")
}

// Handler for the users/:id path
func getUser(c echo.Context) error {
	// Get parameter from URL
	userID := c.Param("id")
	
	// In a real application, you would fetch the user from a database
	return c.JSON(http.StatusOK, map[string]string{
		"id":   userID,
		"name": "John Doe",
		"email": "john@example.com",
	})
}
```

## 3. Implementing Routes and Handlers

### Defining Routes

Echo makes it easy to define routes for your API endpoints:

```go
// Basic GET route
e.GET("/products", getAllProducts)

// Route with path parameter
e.GET("/products/:id", getProductByID)

// POST route for creating resources
e.POST("/products", createProduct)

// PUT route for updating resources
e.PUT("/products/:id", updateProduct)

// DELETE route for deleting resources
e.DELETE("/products/:id", deleteProduct)
```

### Creating Handlers

Handlers are functions that process incoming HTTP requests. Here's how you can implement a handler that returns a JSON response:

```go
func getAllProducts(c echo.Context) error {
	products := []struct {
		ID    string `json:"id"`
		Name  string `json:"name"`
		Price float64 `json:"price"`
	}{
		{ID: "1", Name: "Echo Handbook", Price: 29.99},
		{ID: "2", Name: "Go Programming", Price: 39.99},
		{ID: "3", Name: "Web Development", Price: 49.99},
	}
	
	return c.JSON(http.StatusOK, products)
}
```

### Using Query Parameters

You can access query parameters using the `QueryParam` method:

```go
func searchProducts(c echo.Context) error {
	// Get query parameters
	query := c.QueryParam("q")
	category := c.QueryParam("category")
	
	return c.JSON(http.StatusOK, map[string]string{
		"query": query,
		"category": category,
		"message": "Search results for your query",
	})
}
```

Example request: `GET /products/search?q=echo&category=books`

### Request Body Binding

Echo can automatically bind JSON request bodies to Go structs:

```go
type Product struct {
	Name        string  `json:"name"`
	Description string  `json:"description"`
	Price       float64 `json:"price"`
	Category    string  `json:"category"`
}

func createProduct(c echo.Context) error {
	product := new(Product)
	
	// Bind the request body to the Product struct
	if err := c.Bind(product); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{
			"error": "Invalid request payload",
		})
	}
	
	// In a real application, you would save the product to a database
	
	return c.JSON(http.StatusCreated, product)
}
```

## 4. Adding Middleware

Middleware functions process requests before they reach route handlers or after handlers generate responses. Echo provides several built-in middleware components:

```go
// Add Logger middleware
e.Use(middleware.Logger())

// Add Recover middleware to recover from panics
e.Use(middleware.Recover())

// Add CORS middleware
e.Use(middleware.CORS())

// Add secure headers
e.Use(middleware.Secure())

// Rate limiting
e.Use(middleware.RateLimiter(middleware.NewRateLimiterMemoryStore(20)))
```

### Creating Custom Middleware

You can also create custom middleware:

```go
// Custom authentication middleware
func AuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
	return func(c echo.Context) error {
		token := c.Request().Header.Get("Authorization")
		
		// Check if token is valid
		if token != "valid-token" {
			return c.JSON(http.StatusUnauthorized, map[string]string{
				"error": "Unauthorized access",
			})
		}
		
		// Call the next handler
		return next(c)
	}
}

// Apply middleware to a specific route
e.GET("/protected", protectedHandler, AuthMiddleware)

// Or apply to a group of routes
adminGroup := e.Group("/admin", AuthMiddleware)
adminGroup.GET("/dashboard", adminDashboard)
```

## 5. Testing Your Echo Application

### Manual Testing

You can test your Echo application manually using tools like:

- Curl: A command-line tool for making HTTP requests
- Postman: A GUI tool for testing APIs
- Browser dev tools: For simple GET requests

Example curl command:

```bash
curl -X GET http://localhost:8080/users/123
```

Expected output:
```
{"id":"123","name":"John Doe","email":"john@example.com"}
```

### Automated Testing

Echo makes it easy to write automated tests using Go's testing package:

```go
package main

import (
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
)

func TestHelloHandler(t *testing.T) {
	// Setup
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	
	// Assertions
	if assert.NoError(t, hello(c)) {
		assert.Equal(t, http.StatusOK, rec.Code)
		assert.Equal(t, "Hello, Echo!", rec.Body.String())
	}
}

func TestGetUserHandler(t *testing.T) {
	// Setup
	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.SetPath("/users/:id")
	c.SetParamNames("id")
	c.SetParamValues("123")
	
	// Assertions
	if assert.NoError(t, getUser(c)) {
		assert.Equal(t, http.StatusOK, rec.Code)
		assert.Contains(t, rec.Body.String(), "John Doe")
	}
}
```

## 6. Building and Deploying Your Application

### Building for Production

```bash
# Build the application
go build -o app

# Run the application
./app
```

### Using Environment Variables

For configuration in different environments:

```go
package main

import (
	"os"
	
	"github.com/labstack/echo/v4"
)

func main() {
	e := echo.New()
	
	// Get port from environment variable or use default
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	
	// Start server
	e.Logger.Fatal(e.Start(":" + port))
}
```

### Containerization with Docker

Create a `Dockerfile` for your Echo application:

```dockerfile
FROM golang:1.19-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN go build -o main .

FROM alpine:latest

WORKDIR /app
COPY --from=builder /app/main .

EXPOSE 8080
CMD ["./main"]
```

Build and run the Docker container:

```bash
# Build the Docker image
docker build -t echo-app .

# Run the container
docker run -p 8080:8080 echo-app
```

## Real-World Example: RESTful API for a Book Library

Let's create a simple RESTful API for a book library with Echo:

```go
package main

import (
	"net/http"
	"strconv"
	
	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
)

// Book represents a book in our library
type Book struct {
	ID     int    `json:"id"`
	Title  string `json:"title"`
	Author string `json:"author"`
	Year   int    `json:"year"`
}

// In-memory database
var books = []Book{
	{ID: 1, Title: "The Go Programming Language", Author: "Alan Donovan & Brian Kernighan", Year: 2015},
	{ID: 2, Title: "Clean Code", Author: "Robert C. Martin", Year: 2008},
	{ID: 3, Title: "The Pragmatic Programmer", Author: "Andrew Hunt & David Thomas", Year: 1999},
}

func main() {
	e := echo.New()
	
	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())
	
	// Routes
	e.GET("/books", getAllBooks)
	e.GET("/books/:id", getBookByID)
	e.POST("/books", createBook)
	e.PUT("/books/:id", updateBook)
	e.DELETE("/books/:id", deleteBook)
	
	// Start server
	e.Logger.Fatal(e.Start(":8080"))
}

// Get all books
func getAllBooks(c echo.Context) error {
	return c.JSON(http.StatusOK, books)
}

// Get book by ID
func getBookByID(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}
	
	// Find book by ID
	for _, book := range books {
		if book.ID == id {
			return c.JSON(http.StatusOK, book)
		}
	}
	
	return c.JSON(http.StatusNotFound, map[string]string{"error": "Book not found"})
}

// Create a new book
func createBook(c echo.Context) error {
	book := new(Book)
	if err := c.Bind(book); err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request payload"})
	}
	
	// Set new book ID
	book.ID = len(books) + 1
	
	// Add to in-memory database
	books = append(books, *book)
	
	return c.JSON(http.StatusCreated, book)
}

// Update a book
func updateBook(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}
	
	// Find book by ID
	for i, book := range books {
		if book.ID == id {
			// Update book
			updatedBook := new(Book)
			if err := c.Bind(updatedBook); err != nil {
				return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid request payload"})
			}
			
			// Preserve ID
			updatedBook.ID = id
			
			// Update in-memory database
			books[i] = *updatedBook
			
			return c.JSON(http.StatusOK, updatedBook)
		}
	}
	
	return c.JSON(http.StatusNotFound, map[string]string{"error": "Book not found"})
}

// Delete a book
func deleteBook(c echo.Context) error {
	id, err := strconv.Atoi(c.Param("id"))
	if err != nil {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "Invalid ID"})
	}
	
	// Find book by ID
	for i, book := range books {
		if book.ID == id {
			// Remove from in-memory database
			books = append(books[:i], books[i+1:]...)
			return c.NoContent(http.StatusNoContent)
		}
	}
	
	return c.JSON(http.StatusNotFound, map[string]string{"error": "Book not found"})
}
```

## Summary

In this guide, you've learned the essential Echo development workflow:

1. **Setting up your project**: Creating a new Go module and installing Echo
2. **Creating an Echo application**: Defining the entry point and initializing Echo
3. **Implementing routes and handlers**: Creating endpoints and processing HTTP requests
4. **Using middleware**: Adding built-in and custom middleware for request processing
5. **Testing your application**: Manual and automated testing strategies
6. **Building and deployment**: Building for production and Docker containerization
7. **Real-world implementation**: Creating a RESTful API for a book library

This workflow provides a solid foundation for developing web applications with Echo. As you become more comfortable with these concepts, you can explore more advanced features like WebSockets, file uploads, authentication systems, and database integration.

## Additional Resources

- [Echo Framework Official Documentation](https://echo.labstack.com/)
- [Echo GitHub Repository](https://github.com/labstack/echo)
- [Go Documentation](https://golang.org/doc/)
- [RESTful API Design Best Practices](https://restfulapi.net/)

## Exercises

1. **Basic API**: Extend the book library API to include search functionality by title or author.
2. **Authentication**: Add basic authentication to the book library API using middleware.
3. **Persistent Storage**: Replace the in-memory database with a real database like SQLite or PostgreSQL.
4. **Validation**: Add request validation using Echo's validator.
5. **Documentation**: Add Swagger documentation to your API using echo-swagger.

Happy coding with Echo!