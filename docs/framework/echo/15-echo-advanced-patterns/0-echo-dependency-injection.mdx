---
title: Echo Dependency Injection
description: Learn how to implement dependency injection in Echo to create modular, maintainable, and testable applications

---

# Echo Dependency Injection

## Introduction to Dependency Injection in Echo

Dependency Injection (DI) is a design pattern that helps you create loosely coupled, modular applications by separating the creation of dependencies from the objects that use them. In the context of Echo, a popular Go web framework, implementing dependency injection allows you to build web applications that are easier to test, maintain, and extend.

Instead of hardcoding dependencies within your handlers or middleware, you provide (or "inject") them from the outside. This approach leads to code that is more maintainable and testable since you can easily swap implementations, especially during testing.

## Why Use Dependency Injection with Echo?

- **Improved testability**: Replace real dependencies with mock implementations for unit testing
- **Increased modularity**: Decouple components for better separation of concerns
- **Enhanced maintainability**: Changes to dependencies have minimal impact on dependent code
- **Simplified configuration**: Centralize dependency creation and configuration

## Basic Dependency Injection Techniques

### Method 1: Constructor Injection

The simplest form of dependency injection is through constructors (or factory functions in Go).

```go
// UserService defines methods for user operations
type UserService interface {
    GetUserByID(id string) (*User, error)
    CreateUser(user *User) error
}

// UserHandler manages HTTP requests for users
type UserHandler struct {
    userService UserService // Dependency
}

// NewUserHandler creates a new UserHandler with dependencies
func NewUserHandler(userService UserService) *UserHandler {
    return &UserHandler{
        userService: userService,
    }
}

// GetUser handles GET requests for a specific user
func (h *UserHandler) GetUser(c echo.Context) error {
    id := c.Param("id")
    user, err := h.userService.GetUserByID(id)
    
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
    }
    
    return c.JSON(http.StatusOK, user)
}
```

In your main application:

```go
func main() {
    e := echo.New()
    
    // Create dependencies
    db := initializeDatabase()
    userRepo := repository.NewUserRepository(db)
    userService := service.NewUserService(userRepo)
    
    // Create handler with injected dependencies
    userHandler := handlers.NewUserHandler(userService)
    
    // Register routes
    e.GET("/users/:id", userHandler.GetUser)
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

### Method 2: Closure-Based Injection

Another approach is to use closures to create handlers with access to dependencies:

```go
func NewGetUserHandler(userService UserService) echo.HandlerFunc {
    return func(c echo.Context) error {
        id := c.Param("id")
        user, err := userService.GetUserByID(id)
        
        if err != nil {
            return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
        }
        
        return c.JSON(http.StatusOK, user)
    }
}

// In main:
e.GET("/users/:id", NewGetUserHandler(userService))
```

## Advanced Dependency Injection in Echo

### Using Context for Dependencies

Echo's `Context` can be used to store and retrieve dependencies:

```go
// Middleware to inject dependencies into the context
func InjectDependencies(userService UserService, productService ProductService) echo.MiddlewareFunc {
    return func(next echo.HandlerFunc) echo.HandlerFunc {
        return func(c echo.Context) error {
            c.Set("userService", userService)
            c.Set("productService", productService)
            return next(c)
        }
    }
}

// Handler that uses injected dependencies
func GetUser(c echo.Context) error {
    userService, ok := c.Get("userService").(UserService)
    if !ok {
        return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Service unavailable"})
    }
    
    id := c.Param("id")
    user, err := userService.GetUserByID(id)
    
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{"error": "User not found"})
    }
    
    return c.JSON(http.StatusOK, user)
}

// In main:
e.Use(InjectDependencies(userService, productService))
e.GET("/users/:id", GetUser)
```

While this approach works, it's generally not recommended for all dependencies as it:
- Adds type assertion overhead
- Loses compile-time type safety
- Makes dependencies implicit

### Using a Dependency Container

For more complex applications, you might want to use a dependency container:

```go
// AppContainer holds all application dependencies
type AppContainer struct {
    DB           *sqlx.DB
    UserService  UserService
    AuthService  AuthService
    TokenManager TokenManager
    // More dependencies...
}

// NewAppContainer creates and initializes all dependencies
func NewAppContainer(config Config) (*AppContainer, error) {
    db, err := initDatabase(config.DBConfig)
    if err != nil {
        return nil, err
    }
    
    userRepo := repository.NewUserRepository(db)
    
    return &AppContainer{
        DB:           db,
        UserService:  service.NewUserService(userRepo),
        AuthService:  service.NewAuthService(userRepo, config.JWTSecret),
        TokenManager: auth.NewJWTManager(config.JWTSecret, config.TokenExpiry),
    }, nil
}

// CreateHandlers returns all HTTP handlers with their dependencies injected
func (c *AppContainer) CreateHandlers() *Handlers {
    return &Handlers{
        User: NewUserHandler(c.UserService),
        Auth: NewAuthHandler(c.AuthService, c.TokenManager),
    }
}
```

This centralized approach to dependency management makes your application easier to configure and maintain.

## Real-World Example: Blog Application

Let's see a more complete example of a blog application using dependency injection:

```go
// models.go
type Post struct {
    ID        string    `json:"id"`
    Title     string    `json:"title"`
    Content   string    `json:"content"`
    AuthorID  string    `json:"author_id"`
    CreatedAt time.Time `json:"created_at"`
}

// repository.go
type PostRepository interface {
    GetByID(id string) (*Post, error)
    GetAll() ([]*Post, error)
    Create(post *Post) error
    Update(post *Post) error
    Delete(id string) error
}

type SQLPostRepository struct {
    db *sqlx.DB
}

func NewSQLPostRepository(db *sqlx.DB) PostRepository {
    return &SQLPostRepository{db: db}
}

// Implement PostRepository methods...

// service.go
type PostService interface {
    GetPost(id string) (*Post, error)
    GetAllPosts() ([]*Post, error)
    CreatePost(post *Post) error
    UpdatePost(post *Post) error
    DeletePost(id string) error
}

type DefaultPostService struct {
    repo PostRepository
}

func NewPostService(repo PostRepository) PostService {
    return &DefaultPostService{repo: repo}
}

// Implement PostService methods...

// handler.go
type PostHandler struct {
    service PostService
}

func NewPostHandler(service PostService) *PostHandler {
    return &PostHandler{service: service}
}

func (h *PostHandler) GetPost(c echo.Context) error {
    id := c.Param("id")
    post, err := h.service.GetPost(id)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{"error": "Post not found"})
    }
    return c.JSON(http.StatusOK, post)
}

func (h *PostHandler) GetAllPosts(c echo.Context) error {
    posts, err := h.service.GetAllPosts()
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to fetch posts"})
    }
    return c.JSON(http.StatusOK, posts)
}

// Implement remaining handler methods...

// main.go
func main() {
    e := echo.New()
    
    // Initialize database
    db, err := sqlx.Connect("postgres", "postgres://user:pass@localhost/blog")
    if err != nil {
        e.Logger.Fatal(err)
    }
    
    // Create dependencies
    postRepo := NewSQLPostRepository(db)
    postService := NewPostService(postRepo)
    postHandler := NewPostHandler(postService)
    
    // Register routes
    e.GET("/posts", postHandler.GetAllPosts)
    e.GET("/posts/:id", postHandler.GetPost)
    e.POST("/posts", postHandler.CreatePost)
    e.PUT("/posts/:id", postHandler.UpdatePost)
    e.DELETE("/posts/:id", postHandler.DeletePost)
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Testing with Dependency Injection

One of the major benefits of dependency injection is testability. Here's how to test the `PostHandler`:

```go
func TestGetPost(t *testing.T) {
    // Create mock service
    mockService := &MockPostService{}
    mockService.On("GetPost", "123").Return(&Post{
        ID:       "123",
        Title:    "Test Post",
        Content:  "This is a test post",
        AuthorID: "456",
    }, nil)
    
    // Create handler with mock service
    handler := NewPostHandler(mockService)
    
    // Create request
    req := httptest.NewRequest(http.MethodGet, "/", nil)
    rec := httptest.NewRecorder()
    c := echo.New().NewContext(req, rec)
    c.SetPath("/posts/:id")
    c.SetParamNames("id")
    c.SetParamValues("123")
    
    // Test handler
    if err := handler.GetPost(c); err != nil {
        t.Fatalf("GetPost failed: %v", err)
    }
    
    // Assert response
    if rec.Code != http.StatusOK {
        t.Errorf("Expected status %d, got %d", http.StatusOK, rec.Code)
    }
    
    var post Post
    if err := json.Unmarshal(rec.Body.Bytes(), &post); err != nil {
        t.Fatalf("Failed to parse response: %v", err)
    }
    
    if post.ID != "123" || post.Title != "Test Post" {
        t.Errorf("Response body did not match expected result")
    }
    
    // Verify mock was called as expected
    mockService.AssertExpectations(t)
}
```

This test doesn't rely on a real database or service implementation, making it fast and reliable.

## Using Third-Party DI Libraries

For complex applications, consider using dedicated dependency injection libraries:

### Wire (by Google)

Wire is a compile-time dependency injection tool:

```go
// wire.go
// +build wireinject

package main

import (
    "github.com/google/wire"
)

func InitializeAPI() (*API, error) {
    wire.Build(
        NewConfig,
        NewDatabase,
        NewUserRepository,
        NewUserService,
        NewUserHandler,
        NewAPI,
    )
    return nil, nil
}

// When you run wire, it generates:
func InitializeAPI() (*API, error) {
    config := NewConfig()
    database, err := NewDatabase(config)
    if err != nil {
        return nil, err
    }
    userRepository := NewUserRepository(database)
    userService := NewUserService(userRepository)
    userHandler := NewUserHandler(userService)
    api := NewAPI(userHandler)
    return api, nil
}
```

### Dig (by Uber)

Dig provides runtime dependency injection:

```go
package main

import (
    "go.uber.org/dig"
)

func main() {
    container := dig.New()
    
    // Register dependencies
    container.Provide(NewConfig)
    container.Provide(NewDatabase)
    container.Provide(NewUserRepository)
    container.Provide(NewUserService)
    container.Provide(NewUserHandler)
    container.Provide(NewAPI)
    
    // Run the application
    err := container.Invoke(func(api *API) {
        api.Start()
    })
    
    if err != nil {
        panic(err)
    }
}
```

## Best Practices for Dependency Injection in Echo

1. **Interface-based design**: Define interfaces for dependencies to make them easily replaceable
2. **Single responsibility**: Each component should have one reason to change
3. **Constructor injection**: Pass dependencies through constructors or factory functions
4. **Avoid service locators**: Don't use global state or service locators when possible
5. **Centralize configuration**: Keep dependency creation and wiring in centralized locations
6. **Test with mocks**: Use dependency injection to substitute real implementations with mocks in tests
7. **Keep it simple**: Don't over-engineer; start with simple constructor injection before adopting a DI framework

## Summary

Dependency Injection is a powerful pattern that helps you create more maintainable and testable Echo applications. By explicitly providing dependencies to your handlers and services rather than creating them internally, you achieve a cleaner separation of concerns and improve the flexibility of your codebase.

In this guide, you've learned:
- Basic dependency injection techniques in Echo
- Advanced patterns using dependency containers
- How to structure a real-world application with DI
- Testing strategies for DI components
- Options for using third-party DI libraries

By applying these principles, you'll create Echo applications that are more modular, easier to test, and simpler to maintain as they grow in complexity.

## Additional Resources

- [Echo Framework Documentation](https://echo.labstack.com/)
- [Google Wire Library](https://github.com/google/wire)
- [Uber's Dig Library](https://github.com/uber-go/dig)
- [Effective Go - Interfaces](https://golang.org/doc/effective_go.html#interfaces)
- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

## Exercises

1. **Basic DI**: Create a simple Echo application with a `ProductHandler` that depends on a `ProductService` interface.
2. **Multiple Dependencies**: Extend your application to include authentication using an `AuthService` dependency.
3. **Container Implementation**: Create a simple dependency container for your Echo application that manages all services.
4. **Test Coverage**: Write tests for your handlers using mock implementations of your service interfaces.
5. **Wire Integration**: If you're feeling adventurous, integrate Google's Wire to handle dependency injection in your Echo application.