---
title: "Echo Secure Headers"
description: "Learn how to implement secure HTTP headers in your Echo web applications to protect against common web vulnerabilities"

---

# Echo Secure Headers

In today's web landscape, security is paramount. One of the simplest yet most effective ways to enhance your web application's security is through proper HTTP security headers. This guide will walk you through implementing secure headers in your Echo web applications.

## What are Secure Headers?

Secure headers are HTTP response headers that your application can use to increase the security of your web application. When set correctly, these headers help mitigate common web vulnerabilities like Cross-Site Scripting (XSS), Clickjacking, and other code injection attacks.

## Why are Secure Headers Important?

- They provide an additional layer of security
- They're easy to implement with significant security benefits
- They help protect against common web vulnerabilities
- They improve your application's security posture with minimal effort

## Common Security Headers

Let's explore the most important security headers you should consider implementing in your Echo applications:

### 1. Content-Security-Policy (CSP)

The Content-Security-Policy header helps prevent cross-site scripting (XSS) and data injection attacks by controlling what resources the browser is allowed to load.

### 2. X-XSS-Protection

This header enables the browser's built-in XSS protection filter, which helps detect and prevent reflected XSS attacks.

### 3. X-Frame-Options

This header prevents your page from being placed in an iframe, which helps protect against clickjacking attacks.

### 4. X-Content-Type-Options

Setting this header prevents browsers from MIME-sniffing a response from the declared content-type, reducing exposure to drive-by download attacks.

### 5. Strict-Transport-Security (HSTS)

This header enforces secure (HTTPS) connections to the server, helping protect against protocol downgrade attacks and cookie hijacking.

### 6. Referrer-Policy

Controls how much referrer information should be included with requests.

## Implementing Secure Headers in Echo

Echo provides a middleware called `Secure` that makes it easy to implement these security headers. Let's see how to use it:

### Basic Implementation

First, you need to import the Echo framework and the middleware package:

```go
package main

import (
    "net/http"
    
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    // Initialize Echo instance
    e := echo.New()
    
    // Implement secure headers middleware with default configuration
    e.Use(middleware.Secure())
    
    // Define a simple route
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Hello, Secure World!")
    })
    
    // Start the server
    e.Logger.Fatal(e.Start(":8080"))
}
```

When you run this application and make a request to it, you'll see the default security headers in the response:

```
X-XSS-Protection: 1; mode=block
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
```

### Custom Configuration

For more control, you can customize the security headers:

```go
package main

import (
    "net/http"
    
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    e := echo.New()
    
    // Custom secure middleware configuration
    e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
        XSSProtection:         "1; mode=block",
        ContentTypeNosniff:    "nosniff",
        XFrameOptions:         "DENY",
        HSTSMaxAge:            31536000,
        HSTSExcludeSubdomains: false,
        ContentSecurityPolicy: "default-src 'self'",
        ReferrerPolicy:        "strict-origin-when-cross-origin",
    }))
    
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Hello, Secure World!")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

This configuration will produce the following headers in the HTTP response:

```
Content-Security-Policy: default-src 'self'
Referrer-Policy: strict-origin-when-cross-origin
Strict-Transport-Security: max-age=31536000
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

## In-depth Explanation of Headers

### Content-Security-Policy

The CSP header allows you to define which resources the browser is allowed to load. Here's a more detailed example:

```go
ContentSecurityPolicy: "default-src 'self'; script-src 'self' https://trusted-cdn.com; img-src 'self' https://img-cdn.com; style-src 'self' https://style-cdn.com; font-src 'self' https://font-cdn.com;"
```

This policy:
- Only allows resources from the same origin by default
- Allows JavaScript from the same origin and trusted-cdn.com
- Allows images from the same origin and img-cdn.com
- Allows stylesheets from the same origin and style-cdn.com
- Allows fonts from the same origin and font-cdn.com

### Strict-Transport-Security

The HSTS header ensures that clients connect only via HTTPS:

```go
HSTSMaxAge:            31536000,  // 1 year in seconds
HSTSIncludeSubdomains: true,
HSTSPreload:           true,
```

By setting these options:
- Browsers will remember to use HTTPS for 1 year
- The policy applies to all subdomains
- The site is eligible for preload lists in browsers

## Real-world Example: Secure API Server

Let's create a more comprehensive example of an Echo API server with secure headers:

```go
package main

import (
    "net/http"
    
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    // Create a new Echo instance
    e := echo.New()
    
    // Add middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Setup secure headers middleware
    e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
        XSSProtection:         "1; mode=block",
        ContentTypeNosniff:    "nosniff",
        XFrameOptions:         "DENY",
        HSTSMaxAge:            31536000,
        HSTSIncludeSubdomains: true,
        ContentSecurityPolicy: "default-src 'self'; img-src 'self' https://images.example.com; script-src 'self' https://js.example.com; style-src 'self' https://styles.example.com;",
        ReferrerPolicy:        "strict-origin-when-cross-origin",
    }))
    
    // Define routes
    e.GET("/", func(c echo.Context) error {
        return c.JSON(http.StatusOK, map[string]string{
            "message": "Welcome to the secure API!",
        })
    })
    
    e.GET("/users", getUsers)
    e.POST("/users", createUser)
    
    // Start server
    e.Logger.Fatal(e.Start(":8080"))
}

func getUsers(c echo.Context) error {
    // In a real app, you would fetch users from a database
    users := []map[string]string{
        {"id": "1", "name": "Alice"},
        {"id": "2", "name": "Bob"},
    }
    return c.JSON(http.StatusOK, users)
}

func createUser(c echo.Context) error {
    type User struct {
        Name string `json:"name"`
    }
    
    u := new(User)
    if err := c.Bind(u); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    // In a real app, you would save to a database
    return c.JSON(http.StatusCreated, map[string]string{
        "message": "User created successfully",
        "name":    u.Name,
    })
}
```

## Adding Headers Manually

If you prefer to have even more control, you can also set security headers manually in your handlers:

```go
e.GET("/custom-headers", func(c echo.Context) error {
    // Set custom security headers for this specific route
    c.Response().Header().Set("X-Custom-Security-Header", "value")
    c.Response().Header().Set("Content-Security-Policy", "script-src 'self'")
    
    return c.String(http.StatusOK, "Custom headers set!")
})
```

## Best Practices for Secure Headers

1. **Start with strict policies**: Begin with the most restrictive policies possible, then relax them as needed.
2. **Test thoroughly**: Use browser developer tools to ensure your headers are properly configured.
3. **Use online security scanners**: Services like [Security Headers](https://securityheaders.com/) can analyze your headers.
4. **Regularly update your policies**: Security best practices evolve; keep your headers up-to-date.
5. **Consider your application's needs**: Different applications may require different header configurations.

## Verifying Your Security Headers

To check if your security headers are correctly implemented, you can:

1. Use browser developer tools (Network tab) to inspect response headers
2. Run the `curl` command with the `-I` flag to see headers:

```bash
curl -I http://localhost:8080
```

3. Use online tools like [Security Headers](https://securityheaders.com/)

## Summary

Implementing secure headers in your Echo web applications is a simple yet effective way to enhance security. By using Echo's built-in middleware, you can easily add these headers to protect against common web vulnerabilities.

Key takeaways:
- Secure headers add an important layer of security to web applications
- Echo provides the `Secure` middleware to easily implement security headers
- You can customize the headers based on your application's needs
- Regular testing and validation ensure your headers are effective

## Additional Resources

- [Echo Middleware Documentation](https://echo.labstack.com/middleware/secure)
- [OWASP Secure Headers Project](https://owasp.org/www-project-secure-headers/)
- [MDN Web Security](https://developer.mozilla.org/en-US/docs/Web/Security)
- [Content Security Policy Reference](https://content-security-policy.com/)

## Exercises

1. Implement a basic Echo server with default security headers and test the response headers.
2. Create a custom security header configuration with specific CSP directives for your application.
3. Build an Echo application that uses different security header configurations for different routes.
4. Use an online security header scanner to evaluate your application's header configuration.
5. Implement a middleware that logs whenever a potential security threat is detected based on headers.

By implementing secure headers in your Echo applications, you'll significantly improve your application's security posture with minimal effort.