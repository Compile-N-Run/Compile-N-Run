---
title: Echo Security Middleware
description: Learn how to implement and customize security middleware in Echo framework to protect your web applications from common vulnerabilities.

---

# Echo Security Middleware

Security is a critical aspect of any web application. The Echo framework provides several middleware components that can help secure your applications against common vulnerabilities and attacks. In this tutorial, we'll explore Echo's security middleware options, how to implement them, and best practices for keeping your applications secure.

## Introduction to Echo Security Middleware

Middleware in Echo works as a series of functions that process HTTP requests and responses. Security middleware specifically focuses on applying security measures to protect your application from various threats such as:

- Cross-Site Scripting (XSS)
- Cross-Site Request Forgery (CSRF)
- SQL Injection
- Clickjacking
- Content sniffing

Echo provides built-in middleware for addressing many security concerns, while also allowing you to create custom security middleware for your specific needs.

## Common Security Middleware in Echo

Let's explore the most important security middleware options available in Echo.

### 1. CORS Middleware

Cross-Origin Resource Sharing (CORS) is a security feature implemented by browsers that restricts web pages from making requests to a domain different from the one that served the original page.

#### How to Implement CORS Middleware

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    e := echo.New()
    
    // Default CORS middleware
    e.Use(middleware.CORS())
    
    // Custom CORS configuration
    e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
        AllowOrigins: []string{"https://yourwebsite.com", "https://anothersite.com"},
        AllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},
        AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept},
        AllowCredentials: true,
    }))
    
    // Routes
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Hello, World!")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

### 2. CSRF Protection

Cross-Site Request Forgery (CSRF) is an attack that forces authenticated users to execute unwanted actions on a web application they're currently logged into.

#### Implementing CSRF Middleware

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
    "net/http"
)

func main() {
    e := echo.New()
    
    // CSRF middleware
    e.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
        TokenLookup: "form:csrf",
        ContextKey:  "csrf",
        CookieName:  "csrf",
        CookiePath:  "/",
        Skipper: func(c echo.Context) bool {
            // Skip CSRF protection for certain routes if needed
            return c.Path() == "/public-api"
        },
    }))
    
    // Routes
    e.GET("/form", func(c echo.Context) error {
        // Retrieve the CSRF token
        token := c.Get("csrf").(string)
        
        // Return form with CSRF token
        return c.HTML(http.StatusOK, `
            <form method="POST" action="/submit">
                <input type="hidden" name="csrf" value="`+token+`">
                <input type="text" name="name">
                <button type="submit">Submit</button>
            </form>
        `)
    })
    
    e.POST("/submit", func(c echo.Context) error {
        return c.String(http.StatusOK, "Form submitted successfully!")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

### 3. Secure Headers Middleware

The Secure Headers middleware adds various HTTP headers to enhance security.

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    e := echo.New()
    
    // Default secure headers
    e.Use(middleware.Secure())
    
    // Custom secure headers configuration
    e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
        XSSProtection:         "1; mode=block",
        ContentTypeNosniff:    "nosniff",
        XFrameOptions:         "SAMEORIGIN",
        HSTSMaxAge:            3600,
        ContentSecurityPolicy: "default-src 'self'",
    }))
    
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Protected page")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

### 4. Rate Limiting Middleware

Rate limiting helps protect your application from brute force attacks and DoS attacks by limiting the number of requests that can be made in a given time period.

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
    "time"
)

func main() {
    e := echo.New()
    
    // Rate limiter middleware
    e.Use(middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
        Store: middleware.NewRateLimiterMemoryStore(20), // 20 requests
        Skipper: middleware.DefaultSkipper,
        BeforeFunc: nil,
        IdentifierExtractor: func(ctx echo.Context) (string, error) {
            return ctx.RealIP(), nil // Use the client's IP address as the identifier
        },
        ErrorHandler: func(context echo.Context, err error) error {
            return context.JSON(429, map[string]string{"error": "Too many requests"})
        },
        DenyHandler: func(context echo.Context, identifier string, err error) error {
            return context.JSON(429, map[string]string{"error": "Too many requests"})
        },
    }))
    
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Rate limited endpoint")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Creating Custom Security Middleware

While Echo provides many security middleware options, you might need to create custom middleware for specific security requirements.

### Example: Custom Authentication Middleware

Here's an example of a custom middleware for simple token-based authentication:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "net/http"
)

// TokenAuthMiddleware checks for a valid token in the request header
func TokenAuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        // Get token from header
        token := c.Request().Header.Get("Authorization")
        
        // Validate token (this is a simple example, use a proper validation in production)
        if token != "valid-secret-token" {
            return c.JSON(http.StatusUnauthorized, map[string]string{
                "error": "Invalid or missing authentication token",
            })
        }
        
        // Token is valid, call next middleware/handler
        return next(c)
    }
}

func main() {
    e := echo.New()
    
    // Public route
    e.GET("/public", func(c echo.Context) error {
        return c.String(http.StatusOK, "This is a public endpoint")
    })
    
    // Protected route group
    protectedGroup := e.Group("/protected")
    protectedGroup.Use(TokenAuthMiddleware)
    
    protectedGroup.GET("", func(c echo.Context) error {
        return c.String(http.StatusOK, "You accessed a protected endpoint")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

### Example: SQL Injection Protection Middleware

Here's a simple middleware that checks for possible SQL injection patterns:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "net/http"
    "regexp"
    "strings"
)

// SQLInjectionProtectionMiddleware checks for potential SQL injection patterns
func SQLInjectionProtectionMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        // Check query parameters
        for key, values := range c.QueryParams() {
            for _, value := range values {
                if containsSQLInjection(value) {
                    return c.JSON(http.StatusBadRequest, map[string]string{
                        "error": "Potential SQL injection detected",
                    })
                }
            }
        }
        
        // Check form values
        if err := c.Request().ParseForm(); err == nil {
            for _, value := range c.Request().Form {
                for _, v := range value {
                    if containsSQLInjection(v) {
                        return c.JSON(http.StatusBadRequest, map[string]string{
                            "error": "Potential SQL injection detected",
                        })
                    }
                }
            }
        }
        
        return next(c)
    }
}

// containsSQLInjection checks for common SQL injection patterns
func containsSQLInjection(value string) bool {
    // Convert to lowercase for case-insensitive matching
    value = strings.ToLower(value)
    
    // Check for common SQL injection patterns
    patterns := []string{
        "\\b(select|update|delete|insert|drop|alter)\\b",
        "--",
        "/\\*",
        "union\\s+(all\\s+)?select",
        "';",
        "' or '1'='1",
    }
    
    for _, pattern := range patterns {
        matched, _ := regexp.MatchString(pattern, value)
        if matched {
            return true
        }
    }
    
    return false
}

func main() {
    e := echo.New()
    
    // Apply the SQL injection protection middleware
    e.Use(SQLInjectionProtectionMiddleware)
    
    e.GET("/search", func(c echo.Context) error {
        query := c.QueryParam("q")
        return c.String(http.StatusOK, "Search results for: "+query)
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Combining Multiple Security Middleware

For comprehensive protection, you should combine multiple security middleware:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    e := echo.New()
    
    // Apply various security middleware
    e.Use(middleware.Recover())                       // Recover from panics
    e.Use(middleware.Secure())                        // Secure headers
    e.Use(middleware.CORS())                          // CORS protection
    e.Use(middleware.RateLimiter(middleware.NewRateLimiterMemoryStore(20))) // Rate limiting
    
    // Routes that need CSRF protection
    formGroup := e.Group("/form")
    formGroup.Use(middleware.CSRFWithConfig(middleware.CSRFConfig{
        TokenLookup: "form:csrf",
    }))
    
    // Add your routes
    e.GET("/", func(c echo.Context) error {
        return c.String(200, "Secured application")
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Best Practices for Echo Security Middleware

1. **Use HTTPS**: Always serve your Echo application over HTTPS in production.
2. **Implement Rate Limiting**: Protect against brute-force attacks and DoS attempts.
3. **Apply Secure Headers**: Prevent various browser-based attacks.
4. **Validate All Input**: Never trust user input, validate everything before processing.
5. **Implement Proper Authentication**: Use strong authentication mechanisms.
6. **Enable CSRF Protection**: For all forms and state-changing operations.
7. **Configure CORS Correctly**: Only allow necessary origins and methods.
8. **Keep Middleware Updated**: Always use the latest versions of Echo and its middleware.
9. **Use Prepared Statements**: Prevent SQL injection when working with databases.
10. **Log Security Events**: Maintain comprehensive logs of security-related events.

## Real-World Example: Secure API Server

Here's a complete example of a secure API server using Echo:

```go
package main

import (
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
    "net/http"
)

// JWTCustomClaims are custom claims extending default ones
type JWTCustomClaims struct {
    UserID int    `json:"user_id"`
    Name   string `json:"name"`
    Admin  bool   `json:"admin"`
    jwt.StandardClaims
}

func main() {
    e := echo.New()
    
    // Basic middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Security middleware
    e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
        XSSProtection:         "1; mode=block",
        ContentTypeNosniff:    "nosniff",
        XFrameOptions:         "SAMEORIGIN",
        HSTSMaxAge:            3600,
        ContentSecurityPolicy: "default-src 'self'",
    }))
    e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
        AllowOrigins: []string{"https://yourdomain.com"},
        AllowMethods: []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete},
        AllowHeaders: []string{echo.HeaderOrigin, echo.HeaderContentType, echo.HeaderAccept, echo.HeaderAuthorization},
    }))
    e.Use(middleware.GzipWithConfig(middleware.GzipConfig{
        Level: 5,
    }))
    e.Use(middleware.RateLimiterWithConfig(middleware.RateLimiterConfig{
        Store: middleware.NewRateLimiterMemoryStore(10),
        IdentifierExtractor: func(ctx echo.Context) (string, error) {
            return ctx.RealIP(), nil
        },
    }))
    
    // Public routes
    e.POST("/login", login)
    e.GET("/public", publicEndpoint)
    
    // Restricted routes with JWT middleware
    r := e.Group("/api")
    
    // Configure JWT middleware
    config := middleware.JWTConfig{
        Claims:     &JWTCustomClaims{},
        SigningKey: []byte("your-secret-key"),
    }
    r.Use(middleware.JWTWithConfig(config))
    
    // Protected routes
    r.GET("/private", privateEndpoint)
    r.GET("/admin", adminEndpoint, checkAdmin)
    
    e.Logger.Fatal(e.Start(":8080"))
}

// Login handler - issues JWT tokens
func login(c echo.Context) error {
    username := c.FormValue("username")
    password := c.FormValue("password")
    
    // Check username and password (example only)
    if username != "admin" || password != "password" {
        return echo.ErrUnauthorized
    }
    
    // Set custom claims
    claims := &JWTCustomClaims{
        1,
        "Administrator",
        true,
        jwt.StandardClaims{
            ExpiresAt: time.Now().Add(time.Hour * 24).Unix(),
        },
    }
    
    // Create token with claims
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    
    // Generate encoded token
    t, err := token.SignedString([]byte("your-secret-key"))
    if err != nil {
        return err
    }
    
    return c.JSON(http.StatusOK, map[string]string{
        "token": t,
    })
}

// Public endpoint handler
func publicEndpoint(c echo.Context) error {
    return c.String(http.StatusOK, "This is a public endpoint")
}

// Private endpoint handler
func privateEndpoint(c echo.Context) error {
    user := c.Get("user").(*jwt.Token)
    claims := user.Claims.(*JWTCustomClaims)
    name := claims.Name
    return c.String(http.StatusOK, "Welcome "+name+"!")
}

// Admin-only endpoint handler
func adminEndpoint(c echo.Context) error {
    return c.String(http.StatusOK, "Admin area - high security")
}

// Custom middleware to check if user is admin
func checkAdmin(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        user := c.Get("user").(*jwt.Token)
        claims := user.Claims.(*JWTCustomClaims)
        
        if claims.Admin != true {
            return echo.ErrForbidden
        }
        
        return next(c)
    }
}
```

## Summary

Echo's security middleware provides robust protection against common web vulnerabilities. In this guide, we've covered:

- How to implement CORS protection
- Setting up CSRF protection for forms and state-changing actions
- Adding secure HTTP headers
- Implementing rate limiting to protect against DoS attacks
- Creating custom security middleware for specific needs
- Combining multiple middleware for comprehensive protection

By implementing these security middleware components, you can significantly enhance the security of your Echo applications and protect them from common threats.

## Additional Resources

1. [Echo Framework official documentation](https://echo.labstack.com/middleware/overview)
2. [OWASP Top Ten Web Application Security Risks](https://owasp.org/www-project-top-ten/)
3. [Web Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Web_Security_Testing_Cheat_Sheet.html)

## Exercises

1. Implement a JWT authentication system with role-based access control.
2. Create a custom middleware that logs all attempted security breaches.
3. Build a middleware that validates the content type of requests to prevent content type-based attacks.
4. Implement a more sophisticated rate-limiting middleware that uses a sliding window algorithm.
5. Create a security middleware that identifies and blocks suspicious IP addresses based on their behavior patterns.