---
title: Echo RESTful Services
description: Learn how to create RESTful APIs with the Echo web framework in Go

---

# Echo RESTful Services

## Introduction

RESTful (Representational State Transfer) services are a popular architectural style for building web APIs that are stateless, scalable, and easy to maintain. Echo is a high-performance, extensible, and minimalist web framework for Go that makes building RESTful services straightforward and enjoyable.

In this guide, we'll explore how to create RESTful APIs using the Echo framework, understand the core concepts behind REST architecture, and implement best practices for building robust web services.

## What is REST?

REST (Representational State Transfer) is an architectural style that defines a set of constraints for creating web services. RESTful APIs use standard HTTP methods to perform operations on resources, which are typically represented by URLs.

The key principles of REST include:

- **Statelessness**: Each request from a client to a server contains all the information needed to understand and process the request.
- **Resource-Based**: Everything is a resource that can be identified by a unique URI.
- **Standard HTTP Methods**: Using HTTP methods (GET, POST, PUT, DELETE, etc.) for standard operations.
- **Representation of Resources**: Resources can have multiple representations (JSON, XML, HTML, etc.).

## Setting Up Echo for RESTful Services

First, let's set up an Echo application with the necessary dependencies:

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

func main() {
    // Create an instance of Echo
    e := echo.New()
    
    // Add middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Define routes
    
    // Start the server
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Basic CRUD Operations with Echo

RESTful APIs typically implement CRUD (Create, Read, Update, Delete) operations. Let's create a simple user management API to demonstrate these operations.

### 1. Defining the User Model

First, we'll define a simple User struct:

```go
type User struct {
    ID        int    `json:"id"`
    Name      string `json:"name"`
    Email     string `json:"email"`
    CreatedAt string `json:"created_at"`
}

// In-memory database for simplicity
var users = map[int]*User{}
var nextID = 1
```

### 2. Creating RESTful Endpoints

Now, let's implement the CRUD operations for our User resource:

```go
func main() {
    e := echo.New()
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // RESTful routes for users
    e.GET("/users", getUsers)
    e.POST("/users", createUser)
    e.GET("/users/:id", getUser)
    e.PUT("/users/:id", updateUser)
    e.DELETE("/users/:id", deleteUser)
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

### 3. Implementing the Handlers

Let's implement each of the handler functions:

#### Get All Users

```go
// getUsers returns all users
func getUsers(c echo.Context) error {
    userList := make([]*User, 0, len(users))
    for _, user := range users {
        userList = append(userList, user)
    }
    return c.JSON(http.StatusOK, userList)
}
```

#### Create a User

```go
// createUser adds a new user
func createUser(c echo.Context) error {
    user := new(User)
    if err := c.Bind(user); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    user.ID = nextID
    user.CreatedAt = time.Now().Format(time.RFC3339)
    users[user.ID] = user
    nextID++
    
    return c.JSON(http.StatusCreated, user)
}
```

#### Get a User by ID

```go
// getUser returns a specific user by ID
func getUser(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid user ID")
    }
    
    user, exists := users[id]
    if !exists {
        return echo.NewHTTPError(http.StatusNotFound, "User not found")
    }
    
    return c.JSON(http.StatusOK, user)
}
```

#### Update a User

```go
// updateUser modifies an existing user
func updateUser(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid user ID")
    }
    
    user, exists := users[id]
    if !exists {
        return echo.NewHTTPError(http.StatusNotFound, "User not found")
    }
    
    updatedUser := new(User)
    if err := c.Bind(updatedUser); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    // Preserve the ID and creation time
    updatedUser.ID = user.ID
    updatedUser.CreatedAt = user.CreatedAt
    users[id] = updatedUser
    
    return c.JSON(http.StatusOK, updatedUser)
}
```

#### Delete a User

```go
// deleteUser removes a user from the system
func deleteUser(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid user ID")
    }
    
    if _, exists := users[id]; !exists {
        return echo.NewHTTPError(http.StatusNotFound, "User not found")
    }
    
    delete(users, id)
    return c.NoContent(http.StatusNoContent)
}
```

## Testing Your RESTful API

You can test your API using tools like curl, Postman, or any HTTP client.

### Example Requests

#### Create a User

```bash
curl -X POST http://localhost:8080/users \
  -H "Content-Type: application/json" \
  -d '{"name": "John Doe", "email": "john@example.com"}'
```

Expected response:

```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2023-05-11T15:04:05Z07:00"
}
```

#### Get All Users

```bash
curl http://localhost:8080/users
```

Expected response:

```json
[
  {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com",
    "created_at": "2023-05-11T15:04:05Z07:00"
  }
]
```

#### Get a Specific User

```bash
curl http://localhost:8080/users/1
```

Expected response:

```json
{
  "id": 1,
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2023-05-11T15:04:05Z07:00"
}
```

#### Update a User

```bash
curl -X PUT http://localhost:8080/users/1 \
  -H "Content-Type: application/json" \
  -d '{"name": "Jane Doe", "email": "jane@example.com"}'
```

Expected response:

```json
{
  "id": 1,
  "name": "Jane Doe",
  "email": "jane@example.com",
  "created_at": "2023-05-11T15:04:05Z07:00"
}
```

#### Delete a User

```bash
curl -X DELETE http://localhost:8080/users/1
```

Expected response: No content (204 status code)

## Best Practices for Echo RESTful Services

### 1. Use Appropriate HTTP Methods

- **GET**: For retrieving resources
- **POST**: For creating new resources
- **PUT**: For updating existing resources (full update)
- **PATCH**: For partial updates to resources
- **DELETE**: For removing resources

### 2. Return Proper Status Codes

- **200 OK**: Successful request
- **201 Created**: Resource created successfully
- **204 No Content**: Successful request with no response body
- **400 Bad Request**: Client error
- **404 Not Found**: Resource not found
- **500 Internal Server Error**: Server-side error

### 3. Implement Validation

Echo makes it easy to validate incoming data:

```go
func createUser(c echo.Context) error {
    user := new(User)
    if err := c.Bind(user); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    // Simple validation
    if user.Name == "" || user.Email == "" {
        return echo.NewHTTPError(http.StatusBadRequest, "Name and email are required")
    }
    
    // Email validation
    if !strings.Contains(user.Email, "@") {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid email format")
    }
    
    // Continue with user creation...
}
```

### 4. Implement Middleware for Common Functionality

Echo's middleware system allows you to add cross-cutting concerns:

```go
// Add CORS middleware
e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
    AllowOrigins: []string{"*"},
    AllowMethods: []string{http.MethodGet, http.MethodPut, http.MethodPost, http.MethodDelete},
}))

// Add JWT authentication middleware to protected routes
r := e.Group("/api")
r.Use(middleware.JWT([]byte("secret")))
```

### 5. Use Route Groups to Organize Related Endpoints

```go
// API v1 routes
v1 := e.Group("/api/v1")
{
    users := v1.Group("/users")
    users.GET("", getUsers)
    users.POST("", createUser)
    users.GET("/:id", getUser)
    users.PUT("/:id", updateUser)
    users.DELETE("/:id", deleteUser)
}

// API v2 routes
v2 := e.Group("/api/v2")
{
    // Version 2 API endpoints
}
```

## Real-world Example: Building a Todo API

Let's create a more complete example with a todo list API, including proper error handling, validation, and persistence.

```go
package main

import (
    "net/http"
    "strconv"
    "time"
    
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

// Todo represents a task in our todo list
type Todo struct {
    ID          int       `json:"id"`
    Title       string    `json:"title"`
    Description string    `json:"description"`
    Completed   bool      `json:"completed"`
    DueDate     string    `json:"due_date,omitempty"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// TodoStore provides an interface for todo storage
type TodoStore interface {
    GetAll() ([]Todo, error)
    Get(id int) (Todo, error)
    Create(todo Todo) (Todo, error)
    Update(todo Todo) error
    Delete(id int) error
}

// InMemoryTodoStore implements TodoStore using an in-memory map
type InMemoryTodoStore struct {
    todos  map[int]Todo
    nextID int
}

// NewInMemoryTodoStore creates a new in-memory store
func NewInMemoryTodoStore() *InMemoryTodoStore {
    return &InMemoryTodoStore{
        todos:  make(map[int]Todo),
        nextID: 1,
    }
}

func (s *InMemoryTodoStore) GetAll() ([]Todo, error) {
    todos := make([]Todo, 0, len(s.todos))
    for _, todo := range s.todos {
        todos = append(todos, todo)
    }
    return todos, nil
}

func (s *InMemoryTodoStore) Get(id int) (Todo, error) {
    todo, exists := s.todos[id]
    if !exists {
        return Todo{}, echo.NewHTTPError(http.StatusNotFound, "Todo not found")
    }
    return todo, nil
}

func (s *InMemoryTodoStore) Create(todo Todo) (Todo, error) {
    todo.ID = s.nextID
    todo.CreatedAt = time.Now()
    todo.UpdatedAt = time.Now()
    s.todos[todo.ID] = todo
    s.nextID++
    return todo, nil
}

func (s *InMemoryTodoStore) Update(todo Todo) error {
    if _, exists := s.todos[todo.ID]; !exists {
        return echo.NewHTTPError(http.StatusNotFound, "Todo not found")
    }
    
    existingTodo := s.todos[todo.ID]
    todo.CreatedAt = existingTodo.CreatedAt
    todo.UpdatedAt = time.Now()
    s.todos[todo.ID] = todo
    
    return nil
}

func (s *InMemoryTodoStore) Delete(id int) error {
    if _, exists := s.todos[id]; !exists {
        return echo.NewHTTPError(http.StatusNotFound, "Todo not found")
    }
    
    delete(s.todos, id)
    return nil
}

// TodoHandler handles HTTP requests for todos
type TodoHandler struct {
    store TodoStore
}

// NewTodoHandler creates a new todo handler
func NewTodoHandler(store TodoStore) *TodoHandler {
    return &TodoHandler{store: store}
}

// RegisterRoutes registers all todo routes
func (h *TodoHandler) RegisterRoutes(e *echo.Echo) {
    todos := e.Group("/todos")
    
    todos.GET("", h.GetAllTodos)
    todos.POST("", h.CreateTodo)
    todos.GET("/:id", h.GetTodo)
    todos.PUT("/:id", h.UpdateTodo)
    todos.DELETE("/:id", h.DeleteTodo)
}

// GetAllTodos returns all todos
func (h *TodoHandler) GetAllTodos(c echo.Context) error {
    todos, err := h.store.GetAll()
    if err != nil {
        return err
    }
    return c.JSON(http.StatusOK, todos)
}

// CreateTodo adds a new todo
func (h *TodoHandler) CreateTodo(c echo.Context) error {
    todo := new(Todo)
    if err := c.Bind(todo); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    // Validate todo
    if todo.Title == "" {
        return echo.NewHTTPError(http.StatusBadRequest, "Title is required")
    }
    
    createdTodo, err := h.store.Create(*todo)
    if err != nil {
        return err
    }
    
    return c.JSON(http.StatusCreated, createdTodo)
}

// GetTodo returns a specific todo
func (h *TodoHandler) GetTodo(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid ID")
    }
    
    todo, err := h.store.Get(id)
    if err != nil {
        return err
    }
    
    return c.JSON(http.StatusOK, todo)
}

// UpdateTodo updates an existing todo
func (h *TodoHandler) UpdateTodo(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid ID")
    }
    
    todo := new(Todo)
    if err := c.Bind(todo); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    todo.ID = id
    if err := h.store.Update(*todo); err != nil {
        return err
    }
    
    updatedTodo, err := h.store.Get(id)
    if err != nil {
        return err
    }
    
    return c.JSON(http.StatusOK, updatedTodo)
}

// DeleteTodo removes a todo
func (h *TodoHandler) DeleteTodo(c echo.Context) error {
    id, err := strconv.Atoi(c.Param("id"))
    if err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Invalid ID")
    }
    
    if err := h.store.Delete(id); err != nil {
        return err
    }
    
    return c.NoContent(http.StatusNoContent)
}

func main() {
    // Create a new Echo instance
    e := echo.New()
    
    // Add middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    e.Use(middleware.CORS())
    
    // Create todo store and handler
    store := NewInMemoryTodoStore()
    handler := NewTodoHandler(store)
    
    // Register routes
    handler.RegisterRoutes(e)
    
    // Start the server
    e.Logger.Fatal(e.Start(":8080"))
}
```

## Summary

In this guide, we've explored how to create RESTful services using the Echo framework in Go. We've covered:

- The fundamentals of REST architecture
- Setting up Echo for building APIs
- Implementing CRUD operations
- Best practices for RESTful services
- A real-world todo list application example

Echo provides a powerful yet simple foundation for building high-performance RESTful APIs in Go. By following RESTful principles and leveraging Echo's features, you can create clean, maintainable, and efficient web services.

## Additional Resources

- [Echo Framework Official Documentation](https://echo.labstack.com/)
- [REST API Tutorial](https://restfulapi.net/)
- [HTTP Status Codes](https://httpstatuses.com/)
- [Richardson Maturity Model](https://martinfowler.com/articles/richardsonMaturityModel.html) - A framework for evaluating RESTfulness

## Exercises

1. **Adding Pagination**: Modify the todo list API to support pagination of results.
2. **Filtering and Sorting**: Add query parameters to filter todos by status (completed/incomplete) and sort by due date.
3. **Database Integration**: Replace the in-memory store with a persistent database like PostgreSQL or MongoDB.
4. **Authentication**: Implement JWT authentication to protect the todo API endpoints.
5. **Swagger Documentation**: Add Swagger documentation to your API using Echo Swagger middleware.

By working through these exercises, you'll gain a deeper understanding of RESTful API development with Echo and be well-prepared to build production-ready web services.