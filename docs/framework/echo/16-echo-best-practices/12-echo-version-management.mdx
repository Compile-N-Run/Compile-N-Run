---
title: "Echo Version Management"
description: "Learn best practices for managing versions in your Echo web applications, including versioning APIs, deployment strategies, and dependency management."

---

# Echo Version Management

Managing versions effectively in your Echo applications is crucial for maintaining compatibility, scaling your application, and ensuring smooth updates. This guide will walk you through the best practices for version management in Echo frameworks, helping you build maintainable and scalable web applications.

## Introduction to Version Management

Version management in Echo applications encompasses several aspects:

1. **API versioning** - How to manage different versions of your API endpoints
2. **Echo framework version management** - How to handle Echo updates and migrations
3. **Dependency management** - Managing Go modules and third-party libraries
4. **Application deployment versioning** - Strategies for versioning your deployments

Let's explore each aspect in detail with practical examples.

## API Versioning in Echo

API versioning allows you to evolve your API without breaking existing client applications. There are several approaches to API versioning in Echo:

### 1. URL Path Versioning

This is the most straightforward approach, where you include the version in the URL path.

```go
e := echo.New()

// API v1 routes
v1 := e.Group("/api/v1")
v1.GET("/users", getUsersV1)
v1.POST("/users", createUserV1)

// API v2 routes
v2 := e.Group("/api/v2")
v2.GET("/users", getUsersV2)
v2.POST("/users", createUserV2)
```

This approach allows clients to explicitly request a specific API version.

### 2. Query Parameter Versioning

You can also specify the version as a query parameter:

```go
e.GET("/api/users", func(c echo.Context) error {
    version := c.QueryParam("version")
    
    switch version {
    case "1":
        return getUsersV1(c)
    case "2":
        return getUsersV2(c)
    default:
        return getUsersV1(c) // Default to latest stable version
    }
})
```

### 3. Header-Based Versioning

Using HTTP headers for versioning:

```go
e.GET("/api/users", func(c echo.Context) error {
    version := c.Request().Header.Get("API-Version")
    
    switch version {
    case "1":
        return getUsersV1(c)
    case "2":
        return getUsersV2(c)
    default:
        return getUsersV1(c)
    }
})
```

## Practical API Versioning Example

Let's create a more comprehensive example of API versioning:

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
)

type UserV1 struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
}

type UserV2 struct {
    ID       int    `json:"id"`
    Name     string `json:"name"`
    Email    string `json:"email"`
    JoinDate string `json:"join_date"`
}

func main() {
    e := echo.New()
    
    // API v1 group
    v1 := e.Group("/api/v1")
    v1.GET("/users", func(c echo.Context) error {
        users := []UserV1{
            {ID: 1, Name: "John Doe"},
            {ID: 2, Name: "Jane Smith"},
        }
        return c.JSON(http.StatusOK, users)
    })
    
    // API v2 group
    v2 := e.Group("/api/v2")
    v2.GET("/users", func(c echo.Context) error {
        users := []UserV2{
            {ID: 1, Name: "John Doe", Email: "john@example.com", JoinDate: "2022-01-15"},
            {ID: 2, Name: "Jane Smith", Email: "jane@example.com", JoinDate: "2022-03-20"},
        }
        return c.JSON(http.StatusOK, users)
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

**Example API Calls and Responses:**

For v1:
```
GET /api/v1/users
```

Response:
```json
[
  {"id": 1, "name": "John Doe"},
  {"id": 2, "name": "Jane Smith"}
]
```

For v2:
```
GET /api/v2/users
```

Response:
```json
[
  {"id": 1, "name": "John Doe", "email": "john@example.com", "join_date": "2022-01-15"},
  {"id": 2, "name": "Jane Smith", "email": "jane@example.com", "join_date": "2022-03-20"}
]
```

## Managing Echo Framework Versions

Echo follows semantic versioning, which makes it easier to understand the impact of upgrading.

### Using Go Modules

Go modules allow you to pin specific versions of Echo:

```
go get github.com/labstack/echo/v4@v4.10.2
```

In your `go.mod` file, you'll see:
```
require github.com/labstack/echo/v4 v4.10.2
```

### Upgrading Echo Versions

To upgrade to a newer version:

```
go get -u github.com/labstack/echo/v4
```

For a specific version:
```
go get github.com/labstack/echo/v4@v4.11.0
```

### Breaking Changes Between Versions

When upgrading between major versions (e.g., v3 to v4), you'll need to adapt your code to handle breaking changes. Always read the changelog for important details.

Example migration from Echo v3 to v4:

```go
// Echo v3
e := echo.New()
e.Use(middleware.Logger())

// Echo v4
e := echo.New()
e.Use(middleware.Logger())
// The Context.Path() was renamed to Context.Path in v4
// Context.Path() in v3
// Context.Path in v4
```

## Dependency Management Best Practices

### 1. Vendor Dependencies

Consider vendoring dependencies for production applications:

```
go mod vendor
```

This creates a `vendor` directory with all dependencies, ensuring build reproducibility.

### 2. Use Go Modules

Always use Go modules for dependency management. Initialize a module for your project:

```
go mod init github.com/yourusername/yourproject
```

### 3. Version Pinning

Pin specific versions of critical dependencies:

```
go get github.com/some/dependency@v1.2.3
```

### 4. Regular Audits

Regularly audit and update dependencies to patch security vulnerabilities:

```
go list -m all
go get -u all
```

## Application Deployment Versioning

### Semantic Versioning

Follow semantic versioning (SemVer) for your application:

- **Major version**: Incompatible API changes
- **Minor version**: New functionality, backward-compatible
- **Patch version**: Bug fixes, backward-compatible

Example:
```
v1.2.3
```

### Versioning in Docker Deployments

When using Docker, tag your images with semantic versions:

```dockerfile
FROM golang:1.19-alpine AS builder

WORKDIR /app
COPY . .
RUN go build -o server main.go

FROM alpine:latest
WORKDIR /app
COPY --from=builder /app/server .
ENV APP_VERSION=1.2.3
CMD ["./server"]
```

Build and tag:
```
docker build -t myapp:1.2.3 .
```

### Exposing Version Information

Add a version endpoint to your Echo application:

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
)

var (
    appVersion = "1.2.3" // Set during build
)

func main() {
    e := echo.New()
    
    // Version endpoint
    e.GET("/version", func(c echo.Context) error {
        return c.JSON(http.StatusOK, map[string]string{
            "version": appVersion,
            "echo_version": echo.Version,
        })
    })
    
    e.Logger.Fatal(e.Start(":8080"))
}
```

You can inject the version at build time:

```
go build -ldflags "-X main.appVersion=1.2.3" -o server main.go
```

## Real-World Version Management Example

Let's put everything together in a practical example:

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
    "github.com/labstack/echo/v4/middleware"
)

var (
    appVersion = "0.1.0" // Default value, overridden during build
)

// ApiVersion represents API versioning information
type ApiVersion struct {
    App  string `json:"app_version"`
    Echo string `json:"echo_version"`
    API  string `json:"api_version"`
}

func main() {
    e := echo.New()
    
    // Middleware
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    
    // Version endpoint - available to all
    e.GET("/version", getVersion)
    
    // API v1
    v1 := e.Group("/api/v1")
    v1.GET("/users", getUsersV1)
    v1.POST("/users", createUserV1)
    
    // API v2
    v2 := e.Group("/api/v2")
    v2.GET("/users", getUsersV2)
    v2.POST("/users", createUserV2)
    
    e.Logger.Fatal(e.Start(":8080"))
}

func getVersion(c echo.Context) error {
    return c.JSON(http.StatusOK, ApiVersion{
        App:  appVersion,
        Echo: echo.Version,
        API:  "2.0", // Current API version
    })
}

func getUsersV1(c echo.Context) error {
    users := []map[string]interface{}{
        {"id": 1, "name": "User One"},
        {"id": 2, "name": "User Two"},
    }
    return c.JSON(http.StatusOK, users)
}

func createUserV1(c echo.Context) error {
    // V1 user creation logic
    return c.JSON(http.StatusCreated, map[string]string{"status": "created"})
}

func getUsersV2(c echo.Context) error {
    users := []map[string]interface{}{
        {"id": 1, "name": "User One", "role": "admin", "created_at": "2023-01-01"},
        {"id": 2, "name": "User Two", "role": "user", "created_at": "2023-02-15"},
    }
    return c.JSON(http.StatusOK, users)
}

func createUserV2(c echo.Context) error {
    // V2 user creation logic with enhanced fields
    return c.JSON(http.StatusCreated, map[string]string{
        "status": "created",
        "version": "2.0",
    })
}
```

To build with version information:
```
go build -ldflags "-X main.appVersion=1.0.0" -o server main.go
```

## Version Documentation

Document your API versions clearly for clients:

```go
e.GET("/docs", func(c echo.Context) error {
    docs := map[string]interface{}{
        "v1": {
            "status": "stable",
            "endpoints": []string{"/api/v1/users"},
            "deprecation_date": "2024-01-01",
        },
        "v2": {
            "status": "current",
            "endpoints": []string{"/api/v2/users"},
            "added_features": ["user roles", "timestamps"],
        },
    }
    return c.JSON(http.StatusOK, docs)
})
```

## Summary

Effective version management in Echo applications involves:

1. **API Versioning**: Choose a versioning strategy (URL path, query parameters, or headers) that fits your application needs.

2. **Echo Framework Updates**: Use Go modules to manage Echo versions and carefully handle breaking changes during updates.

3. **Dependency Management**: Follow Go module best practices, pin versions, and regularly audit dependencies.

4. **Deployment Versioning**: Implement semantic versioning for your application and expose version information through an API endpoint.

By following these best practices, you'll create maintainable Echo applications that can evolve without breaking existing clients.

## Additional Resources

- [Echo Framework Documentation](https://echo.labstack.com/)
- [Semantic Versioning Specification](https://semver.org/)
- [Go Modules Documentation](https://golang.org/ref/mod)
- [RESTful API Design Guidelines](https://restfulapi.net/versioning/)

## Exercises

1. Create a simple Echo application with two API versions and a version endpoint.
2. Implement header-based API versioning with fallback to the latest stable version.
3. Add a middleware that logs the API version being used for each request.
4. Create a Docker setup that builds and tags your Echo application with the correct version number.
5. Implement a graceful upgrade mechanism that allows running two versions of your API simultaneously during a deployment.