---
title: Echo WebSocket Events
description: Learn about the different events available in Echo WebSockets and how to handle them effectively in your real-time applications.

---

# Echo WebSocket Events

When building real-time applications with Echo WebSockets, understanding the various events that occur during a WebSocket connection is crucial. These events allow your application to respond appropriately to connection states, messages, and errors. In this guide, we'll explore the different types of events in Echo WebSockets and how to use them effectively.

## Introduction to WebSocket Events

WebSockets provide a persistent connection between a client and server, enabling real-time, bidirectional communication. Echo is a JavaScript library that simplifies working with WebSockets by providing an elegant, developer-friendly API. 

Echo WebSockets use an event-based system where you can register callbacks for specific events, making your application react to changes in the connection state or incoming messages.

## Core Echo WebSocket Events

### Connection Events

Echo provides several events that help you manage the connection lifecycle:

#### 1. Connect Event

The connect event fires when a connection is successfully established with the server.

```javascript
// Initialize Echo instance
const echo = new Echo({
    broadcaster: 'pusher',
    key: 'your-pusher-key',
    wsHost: window.location.hostname,
    wsPort: 6001,
    forceTLS: false,
    disableStats: true,
});

// Listen for connection
echo.connector.pusher.connection.bind('connected', () => {
    console.log('Connection established successfully!');
    // Update UI or initialize components that require WebSocket connection
});
```

#### 2. Disconnect Event

The disconnect event is triggered when the WebSocket connection is closed.

```javascript
echo.connector.pusher.connection.bind('disconnected', () => {
    console.log('Disconnected from WebSocket server');
    // Handle disconnection, perhaps show a reconnecting message
});
```

#### 3. Error Event

The error event fires when there's an error with the WebSocket connection.

```javascript
echo.connector.pusher.connection.bind('error', (error) => {
    console.error('WebSocket connection error:', error);
    // Handle error, perhaps retry connection or show error message
});
```

### Channel Events

Beyond connection events, Echo provides events for channel operations:

#### 1. Subscription Succeeded

This event triggers when you successfully subscribe to a channel.

```javascript
const channel = echo.channel('notifications');

channel.subscribe(() => {
    console.log('Successfully subscribed to notifications channel');
});
```

#### 2. Subscription Error

This event fires when there's an error subscribing to a channel.

```javascript
channel.error((error) => {
    console.error('Error subscribing to channel:', error);
});
```

## Custom Events

The real power of Echo WebSockets comes from handling custom events that your application defines.

### Basic Custom Event Handling

```javascript
// Listen for a 'NewMessage' event on the 'chat' channel
echo.channel('chat')
    .listen('NewMessage', (e) => {
        console.log('New message received:', e.message);
        // Handle the new message, e.g., append to chat window
        appendMessageToChat(e.message, e.user);
    });
```

### Private Channel Events

For authenticated channels, the approach is similar but uses the `private` method:

```javascript
echo.private('chat.user.' + userId)
    .listen('PrivateMessage', (e) => {
        console.log('Private message received:', e.message);
        // Handle the private message
        showPrivateNotification(e.message, e.fromUser);
    });
```

### Presence Channel Events

Presence channels add special events for tracking users joining or leaving:

```javascript
const presenceChannel = echo.join('room.' + roomId);

// When users join the channel
presenceChannel.here((users) => {
    console.log('Users currently in the room:', users);
    displayActiveUsers(users);
});

// When a new user joins
presenceChannel.joining((user) => {
    console.log('User joined the room:', user);
    addUserToList(user);
    showJoinNotification(user.name);
});

// When a user leaves
presenceChannel.leaving((user) => {
    console.log('User left the room:', user);
    removeUserFromList(user);
    showLeaveNotification(user.name);
});
```

## Practical Example: Building a Real-Time Chat Application

Let's combine what we've learned to build a simple chat application using Echo WebSockets events:

```javascript
// Initialize Echo
const echo = new Echo({
    broadcaster: 'pusher',
    key: 'your-pusher-key',
    wsHost: window.location.hostname,
    wsPort: 6001,
    forceTLS: false,
    disableStats: true,
});

// Connection status indicator
const statusIndicator = document.getElementById('connection-status');

// Connection events
echo.connector.pusher.connection.bind('connected', () => {
    statusIndicator.textContent = 'Connected';
    statusIndicator.className = 'status-online';
});

echo.connector.pusher.connection.bind('disconnected', () => {
    statusIndicator.textContent = 'Disconnected';
    statusIndicator.className = 'status-offline';
});

echo.connector.pusher.connection.bind('error', (error) => {
    statusIndicator.textContent = 'Error: ' + error.message;
    statusIndicator.className = 'status-error';
});

// Join presence channel for the chat room
const chatRoom = echo.join('chat.room.1');
const messageList = document.getElementById('messages');
const usersList = document.getElementById('users');

// Handle presence events
chatRoom.here((users) => {
    usersList.innerHTML = ''; // Clear the list
    users.forEach(user => {
        const userEl = document.createElement('li');
        userEl.textContent = user.name;
        userEl.id = `user-${user.id}`;
        usersList.appendChild(userEl);
    });
});

chatRoom.joining((user) => {
    const userEl = document.createElement('li');
    userEl.textContent = user.name;
    userEl.id = `user-${user.id}`;
    usersList.appendChild(userEl);
    
    // Show notification
    showNotification(`${user.name} has joined the chat`);
});

chatRoom.leaving((user) => {
    const userEl = document.getElementById(`user-${user.id}`);
    if (userEl) userEl.remove();
    
    // Show notification
    showNotification(`${user.name} has left the chat`);
});

// Listen for new chat messages
chatRoom.listen('MessageSent', (event) => {
    const messageEl = document.createElement('div');
    messageEl.className = 'message';
    messageEl.innerHTML = `
        <span class="username">${event.user.name}:</span>
        <span class="text">${event.message}</span>
        <span class="time">${new Date().toLocaleTimeString()}</span>
    `;
    messageList.appendChild(messageEl);
    
    // Auto-scroll to the latest message
    messageList.scrollTop = messageList.scrollHeight;
});

// Function to send a message
function sendMessage() {
    const input = document.getElementById('message-input');
    const message = input.value.trim();
    
    if (message) {
        // Send via your API
        fetch('/api/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content
            },
            body: JSON.stringify({ message: message, room_id: 1 })
        }).then(response => {
            if (response.ok) {
                input.value = ''; // Clear input field
            }
        }).catch(error => {
            console.error('Error sending message:', error);
        });
    }
}

// Helper function for notifications
function showNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.textContent = message;
    messageList.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        notification.remove();
    }, 5000);
}

// Attach event listener to send button
document.getElementById('send-button').addEventListener('click', sendMessage);

// Allow pressing Enter to send
document.getElementById('message-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        sendMessage();
    }
});
```

In this example, we've built a chat application that:

1. Shows connection status
2. Displays a list of online users
3. Shows notifications when users join or leave
4. Displays incoming messages in real-time
5. Allows users to send messages

## Advanced Event Handling

### Wildcard Event Listeners

Sometimes you might want to listen to multiple events with similar patterns. Echo supports wildcard event listeners:

```javascript
echo.channel('orders')
    .listen('.order.*', (event, eventName) => {
        console.log(`Event ${eventName} was triggered with data:`, event);
        
        // Different handling based on event name
        if (eventName === '.order.created') {
            showNewOrderNotification(event);
        } else if (eventName === '.order.updated') {
            updateOrderInList(event);
        } else if (eventName === '.order.shipped') {
            markOrderAsShipped(event);
        }
    });
```

### Unsubscribing from Events

It's important to clean up event listeners when they're no longer needed to prevent memory leaks:

```javascript
// Store reference to the callback
const messageCallback = (e) => {
    console.log('Message received:', e);
};

// Subscribe to the event
const channel = echo.channel('chat');
channel.listen('NewMessage', messageCallback);

// Later, unsubscribe from the event
channel.stopListening('NewMessage', messageCallback);

// To unsubscribe from all events on a channel
channel.stopListening();

// To leave a channel entirely
echo.leave('chat');
```

### Handling Reconnections

Echo automatically attempts to reconnect when a connection is lost. You can handle reconnection events:

```javascript
echo.connector.pusher.connection.bind('connecting', () => {
    console.log('Attempting to reconnect...');
    showReconnectingIndicator();
});

echo.connector.pusher.connection.bind('connected', () => {
    console.log('Reconnected successfully!');
    hideReconnectingIndicator();
    // Refresh data that might have been missed during disconnection
    refreshData();
});
```

## Common Patterns and Best Practices

1. **Error Handling**: Always handle connection errors gracefully to provide a good user experience.

```javascript
echo.connector.pusher.connection.bind('error', (error) => {
    if (error.type === 'WebSocketError') {
        showUserFriendlyError("We're having trouble connecting to the server. Please check your internet connection.");
    } else if (error.type === 'AuthError') {
        // Authentication error, user might need to log in again
        showAuthError("Your session has expired. Please log in again.");
        redirectToLogin();
    } else {
        showGenericError("Something went wrong. We'll try to reconnect automatically.");
    }
});
```

2. **Loading States**: Show appropriate loading states while establishing connections.

```javascript
// Before connecting
showLoadingIndicator();

// When connected
echo.connector.pusher.connection.bind('connected', () => {
    hideLoadingIndicator();
    showConnectedState();
});
```

3. **Organizing Event Handlers**: For complex applications, organize your event handlers by feature.

```javascript
// In chat.js
function initializeChatEvents(echo, roomId) {
    const channel = echo.join(`chat.room.${roomId}`);
    // Set up all chat-related event handlers
    // ...
    return channel; // Return for potential cleanup
}

// In notifications.js
function initializeNotificationEvents(echo, userId) {
    const channel = echo.private(`user.${userId}.notifications`);
    // Set up all notification-related event handlers
    // ...
    return channel;
}

// In your main app
const chatChannel = initializeChatEvents(echo, currentRoomId);
const notificationChannel = initializeNotificationEvents(echo, currentUserId);

// Cleanup when component/page is destroyed
function cleanup() {
    echo.leave(`chat.room.${currentRoomId}`);
    echo.leave(`user.${currentUserId}.notifications`);
}
```

## Summary

Echo WebSocket events provide a powerful system for creating responsive real-time applications. In this guide, we've covered:

- The core connection events (connected, disconnected, error)
- Channel subscription events
- Custom event handling for regular, private, and presence channels
- Practical implementation of a real-time chat application
- Advanced event handling techniques including wildcard listeners and event cleanup
- Best practices for organizing and managing WebSocket events

By understanding and properly implementing these events, you can create robust real-time applications that provide excellent user experiences.

## Additional Resources

- [Official Echo Documentation](https://laravel.com/docs/broadcasting#receiving-broadcasts)
- [Pusher Documentation](https://pusher.com/docs/channels) (if using Pusher as the WebSocket provider)
- [WebSocket API Reference](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)

## Exercises

1. **Basic Chat Application**: Implement the chat application example from this guide, adding features like user typing indicators and read receipts.

2. **Notification System**: Create a notification system that uses WebSockets to deliver instant notifications to users.

3. **Live Dashboard**: Build a simple dashboard that shows real-time statistics (e.g., active users, messages sent) using WebSockets.

4. **Error Handling**: Practice implementing robust error handling and reconnection logic for a WebSocket application.

5. **Multi-Room Chat**: Extend the chat application to support multiple rooms that users can join and leave dynamically.

Happy coding with Echo WebSockets!