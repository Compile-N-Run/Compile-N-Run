---
title: Echo WebSocket Security
description: Learn how to secure your Echo WebSocket applications with best practices for authentication, encryption, rate limiting, and more.

---

# Echo WebSocket Security

## Introduction

WebSockets provide full-duplex communication channels over a single TCP connection, enabling real-time interactions between clients and servers. However, this powerful capability also introduces unique security challenges that must be addressed. In this guide, we'll explore essential security considerations and best practices when implementing Echo WebSocket applications.

Security is not optionalâ€”it's a fundamental aspect of any production-ready application. Properly securing your WebSocket connections protects both your users' data and your server resources from potential threats.

## Basic Security Considerations

### 1. Authentication and Authorization

When working with WebSockets, you should always authenticate users before establishing persistent connections.

#### Token-based Authentication Example

```go
// Server-side authentication middleware for Echo WebSockets
func WebSocketAuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
  return func(c echo.Context) error {
    // Get token from query parameter or headers
    token := c.QueryParam("token")
    if token == "" {
      token = c.Request().Header.Get("Authorization")
      // Remove Bearer prefix if present
      token = strings.TrimPrefix(token, "Bearer ")
    }
    
    // Validate token
    if !isValidToken(token) {
      return c.JSON(http.StatusUnauthorized, map[string]string{
        "error": "Invalid or missing authentication token",
      })
    }
    
    // Store user info in context
    userID := getUserIDFromToken(token)
    c.Set("userID", userID)
    
    return next(c)
  }
}

// Register the WebSocket route with authentication
func registerWebSocketRoutes(e *echo.Echo) {
  // Apply auth middleware to WebSocket endpoint
  ws := e.Group("/ws")
  ws.Use(WebSocketAuthMiddleware)
  ws.GET("/chat", handleWebSocket)
}
```

#### Client-side Authentication

```javascript
// Client-side connection with authentication token
const connectWebSocket = (token) => {
  // Include token in the connection URL
  const socket = new WebSocket(`ws://example.com/ws/chat?token=${token}`);
  
  // Or alternatively set it in a protocol header
  // const socket = new WebSocket('ws://example.com/ws/chat', ['token', token]);
  
  socket.onopen = () => {
    console.log('Connection established');
  };
  
  socket.onclose = (event) => {
    if (event.code === 1008) {
      console.error('Authentication failed');
    }
  };
  
  return socket;
};
```

### 2. Transport Layer Security (TLS/SSL)

Always use secure WebSocket connections (WSS) in production environments. This encrypts the data exchanged between the client and server.

```go
// Server configuration with TLS
func main() {
  e := echo.New()
  
  // Add routes and middleware
  registerWebSocketRoutes(e)
  
  // Start server with TLS
  e.Logger.Fatal(e.StartTLS(":8443", "cert.pem", "key.pem"))
}
```

On the client side, ensure you're connecting using the secure protocol:

```javascript
// Secure WebSocket connection
const socket = new WebSocket('wss://example.com/ws/chat');
```

## Advanced Security Measures

### 1. Rate Limiting

Protect your server from denial-of-service attacks by implementing rate limiting for WebSocket connections and messages.

```go
// Simple rate limiter middleware for WebSockets
func WebSocketRateLimiter(next echo.HandlerFunc) echo.HandlerFunc {
  // Create a map to track connection attempts by IP
  connectionAttempts := make(map[string]int)
  connectionMutex := &sync.Mutex{}
  
  return func(c echo.Context) error {
    ip := c.RealIP()
    connectionMutex.Lock()
    defer connectionMutex.Unlock()
    
    // Check if the IP has exceeded the connection limit
    if connectionAttempts[ip] > 10 { // Max 10 connections per minute
      return c.JSON(http.StatusTooManyRequests, map[string]string{
        "error": "Rate limit exceeded. Try again later.",
      })
    }
    
    // Increment counter and set up automatic decrement after 60 seconds
    connectionAttempts[ip]++
    go func() {
      time.Sleep(time.Minute)
      connectionMutex.Lock()
      connectionAttempts[ip]--
      if connectionAttempts[ip] <= 0 {
        delete(connectionAttempts, ip)
      }
      connectionMutex.Unlock()
    }()
    
    return next(c)
  }
}
```

### 2. Message Validation

Always validate incoming WebSocket messages to prevent injection attacks and other security issues.

```go
// Message validation example
func handleChatMessage(c echo.Context, msg []byte) error {
  // Parse the message
  var chatMsg struct {
    Type    string `json:"type"`
    Content string `json:"content"`
    Room    string `json:"room"`
  }
  
  if err := json.Unmarshal(msg, &chatMsg); err != nil {
    return err
  }
  
  // Validate message type
  if chatMsg.Type != "message" && chatMsg.Type != "join" && chatMsg.Type != "leave" {
    return errors.New("invalid message type")
  }
  
  // Validate content length
  if len(chatMsg.Content) > 1000 {
    return errors.New("message too long")
  }
  
  // Sanitize content to prevent XSS
  chatMsg.Content = sanitizeHTML(chatMsg.Content)
  
  // Process the validated message
  // ...
  
  return nil
}

// HTML sanitization function (simplified example)
func sanitizeHTML(input string) string {
  // Replace potentially dangerous characters
  input = strings.ReplaceAll(input, "<", "&lt;")
  input = strings.ReplaceAll(input, ">", "&gt;")
  input = strings.ReplaceAll(input, "\"", "&quot;")
  input = strings.ReplaceAll(input, "'", "&#39;")
  return input
}
```

## Real-world Application: Secure Chat Service

Let's put these concepts together in a more comprehensive example of a secure chat application using Echo WebSockets.

### Server Implementation

```go
package main

import (
  "github.com/gorilla/websocket"
  "github.com/labstack/echo/v4"
  "github.com/labstack/echo/v4/middleware"
  "net/http"
  "sync"
  "time"
)

// Configure WebSocket upgrader
var upgrader = websocket.Upgrader{
  ReadBufferSize:  1024,
  WriteBufferSize: 1024,
  CheckOrigin: func(r *http.Request) bool {
    // In production, validate the origin
    origin := r.Header.Get("Origin")
    return isAllowedOrigin(origin)
  },
}

// Check if origin is allowed
func isAllowedOrigin(origin string) bool {
  allowedOrigins := []string{
    "https://your-domain.com",
    "https://app.your-domain.com",
  }
  
  for _, allowed := range allowedOrigins {
    if allowed == origin {
      return true
    }
  }
  return false
}

// Connection manager
type ClientManager struct {
  clients    map[*websocket.Conn]string // Conn -> UserID
  broadcast  chan []byte
  register   chan *websocket.Conn
  unregister chan *websocket.Conn
  mutex      sync.Mutex
}

func main() {
  e := echo.New()
  
  // Apply middleware
  e.Use(middleware.Logger())
  e.Use(middleware.Recover())
  e.Use(middleware.CORS())
  e.Use(middleware.SecureWithConfig(middleware.SecureConfig{
    XSSProtection:         "1; mode=block",
    ContentTypeNosniff:    "nosniff",
    XFrameOptions:         "SAMEORIGIN",
    HSTSMaxAge:            31536000,
    HSTSExcludeSubdomains: false,
    ContentSecurityPolicy: "default-src 'self'",
  }))
  
  // Initialize client manager
  manager := &ClientManager{
    clients:    make(map[*websocket.Conn]string),
    broadcast:  make(chan []byte),
    register:   make(chan *websocket.Conn),
    unregister: make(chan *websocket.Conn),
  }
  
  // Start the manager
  go manager.run()
  
  // Auth middleware
  authMiddleware := WebSocketAuthMiddleware
  
  // Rate limiter middleware
  rateLimiter := WebSocketRateLimiter
  
  // WebSocket endpoint
  e.GET("/ws/chat", func(c echo.Context) error {
    userID := c.Get("userID").(string)
    
    // Upgrade the connection
    ws, err := upgrader.Upgrade(c.Response(), c.Request(), nil)
    if err != nil {
      return err
    }
    defer ws.Close()
    
    // Register new client
    manager.register <- ws
    manager.mutex.Lock()
    manager.clients[ws] = userID
    manager.mutex.Unlock()
    
    // Handle incoming messages
    for {
      _, msg, err := ws.ReadMessage()
      if err != nil {
        manager.unregister <- ws
        break
      }
      
      // Validate and process the message
      if err := handleChatMessage(c, msg); err != nil {
        // Send error back to client
        ws.WriteJSON(map[string]string{"error": err.Error()})
        continue
      }
      
      // Broadcast valid message
      manager.broadcast <- msg
    }
    
    return nil
  }, authMiddleware, rateLimiter)
  
  // Start server with TLS
  e.Logger.Fatal(e.StartTLS(":8443", "cert.pem", "key.pem"))
}

// Manager run loop
func (manager *ClientManager) run() {
  for {
    select {
    case client := <-manager.register:
      // Handle new client registration
      
    case client := <-manager.unregister:
      // Handle client disconnection
      manager.mutex.Lock()
      delete(manager.clients, client)
      manager.mutex.Unlock()
      
    case message := <-manager.broadcast:
      // Broadcast message to all clients
      manager.mutex.Lock()
      for client := range manager.clients {
        err := client.WriteMessage(websocket.TextMessage, message)
        if err != nil {
          client.Close()
          delete(manager.clients, client)
        }
      }
      manager.mutex.Unlock()
    }
  }
}
```

### Client Implementation

```javascript
// Secure chat client implementation
class SecureChatClient {
  constructor(url, token) {
    this.url = url;
    this.token = token;
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.listeners = {
      message: [],
      connect: [],
      disconnect: []
    };
  }
  
  connect() {
    // Close any existing connection
    if (this.socket) {
      this.socket.close();
    }
    
    // Create secure connection with token
    this.socket = new WebSocket(`${this.url}?token=${this.token}`);
    
    this.socket.onopen = () => {
      console.log('Connected to secure chat');
      this.reconnectAttempts = 0;
      this.notifyListeners('connect');
    };
    
    this.socket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        
        // Check for error messages
        if (data.error) {
          console.error('Server error:', data.error);
          return;
        }
        
        // Handle regular messages
        this.notifyListeners('message', data);
      } catch (e) {
        console.error('Failed to parse message:', e);
      }
    };
    
    this.socket.onclose = (event) => {
      this.notifyListeners('disconnect', event);
      
      // Handle authentication failures
      if (event.code === 1008) {
        console.error('Authentication failed');
        return;
      }
      
      // Attempt reconnection for other issues
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
        this.reconnectAttempts++;
        
        console.log(`Connection lost. Reconnecting in ${delay}ms...`);
        setTimeout(() => this.connect(), delay);
      }
    };
    
    this.socket.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
  }
  
  sendMessage(type, content, room) {
    if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
      console.error('Cannot send message: connection not open');
      return false;
    }
    
    // Validate message before sending
    if (!content || content.length > 1000) {
      console.error('Invalid message: content empty or too long');
      return false;
    }
    
    const message = JSON.stringify({
      type,
      content,
      room,
      timestamp: new Date().toISOString()
    });
    
    this.socket.send(message);
    return true;
  }
  
  on(event, callback) {
    if (this.listeners[event]) {
      this.listeners[event].push(callback);
    }
  }
  
  notifyListeners(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(callback => callback(data));
    }
  }
  
  disconnect() {
    if (this.socket) {
      this.socket.close();
      this.socket = null;
    }
  }
}

// Usage example
const chat = new SecureChatClient('wss://example.com/ws/chat', 'user-auth-token');

chat.on('connect', () => {
  console.log('Successfully connected to chat!');
  // Join a chat room
  chat.sendMessage('join', '', 'general');
});

chat.on('message', (data) => {
  console.log(`${data.sender}: ${data.content}`);
});

chat.on('disconnect', (event) => {
  console.log('Disconnected from chat:', event.reason);
});

// Connect to the chat server
chat.connect();

// Send a message
document.getElementById('send-button').addEventListener('click', () => {
  const messageInput = document.getElementById('message-input');
  const message = messageInput.value.trim();
  
  if (message) {
    chat.sendMessage('message', message, 'general');
    messageInput.value = '';
  }
});
```

## Common Security Pitfalls to Avoid

1. **Not using TLS/SSL**: Always use `wss://` (WebSocket Secure) in production.

2. **Missing authentication**: Require authentication before establishing WebSocket connections.

3. **No message rate limiting**: Implement rate limiting to prevent flooding attacks.

4. **Insufficient input validation**: Always validate and sanitize user inputs.

5. **No origin checking**: Verify the request origin to prevent cross-site WebSocket hijacking.

6. **Storing sensitive data in WebSocket messages**: Avoid transmitting sensitive information like passwords.

7. **Not handling reconnections properly**: Implement exponential backoff for reconnection attempts.

## Summary

Securing Echo WebSocket applications requires attention to multiple aspects including authentication, encryption, rate limiting, and message validation. By implementing the security practices covered in this guide, you can protect your WebSocket servers from common threats while providing a reliable, real-time communication experience for your users.

Remember these key points:
- Always use TLS/SSL encryption with `wss://` protocol
- Implement proper authentication and authorization
- Validate and sanitize all incoming messages
- Apply rate limiting to prevent abuse
- Check origins to prevent cross-site attacks
- Handle reconnections gracefully with exponential backoff

## Additional Resources

- [OWASP WebSocket Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Websocket_Security_Cheat_Sheet.html)
- [Echo WebSocket Documentation](https://echo.labstack.com/cookbook/websocket/)
- [Gorilla WebSocket Security Considerations](https://pkg.go.dev/github.com/gorilla/websocket?tab=doc#hdr-Origin_Considerations)

## Exercises

1. Implement a token-based authentication system for your Echo WebSocket application.

2. Add rate limiting to prevent users from connecting more than 10 times per minute from the same IP address.

3. Create a message validation function that:
   - Checks message size (under 4KB)
   - Validates required fields
   - Sanitizes text to prevent XSS attacks

4. Implement secure reconnection logic in your WebSocket client with exponential backoff.

5. Add origin validation for your WebSocket server that only accepts connections from your allowed domains.